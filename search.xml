<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何去搞前端基建</title>
      <link href="/2023/06/26/frontend/infrastructure/ru-he-qu-gao-qian-duan-ji-jian/"/>
      <url>/2023/06/26/frontend/infrastructure/ru-he-qu-gao-qian-duan-ji-jian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a href="https://juejin.cn/post/7144881028661723167#heading-22">https://juejin.cn/post/7144881028661723167#heading-22</a></p><p><a name="FN5iV"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大家好，我是<a href="https://link.juejin.cn/?target=https://github.com/YWzzy">yinhan</a>，话说当下，前端职位在近十年的磨砺之下，已是百花齐放万家争鸣，前端也不再是以前那个单纯的切图仔；<br />要问为什么不单纯，无异于 前端工程化、前端 devops、前端跨端、前端工具化、前端 CI&#x2F;CD、前端 BFF、微前端 这些技术的出现，然而这些日新月异的技术聚合，咱们可以称其为 前端基建；<br />其实无论您是想成为 高级前端工程师，还是一名 合格的 Leader，都离不开对 <strong>前端技术与业务的基础建设沉淀</strong>；<br />看完全文，我相信 <strong>您的收获会远不止于此</strong> ~<br><a name="mD7nC"></a></p><h1 id="一、什么是基建？"><a href="#一、什么是基建？" class="headerlink" title="一、什么是基建？"></a>一、什么是基建？</h1><p>基建 这个词无论身处哪个行业，基本都会存在；只是在最近几年的软件计算机行业中尤为流行；<br />在建筑行业：一幢大厦所需的地基，脚手架，一块砖、一片瓦、一袋水泥、一扇窗等等咱都可以称之为基础建设的一部分；<br />在汽车行业：一辆汽车所需的车架子、发动机、车轱辘、方向盘、门窗等等咱也可称之为基础建设的一部分；<br />那么在互联网软件行业呢？<br />笔者的理解是：在软件行业，站在广义的角度上来讲基建包含了：业务基建、工程基建、前端基建、后端基建 等等；（此处仅笔者个人理解，如果意见不一样，以你的为准）<br><a name="VUwSL"></a></p><h2 id="业务基建？"><a href="#业务基建？" class="headerlink" title="业务基建？"></a>业务基建？</h2><p>业务基建 是指公司某个业务团队层面所维护的 前端基建、后端基建、基本规范文档、产品规则、设计规范、研发流程、测试边界、上线标准以及业务中台 等等的建设；<br />业务基建 服务于整个业务团队<br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103192-d8ab0706-9dbe-409a-b3b6-e9fca379d5d5.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103192-d8ab0706-9dbe-409a-b3b6-e9fca379d5d5.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a name="vZHeV"></a></p><h2 id="工程基建？"><a href="#工程基建？" class="headerlink" title="工程基建？"></a>工程基建？</h2><p>工程基建 指的是业务团队内所有工程师的的一些 编码规范、api规范、前后端协作、环境部署、微服务、微前端、性能、安全防御、统计监控、可视化 等等的建设；<br />工程基建 服务于整个工程团队；<br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103192-d8ab0706-9dbe-409a-b3b6-e9fca379d5d5.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103192-d8ab0706-9dbe-409a-b3b6-e9fca379d5d5.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="工程基建"><br><a name="sUoPL"></a></p><h2 id="前端基建？"><a href="#前端基建？" class="headerlink" title="前端基建？"></a>前端基建？</h2><p>前端基建 指的是业务团队内的前端工程师执行的一些基础建设，包括了 前端规范文档、前端脚手架、前端模板、前端组件库、前端工具库、前端BFF、前端CI&#x2F;CD的构建部署、前端数据埋点 等等；<br />前端基建 仅服务于前端团队；<br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103292-69a329ee-2913-4281-90ea-8b19710ba834.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103292-69a329ee-2913-4281-90ea-8b19710ba834.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a name="RB8uY"></a></p><h2 id="后端基建？"><a href="#后端基建？" class="headerlink" title="后端基建？"></a>后端基建？</h2><p>后端基建 指的是业务团队内的后端工程师执行的一些基础建设，包括了 后端规范文档、后端模板、安全、日志、微服务、RESTful API、中间件、数据库、分布式、权限控制、服务器性能并发 等等；<br />注意：后端基建 仅服务于后端团队；<br><a name="YPeSd"></a></p><h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103126-d59552e2-a23e-450f-ac97-8309c2839051.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103126-d59552e2-a23e-450f-ac97-8309c2839051.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br />看到这里，咱们已经明白了公司基建的一些基本分类和概括，下面我们也主要介绍下本文的主题前端基建；<br><a name="hEQFR"></a></p><h1 id="二、为什么要做前端基建？"><a href="#二、为什么要做前端基建？" class="headerlink" title="二、为什么要做前端基建？"></a>二、为什么要做前端基建？</h1><p><a name="amcFS"></a></p><h2 id="场景复现"><a href="#场景复现" class="headerlink" title="场景复现"></a>场景复现</h2><p><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103136-94a241c3-415a-417b-9c96-b64f6e5abf32.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103136-94a241c3-415a-417b-9c96-b64f6e5abf32.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a name="KX7VW"></a></p><h2 id="前端基建意义与作用"><a href="#前端基建意义与作用" class="headerlink" title="前端基建意义与作用"></a>前端基建意义与作用</h2><ul><li>业务复用；</li><li>提升研发效率；</li><li>规范研发流程；</li><li>团队技术提升；</li><li>团队的技术影响力；</li><li>开源建设；<br><a name="ZDuKL"></a></li></ul><h1 id="三、前端基建如何推动落地？"><a href="#三、前端基建如何推动落地？" class="headerlink" title="三、前端基建如何推动落地？"></a>三、前端基建如何推动落地？</h1><p><a name="TPbJ5"></a></p><h2 id="技术基建简要流程"><a href="#技术基建简要流程" class="headerlink" title="技术基建简要流程"></a>技术基建简要流程</h2><p>要说 前端基建，最主要的难点莫过于如何去推动落地，其中不乏需要前端同学的付出，还需要领导的支持等等，下面我给大家罗列一下大致的步骤（因团队而异）</p><ol><li><strong>要合适的同学（资源）</strong><ul><li>挨个与前端同学商议，或者自己钦点某位同学等等；而且要有动力，切勿急于求成、半途而废，注重系统思维，也千万不要找不稳定的同学（切记切记切记）</li></ul></li><li><strong>要解决的问题（问题）</strong><ul><li>针对现有公司前端人员架构、技术架构以及业务架构做对应的方案，这个没有固定的套路，不同公司所面临的问题也不一致；</li></ul></li><li><strong>要解决问题方案计划书（方案）</strong><ul><li>到目前，咱们已经有人（前端同学），也有具体想要做的事了，那么接下来很重要的一步就是出解决方案找领导确认了；</li><li>其实就类似你有一个很好 idea，写了一份特别详细的商业计划书（BP）去找投资人拉投资是一个道理；</li><li>不过最后能不能打动你的投资人，这就取决于你的 BP 做的是否够吸引人了；</li></ul></li><li><strong>要具体执行的步骤（执行）</strong><ul><li>天底下没有一蹴而就的事，工作也是，所以对于一个现有的技术团队，咱们最好是从渐进式出发，在对现有业务不影响的前提下去做增量式的研发；<br><a name="Jwfjz"></a></li></ul></li></ol><h2 id="技术基建四大特性（切记）"><a href="#技术基建四大特性（切记）" class="headerlink" title="技术基建四大特性（切记）"></a>技术基建四大特性（切记）</h2><ul><li>技术的健全性</li><li>基建的稳定性</li><li>研发的效率性</li><li>业务的体验性</li></ul><p>到这里，我相信大家对前端基建已有初步的了解，可能会有同学已经想跃跃欲试了，但是前端基建到底有些什么呢？咱们一起往下看。<br><a name="E6zrL"></a></p><h1 id="四、前端基建都有什么？"><a href="#四、前端基建都有什么？" class="headerlink" title="四、前端基建都有什么？"></a>四、前端基建都有什么？</h1><p>前端基建 在每个公司甚者每个业务团队都会有差异，其中有 技术栈的差异，有编码的差异，有文档注释的差异 等等；<br />为了迎合主要的前端基建市场，结合我司以及大部分公司的基建所需，下面给大家介绍一些符合大众的常用基建部分（后续会持续更新）；<br />下面所有分类只会简单介绍，详细相关文章会在《<a href="https://juejin.cn/column/7139087916306792462">前端搞基建</a>》专栏后续发表（敬请期待…）；<br><a name="McB2d"></a></p><h2 id="1-前端规范（Standard）"><a href="#1-前端规范（Standard）" class="headerlink" title="1. 前端规范（Standard）"></a>1. 前端规范（Standard）</h2><p>正所谓：前端不规范，后面看着办 ~<br />我相信规范两个词，是所有同学的噩梦，怕他不规范，又怕他太规范，这可真是难为死这个规范了；<br /><strong>假设招聘现有三个候选人，你会选择哪个呢？</strong></p><ul><li>一名 <strong>“摆烂”</strong> 的程序员，写的代码能运行就行；</li><li>一名 <strong>“合格”</strong> 的程序员，写的代码能运行且无 BUG；</li><li>一名 <strong>“优秀”</strong> 的程序员，写的代码能运行无 BUG 且可读性、可维护性、可复用性都高；</li></ul><p>答案显而易见 ~<br /><strong>前端规范的意义：</strong></p><ul><li>降低开发的成本；</li><li>保证代码的一致性；</li><li>提升团队的整体效率；</li></ul><p><strong>前端规范有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103622-9e027779-344f-40f3-b7c6-ef32bc760582.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103622-9e027779-344f-40f3-b7c6-ef32bc760582.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a name="KQ0yz"></a></p><h2 id="2-前端文档（Document）"><a href="#2-前端文档（Document）" class="headerlink" title="2.前端文档（Document）"></a>2.前端文档（Document）</h2><p>其实在许许多多的小型公司，文档缺失是一项必不可少的问题；无论是 业务文档，还是 技术文档，还是 其它文档等等；<br /><strong>问题点：</strong></p><ul><li>有些公司招人进来上午安环境，下午直接开始撸需求代码；</li><li>有些公司的新人来公司一个月了竟然还不知道公司组织架构与业务划分；</li><li>有些公司老对新几乎无交集，全靠新人猜，一个需求做下来竟然不知道做的什么，只知道一直很忙；</li><li>有些公司在安排员工去开发另一个项目业务，竟然无从下手，不知所措；</li><li>……</li></ul><p>所以一个合格的公司文档是必不可少的，无论是 新人自治，还是老带新，业务转岗 等等；<br /><strong>前端文档的意义：</strong></p><ul><li>对新人友好，快速上手；</li><li>快速融入团队；</li><li>快速了解业务；</li></ul><p><strong>前端文档有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103692-08d1ea0a-9cb6-42fd-b628-6c8afcc5decb.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103692-08d1ea0a-9cb6-42fd-b628-6c8afcc5decb.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a name="rgekp"></a></p><h2 id="3-前端项目模板管理（Templates）"><a href="#3-前端项目模板管理（Templates）" class="headerlink" title="3. 前端项目模板管理（Templates）"></a>3. 前端项目模板管理（Templates）</h2><p>前端项目模板 说直白点就是，公司前端所对应的项目模板，以便快速创建项目；<br /><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103909-f0324e60-6e8d-42e4-bfc0-2d4f640104e7.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103909-f0324e60-6e8d-42e4-bfc0-2d4f640104e7.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br /><strong>前端项目模板主要意义：</strong></p><ul><li>快速创建项目，提升效率；</li><li>项目技术栈统一，方便管理；</li></ul><p><strong>前端项目模板有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103939-19ed21a0-0ad9-4652-a66e-1a5a47ba12f6.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103939-19ed21a0-0ad9-4652-a66e-1a5a47ba12f6.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a name="Jonae"></a></p><h2 id="4-前端脚手架（CLI）"><a href="#4-前端脚手架（CLI）" class="headerlink" title="4. 前端脚手架（CLI）"></a>4. 前端脚手架（CLI）</h2><p>前端脚手架 作为衡量一个成熟前端团队的标准，我相信很多前端er 都对他已经很了解了；<br />但是目前市面上对脚手架的应用我相信90%以上的团队仅限用于项目的快速创建，也就是使用现成的模板通过命令行快速搭建；<br />那么我们做这个脚手架是不是已经做到了 资源最大化 呢？<br />显然是没有的，如何去做我会在后续的文章中详解，大家敬请期待…<br /><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104008-f0a7309d-38b3-4737-8ec3-5d47561a8d7c.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104008-f0a7309d-38b3-4737-8ec3-5d47561a8d7c.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br /><strong>前端脚手架的意义：</strong></p><ul><li>快速搭建项目；</li><li>技术栈统一；</li><li>规范代码风格；</li><li>提升研发效率；</li><li>自动化；</li></ul><p><strong>前端脚手架有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104029-0ba5548c-0c68-4d58-ab7a-31619236f947.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104029-0ba5548c-0c68-4d58-ab7a-31619236f947.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a name="tVBKN"></a></p><h2 id="5-前端组件库（UI-Design）"><a href="#5-前端组件库（UI-Design）" class="headerlink" title="5. 前端组件库（UI Design）"></a>5. 前端组件库（UI Design）</h2><p>前端 UI 组件库：在开源社区有数不胜数的组件库，例如 Ant Design、Element UI、Vant UI 等等（实在太多啦），如果你觉得某个组件库很适合用在你的项目，那么你将少一半的开发时间，是不是摸鱼的时间又多了一半呢？<br />但是在一些中大型的公司，他们<strong>有他们的标准，不可能去使用一些现成的组件库；</strong><br />而且现成的一些开源组件库中的样式与交互达不到公司设计师的要求，所以这时候 为了统一业务的设计规范与样式，咱们可以马不停蹄地赶紧向领导去提一提搞一个组件库试试看咯！<br /><strong>场景重现：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104069-53f50ff9-f30f-4268-a334-6c5be44c5958.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104069-53f50ff9-f30f-4268-a334-6c5be44c5958.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br /><strong>前端组件库的意义：</strong></p><ul><li>组件复用，提升研发效率；</li></ul><p><strong>前端组件库有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104279-b0e414ba-41cd-40a2-812f-312baa3e3ae9.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104279-b0e414ba-41cd-40a2-812f-312baa3e3ae9.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a name="KTnoC"></a></p><h2 id="6-前端响应式设计-or-自适应设计"><a href="#6-前端响应式设计-or-自适应设计" class="headerlink" title="6. 前端响应式设计 or 自适应设计"></a>6. 前端响应式设计 or 自适应设计</h2><p>响应式设计（Responseive Design） 指的是一个网站同一页面在不同屏幕尺寸下有不同的布局；一套代码能在所有终端能够正常展示，并不是为每个终端做一个特定版本，响应式是为解决移动互联网浏览器而诞生的。<br />自适应设计（Adaptive web design） 需要开发多套界面，通过检测视口以及设备，来判断当前访问的设备是pc端与移动端，从而返回不同的页面。<br /><strong>前端响应式设计：</strong></p><ul><li>一套代码提升研发效率；</li><li>不同分辨率设备灵活性强；</li><li>快速适配多端；</li></ul><p><strong>前端自适应设计：</strong></p><ul><li>设计与体验较好；</li><li>性能相对好；</li></ul><p>注意：<br />一个项目到底是用<strong>响应式设计</strong>，还是<strong>自适应设计</strong>，这个取决于项目的排版和设计的出入程度;<br />所以如果公司PC端和H5端的排版设计有较大的出入还是建议使用自适应设计；反之可以考虑响应式设计；<br />切入盲目选择；<br><a name="BxqK1"></a></p><h2 id="7-前端工具库（类-Hooks-x2F-Utils）"><a href="#7-前端工具库（类-Hooks-x2F-Utils）" class="headerlink" title="7. 前端工具库（类 Hooks &#x2F; Utils）"></a>7. 前端工具库（类 Hooks &#x2F; Utils）</h2><p>开源社区有数不胜数的 前端工具库，如 Day.js、axios、loadsh 等等，只是其中功能未必是你想要的；<br />而且许多 前端工具库边界考量范围大，这样就增加库的体积，明明我想要的只是一个简单的功能，可还是引入了整个库，这样就得不偿失；<br />可能有同学要说不是有 Tree Shaking 了吗，难道有了 按需引入 有了 Tree Shaking 我们就可以为所欲为了吗<br />一些中大型企业团队为了复用某些工具方法，提升研发效率，一般都会封装一个工具库，身为一个合格的基建搬砖工，前端工具库怎么能少得了呢？<br /><strong>前端工具库的意义：</strong></p><ul><li>工具方法复用，提升研发效率；</li><li>减少代码量；</li><li>团队技术提升；</li></ul><p><strong>前端工具库有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104353-bb2fc1f6-f90d-45c8-a43b-84f7669b4a25.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104353-bb2fc1f6-f90d-45c8-a43b-84f7669b4a25.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a name="jMjja"></a></p><h2 id="8-前端工具自动化（Tools）"><a href="#8-前端工具自动化（Tools）" class="headerlink" title="8. 前端工具自动化（Tools）"></a>8. 前端工具自动化（Tools）</h2><p>可能会有同学疑惑，这个前端工具和上面的前端工具不是一样的吗？</p><ul><li>前端工具自动化 主要针对的代码上层的格式、规范、测试方面的自动化工具；</li><li>前端工具库 主要针对的是代码层面的方法复用工具，所以其本质上有较为明显的区别；</li></ul><p><strong>场景重现：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104390-f3548c35-c620-4714-bddd-382c922b2fa7.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104390-f3548c35-c620-4714-bddd-382c922b2fa7.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br /><strong>前端工具自动化的意义：</strong></p><ul><li>代码质量与风格的统一；</li><li>自动化编码流程；</li><li>提升效率；</li></ul><p><strong>前端工具自动化有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104522-0bf97777-e7cb-48c0-a396-4168c51df863.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104522-0bf97777-e7cb-48c0-a396-4168c51df863.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a name="ijHEN"></a></p><h2 id="9-接口数据聚合（BFF）"><a href="#9-接口数据聚合（BFF）" class="headerlink" title="9. 接口数据聚合（BFF）"></a>9. 接口数据聚合（BFF）</h2><p>前端 BFF（Backends For Frontends） 即服务于前端的后端，也称聚合层或者中间层；<br />主要将后端复杂的微服务，聚合成对各种不同用户端（无线&#x2F;Web&#x2F;H5&#x2F;第三方等）友好和统一的API；<br /><strong>场景重现：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104879-08251786-380c-412c-927f-2b56044a3fc5.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104879-08251786-380c-412c-927f-2b56044a3fc5.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br /><strong>前端 BFF 的意义：</strong></p><ul><li>聚合 API，释放后端；</li><li>解耦合各个业务；</li><li>后端微服务引入；</li><li>易维护和修改 API；</li><li>更好的安全性；</li><li>更好的前端错误处理；</li></ul><p><strong>前端 BFF 的简单架构：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104856-218c8b92-661a-4429-afb4-cc433e88e198.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104856-218c8b92-661a-4429-afb4-cc433e88e198.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a name="i5C8n"></a></p><h2 id="10-前端-SSR-推进"><a href="#10-前端-SSR-推进" class="headerlink" title="10. 前端 SSR 推进"></a>10. 前端 SSR 推进</h2><p>服务器端渲染（Server-Side Rendering） 是指由服务端完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。<br />简单理解就是html是由服务端写出，可以动态改变页面内容，即所谓的动态页面。早年的 <a href="https://link.juejin.cn/?target=https://baike.baidu.com/item/php/9337">php</a>、<a href="https://link.juejin.cn/?target=https://baike.baidu.com/item/asp/128906">asp</a> 、<a href="https://link.juejin.cn/?target=https://baike.baidu.com/item/jsp/141543">jsp</a> 这些 Server Page 都是 SSR 的。<br />由于公司主要是C端用户，而且 SEO 要求极高，所以在前后端分离的情况下，SSR 就必不可少了 ~<br /><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104999-c2d07874-ea37-4813-afce-dc789679d052.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104999-c2d07874-ea37-4813-afce-dc789679d052.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br /><strong>前端 SSR 的目的：</strong></p><ul><li>前后端分离；</li><li>首屏加载速度快；</li><li>利于 SEO；<br><a name="BfMuC"></a></li></ul><h2 id="11-前端自动化构建部署（CI-x2F-CD）"><a href="#11-前端自动化构建部署（CI-x2F-CD）" class="headerlink" title="11. 前端自动化构建部署（CI&#x2F;CD）"></a>11. 前端自动化构建部署（CI&#x2F;CD）</h2><p>前端 CI&#x2F;CD 一般是指持续集成、部署、发布的一个过程；<br />用白话文讲，就是你每次 git commit 代码后，都会自动的为你部署项目至 测试环境、预生产环境、生产环境，不用你每次手动的去打包后 cv 到多个服务器和环境；<br /><strong>前端 CI&#x2F;CD 的意义：</strong></p><ul><li>提高开发人员生产力；</li><li>自动化发布；</li><li>提高代码质量；</li><li>更快地提供更新；</li></ul><p><strong>前端 CI&#x2F;CD 有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104802-556c26a8-3069-4925-b6db-b9c778169476.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104802-556c26a8-3069-4925-b6db-b9c778169476.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a name="T8JYg"></a></p><h2 id="12-全链路前端监控-x2F-数据埋点系统"><a href="#12-全链路前端监控-x2F-数据埋点系统" class="headerlink" title="12. 全链路前端监控&#x2F;数据埋点系统"></a>12. 全链路前端监控&#x2F;数据埋点系统</h2><p>在大部分 To C 的项目中，我相信产品和运营都需要 统计线上产品在用户中的行为和使用情况，因为这样可以更快的去了解用户群里的使用情况，从而升级和迭代产品，使其更加贴近用户。<br /><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105105-05d4158c-135d-43dc-b293-fa82fe4c55a8.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105105-05d4158c-135d-43dc-b293-fa82fe4c55a8.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br /><strong>前端监控&#x2F;数据埋点的目的是：</strong></p><ul><li>实现精准的点对点营销；</li><li>可以做相关的分类统计；</li><li>为用户画像的构建提供数据支持；</li><li>指导产品研发以及优化用户体验；</li></ul><p><strong>前端监控&#x2F;数据埋点有哪些数据？</strong></p><ul><li>行为数据：时间、地点、人物、交互、交互的内容；</li><li>质量数据：浏览器加载情况、错误异常等；</li><li>环境数据：浏览器相关的元数据以及地理、运营商等；</li><li>运营数据：PV、UV、转化率、留存率（很直观的数据）；<br><a name="Sxzk0"></a></li></ul><h2 id="13-前端可视化平台"><a href="#13-前端可视化平台" class="headerlink" title="13. 前端可视化平台"></a>13. 前端可视化平台</h2><p>前端可视化 字面意义理解就是用肉眼可见的就称呼为前端可视化；即所见即所得；<br />笔者这里的理解 前端可视化 包括了 数据可视化、图形可视化、VR 全景可视化、中后台视觉可视化 等等；<br />其中每一个都需要花费大量的人力与精力，如果你想全方面的从入门到精通，可以看看<a href="https://juejin.cn/user/712139263189303">月影大佬</a>的可视化教程。<br />目前公司在基于前端基建这块，所做的可视化主要是基于大家的工作流程以及工作效率所做的一个 工程可视化平台；<br /><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105264-c330d510-e0bb-4882-8e2c-17dab219e8cc.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105264-c330d510-e0bb-4882-8e2c-17dab219e8cc.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br /><strong>前端工程可视化平台的目的：</strong></p><ul><li>方便项目管理；</li><li>高效提升工作效率；</li><li>一键搞定CI&#x2F;CD流；</li></ul><p><strong>前端工程可视化平台有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157106022-5dcbd2ae-bdeb-4334-ae93-72e2be9d51fc.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157106022-5dcbd2ae-bdeb-4334-ae93-72e2be9d51fc.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a name="yQgmu"></a></p><h2 id="14-前端性能优化"><a href="#14-前端性能优化" class="headerlink" title="14. 前端性能优化"></a>14. 前端性能优化</h2><p>性能优化这个词，我相信只要是程序员，多多少少都听过，而且都经历过；<br />如果你的项目是 ToB 项目，可能性能优化不会做到极致；<br />但是你的项目是 ToC 项目呢，那性能优化是不是就是一个你必须要考量的点呢？<br /><strong>场景重现：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105522-3c778742-f481-4770-84a8-f1b5e7d5ef4b.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105522-3c778742-f481-4770-84a8-f1b5e7d5ef4b.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br />好家伙，用户直接崩溃，这是什么破网站，这么 🌶 🐔 ；<br /><strong>前端性能优化的意义：</strong></p><ul><li>页面加载的更快；</li><li>更好的用户体验；</li><li>降低服务器负荷；</li><li>提升编码的能力；</li></ul><p><strong>前端性能优化都有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105542-6d141ec1-7eaf-4ab8-8de3-52a6c6ee9ba9.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105542-6d141ec1-7eaf-4ab8-8de3-52a6c6ee9ba9.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a name="MUaAD"></a></p><h2 id="15-前端低代码平台搭建（建设中）"><a href="#15-前端低代码平台搭建（建设中）" class="headerlink" title="15. 前端低代码平台搭建（建设中）"></a>15. 前端低代码平台搭建（建设中）</h2><p>维基百科定义：低代码开发平台（LCDP） 本身也是一种软件，它为开发者提供了一个创建应用软件的开发环境；与传统编写代码的 IDE 不同，低代码开发平台提供更易用的可视化 IDE。<br />简单来讲，低代码（Low Code）就是一种可视化搭建系统，从字面意思来讲，一是可视化；二是少写代码。<br />无代码（No Code） 同样从字面上来理解，一是可视化，二是不写代码。<br /><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105642-c5437ded-0deb-4a53-a281-4bbf3a0fa599.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105642-c5437ded-0deb-4a53-a281-4bbf3a0fa599.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br /><strong>前端低代码平台的意义：</strong></p><ul><li><strong>降低开发成本；</strong></li><li><strong>所见即所得；</strong></li><li><strong>一站式研发；</strong></li><li><strong>技术收敛；</strong></li><li><strong>专业门槛低；</strong></li><li><strong>对新人友好，上手快；</strong></li></ul><p>注意：<br />低代码平台一般较针对于一些业务使用率较大且多是 ToB 的平台，所以判断当前系统是否需要使用低代码平台，建议在有大量业务的支撑前提下，否则得不偿失；<br />用新技术，更多的不是因为先进，而是适合。<br><a name="A5dpY"></a></p><h2 id="16-微前端（Micro-App）"><a href="#16-微前端（Micro-App）" class="headerlink" title="16. 微前端（Micro App）"></a>16. 微前端（Micro App）</h2><p>微前端（Micro-Frontends） 并没有定义框架或 API，它其实是一个类似 微服务架构 的概念；将 微服务 的概念扩展到了前端世界；<br />说微服务可能有些前端同学会感觉陌生，以咱们前端的角度一句话概括就是： 将您的大型前端应用拆分为多个小型前端应用，这样每个小型前端应用都有自己的仓库，可以专注于单一的某个功能；<br />需要强调的是，尽管我们将前端应用拆分为多个项目，但它们最终还是会被集成到一个单页前端应用程序中；因此，通过使用微前端架构，您不会在用户体验上有任何损失，只会有过之而无不及；<br /><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105710-811e06bd-d9a4-46d2-8b21-60123228e6e4.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105710-811e06bd-d9a4-46d2-8b21-60123228e6e4.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br /><strong>为什么要用微前端：</strong></p><ul><li>技术上的灵活选择；</li><li>更快的且独立的部署；</li><li>团队代码的相互隔离；</li><li>并行开发和团队的自治；</li><li>项目的增量升级；</li></ul><p><strong>微前端的价值：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105978-9c61f61b-26cb-474e-a3fd-7187874549e7.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105978-9c61f61b-26cb-474e-a3fd-7187874549e7.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><strong>》</strong><br><a name="CHHyo"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于前端基建，在每个公司基建部分都会有所差异，有纯自动化一条龙的，有半自动化的等等；<br />但是如果我们细心的会发现，在几乎所有大中厂中，基建部分都不会少了 前端规范、前端文档、前端脚手架、前端组件库、前端工具库，所以如果实在是公司资源与业务限制，这几个还是值得去一探究竟的。<br />其实很多公司基建都不是一触而蹴的，基本上都是在常年累月的业务当中去 发现问题，定位问题，最后解决问题，然后在这个过程当中自然而然的沉淀出前端各个面向的基础设施，团队成员也会在这个过程当中找到适合自己的前端领域，并且深耕下去。<br />该系列会是一个持续更新系列，关于 前端基建，笔者主要会从如下图几个方面讲解，如果您想第一时间看到我的更新文章，可以<a href="https://juejin.cn/user/2305054774145918/columns">关注我</a>和我的《<a href="https://juejin.cn/column/7139087916306792462">前端要搞基建</a>》专栏<br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105961-c45c173c-41ce-4af5-a4d6-9494fb10a98c.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105961-c45c173c-41ce-4af5-a4d6-9494fb10a98c.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a name="wOatq"></a></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compatible </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端四大手写</title>
      <link href="/2023/06/26/frontend/interview/qian-duan-si-da-shou-xie/"/>
      <url>/2023/06/26/frontend/interview/qian-duan-si-da-shou-xie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>要问程序员最心虚的面试题，如果要投票选择，<strong>手撕代码</strong>一定是前三位的。其中在前端领域，以<strong>手写 bind</strong>、<strong>手写深拷贝</strong>、<strong>手写 EventHub</strong>（发布-订阅）、<strong>手写 Promise</strong>最为常见，我将他们称为<strong>四大手写。</strong>本文的目的就是要破除大家对四大手写的恐惧，将从<strong>为什么要会手写</strong>，到每个手写的<strong>关键思路总结</strong>，再到<strong>最终模板</strong>，我都会<strong>毫无保留</strong>地分享给大家。话不多说，让我们开始吧。<br><a name="VqL5S"></a></p><h2 id="为什么要会手写"><a href="#为什么要会手写" class="headerlink" title="为什么要会手写"></a>为什么要会手写</h2><p>面试遇到手写题一脸懵逼的你也许一定想问：网上代码一堆，随便抄一下不香吗，为什么要手写？关于这个问题最直接的回答：为了<strong>区分</strong>厉害的和普通的。但坦白来讲，<strong>会白板实现关键功能的人，实现业务需求的效率一定更高</strong>。<br />为什么这么说？<br />拿手写 Promise 举例来讲，真实的业务场景会遇到大量的 AJAX 异步请求，而且大多是嵌套多层的异步代码。<br />普通前端 A 平时只会最简单的 Promise 用法，遇到多层嵌套的 Promise 就搞不清楚逻辑了，于是开发 1 小时，修 Bug 3 小时，<strong>内卷 996</strong>；<br />高级前端 B 会手写 Promise，对 Promise 的内在逻辑一清二楚，于是开发半小时，修 Bug 15 分钟，完成质量高速度快，深受 PM 小姐姐和测试小哥哥的喜爱，<strong>准点下班绩效高</strong>。<br />再举个 EventHub 的例子，会手写 EventHub 的前端，Vue 里的 $emit、$on 基本就是闭眼写；同理还有 React 里面组件想要调用普通函数（非箭头函数），需要 this.fn.bind(this)，会手写 bind 的前端就更容易举一反三，不会的就只能死记硬背，遇到 Bug 不知所措。。。<br />所以，会“四大手写”是<strong>前端进阶</strong>的必由之路，甚至可以说，<strong>手写关键代码的能力 ≈ 编程能力</strong>。</p><hr><p><a name="sODCV"></a></p><h2 id="手写-bind"><a href="#手写-bind" class="headerlink" title="手写 bind"></a>手写 bind</h2><p>bind 用法不难，一句话解释就是把新的 this 绑定到某个函数 func 上，并返回 func 的一个拷贝。使用方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> boundFunc = func.<span class="title function_">bind</span>(thisArg[, arg1[, arg2[, ...argN]]])</span><br></pre></td></tr></table></figure><p><br />那怎么实现呢？我认为手写 bind 可以分为三个境界：</p><ol><li>初级：只用 ES6 新语法</li></ol><ul><li>优点：因为可以使用 const 、… 操作符，代码简洁</li><li>缺点：兼容性稍差</li></ul><ol start="2"><li>中级：使用 ES5 语法</li></ol><ul><li>优点：兼容 IE（其实可以忽略）</li><li>缺点：参数要用Array.prototype.slice 获取，复杂且不支持 new</li></ul><ol start="3"><li>高级：ES5 + 支持 new</li></ol><ul><li>优点：支持 new</li><li>缺点：最复杂</li></ul><p><a name="P5uSV"></a></p><h3 id="初级-bind"><a href="#初级-bind" class="headerlink" title="初级 bind"></a>初级 bind</h3><p>这种方式的优点是因为可以使用 const 、… 操作符，代码简洁；缺点是不兼容 IE 等一些古老浏览器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初级：ES6 新语法 const/...</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bind_1</span>(<span class="params">asThis, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span>; <span class="comment">// 这里的 this 就是调用 bind 的函数 func</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(asThis, ...args, ...args2);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="mivQ4"></a></p><h3 id="中级-bind"><a href="#中级-bind" class="headerlink" title="中级 bind"></a>中级 bind</h3><ul><li>优点：兼容 IE</li><li>缺点：参数要用Array.prototype.slice 取，复杂且不支持 new</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中级：兼容 ES5</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bind_2</span>(<span class="params">asThis</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> slice = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>;</span><br><span class="line">  <span class="keyword">var</span> args = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;cannot bind non_function&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> args2 = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(asThis, args.<span class="title function_">concat</span>(args2));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Vig5y"></a></p><h3 id="高级-bind"><a href="#高级-bind" class="headerlink" title="高级 bind"></a>高级 bind</h3><ul><li>优点：支持 new</li><li>缺点：最复杂</li></ul><p>写之前，我们先来看一看我们应该如何判断 new，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title function_">fn</span>(args)</span><br></pre></td></tr></table></figure><p> 其实<strong>等价于</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> temp = &#123;&#125;</span><br><span class="line">temp.<span class="property">__proto__</span> = fn.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">fn.<span class="title function_">apply</span>(temp, [...args])</span><br><span class="line"><span class="keyword">return</span> temp</span><br></pre></td></tr></table></figure><p>核心在第二句：temp.<strong>proto</strong> &#x3D; fn.prototype，有了这个，我们便知道可以用 fn.prototype 是否为对象原型来判断是否为 new 的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高级：支持 new，例如 new (funcA.bind(thisArg, args))</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bind_3</span>(<span class="params">asThis</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> slice = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>;</span><br><span class="line">  <span class="comment">// 改变数组slice方法的作用域，使 this 指向arguments对象</span></span><br><span class="line">  <span class="comment">// call () 方法的第二个参数表示传递给slice的参数即截取数组的起始位置</span></span><br><span class="line">  <span class="keyword">var</span> args1 = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Must accept function&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resultFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> args2 = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">      resultFn.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(<span class="variable language_">this</span>) ? <span class="variable language_">this</span> : asThis, <span class="comment">// 用来绑定 this</span></span><br><span class="line">      args1.<span class="title function_">concat</span>(args2)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  resultFn.<span class="property"><span class="keyword">prototype</span></span> = fn.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="keyword">return</span> resultFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是前端年年考，年年不会，网上博客又经常误人子弟的“手写深拷贝”。</p><hr><p><a name="vuhlj"></a></p><h2 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h2><p>先问这么几个问题，</p><ul><li>首先为什么要深拷贝？不希望数据被修改或者只需要部分修改数据。</li><li>怎么实现深拷贝？简单需求用 JSON 反序列化，复杂需求用递归克隆。</li><li>手写深拷贝的优点？体现扎实的 JS 基础。</li><li>至于缺点以及如何解决稍后再回答<br><a name="IQGQm"></a></li></ul><h3 id="简单需求"><a href="#简单需求" class="headerlink" title="简单需求"></a>简单需求</h3><p>最简单的手写深拷贝就一行，通过 <strong>JSON 反序列化</strong>来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> B = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(A))</span><br></pre></td></tr></table></figure><p>缺点也是显而易见的，<strong>JSON value不支持的数据类型，都拷贝不了</strong></p><ol><li>不支持函数</li><li>不支持undefined（<strong>支持null</strong>）</li><li>不支持循环引用，比如 a &#x3D; {name: ‘a’}; a.self &#x3D; a; a2 &#x3D; JSON.parse(JSON.stringify(a))</li><li>不支持Date，会变成 ISO8601 格式的字符串</li><li>不支持正则表达式</li><li>不支持Symbol</li></ol><p>如何支持这些复杂需求，就需要用到<strong>递归克隆</strong>了。<br><a name="LTgyG"></a></p><h3 id="复杂需求"><a href="#复杂需求" class="headerlink" title="复杂需求"></a>复杂需求</h3><p><strong>核心</strong>有三点：</p><ol><li>递归</li><li>对象分类型讨论</li><li>解决循环引用（环）</li></ol><p>下面给出我的模板：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeepClone</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cacheList</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="params">source</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">Object</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> cache = <span class="variable language_">this</span>.<span class="title function_">findCache</span>(source);</span><br><span class="line">      <span class="keyword">if</span> (cache) <span class="keyword">return</span> cache; <span class="comment">// 如果找到缓存，直接返回</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> target;</span><br><span class="line">        <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">          target = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">          target = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> source.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">          target = <span class="keyword">new</span> <span class="title class_">Date</span>(source);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) &#123;</span><br><span class="line">          target = <span class="keyword">new</span> <span class="title class_">RegExp</span>(source.<span class="property">source</span>, source.<span class="property">flags</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cacheList</span>.<span class="title function_">push</span>([source, target]); <span class="comment">// 把源对象和新对象放进缓存列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">          <span class="keyword">if</span> (source.<span class="title function_">hasOwnProperty</span>(key)) &#123; <span class="comment">// 不拷贝原型上的属性，太浪费内存</span></span><br><span class="line">            target[key] = <span class="variable language_">this</span>.<span class="title function_">clone</span>(source[key]); <span class="comment">// 递归克隆</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">findCache</span>(<span class="params">source</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">cacheList</span>.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cacheList</span>[i][<span class="number">0</span>] === source) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">cacheList</span>[i][<span class="number">1</span>]; <span class="comment">// 如果有环，返回对应的新对象</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充一句，如果您想看详细的测试与运行结果，请参见 <a href="https://link.zhihu.com/?target=https://github.com/venaissance/source-deepClone">我的 GitHub →</a><br />递归克隆看起来很强大，但是完美无缺吗？其实还是有不小的距离：</p><ol><li>对象类型支持不够多（Buffer，Map，Set等都不支持）</li><li>存在递归爆栈的风险</li></ol><p>如果要解决这些问题，实现一个”完美“的深拷贝，只能求教上百行代码的 <a href="https://link.zhihu.com/?target=https://github.com/lodash/lodash/blob/master/cloneDeep.js">Lodash.cloneDeep()</a> 了 。<br />让我们再引申一下，深拷贝有局限吗？<br><a name="hlf23"></a></p><h2 id="深拷贝的局限"><a href="#深拷贝的局限" class="headerlink" title="深拷贝的局限"></a>深拷贝的局限</h2><p>如果需要对一个复杂对象进行频繁操作，每次都完全深拷贝一次的话性能岂不是太差了，因为大部分场景下都只是更新了这个对象的某几个字段，而其他的字段都不变，对这些不变的字段的拷贝明显是多余的。那么问题来了，浅拷贝不更新，深拷贝性能差，怎么办？<br />这里推荐3个可以实现”部分“深拷贝的库：</p><ol><li><a href="https://link.zhihu.com/?target=https://immutable-js.github.io/immutable-js/">Immutable.js</a> Immutable.js 会把对象所有的 key 进行 hash 映射，将得到的 hash 值转化为二进制，从后向前每 5 位进行分割后再转化为 Trie 树。Trie 树利用这些 hash 值的公共前缀来减少查询时间，最大限度地减少无谓 key 的比较。关于 Trie 树（字典树）的介绍，可以看我的博客<a href="https://zhuanlan.zhihu.com/p/136103651">算法基础06-字典树、并查集、高级搜索、红黑树、AVL 树</a></li><li><a href="https://link.zhihu.com/?target=https://github.com/rtfeldman/seamless-immutable">seamless-immutable</a>，如果数据量不大但想用这种类似 updateIn 便利的语法的话可以用 seamless-immutable。这个库就没有上面的 Trie 树这些幺蛾子了，就是为其扩展了 updateIn、merge 等 9 个方法的普通简单对象，利用 Object.freeze 冻结对象本身改动, 每次修改返回副本。感觉像是阉割版，性能不及 Immutable.js，但在部分场景下也是适用的。</li><li><a href="https://link.zhihu.com/?target=https://github.com/immerjs/immer">Immer.js</a>，通过用来数据劫持的 Proxy 实现：对原始数据中每个访问到的节点都创建一个 Proxy，修改节点时修改副本而不操作原数据，最后返回到对象由未修改的部分和已修改的副本组成。（这不就是 Vue3 数据响应式原理嘛）<br><a name="ZzcKr"></a></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看完这一段，你现在能回答怎么实现深拷贝了吗？概括成一句就是：<strong>简单需求用 JSON 反序列化，复杂需求用递归克隆</strong>。<br />对于递归克隆的深拷贝，核心有三点：</p><ol><li><strong>对象分类</strong></li><li><strong>递归</strong></li><li>用<strong>缓存</strong>对付<strong>环</strong></li></ol><hr><p><a name="QMocX"></a></p><h2 id="手写-EventHub（发布-订阅）"><a href="#手写-EventHub（发布-订阅）" class="headerlink" title="手写 EventHub（发布-订阅）"></a>手写 EventHub（发布-订阅）</h2><p>核心思路是：</p><ol><li>使用一个对象作为<strong>缓存</strong></li><li>on 负责把方法<strong>发布</strong>到缓存的 EventName 对应的数组</li><li>emit 负责遍历触发<strong>（订阅）</strong> EventName 下的方法数组</li><li>off <strong>找</strong>方法的<strong>索引</strong>，并删除</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventHub</span> &#123;</span><br><span class="line">  cache = &#123;&#125;;</span><br><span class="line">  <span class="title function_">on</span>(<span class="params">eventName, fn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>[eventName] = <span class="variable language_">this</span>.<span class="property">cache</span>[eventName] || [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>[eventName].<span class="title function_">push</span>(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">eventName</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>[eventName].<span class="title function_">forEach</span>(<span class="function">(<span class="params">fn</span>) =&gt;</span> <span class="title function_">fn</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">off</span>(<span class="params">eventName, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="title function_">indexOf</span>(<span class="variable language_">this</span>.<span class="property">cache</span>[eventName], fn); <span class="comment">// 这里用 this.cache[eventName].indexOf(fn) 完全可以，封装成函数是为了向下兼容</span></span><br><span class="line">    <span class="keyword">if</span> (index === -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>[eventName].<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兼容 IE 8 的 indexOf</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">indexOf</span>(<span class="params">arr, item</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr === <span class="literal">undefined</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> index = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] === item) &#123;</span><br><span class="line">      index = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您想看详细的测试与运行结果，请参见 <a href="https://link.zhihu.com/?target=https://github.com/venaissance/ts-source-EventHub">我的 GitHub →</a></p><hr><p><a name="kGhQd"></a></p><h2 id="手写-Promise"><a href="#手写-Promise" class="headerlink" title="手写 Promise"></a>手写 Promise</h2><p>无疑是要求最高的，如果要硬按照 Promises&#x2F;A+ 规范来写，可能至少要 2-3 个小时，400+行代码，这种情况是几乎不可能出现在面试中。所以我们只需要完成一个<strong>差不多</strong>的版本，保留最核心的功能。<br />核心功能：</p><ul><li>new Promise(fn) 其中 fn 只能为函数，且要<strong>立即执行</strong></li><li>promise.then(success, fail)中的 success 是函数，且会在 resolve 被调用的时候执行，fail 同理</li></ul><p>实现思路：</p><ol><li>then(succeed, fail) 先把成功失败回调放到一个回调数组 callbacks[] 上</li><li>resolve() 和 reject() 遍历 callbacks</li><li>resolve() 读取成功回调 &#x2F; reject() 读取失败回调，并异步执行 callbacks 里面的成功和失败回调（放到本轮的微任务队列中）</li></ol><p>下面分享我自己根据上述需求及思路实现的模板：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise2</span> &#123;</span><br><span class="line">  state = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">  callbacks = [];</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;must pass function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">    <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">handle</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> handle[<span class="number">0</span>] === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">          handle[<span class="number">0</span>].<span class="title function_">call</span>(<span class="literal">undefined</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">    <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">handle</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> handle[<span class="number">1</span>] === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">          handle[<span class="number">1</span>].<span class="title function_">call</span>(<span class="literal">undefined</span>, reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">succeed, fail</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> handle = [];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      handle[<span class="number">0</span>] = succeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      handle[<span class="number">1</span>] = fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(handle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process !== <span class="literal">undefined</span> &amp;&amp; <span class="keyword">typeof</span> process.<span class="property">nextTick</span> === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> process.<span class="title function_">nextTick</span>(fn);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 用MutationObserver实现浏览器上的nextTick</span></span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(fn);</span><br><span class="line">    <span class="keyword">var</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter));</span><br><span class="line"></span><br><span class="line">    observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">      <span class="attr">characterData</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line">    textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，如果您想看详细的测试与运行结果，请参见 <a href="https://link.zhihu.com/?target=https://github.com/venaissance/ts-source-promise">我的 GitHub →</a></p><hr><p><a name="HjuHV"></a></p><h2 id="手写-Promise-all"><a href="#手写-Promise-all" class="headerlink" title="手写 Promise.all()"></a>手写 Promise.all()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">PromiseAll</span>(<span class="params">promiseArray</span>) &#123;    <span class="comment">//返回一个Promise对象</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(promiseArray)) &#123;                        <span class="comment">//传入的参数是否为数组</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;传入的参数不是数组！&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> res = []</span><br><span class="line">        <span class="keyword">let</span> counter = <span class="number">0</span>                         <span class="comment">//设置一个计数器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promiseArray.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promiseArray[i]).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                counter++                  <span class="comment">//使用计数器返回 必须使用counter</span></span><br><span class="line">                res[i] = value</span><br><span class="line">                <span class="keyword">if</span> (counter === promiseArray.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(res)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">reject</span>(e))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上为核心实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">res</span>(<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">res</span>(<span class="string">&#x27;p2&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">res</span>(<span class="string">&#x27;p3&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="title class_">PromiseAll</span>([p1, p2, p3])</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e))</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test);</span><br></pre></td></tr></table></figure><p><a name="C9epL"></a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>总结一下，会手写关键代码对技术发展的重要性是不言而喻的，所以大家一定要勇于克服自己内心的恐惧，<strong>刻意练习</strong>，终有一天，你会体会到技术精进的快感！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compatible </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html常见兼容问题</title>
      <link href="/2023/06/26/compatible/html-compatible/"/>
      <url>/2023/06/26/compatible/html-compatible/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="fwfFj"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>iphoneX的“刘海”为相机和其他组件留出了空间，同时在底部也留有可操作区域。其实对于 web 前端来说，刘海在绝大多数的场景下是可以不用处理的，因为 safari 或客户端（微信，手Q等）的 statusBar 已经替我们抹平了顶部刘海，我们只需要关心底部的可操作区域，因为如果页面底部有按钮的话，就会被可操作区域给挡住。<br><a name="MGMfZ"></a></p><h3 id="iPhoneX之变化"><a href="#iPhoneX之变化" class="headerlink" title="iPhoneX之变化"></a>iPhoneX之变化</h3><p><a name="yXFoK"></a></p><h4 id="1-屏幕尺寸、分辨率"><a href="#1-屏幕尺寸、分辨率" class="headerlink" title="1. 屏幕尺寸、分辨率"></a>1. 屏幕尺寸、分辨率</h4><p>追求全面屏的 iPhone X 此次启用 5.8 英寸的超视网膜高清显示屏，458ppi 的屏幕像素密度。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635168-afbcb6c4-7f5f-46bf-a1a4-6fbb06a145e4.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635168-afbcb6c4-7f5f-46bf-a1a4-6fbb06a145e4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br />竖屏时像素分辨率达到了 1125px × 2436px（375pt × 812pt @3x），可以发现 iPhone X 的宽度与原来的 iPhone 7 等 4.7 英寸屏的宽度是一致的，而高度却大了 145pt，长宽比也由原来常见的 16 : 9 变成了 13 : 6。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635317-3044724c-c0e4-4f6a-9b7f-34072df4e91c.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635317-3044724c-c0e4-4f6a-9b7f-34072df4e91c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a name="gssKl"></a></p><h4 id="2-顶部刘海"><a href="#2-顶部刘海" class="headerlink" title="2.顶部刘海"></a>2.顶部刘海</h4><p>新版本的 iPhone 顶部有高度为 30pt 的黑色圆角条来放置扬声器、前置摄像头及各种传感器等，江湖人称 「刘海儿」，这也意味着原页面此处的内容有可能会被遮挡导致显示欠佳，进而影响用户体验，所以这也是我们需要关注的一个适配点。<br />刘海在绝大多数的场景下是可以不用处理的，因为 safari 或客户端（微信，手Q等）的 statusBar 已经替我们抹平了顶部刘海。<br><a name="xJ7kr"></a></p><h4 id="3-虚拟-Home-键"><a href="#3-虚拟-Home-键" class="headerlink" title="3.虚拟 Home 键"></a>3.虚拟 Home 键</h4><p>iPhone X 取消了以往的实体圆形 home 键，取而代之的是在屏幕底部一条 134pt × 5pt 的虚拟指示条。整个虚拟 Home 键也占据了一个高度 34pt 的保留区域。<br />原来实体 Home 键的单击返回桌面、双击唤起多任务处理、长按启动 Siri 等等基础功能操作，也幻化成了不同的手势操作或新技术替代，具体交互手势将在下节详述。而为了增强手势的操作感，整个虚拟 Home 键也占据了一个高度 34pt 的保留区域。<br />而在非特定条件下，这个虚拟指示条无论在横、竖屏中都将是强制性设计元素出现在屏幕底部上，意味着这设计中必须考虑好周围元素与它的兼容，因此，这又是我们适配过程中的另一个关注点。只有在需要获得沉浸式体验（如播放视频、查看图片）时，才会建议开发者可以虚拟指示条 「自动隐藏」功能。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635248-bb443c96-fa7e-4cb0-8658-e9f810cd41fd.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635248-bb443c96-fa7e-4cb0-8658-e9f810cd41fd.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a name="w2Klj"></a></p><h4 id="4-安全区域"><a href="#4-安全区域" class="headerlink" title="4.安全区域"></a>4.安全区域</h4><p>根据上述顶部刘海、虚拟 home 键的不同要求，Apple 提供了横、竖屏状态下的安全区域视觉规范。</p><ul><li>竖屏：竖屏时候，除去屏幕最顶部往下 44pt，底部往上 34pt 后，中间部分视为安全区域。</li><li>横屏：而横屏时候则相对复杂一些，因为虚拟指示条通常情况下都是出现在屏幕底部，所以不仅屏幕左右会留出 44pt 的空白位置，屏幕底部也会留出 21pt 的位置。</li></ul><p>至于为什么没有 “刘海儿” 一侧也会留出空白位置，则是 Apple 认为，“刘海儿”出现于左侧或右侧并不确定，让安全区域中的内容居中显示，可以避免屏幕旋转所造成的 UI 元素位置变化。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635212-b26f4b24-0508-4a49-949c-68e341db7424.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635212-b26f4b24-0508-4a49-949c-68e341db7424.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a name="ZRb8e"></a></p><h3 id="适配方案"><a href="#适配方案" class="headerlink" title="适配方案"></a>适配方案</h3><p>了解到 iPhone X 这边变化之后，我们大致可以知道需要在于安全区域布局、全屏图缩放裁切以及边界交互手势做相关的适配。在 iOS11 中我们可以使用 viewport-fit&#x3D;cover + safe-area-inset-*，<br><a name="xTEji"></a></p><h4 id="关于viewport-fit"><a href="#关于viewport-fit" class="headerlink" title="关于viewport-fit"></a>关于viewport-fit</h4><p>viewport-fit 可以设置可视视窗的大小，它有三个属性值：</p><ul><li>Auto：默认值。这个值不影响初始布局视窗，整个 Web 页面是可视的，与Contain表现一致。</li><li>Contain：最初的布局视窗和视觉布局视窗被设置为最大的矩形（左图）。</li><li>Cover：初始布局视窗和视觉布局视窗被设置为设备物理屏幕的限定矩形（右图）。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635183-fb3978a6-de41-4ae6-b070-8589ee304007.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635183-fb3978a6-de41-4ae6-b070-8589ee304007.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a name="s5zDN"></a></p><h4 id="关于-safe-area-inset"><a href="#关于-safe-area-inset" class="headerlink" title="关于 safe-area-inset-*"></a>关于 safe-area-inset-*</h4><p>各种 iPhone x 都是不规则形状，我们如何控制页面元素到安全区域呢？Apple 把安全区域的位置通过 css 属性提供给了开发者，它们可以通过CSS的constant( )函数来完成：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635694-436826a6-fcfc-4a5c-baf9-bac3a995e66c.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635694-436826a6-fcfc-4a5c-baf9-bac3a995e66c.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><ul><li>constant(safe-area-inset-top)：在Viewport顶部的安全区域内设置量（CSS像素）</li><li>constant(safe-area-inset-bottom)：在Viewport底部的安全区域内设置量（CSS像素）</li><li>constant(safe-area-inset-left)：在Viewport左边的安全区域内设置量（CSS像素）</li><li>constant(safe-area-inset-right)：在Viewport右边的安全区域内设置量（CSS像素）</li><li><br /></li></ul><p>简单来说我们可以通过 constant( ) 可以获取到非安全边距，再结合 padding 或 margin 来控制页面元素避开非安全区域。 Webkit 在 iOS11 中新增 CSS Functions: env( ) 替代 constant( )，文档中推荐使用 env( )，而 constant( ) 从 Safari Techology Preview 41 和 iOS11.2 Beta 开始会被弃用。在不支持 env( ) 的浏览器中，会自动忽略这一样式规则，不影响网页正常的渲染。为了达到最大兼容目的，我们可以 constant( ) 和 env( ) 同时使用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.footerClass</span> &#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">constant</span>(safe-area-inset-bottom); <span class="comment">/* iOS 11.0 */</span></span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-inset-bottom); <span class="comment">/* iOS 11.2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="lVFnh"></a></p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><a name="ei1Oe"></a></p><h4 id="1-设置网页在可视区域的布局方式"><a href="#1-设置网页在可视区域的布局方式" class="headerlink" title="1.设置网页在可视区域的布局方式"></a>1.设置网页在可视区域的布局方式</h4><p>新增 viweport-fit 属性，使得页面内容完全覆盖整个窗口：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; <span class="attribute">content</span>=&quot;<span class="attribute">width</span>=device-<span class="attribute">width</span>, initial-scale=<span class="number">1.0</span>, viewport-fit=cover, minimum-scale=<span class="number">1</span>, maximum-scale=<span class="number">1.0</span>, user-scalable=<span class="number">0</span>&quot;&gt;</span><br></pre></td></tr></table></figure><p><a name="YdtfC"></a></p><h4 id="2-让主体内容控制在安全区域内"><a href="#2-让主体内容控制在安全区域内" class="headerlink" title="2.让主体内容控制在安全区域内"></a>2.让主体内容控制在安全区域内</h4><p>假设我们的底部按钮高度是50px：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="built_in">env</span>(safe-area-inset-top);</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="built_in">env</span>(safe-area-inset-right);</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">50px</span>;  <span class="comment">/* 兼容不支持 env( ) 的设备  */</span></span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">calc</span>(<span class="built_in">env</span>(safe-area-inset-bottom) + <span class="number">50px</span>); <span class="comment">/* 在 iphone x + 中本句才会生效 */</span></span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="built_in">env</span>(safe-area-inset-left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个关键点：</p><ol><li>写在前面的 padding-bottom: 50px 为了兼容没有底部胡子的设备，让主体内容偏移出底部按钮的高度，避免按钮遮挡内容。</li><li><code>padding-bottom: calc(env(safe-area-inset-bottom) + 50px);</code> 计算 底部非安全区域距离 与 底部按钮高度 之和 来做为 <code>padding-bottom</code>值，如果设备支持 env，那么 calc 会计算出一个合法的值，本句的优先级则最高，会覆盖前面的 <code>padding-bottom: 50px</code>。否则 calc 会计算出一个不合法的值，则本句声明不会生效。这样在不支持 env 设备中也可以达到兼容的目的。</li></ol><p>目前到这，在横屏场景下左侧的内容就不会被刘海遮挡住了：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635706-86150bda-7c7b-445b-8d0e-c11ff52e1d77.png#averageHue=%238c9c83&clientId=u30bf360d-bf01-4&from=paste&id=uf3b439d5&originHeight=544&originWidth=960&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf1e4d04d-c750-41c8-8b26-eda83b6e1c8&title=" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635706-86150bda-7c7b-445b-8d0e-c11ff52e1d77.png#averageHue=%238c9c83&clientId=u30bf360d-bf01-4&from=paste&id=uf3b439d5&originHeight=544&originWidth=960&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf1e4d04d-c750-41c8-8b26-eda83b6e1c8&title=" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a name="nvhAH"></a></p><h4 id="3-底部按钮的处理"><a href="#3-底部按钮的处理" class="headerlink" title="3.底部按钮的处理"></a>3.底部按钮的处理</h4><p>首先给底部按钮一个外层容器 .btn-container ，设置样式时其中有几点比较关键：</p><ol><li>设置<code>padding-bottom: env(safe-area-inset-bottom);</code>增加一个 padding 值，让底部向外扩展一个非安全区域的距离。</li><li>设置<code>background: #FFF</code> 让整个 <code>.btn-container</code>背景为白色（包括刚新增的 <code>padding-bottom</code> 的区域）这样就可以遮挡住了底部内容。</li><li>设置 <code>box-sizing: content-box;</code>，因为在通常情况下 css 在 reset 阶段一般都设置了<code>* &#123;box-sizing: border-box;&#125;</code>这样一来设置 padding 就不能向外扩展距离了，所以在这里我们要把他改回 <code>content-box</code>。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn-container</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#FFF</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-inset-bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#00c340</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果如图所示<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635866-dc17d470-498c-41cb-b62e-4095ded62ab9.png#averageHue=%2399a694&clientId=u30bf360d-bf01-4&from=paste&id=u918115cd&originHeight=960&originWidth=544&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u87459362-8a26-445e-b7fd-dc906a20d61&title=" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635866-dc17d470-498c-41cb-b62e-4095ded62ab9.png#averageHue=%2399a694&clientId=u30bf360d-bf01-4&from=paste&id=u918115cd&originHeight=960&originWidth=544&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u87459362-8a26-445e-b7fd-dc906a20d61&title=" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>在 safari 中，页面往上稍滑动一点，出现 safari 的操作栏后，底部按钮依然会紧贴着操作栏：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635821-83d98fec-a439-45dc-bace-df3849d54600.png#averageHue=%238c9484&clientId=u30bf360d-bf01-4&from=paste&id=u44f16efe&originHeight=799&originWidth=453&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u72633772-beb4-4a1b-8a0e-e8023da51b1&title=" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635821-83d98fec-a439-45dc-bace-df3849d54600.png#averageHue=%238c9484&clientId=u30bf360d-bf01-4&from=paste&id=u44f16efe&originHeight=799&originWidth=453&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u72633772-beb4-4a1b-8a0e-e8023da51b1&title=" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><a name="AYsAZ"></a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/a1e8c7cf8821">如何适配 iPhone X</a><br /><a href="https://link.juejin.cn/?target=https://www.w3.org/TR/css-round-display-1/%23viewport-fit-descriptor">CSS Round Display Level 1</a><br /><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/conflicting/Web/CSS/@viewport_a33ee59ffd8336ffb3336900dea02e9f">viewport-fit</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> compatible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js常见兼容问题</title>
      <link href="/2023/06/26/compatible/js-compatible/"/>
      <url>/2023/06/26/compatible/js-compatible/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><a name="aqBRj"></a><h3 id="iPhone7用for…in-遍历数组失效"><a href="#iPhone7用for…in-遍历数组失效" class="headerlink" title="iPhone7用for…in 遍历数组失效"></a>iPhone7用for…in 遍历数组失效</h3><p>问题描述：最初学习使用js时，觉得<code>for...in</code>遍历比<code>for循环</code>简洁，后期在用户反馈后发现iPhone7不支持用for…in遍历数组<br />解决方式： 改为<code>for循环</code>遍历</p><p><a name="kiAHW"></a></p><h3 id="移动端点击事件300-ms延迟问题"><a href="#移动端点击事件300-ms延迟问题" class="headerlink" title="移动端点击事件300 ms延迟问题"></a>移动端点击事件300 ms延迟问题</h3><p>问题描述：移动端web网页是有300ms延迟的，往往会造成按钮点击延迟甚至是点击失效。<br />解决方式：</p><ul><li>fastclick可以解决在手机上点击事件的300ms延迟</li><li>zepto.js的touch模块，tap事件也是为了解决在click的延迟问题</li></ul><p><a name="nK6Db"></a></p><h3 id="audio-和-video-在-ios-和-andriod-中自动播放"><a href="#audio-和-video-在-ios-和-andriod-中自动播放" class="headerlink" title="audio 和 video 在 ios 和 andriod 中自动播放"></a>audio 和 video 在 ios 和 andriod 中自动播放</h3><p>出于优化用户体验，苹果系统和安卓系统通常都会禁止自动播放和禁止页面加载时使用 JS 触发播放，必须由用户主动点击页面才可以触发播放。通过给页面根元素加touchstart的监听事件实现触发播放</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;html&#x27;</span>).<span class="title function_">one</span>(<span class="string">&#x27;touchstart&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  audio.<span class="title function_">play</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a name="aIKcn"></a></p><h3 id="iOS-上拉边界下拉出现空白"><a href="#iOS-上拉边界下拉出现空白" class="headerlink" title="iOS 上拉边界下拉出现空白"></a>iOS 上拉边界下拉出现空白</h3><p>问题描述：手指按住屏幕下拉，屏幕顶部会多出一块白色区域。手指按住屏幕上拉，底部多出一块白色区域。<br />产生原因：在 iOS 中，手指按住屏幕上下拖动，会触发 touchmove 事件。这个事件触发的对象是整个 webview 容器，容器自然会被拖动，剩下的部分会成空白。<br />解决方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;touchmove&#x27;</span>,</span><br><span class="line">  <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">_isScroller</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 阻止默认事件</span></span><br><span class="line">    e.<span class="title function_">preventDefault</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">passive</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a name="emtPB"></a></p><h3 id="ios-日期转换-NAN-的问题"><a href="#ios-日期转换-NAN-的问题" class="headerlink" title="ios 日期转换 NAN 的问题"></a>ios 日期转换 NAN 的问题</h3><p>将日期字符串的格式符号替换成’&#x2F;‘</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;yyyy-MM-dd&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/-/g</span>, <span class="string">&#x27;/&#x27;</span>)</span><br></pre></td></tr></table></figure><p><a name="ibcS5"></a></p><h3 id="软键盘问题"><a href="#软键盘问题" class="headerlink" title="软键盘问题"></a>软键盘问题</h3><p><a name="oXllV"></a></p><h4 id="iOS-系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格"><a href="#iOS-系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格" class="headerlink" title="iOS 系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格"></a>iOS 系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格</h4><p>解决方式：可以通过正则去掉</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">value</span>.<span class="title function_">replace</span>(<span class="regexp">/\u2006/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure><p><a name="Qmh75"></a></p><h4 id="IOS-键盘弹起挡住原来的视图"><a href="#IOS-键盘弹起挡住原来的视图" class="headerlink" title="IOS 键盘弹起挡住原来的视图"></a>IOS 键盘弹起挡住原来的视图</h4><p>解决方式：</p><ul><li>可以通过监听移动端软键盘弹起 Element.scrollIntoViewIfNeeded（Boolean）方法用来将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域。 如果该元素已经在浏览器窗口的可见区域内，则不会发生滚动。</li><li>true，则元素将在其所在滚动区的可视区域中居中对齐。</li><li>false，则元素将与其所在滚动区的可视区域最近的边缘对齐。 根据可见区域最靠近元素的哪个边缘，元素的顶部将与可见区域的顶部边缘对准，或者元素的底部边缘将与可见区域的底部边缘对准。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">activeElement</span>.<span class="property">tagName</span> === <span class="string">&#x27;INPUT&#x27;</span> ||</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">activeElement</span>.<span class="property">tagName</span> === <span class="string">&#x27;TEXTAREA&#x27;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&#x27;scrollIntoView&#x27;</span> <span class="keyword">in</span> <span class="variable language_">document</span>.<span class="property">activeElement</span>) &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">activeElement</span>.<span class="title function_">scrollIntoView</span>(<span class="literal">false</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">activeElement</span>.<span class="title function_">scrollIntoViewIfNeeded</span>(<span class="literal">false</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a name="RQUuS"></a></p><h4 id="onkeyUp-和-onKeydown-兼容性问题"><a href="#onkeyUp-和-onKeydown-兼容性问题" class="headerlink" title="onkeyUp 和 onKeydown 兼容性问题"></a>onkeyUp 和 onKeydown 兼容性问题</h4><p>IOS 中 input 键盘事件 keyup、keydown、等支持不是很好, 用 input 监听键盘 keyup 事件，在安卓手机浏览器中没有问题，但是在 ios 手机浏览器中用输入法输入之后，并未立刻相应 keyup 事件</p><p><a name="vb5qX"></a></p><h4 id="IOS12-输入框难以点击获取焦点，弹不出软键盘"><a href="#IOS12-输入框难以点击获取焦点，弹不出软键盘" class="headerlink" title="IOS12 输入框难以点击获取焦点，弹不出软键盘"></a>IOS12 输入框难以点击获取焦点，弹不出软键盘</h4><p>定位找到问题是 fastclick.js 对 IOS12 的兼容性，可在 fastclick.js 源码或者 main.js 做以下修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">FastClick</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">focus</span> = <span class="keyword">function</span>(<span class="params">targetElement</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> length</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    deviceIsIOS &amp;&amp;</span><br><span class="line">    targetElement.<span class="property">setSelectionRange</span> &amp;&amp;</span><br><span class="line">    targetElement.<span class="property">type</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;date&#x27;</span>) !== <span class="number">0</span> &amp;&amp;</span><br><span class="line">    targetElement.<span class="property">type</span> !== <span class="string">&#x27;time&#x27;</span> &amp;&amp;</span><br><span class="line">    targetElement.<span class="property">type</span> !== <span class="string">&#x27;month&#x27;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    length = targetElement.<span class="property">value</span>.<span class="property">length</span></span><br><span class="line">    targetElement.<span class="title function_">setSelectionRange</span>(length, length)</span><br><span class="line">    targetElement.<span class="title function_">focus</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    targetElement.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="vo5o5"></a></p><h4 id="IOS-键盘收起时页面没用回落，底部会留白"><a href="#IOS-键盘收起时页面没用回落，底部会留白" class="headerlink" title="IOS 键盘收起时页面没用回落，底部会留白"></a>IOS 键盘收起时页面没用回落，底部会留白</h4><p>通过监听键盘回落时间滚动到原来的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;focusout&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//input输入框弹起软键盘的解决方案。</span></span><br><span class="line"><span class="keyword">var</span> bfscrolltop = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span></span><br><span class="line">$(<span class="string">&#x27;input&#x27;</span>)</span><br><span class="line">  .<span class="title function_">focus</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollHeight</span></span><br><span class="line">    <span class="comment">//console.log(document.body.scrollTop);</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">blur</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> = bfscrolltop</span><br><span class="line">    <span class="comment">//console.log(document.body.scrollTop);</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="ALt6l"></a></p><h4 id="IOS-下-fixed-失效"><a href="#IOS-下-fixed-失效" class="headerlink" title="IOS 下 fixed 失效"></a>IOS 下 fixed 失效</h4><p>问题描述：软键盘唤起后，页面的 fixed 元素将失效，变成了 absolute，所以当页面超过一屏且滚动时，失效的 fixed 元素就会跟随滚动了。不仅限于 type&#x3D;text 的输入框，凡是软键盘（比如时间日期选择、select 选择等等）被唤起，都会遇到同样地问题。 解决方法: 不让页面滚动，而是让主体部分自己滚动,主体部分高度设为 100%，overflow:scroll</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;warper&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;main&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fix-bottom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.warper</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">  -webkit-<span class="attribute">overflow</span>-scrolling: touch; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fix-bottom</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compatible </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css常见兼容问题</title>
      <link href="/2023/06/26/compatible/css-compatible/"/>
      <url>/2023/06/26/compatible/css-compatible/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h4 id="移动端的-1px"><a href="#移动端的-1px" class="headerlink" title="移动端的 1px"></a>移动端的 1px</h4><p>问题描述：1px 的边框。在高清屏下，移动端的 1px 会很粗。<br />产生原因：首先先要了解一个概念：<strong>DPR(devicePixelRatio) 设备像素比</strong>，它是默认缩放为 100%的情况下，设备像素和 CSS 逻辑像素的比值。目前主流的屏幕 DPR&#x3D;2 或者 3。CSS中设置的px是逻辑像素,这就造成1px变成物理像素的2px或者3px，比如2 倍屏，设备的物理像素要实现 1 像素，所以 CSS 逻辑像素只能是 0.5px。<br />下面介绍最常用的方法<br />通过CSS :before 选择器或CSS :after 选择器设置height:1px，同时缩放0.5倍实现。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 底边框 */</span></span><br><span class="line"><span class="selector-class">.b-border</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.b-border</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#d9d9d9</span>;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  -webkit-<span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 四条边 */</span></span><br><span class="line"><span class="selector-class">.setBorderAll</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  &amp;<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">    <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e5e5e5</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="KO4Ca"></a></p><h4 id="CSS动画页面闪白-动画卡顿"><a href="#CSS动画页面闪白-动画卡顿" class="headerlink" title="CSS动画页面闪白,动画卡顿"></a>CSS动画页面闪白,动画卡顿</h4><p>问题描述：CSS动画页面闪白,动画卡顿<br />解决方法: <br />1.尽可能地使用合成属性transform和opacity来设计CSS3动画，不使用position的left和top来定位 <br />2.开启硬件加速</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-webkit-<span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">-moz-<span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">-ms-<span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><a name="cvaLi"></a></p><h4 id="屏蔽用户选择"><a href="#屏蔽用户选择" class="headerlink" title="屏蔽用户选择"></a>屏蔽用户选择</h4><p>禁止用户选择页面中的文字或者图片</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  -webkit-touch-callout: none;</span><br><span class="line">  -webkit-user-select: none;</span><br><span class="line">  -khtml-user-select: none;</span><br><span class="line">  -moz-user-select: none;</span><br><span class="line">  -ms-user-select: none;</span><br><span class="line">  user-select: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="IzfcU"></a></p><h4 id="清除输入框内阴影"><a href="#清除输入框内阴影" class="headerlink" title="清除输入框内阴影"></a>清除输入框内阴影</h4><p>问题描述：在 iOS 上，输入框默认有内部阴影 解决方式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">  -webkit-appearance: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="GBwTM"></a></p><h4 id="禁止保存或拷贝图像"><a href="#禁止保存或拷贝图像" class="headerlink" title="禁止保存或拷贝图像"></a>禁止保存或拷贝图像</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  -webkit-touch-callout: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="o7i6z"></a></p><h4 id="输入框默认字体颜色设置"><a href="#输入框默认字体颜色设置" class="headerlink" title="输入框默认字体颜色设置"></a>输入框默认字体颜色设置</h4><p>设置 input 里面 placeholder 字体的颜色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span>::-webkit-input-placeholder,</span><br><span class="line">textarea::-webkit-input-placeholder &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#c7c7c7</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span>:-moz-placeholder,</span><br><span class="line">textarea:-moz-placeholder &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#c7c7c7</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span>:-ms-input-placeholder,</span><br><span class="line">textarea:-ms-input-placeholder &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#c7c7c7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="b54E7"></a></p><h4 id="用户设置字号放大或者缩小导致页面布局错误"><a href="#用户设置字号放大或者缩小导致页面布局错误" class="headerlink" title="用户设置字号放大或者缩小导致页面布局错误"></a>用户设置字号放大或者缩小导致页面布局错误</h4><p>设置字体禁止缩放</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  -webkit-text-size-adjust: <span class="number">100%</span> <span class="meta">!important</span>;</span><br><span class="line">  text-size-adjust: <span class="number">100%</span> <span class="meta">!important</span>;</span><br><span class="line">  -moz-text-size-adjust: <span class="number">100%</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="QmFWH"></a></p><h4 id="android系统中元素被点击时产生边框"><a href="#android系统中元素被点击时产生边框" class="headerlink" title="android系统中元素被点击时产生边框"></a>android系统中元素被点击时产生边框</h4><p>部分android系统点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样。去除代码如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>,<span class="selector-tag">button</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>&#123;</span><br><span class="line">  -webkit-tap-highlight-<span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">  -webkit-user-modify:read-write-plaintext-only; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="OVd7J"></a></p><h4 id="iOS-滑动不流畅"><a href="#iOS-滑动不流畅" class="headerlink" title="iOS 滑动不流畅"></a>iOS 滑动不流畅</h4><p>ios 手机上下滑动页面会产生卡顿，手指离开页面，页面立即停止运动。整体表现就是滑动不流畅，没有滑动惯性。 iOS 5.0 以及之后的版本，滑动有定义有两个值 auto 和 touch，默认值为 auto。</p><ul><li>解决方式</li></ul><p>1.在滚动容器上增加滚动 touch 方法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  -webkit-<span class="attribute">overflow</span>-scrolling: touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2.设置 overflow 设置外部 overflow 为 hidden,设置内容元素 overflow 为 auto。内部元素超出 body 即产生滚动，超出的部分 body 隐藏。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">overflow-y</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">overflow-y</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compatible </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
