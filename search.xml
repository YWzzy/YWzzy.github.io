<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从输入url到页面加载</title>
      <link href="/2023/06/27/frontend/browser/cong-shu-ru-url-dao-ye-mian-jia-zai/"/>
      <url>/2023/06/27/frontend/browser/cong-shu-ru-url-dao-ye-mian-jia-zai/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="section-3"></a></p><h2 id="对知识体系进行一次预评级"><a href="#对知识体系进行一次预评级" class="headerlink" title="对知识体系进行一次预评级"></a>对知识体系进行一次预评级</h2><p>看到这道题目，不借助搜索引擎，自己的心里是否有一个答案？<br />这里，以目前的经验（了解过一些处于不同阶段的相关前端人员的情况），大概有以下几种情况：（以下都是以点见面，实际上不同阶段人员一般都会有其它的隐藏知识点的）<br><a name="section-3-1"></a></p><h3 id="level1"><a href="#level1" class="headerlink" title="level1:"></a><strong>level1:</strong></h3><p>完全没什么概念的，支支吾吾的回答，一般就是这种水平（大致形象点描述）：</p><blockquote><ul><li>浏览器发起请求</li><li>服务端返回数据</li><li>前端解析成网页，执行脚本。。。</li></ul></blockquote><p>这类人员一般都是：</p><ul><li>萌新（刚接触前端的，包括0-6个月都有可能有这种回答）</li><li>沉淀人员（就是那种可能已经接触了前端几年，但是仍然处于初级阶段的那种。。。）</li></ul><p>当然了，后者一般还会偶尔提下<code>**http**</code><strong>、</strong><code>**后台**</code><strong>、</strong><code>**浏览器渲染**</code><strong>，</strong><code>**js引擎**</code>等等关键字，但基本都是一详细的问就不知道了。。。</p><p><a name="section-3-2"></a></p><h3 id="level2"><a href="#level2" class="headerlink" title="level2:"></a><strong>level2:</strong></h3><p>已经有初步概念，但是可能没有完整梳理过，导致无法形成一个完整的体系，或者是很多细节都不会展开，大概是这样子的：（可能符合若干条）</p><blockquote><ul><li>知道浏览器输入url后会有http请求这个概念</li><li>有后台这个概念，大致知道前后端的交互，知道前后端只要靠http报文通信</li><li>知道浏览器接收到数据后会进行解析，有一定概念，但是具体流程不熟悉（如render树构建流程，layout、paint，复合层与简单层，常用优化方案等不是很熟悉）</li><li>对于js引擎的解析流程有一定概念，但是细节不熟悉（如具体的形参，函数，变量提升，执行上下文以及VO、AO、作用域链，回收机制等概念不是很熟悉）</li><li>如可能知道一些http规范初步概念，但是不熟悉（如http报文结构，常用头部，缓存机制，http2.0，https等特性，跨域与web安全等不是很熟悉）</li></ul></blockquote><p>到这里，看到这上面一大堆的概念后，心里应该也会有点底了。。。<br /><strong>实际上，大部分的前端人员可能都处于level2</strong>，但是，跳出这个阶段并不容易，一般需要积累，不断学习，才能水到渠成<br />这类人员一般都是：</p><ul><li>工作1-3年左右的普通人员（占大多数，而且大多数人员工作3年左右并没有实质上的提升）</li><li>工作3年以上的老人（这部分人大多都业务十分娴熟，一个当好几个用，但是，基础比较薄弱，可能没有尝试写过框架、组件、脚手架等）</li></ul><p>大部分的初中级都陷在这个阶段，如果要突破，不断学习，积累，自然能水到渠成，打通任督二脉</p><p><a name="section-3-3"></a></p><h3 id="level3"><a href="#level3" class="headerlink" title="level3:"></a><strong>level3:</strong></h3><p>基本能到这一步的，不是高阶就是接近高阶，因为很多概念并不是靠背就能理解的，而要理解这么多，需形成体系，一般都需要积累，非一日之功。<br />一般包括什么样的回答呢？（这里就以自己的简略回答进行举例），一般这个阶段的人员都会符合若干条（不一定全部，当然可能还有些是这里遗漏的）:</p><blockquote><ul><li>首先略去那些键盘输入、和操作系统交互、以及屏幕显示原理、网卡等硬件交互之类的（前端向中，很多硬件原理暂时略去。。。）</li><li>对浏览器模型有整体概念，知道浏览器是多进程的，浏览器内核是多线程的，清楚进程与线程之间得区别，以及输入url后会开一个新的网络线程</li><li>对从开启网络线程到发出一个完整的http请求中间的过程有所了解（如dns查询，tcp&#x2F;ip链接，五层因特网协议栈等等，以及一些优化方案，如<code>dns-prefetch</code>）</li><li>对从服务器接收到请求到对应后台接收到请求有一定了解（如负载均衡，安全拦截以及后台代码处理等）</li><li>对后台和前台的http交互熟悉（包括http报文结构，场景头部，cookie，跨域，web安全，http缓存，http2.0，https等）</li><li>对浏览器接收到http数据包后的解析流程熟悉（包括解析html，词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、里面可能还包括复合图层的合成、GPU绘制、外链处理、加载顺序等）</li><li>对JS引擎解析过程熟悉（包括JS的解释，预处理，执行上下文，VO，作用域链，this，回收机制等）</li></ul></blockquote><p>可以看到，上述包括了一大堆的概念，仅仅是偏前端向，而且没有详细展开，就已经如此之多的概念了，所以，个人认为如果没有自己的见解，没有形成自己的知识体系，仅仅是看看，背背是没用的，过一段时间就会忘光了。<br />再说下一般这个阶段的都可能是什么样的人吧。（不一定准确，这里主要是靠少部分现实以及大部分推测得出）</p><ul><li>工作2年以上的前端（基本上如果按正常进度的话，至少接触前端两年左右才会开始走向高阶，当然，现在很多都是上学时就开始学了的，还有部分是天赋异禀，不好预估。。。）</li><li>或者是已经十分熟悉其它某门语言，再转前端的人（基本上是很快就可以将前端水准提升上去）</li></ul><p>一般符合这个条件的都会有各种隐藏属性（如看过各大框架、组件的源码，写过自己的组件、框架、脚手架，做过大型项目，整理过若干精品博文等）</p><p><a name="section-3-4"></a></p><h3 id="level4"><a href="#level4" class="headerlink" title="level4:"></a><strong>level4:</strong></h3><p>由于本人层次尚未达到，所以大致说下自己的见解吧。<br />一般这个层次，很多大佬都并不仅仅是某个技术栈了，而是成为了技术专家，技术leader之类的角色。所以仅仅是回答某个技术问题已经无法看出水准了， 可能更多的要看架构，整体把控，大型工程构建能力等等<br />不过，对于某些执着于技术的大佬，大概会有一些回答吧：（猜的）</p><blockquote><ul><li>从键盘谈起到系统交互</li><li>从浏览器到CPU</li><li>从调度机制到系统内核</li><li>从数据请求到二进制、汇编</li><li>从GPU绘图到LCD显示</li><li>然后再分析系统底层的进程、内存等等</li></ul></blockquote><p>总之，从软件到硬件，到材料，到分子，原子，量子，薛定谔的猫，人类起源，宇宙大爆炸，平行宇宙？感觉都毫无违和感。。。<br />这点可以参考下本题的原始出处：<br /><a href="http://fex.baidu.com/blog/2014/05/what-happen/">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a></p><p><a name="section-4"></a></p><h2 id="为什么说知识体系如此重要？"><a href="#为什么说知识体系如此重要？" class="headerlink" title="为什么说知识体系如此重要？"></a>为什么说知识体系如此重要？</h2><p>为什么说知识体系如此重要呢？这里举几个例子<br />假设有被问到这样一道题目（随意想到的一个）：</p><ul><li>如何理解<code>getComputedStyle</code></li></ul><p>在尚未梳理知识体系前，大概会这样回答：</p><ul><li>普通版本：<code>getComputedStyle</code>会获取当前元素所有最终使用的CSS属性值（最终计算后的结果），通过<code>window.getComputedStyle</code>等价于<code>document.defaultView.getComputedStyle</code>调用</li><li>详细版本：<code>window.getComputedStyle(elem, null).getPropertyValue(&quot;height&quot;)</code>可能的值为<code>100px</code>，而且，就算是css上写的是<code>inherit</code>，<code>getComputedStyle</code>也会把它最终计算出来的。不过注意，如果元素的背景色透明，那么<code>getComputedStyle</code>获取出来的就是透明的这个背景（因为透明本身也是有效的），而不会是父节点的背景。所以它不一定是最终显示的颜色。</li></ul><p>就这个API来说，上述的回答已经比较全面了。<br />但是，其实它是可以继续延伸的。<br />譬如现在会这样回答：</p><ul><li><code>getComputedStyle</code>会获取当前元素所有最终使用的CSS属性值，<code>window.</code>和<code>document.defaultView.</code>等价…</li><li><code>getComputedStyle</code>会引起回流，因为它需要获取祖先节点的一些信息进行计算（譬如宽高等），所以用的时候慎用，回流会引起性能问题。然后合适的话会将话题引导回流，重绘，浏览器渲染原理等等。当然也可以列举一些其它会引发回流的操作，如<code>offsetXXX</code>，<code>scrollXXX</code>，<code>clientXXX</code>，<code>currentStyle</code>等等</li></ul><p>再举一个例子：</p><ul><li><code>visibility: hidden</code>和<code>display: none</code>的区别</li></ul><p>可以如下回答：</p><ul><li>普通回答，一个隐藏，但占据位置，一个隐藏，不占据位置</li><li>进一步，<code>display</code>由于隐藏后不占据位置，所以造成了dom树的改变，会引发回流，代价较大</li><li>再进一步，当一个页面某个元素经常需要切换<code>display</code>时如何优化，一般会用复合层优化，或者要求低一点用<code>absolute</code>让其脱离普通文档流也行。然后可以将话题引到普通文档流，<code>absolute</code>文档流，复合图层的区别，</li><li>再进一步可以描述下浏览器渲染原理以及复合图层和普通图层的绘制区别（复合图层单独分配资源，独立绘制，性能提升，但是不能过多，还有隐式合成等等）</li></ul><p>上面这些大概就是知识系统化后的回答，会更全面，容易由浅入深，而且一有机会就可以往更底层挖<br><a name="section-4-1"></a></p><h3 id="前端向知识的重点"><a href="#前端向知识的重点" class="headerlink" title="前端向知识的重点"></a>前端向知识的重点</h3><p><strong>此部分的内容是站在个人视角分析的，并不是说就一定是正确答案</strong><br />首先明确，计算机方面的知识是可以无穷无尽的挖的，而本文的重点是梳理<strong>前端向</strong>的重点知识<br />对于<strong>前端向</strong>（这里可能没有提到<code>node.js</code>之类的，更多的是指客户端前端），这里将知识点按重要程度划分成以下几大类：</p><ul><li>核心知识，必须掌握的，也是最基础的，譬如浏览器模型，渲染原理，JS解析过程，JS运行机制等，作为骨架来承载知识体系</li><li>重点知识，往往每一块都是一个知识点，而且这些知识点都很重要，譬如http相关，web安全相关，跨域处理等</li><li>拓展知识，这一块可能更多的是了解，稍微实践过，但是认识上可能没有上面那么深刻，譬如五层因特网协议栈，hybrid模式，移动原生开发，后台相关等等（当然，在不同领域，可能有某些知识就上升到重点知识层次了，譬如hybrid开发时，懂原生开发是很重要的）</li></ul><p>为什么要按上面这种方式划分？<br />这大概与个人的技术成长有关。<br />记得最开始学前端知识时，是一点一点的积累，一个知识点一个知识点的攻克。<br />就这样，虽然在很长一段时间内积累了不少的知识，但是，总是无法将它串联到一起。每次梳理时都是很分散的，无法保持思路连贯性。<br />直到后来，在将浏览器渲染原理、JS运行机制、JS引擎解析流程梳理一遍后，感觉就跟打通了任督二脉一样，有了一个整体的架构，以前的知识点都连贯起来了。<br />梳理出了一个知识体系，以后就算再学新的知识，也会尽量往这个体系上靠拢，环环相扣，更容易理解，也更不容易遗忘<br><a name="section-5"></a></p><h2 id="梳理主干流程"><a href="#梳理主干流程" class="headerlink" title="梳理主干流程"></a>梳理主干流程</h2><p>回到这道题上，如何回答呢？先梳理一个骨架<br />知识体系中，最重要的是骨架，脉络。有了骨架后，才方便填充细节。所以，先梳理下主干流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）</span><br><span class="line">2. 开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）</span><br><span class="line">3. 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</span><br><span class="line">4. 后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）</span><br><span class="line">5. 单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）</span><br><span class="line">6. 浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）</span><br><span class="line">7. CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）</span><br><span class="line">8. JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</span><br><span class="line">9. 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）</span><br></pre></td></tr></table></figure><p>梳理出主干骨架，然后就需要往骨架上填充细节内容<br><a name="section-6"></a></p><h2 id="从浏览器接收url到开启网络请求线程"><a href="#从浏览器接收url到开启网络请求线程" class="headerlink" title="从浏览器接收url到开启网络请求线程"></a>从浏览器接收url到开启网络请求线程</h2><p>这一部分展开的内容是：浏览器进程&#x2F;线程模型，JS的运行机制<br><a name="section-6-1"></a></p><h3 id="多进程的浏览器"><a href="#多进程的浏览器" class="headerlink" title="多进程的浏览器"></a>多进程的浏览器</h3><p>浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）<br />进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等</p><ul><li>Browser进程：浏览器的主进程（负责协调、主控），只有一个</li><li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li><li>GPU进程：最多一个，用于3D绘制</li><li>浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）</li></ul><p>如下图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596828180-d5b4f0a9-fafc-4381-a27e-831c7edb58ab.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596828180-d5b4f0a9-fafc-4381-a27e-831c7edb58ab.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="section-6-2"></a></p><h3 id="多线程的浏览器内核"><a href="#多线程的浏览器内核" class="headerlink" title="多线程的浏览器内核"></a>多线程的浏览器内核</h3><p>每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程</p><ul><li>GUI线程</li><li>JS引擎线程</li><li>事件触发线程</li><li>定时器线程</li><li>网络请求线程</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596833651-e63a1e70-79f0-400c-8d54-6e5548d39d9e.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596833651-e63a1e70-79f0-400c-8d54-6e5548d39d9e.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />可以看到，里面的JS引擎是内核进程中的一个线程，这也是为什么常说JS引擎是单线程的<br><a name="section-6-3"></a></p><h3 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h3><p>输入URL后，会进行解析（URL的本质就是统一资源定位符）<br />URL一般包括几大部分：</p><ul><li><code>protocol</code>，协议头，譬如有http，ftp等</li><li><code>host</code>，主机域名或IP地址</li><li><code>port</code>，端口号</li><li><code>path</code>，目录路径</li><li><code>query</code>，即查询参数</li><li><code>fragment</code>，即<code>#</code>后的hash值，一般用来定位到某个位置<br><a name="section-6-4"></a></li></ul><h3 id="网络请求都是单独的线程"><a href="#网络请求都是单独的线程" class="headerlink" title="网络请求都是单独的线程"></a>网络请求都是单独的线程</h3><p>每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载<br />因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源（这里，暂时理解为是浏览器内核开辟的，如有错误，后续修复）<br><a name="section-6-5"></a></p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>由于篇幅关系，这里就大概介绍一个主干流程，关于浏览器的进程机制，更多可以参考以前总结的一篇文章（因为内容实在过多，里面包括JS运行机制，进程线程的详解）<br /><a href="https://segmentfault.com/a/1190000012925872">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a><br><a name="section-7"></a></p><h2 id="开启网络线程到发出一个完整的http请求"><a href="#开启网络线程到发出一个完整的http请求" class="headerlink" title="开启网络线程到发出一个完整的http请求"></a>开启网络线程到发出一个完整的http请求</h2><p>这一部分主要内容包括：<code>dns</code>查询，<code>tcp/ip</code>请求构建，<code>五层因特网协议栈</code>等等<br />仍然是先梳理主干，有些详细的过程不展开（因为展开的话内容过多）<br><a name="section-7-1"></a></p><h3 id="DNS查询得到IP"><a href="#DNS查询得到IP" class="headerlink" title="DNS查询得到IP"></a>DNS查询得到IP</h3><p>如果输入的是域名，需要进行dns解析成IP，大致流程：</p><ul><li>如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host</li><li>如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP</li></ul><p>注意，域名查询时有可能是经过了CDN调度器的（如果有cdn存储功能的话）<br />而且，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑<code>dns-prefetch</code>优化<br />这一块可以深入展开，具体请去网上搜索，这里就不占篇幅了（网上可以看到很详细的解答）<br><a name="section-7-2"></a></p><h3 id="tcp-x2F-ip请求"><a href="#tcp-x2F-ip请求" class="headerlink" title="tcp&#x2F;ip请求"></a>tcp&#x2F;ip请求</h3><p>http的本质就是<code>tcp/ip</code>请求<br />需要了解3次握手规则建立连接以及断开连接时的四次挥手<br />tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输<br /><strong>三次握手的步骤：（抽象派）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端：hello，你是server么？</span><br><span class="line">服务端：hello，我是server，你是client么</span><br><span class="line">客户端：yes，我是client</span><br></pre></td></tr></table></figure><p>建立连接成功后，接下来就正式传输数据<br />然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）<br /><strong>四次挥手的步骤：（抽象派）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主动方：我已经关闭了向你那边的主动通道了，只能被动接收了</span><br><span class="line">被动方：收到通道关闭的信息</span><br><span class="line">被动方：那我也告诉你，我这边向你的主动通道也关闭了</span><br><span class="line">主动方：最后收到数据，之后双方无法通信</span><br></pre></td></tr></table></figure><p><strong>tcp&#x2F;ip的并发限制</strong><br />浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）<br />而且在http1.0中往往一个资源下载就需要对应一个tcp&#x2F;ip请求<br />所以针对这个瓶颈，又出现了很多的资源优化方案<br /><strong>get和post的区别</strong><br />get和post虽然本质都是tcp&#x2F;ip，但两者除了在http层面外，在tcp&#x2F;ip层面也有区别。<br />get会产生一个tcp数据包，post两个<br />具体就是：</p><ul><li>get请求时，浏览器会把<code>headers</code>和<code>data</code>一起发送出去，服务器响应200（返回数据），</li><li>post请求时，浏览器先发送<code>headers</code>，服务器响应<code>100 continue</code>， 浏览器再发送<code>data</code>，服务器响应200（返回数据）。</li></ul><p>再说一点，这里的区别是<code>specification</code>（规范）层面，而不是<code>implementation</code>（对规范的实现）<br><a name="section-7-3"></a></p><h3 id="五层因特网协议栈"><a href="#五层因特网协议栈" class="headerlink" title="五层因特网协议栈"></a>五层因特网协议栈</h3><p>其实这个概念挺难记全的，记不全没关系，但是要有一个整体概念<br />其实就是一个概念： <strong>从客户端发出http请求到服务器接收，中间会经过一系列的流程。</strong><br />简括就是：<br /><strong>从应用层的发送http请求，到传输层通过三次握手建立tcp&#x2F;ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。</strong><br />当然，服务端的接收就是反过来的步骤<br />五层因特网协议栈其实就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.应用层(dns,http) DNS解析成IP并发送http请求</span><br><span class="line">2.传输层(tcp,udp) 建立tcp连接（三次握手）</span><br><span class="line">3.网络层(IP,ARP) IP寻址</span><br><span class="line">4.数据链路层(PPP) 封装成帧</span><br><span class="line">5.物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）</span><br></pre></td></tr></table></figure><p>当然，其实也有一个完整的OSI七层框架，与之相比，多了会话层、表示层。<br />OSI七层框架：<code>物理层</code>、<code>数据链路层</code>、<code>网络层</code>、<code>传输层</code>、<code>会话层</code>、<code>表示层</code>、<code>应用层</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等</span><br><span class="line">会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程</span><br></pre></td></tr></table></figure><p><a name="section-8"></a></p><h2 id="从服务器接收到请求到对应后台接收到请求"><a href="#从服务器接收到请求到对应后台接收到请求" class="headerlink" title="从服务器接收到请求到对应后台接收到请求"></a>从服务器接收到请求到对应后台接收到请求</h2><p>服务端在接收到请求时，内部会进行很多的处理<br />这里由于不是专业的后端分析，所以只是简单的介绍下，不深入<br><a name="section-9"></a></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合反向代理实现负载均衡<br />当然了，负载均衡不止这一种实现方式，这里不深入…<br />简单的说：<br /><strong>用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户</strong><br><a name="section-10"></a></p><h2 id="后台的处理"><a href="#后台的处理" class="headerlink" title="后台的处理"></a>后台的处理</h2><p>一般后台都是部署到容器中的，所以一般为：</p><ul><li>先是容器接受到请求（如tomcat容器）</li><li>然后对应容器中的后台程序接收到请求（如java程序）</li><li>然后就是后台会有自己的统一处理，处理完后响应响应结果</li></ul><p>概括下：</p><ul><li>一般有的后端是有统一的验证的，如安全拦截，跨域验证</li><li>如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）</li><li>然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）</li><li>等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）</li><li>然后就是将这个包从后端发送到前端，完成交互<br><a name="section-11"></a></li></ul><h2 id="后台和前台的http交互"><a href="#后台和前台的http交互" class="headerlink" title="后台和前台的http交互"></a>后台和前台的http交互</h2><p>前后端交互时，http报文作为信息的载体<br />所以http是一块很重要的内容，这一部分重点介绍它<br><a name="section-11-1"></a></p><h3 id="http报文结构"><a href="#http报文结构" class="headerlink" title="http报文结构"></a>http报文结构</h3><p>报文一般包括了：<code>通用头部</code>，<code>请求/响应头部</code>，<code>请求/响应体</code><br /><strong>通用头部</strong><br />这也是开发人员见过的最多的信息，包括如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Request Url: 请求的web服务器地址</span><br><span class="line">Request Method: 请求方式</span><br><span class="line">（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）</span><br><span class="line">Status Code: 请求的返回状态码，如200代表成功</span><br><span class="line">Remote Address: 请求的远程服务器地址（会转为IP）</span><br></pre></td></tr></table></figure><p>譬如，在跨域拒绝时，可能是method为<code>options</code>，状态码为<code>404/405</code>等（当然，实际上可能的组合有很多）<br />其中，Method的话一般分为两批次：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。</span><br><span class="line">以及几种Additional Request Methods：PUT、DELETE、LINK、UNLINK</span><br><span class="line">HTTP1.1定义了八种请求方法：GET、POST、HEAD、OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</span><br></pre></td></tr></table></figure><p><code>HTTP 1.0</code>定义参考：<a href="https://tools.ietf.org/html/rfc1945">https://tools.ietf.org/html/rfc1945</a><br /><code>HTTP 1.1</code>定义参考：<a href="https://tools.ietf.org/html/rfc2616">https://tools.ietf.org/html/rfc2616</a><br />这里面最常用到的就是状态码，很多时候都是通过状态码来判断，如（列举几个最常见的）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">200——表明该请求被成功地完成，所请求的资源发送回客户端</span><br><span class="line">304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存</span><br><span class="line">400——客户端请求有错（譬如可以是安全模块拦截）</span><br><span class="line">401——请求未经授权</span><br><span class="line">403——禁止访问（譬如可以是未登录时禁止）</span><br><span class="line">404——资源未找到</span><br><span class="line">500——服务器内部错误</span><br><span class="line">503——服务不可用</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>再列举下大致不同范围状态的意义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1xx——指示信息，表示请求已接收，继续处理</span><br><span class="line">2xx——成功，表示请求已被成功接收、理解、接受</span><br><span class="line">3xx——重定向，要完成请求必须进行更进一步的操作</span><br><span class="line">4xx——客户端错误，请求有语法错误或请求无法实现</span><br><span class="line">5xx——服务器端错误，服务器未能实现合法的请求</span><br></pre></td></tr></table></figure><p>总之，当请求出错时，状态码能帮助快速定位问题，完整版本的状态可以自行去互联网搜索<br /><strong>请求&#x2F;响应头部</strong><br />请求和响应头部也是分析时常用到的<br />常用的请求头部（部分）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Accept: 接收类型，表示浏览器支持的MIME类型</span><br><span class="line">（对标服务端返回的Content-Type）</span><br><span class="line">Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收</span><br><span class="line">Content-Type：客户端发送出去实体内容的类型</span><br><span class="line">Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache</span><br><span class="line">If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中</span><br><span class="line">Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间</span><br><span class="line">Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中</span><br><span class="line">If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中</span><br><span class="line">Cookie: 有cookie并且同域访问时会自动带上</span><br><span class="line">Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive</span><br><span class="line">Host：请求的服务器URL</span><br><span class="line">Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私</span><br><span class="line">Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)</span><br><span class="line">User-Agent：用户客户端的一些必要信息，如UA头部等</span><br></pre></td></tr></table></figure><p>常用的响应头部（部分）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Headers: 服务器端允许的请求Headers</span><br><span class="line">Access-Control-Allow-Methods: 服务器端允许的请求方法</span><br><span class="line">Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）</span><br><span class="line">Content-Type：服务端返回的实体内容的类型</span><br><span class="line">Date：数据从服务器发送的时间</span><br><span class="line">Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档</span><br><span class="line">Last-Modified：请求资源的最后修改时间</span><br><span class="line">Expires：应该在什么时候认为文档已经过期,从而不再缓存它</span><br><span class="line">Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效</span><br><span class="line">ETag：请求变量的实体标签的当前值</span><br><span class="line">Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端</span><br><span class="line">Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）</span><br><span class="line">Server：服务器的一些相关信息</span><br></pre></td></tr></table></figure><p>一般来说，请求头部和响应头部是匹配分析的。<br />譬如，请求头部的<code>Accept</code>要和响应头部的<code>Content-Type</code>匹配，否则会报错<br />譬如，跨域请求时，请求头部的<code>Origin</code>要匹配响应头部的<code>Access-Control-Allow-Origin</code>，否则会报跨域错误<br />譬如，在使用缓存时，请求头部的<code>If-Modified-Since</code>、<code>If-None-Match</code>分别和响应头部的<code>Last-Modified</code>、<code>ETag</code>对应<br />还有很多的分析方法，这里不一一赘述<br /><strong>请求&#x2F;响应实体</strong><br />http请求时，除了头部，还有消息实体，一般来说<br />请求实体中会将一些需要的参数都放入进入（用于post请求）。<br />譬如实体中可以放参数的序列化形式（<code>a=1&amp;b=2</code>这种），或者直接放表单对象（<code>Form Data</code>对象，上传时可以夹杂参数以及文件），等等<br />而一般响应实体中，就是放服务端需要传给客户端的内容<br />一般现在的接口请求时，实体中就是对于的信息的json格式，而像页面请求这种，里面就是直接放了一个html字符串，然后浏览器自己解析并渲染。<br /><strong>CRLF</strong><br />CRLF（Carriage-Return Line-Feed），意思是回车换行，一般作为分隔符存在<br />请求头和实体消息之间有一个CRLF分隔，响应头部和响应实体之间用一个CRLF分隔<br />一般来说（分隔符类别）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CRLF-&gt;Windows-style</span><br><span class="line">LF-&gt;Unix Style</span><br><span class="line">CR-&gt;Mac Style</span><br></pre></td></tr></table></figure><p>如下图是对某请求的http报文结构的简要分析<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596826323-37c57fdf-d8fb-4c9e-9d0c-7f035baba086.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596826323-37c57fdf-d8fb-4c9e-9d0c-7f035baba086.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="section-11-2"></a></p><h3 id="cookie以及优化"><a href="#cookie以及优化" class="headerlink" title="cookie以及优化"></a>cookie以及优化</h3><p>cookie是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的session使用。<br />场景如下（简述）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在登陆页面，用户登陆了</span><br><span class="line">此时，服务端会生成一个session，session中有对于用户的信息（如用户名、密码等）</span><br><span class="line">然后会有一个sessionid（相当于是服务端的这个session对应的key）</span><br><span class="line">然后服务端在登录页面中写入cookie，值就是:jsessionid=xxx</span><br><span class="line">然后浏览器本地就有这个cookie了，以后访问同域名下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆。</span><br></pre></td></tr></table></figure><p>上述就是cookie的常用场景简述（当然了，实际情况下得考虑更多因素）<br />一般来说，cookie是不允许存放敏感信息的（千万不要明文存储用户名、密码），因为非常不安全，如果一定要强行存储，首先，一定要在cookie中设置<code>httponly</code>（这样就无法通过js操作了），另外可以考虑rsa等非对称加密（因为实际上，浏览器本地也是容易被攻克的，并不安全）<br />另外，由于在同域名的资源请求时，浏览器会默认带上本地的cookie，针对这种情况，在某些场景下是需要优化的。<br />譬如以下场景：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客户端在域名A下有cookie（这个可以是登陆时由服务端写入的）</span><br><span class="line">然后在域名A下有一个页面，页面中有很多依赖的静态资源（都是域名A的，譬如有20个静态资源）</span><br><span class="line">此时就有一个问题，页面加载，请求这些静态资源时，浏览器会默认带上cookie</span><br><span class="line">也就是说，这20个静态资源的http请求，每一个都得带上cookie，而实际上静态资源并不需要cookie验证</span><br><span class="line">此时就造成了较为严重的浪费，而且也降低了访问速度（因为内容更多了）</span><br></pre></td></tr></table></figure><p>当然了，针对这种场景，是有优化方案的（多域名拆分）。具体做法就是：</p><ul><li>将静态资源分组，分别放到不同的域名下（如<code>static.base.com</code>）</li><li>而<code>page.base.com</code>（页面所在域名）下请求时，是不会带上<code>static.base.com</code>域名的cookie的，所以就避免了浪费</li></ul><p>说到了多域名拆分，这里再提一个问题，那就是：</p><ul><li>在移动端，如果请求的域名数过多，会降低请求速度（因为域名整套解析流程是很耗费时间的，而且移动端一般带宽都比不上pc）</li><li>此时就需要用到一种优化方案：<code>dns-prefetch</code>（让浏览器空闲时提前解析dns域名，不过也请合理使用，勿滥用）</li></ul><p>关于cookie的交互，可以看下图总结<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596827095-d66490b9-d964-48db-8891-a9a125d6d811.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596827095-d66490b9-d964-48db-8891-a9a125d6d811.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="section-11-3"></a></p><h3 id="gzip压缩"><a href="#gzip压缩" class="headerlink" title="gzip压缩"></a>gzip压缩</h3><p>首先，明确<code>gzip</code>是一种压缩格式，需要浏览器支持才有效（不过一般现在浏览器都支持）， 而且gzip压缩效率很好（高达70%左右）<br />然后gzip一般是由<code>apache</code>、<code>tomcat</code>等web服务器开启<br />当然服务器除了gzip外，也还会有其它压缩格式（如deflate，没有gzip高效，且不流行）<br />所以一般只需要在服务器上开启了gzip压缩，然后之后的请求就都是基于gzip压缩格式的， 非常方便。<br><a name="section-11-4"></a></p><h3 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h3><p>首先看<code>tcp/ip</code>层面的定义：</p><ul><li>长连接：一个tcp&#x2F;ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）</li><li>短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接</li></ul><p>然后在http层面：</p><ul><li><code>http1.0</code>中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接</li><li>http1.1起，默认使用长连接，使用长连接会有这一行<code>Connection: keep-alive</code>，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接</li></ul><p>注意： <strong>keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效</strong><br><a name="section-11-5"></a></p><h3 id="http-2-0"><a href="#http-2-0" class="headerlink" title="http 2.0"></a>http 2.0</h3><p>http2.0不是https，它相当于是http的下一代规范（譬如https的请求可以是http2.0规范的）<br />然后简述下http2.0与http1.1的显著不同点：</p><ul><li>http1.1中，每请求一个资源，都是需要开启一个tcp&#x2F;ip连接的，所以对应的结果是，每一个资源对应一个tcp&#x2F;ip请求，由于tcp&#x2F;ip本身有并发数限制，所以当资源一多，速度就显著慢下来</li><li>http2.0中，一个tcp&#x2F;ip请求可以请求多个资源，也就是说，只要一次tcp&#x2F;ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。</li></ul><p>所以，如果http2.0全面应用，很多http1.1中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等）<br />然后简述下http2.0的一些特性：</p><ul><li>多路复用（即一个tcp&#x2F;ip连接可以请求多个资源）</li><li>首部压缩（http头部压缩，减少体积）</li><li>二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）</li><li>服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）</li><li>请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）<br><a name="section-11-6"></a></li></ul><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>https就是安全版本的http，譬如一些支付等操作基本都是基于https的，因为http请求的安全系数太低了。<br />简单来看，https与http的区别就是： <strong>在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析</strong><br />一般来说，如果要将网站升级成https，需要后端支持（后端需要申请证书等），然后https的开销也比http要大（因为需要额外建立安全链接以及加密等），所以一般来说http2.0配合https的体验更佳（因为http2.0更快了）<br />一般来说，主要关注的就是SSL&#x2F;TLS的握手流程，如下（简述）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. 浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。 </span><br><span class="line">2. 服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器</span><br><span class="line">（证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）</span><br><span class="line">3. 浏览器收到服务端的证书后</span><br><span class="line">    </span><br><span class="line">    - 验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示</span><br><span class="line">    </span><br><span class="line">    - 用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密`Premaster secret`，发送给服务器。</span><br><span class="line">    </span><br><span class="line">    - 利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key-`session key`</span><br><span class="line">    </span><br><span class="line">    - 使用约定好的HASH算法计算握手消息，并使用生成的`session key`对消息进行加密，最后将之前生成的所有信息发送给服务端。 </span><br><span class="line">    </span><br><span class="line">4. 服务端收到浏览器的回复</span><br><span class="line">    - 利用已知的加解密方式与自己的私钥进行解密，获取`Premaster secret`</span><br><span class="line">    </span><br><span class="line">    - 和浏览器相同规则生成`session key`</span><br><span class="line">    </span><br><span class="line">    - 使用`session key`解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致</span><br><span class="line">    </span><br><span class="line">    - 使用`session key`加密一段握手消息，发送给浏览器</span><br><span class="line">    </span><br><span class="line">5. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，</span><br></pre></td></tr></table></figure><p><strong>之后所有的https通信数据将由之前浏览器生成的</strong><code>**session key**</code><strong>并利用对称加密算法进行加密</strong><br />这里放一张图（来源：<a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">阮一峰-图解SSL&#x2F;TLS协议</a>）<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596826666-f955799e-75b6-4359-abf9-1fe56f15e6e8.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596826666-f955799e-75b6-4359-abf9-1fe56f15e6e8.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="section-12"></a></p><h2 id="单独拎出来的缓存问题，http的缓存"><a href="#单独拎出来的缓存问题，http的缓存" class="headerlink" title="单独拎出来的缓存问题，http的缓存"></a>单独拎出来的缓存问题，http的缓存</h2><p>前后端的http交互中，使用缓存能很大程度上的提升效率，而且基本上对性能有要求的前端项目都是必用缓存的<br><a name="section-12-1"></a></p><h3 id="强缓存与弱缓存"><a href="#强缓存与弱缓存" class="headerlink" title="强缓存与弱缓存"></a>强缓存与弱缓存</h3><p>缓存可以简单的划分成两种类型：<code>强缓存</code>（<code>200 from cache</code>）与<code>协商缓存</code>（<code>304</code>）<br />区别简述如下：</p><ul><li>强缓存（<code>200 from cache</code>）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求</li><li>协商缓存（<code>304</code>）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存</li></ul><p>对于协商缓存，使用<code>Ctrl + F5</code>强制刷新可以使得缓存无效<br />但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）<br><a name="section-12-2"></a></p><h3 id="缓存头部简述"><a href="#缓存头部简述" class="headerlink" title="缓存头部简述"></a>缓存头部简述</h3><p>上述提到了强缓存和协商缓存，那它们是怎么区分的呢？<br />答案是通过不同的http头部控制<br />先看下这几个头部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match/E-tag、If-Modified-Since/Last-Modified、Cache-Control/Max-Age、Pragma/Expires</span><br></pre></td></tr></table></figure><p>这些就是缓存中常用到的头部，这里不展开。仅列举下大致使用。<br />属于强缓存控制的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（http1.1）Cache-Control/Max-Age</span><br><span class="line">（http1.0）Pragma/Expires</span><br></pre></td></tr></table></figure><p>注意：<code>**Max-Age**</code><strong>不是一个头部，它是</strong><code>**Cache-Control**</code><strong>头部的值</strong><br />属于协商缓存控制的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（http1.1）If-None-Match/E-tag</span><br><span class="line">（http1.0）If-Modified-Since/Last-Modified</span><br></pre></td></tr></table></figure><p>可以看到，上述有提到<code>http1.1</code>和<code>http1.0</code>，这些不同的头部是属于不同http时期的<br />再提一点，其实HTML页面中也有一个meta标签可以控制缓存方案-<code>Pragma</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;META HTTP-EQUIV=&quot;Pragma&quot; CONTENT=&quot;no-cache&quot;&gt;</span><br></pre></td></tr></table></figure><p>不过，这种方案还是比较少用到，因为支持情况不佳，譬如缓存代理服务器肯定不支持，所以不推荐<br><a name="section-12-3"></a></p><h3 id="头部的区别"><a href="#头部的区别" class="headerlink" title="头部的区别"></a>头部的区别</h3><p>首先明确，http的发展是从http1.0到http1.1<br />而在http1.1中，出了一些新内容，弥补了http1.0的不足。<br /><strong>http1.0中的缓存控制：</strong></p><ul><li><code>Pragma</code>：严格来说，它不属于专门的缓存控制头部，但是它设置<code>no-cache</code>时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用）</li><li><code>Expires</code>：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如<code>Expires：Fri, 30 Oct 1998 14:19:41</code></li><li><code>If-Modified-Since/Last-Modified</code>：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是<code>If-Modified-Since</code>，而服务端的是<code>Last-Modified</code>，它的作用是，在发起请求时，如果<code>If-Modified-Since</code>和<code>Last-Modified</code>匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。<code>Last-Modified</code>，顾名思义，指的是文件最后的修改时间，而且只能精确到<code>1s</code>以内</li></ul><p><strong>http1.1中的缓存控制：</strong></p><ul><li><code>Cache-Control</code>：缓存控制头部，有no-cache、max-age等多种取值</li><li><code>Max-Age</code>：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如<code>Cache-Control: max-age=3600</code>，而且它值得是绝对时间，由浏览器自己计算</li><li><code>If-None-Match/E-tag</code>：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是<code>If-None-Match</code>，而服务端的是<code>E-tag</code>，同样，发出请求后，如果<code>If-None-Match</code>和<code>E-tag</code>匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于<code>FileEtag INode Mtime Size</code>生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。</li></ul><p><strong>Max-Age相比Expires？</strong><br /><code>Expires</code>使用的是服务器端的时间<br />但是有时候会有这样一种情况-客户端时间和服务端不同步<br />那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期<br />所以一般http1.1后不推荐使用<code>Expires</code><br />而<code>Max-Age</code>使用的是客户端本地时间的计算，因此不会有这个问题<br />因此推荐使用<code>Max-Age</code>。<br />注意，如果同时启用了<code>Cache-Control</code>与<code>Expires</code>，<code>Cache-Control</code>优先级高。<br /><strong>E-tag相比Last-Modified？</strong><br /><code>Last-Modified</code>：</p><ul><li>表明服务端的文件最后何时改变的</li><li>它有一个缺陷就是只能精确到1s，</li><li>然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效</li></ul><p>而<code>E-tag</code>：</p><ul><li>是一种指纹机制，代表文件相关指纹</li><li>只有文件变才会变，也只要文件变就会变，</li><li>也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了</li></ul><p>如果同时带有<code>E-tag</code>和<code>Last-Modified</code>，服务端会优先检查<code>E-tag</code><br />各大缓存头部的整体关系如下图<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596826929-1f0b241c-2548-4b7e-abc1-93f42eedc27a.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596826929-1f0b241c-2548-4b7e-abc1-93f42eedc27a.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="section-13"></a></p><h2 id="解析页面流程"><a href="#解析页面流程" class="headerlink" title="解析页面流程"></a>解析页面流程</h2><p>前面有提到http交互，那么接下来就是浏览器获取到html，然后解析，渲染<br /><strong>这部分很多都参考了网上资源，特别是图片，参考了来源中的文章</strong><br><a name="section-13-1"></a></p><h3 id="流程简述"><a href="#流程简述" class="headerlink" title="流程简述"></a>流程简述</h3><p>浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 解析HTML，构建DOM树</span><br><span class="line">2. 解析CSS，生成CSS规则树</span><br><span class="line">3. 合并DOM树和CSS规则，生成render树</span><br><span class="line">4. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算</span><br><span class="line">5. 绘制render树（paint），绘制页面像素信息</span><br><span class="line">6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</span><br></pre></td></tr></table></figure><p>如下图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596829677-38270453-c2a0-469f-8c29-4103c641bec2.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596829677-38270453-c2a0-469f-8c29-4103c641bec2.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="section-13-2"></a></p><h3 id="HTML解析，构建DOM"><a href="#HTML解析，构建DOM" class="headerlink" title="HTML解析，构建DOM"></a>HTML解析，构建DOM</h3><p>整个渲染步骤中，HTML解析是第一步。<br />简单的理解，这一步的流程是这样的：<strong>浏览器解析HTML，构建DOM树。</strong><br />但实际上，在分析整体构建时，却不能一笔带过，得稍微展开。<br />解析HTML到构建出DOM当然过程可以简述如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bytes → characters → tokens → nodes → DOM</span><br></pre></td></tr></table></figure><p>譬如假设有这样一个HTML页面：（以下部分的内容出自参考来源，修改了下格式）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</span><br><span class="line">    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;title&gt;Critical Path&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;</span><br><span class="line">    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>浏览器的处理如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596829219-ed51e09e-6e56-4557-a6b4-fd2362c2b401.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596829219-ed51e09e-6e56-4557-a6b4-fd2362c2b401.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />列举其中的一些重点过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符</span><br><span class="line">2. Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集</span><br><span class="line">3. Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则</span><br><span class="line">4. DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样</span><br><span class="line">例如：body对象的父节点就是HTML对象，然后段略p对象的父节点就是body对象</span><br></pre></td></tr></table></figure><p>最后的DOM树如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596831267-4bc2c7b3-2682-4e30-b451-07de0442957b.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596831267-4bc2c7b3-2682-4e30-b451-07de0442957b.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="section-13-3"></a></p><h3 id="生成CSS规则"><a href="#生成CSS规则" class="headerlink" title="生成CSS规则"></a>生成CSS规则</h3><p>同理，CSS规则树的生成也是类似。简述为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bytes → characters → tokens → nodes → CSSOM</span><br></pre></td></tr></table></figure><p>譬如<code>style.css</code>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body &#123; font-size: 16px &#125;</span><br><span class="line">p &#123; font-weight: bold &#125;</span><br><span class="line">span &#123; color: red &#125;</span><br><span class="line">p span &#123; display: none &#125;</span><br><span class="line">img &#123; float: right &#125;</span><br></pre></td></tr></table></figure><p>那么最终的CSSOM树就是：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596830151-b1681a32-9be9-4ff5-aa0a-89396221a409.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596830151-b1681a32-9be9-4ff5-aa0a-89396221a409.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="section-13-4"></a></p><h3 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h3><p>当DOM树和CSSOM都有了后，就要开始构建渲染树了<br />一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应<br />因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者<code>display: none</code>等<br />整体来说可以看图：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596827869-e6ad6b79-a912-4bbd-ad09-af1cb6b9c96b.png#height=420&id=eOPtP&originHeight=420&originWidth=900&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=900" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596827869-e6ad6b79-a912-4bbd-ad09-af1cb6b9c96b.png#height=420&id=eOPtP&originHeight=420&originWidth=900&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=900" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="section-13-5"></a></p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>有了render树，接下来就是开始渲染，基本流程如下：<br /><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/164572/1588596831489-075f87dd-2cbe-4e92-af49-1bf03b96befa.jpeg" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/jpeg/164572/1588596831489-075f87dd-2cbe-4e92-af49-1bf03b96befa.jpeg" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />图中重要的四个步骤就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 计算CSS样式</span><br><span class="line">2. 构建渲染树</span><br><span class="line">3. 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性</span><br><span class="line">4. 绘制，将图像绘制出来</span><br></pre></td></tr></table></figure><p>然后，图中的线与箭头代表通过js动态修改了DOM或CSS，导致了重新布局（Layout）或渲染（Repaint）<br />这里Layout和Repaint的概念是有区别的：</p><ul><li>Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</li><li>Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了</li></ul><p>回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流， 所以优化方案中一般都包括，尽量避免回流。<br /><strong>什么会引起回流？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.页面渲染初始化</span><br><span class="line">2.DOM结构改变，比如删除了某个节点</span><br><span class="line">3.render树变化，比如减少了padding</span><br><span class="line">4.窗口resize</span><br><span class="line">5.最复杂的一种：获取某些属性，引发回流，</span><br><span class="line">很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，</span><br><span class="line">但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括</span><br><span class="line">    （1）offset(Top/Left/Width/Height)</span><br><span class="line">     (2) scroll(Top/Left/Width/Height)</span><br><span class="line">     (3) cilent(Top/Left/Width/Height)</span><br><span class="line">     (4) width,height</span><br><span class="line">     (5) 调用了getComputedStyle()或者IE的currentStyle</span><br></pre></td></tr></table></figure><p>回流一定伴随着重绘，重绘却可以单独出现<br />所以一般会有一些优化方案，如：</p><ul><li>减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新</li><li>避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document</li><li>避免多次读取offset等属性。无法避免则将它们缓存到变量</li><li>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高</li></ul><p><strong>注意：改变字体大小会引发回流</strong><br />再来看一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var s = document.body.style;</span><br><span class="line">s.padding = &quot;2px&quot;; // 回流+重绘</span><br><span class="line">s.border = &quot;1px solid red&quot;; // 再一次 回流+重绘</span><br><span class="line">s.color = &quot;blue&quot;; // 再一次重绘</span><br><span class="line">s.backgroundColor = &quot;#ccc&quot;; // 再一次 重绘</span><br><span class="line">s.fontSize = &quot;14px&quot;; // 再一次 回流+重绘</span><br><span class="line">// 添加node，再一次 回流+重绘</span><br><span class="line">document.body.appendChild(document.createTextNode(&#x27;abc!&#x27;));</span><br></pre></td></tr></table></figure><p><a name="section-13-6"></a></p><h3 id="简单层与复合层"><a href="#简单层与复合层" class="headerlink" title="简单层与复合层"></a>简单层与复合层</h3><p>上述中的渲染中止步于绘制，但实际上绘制这一步也没有这么简单，它可以结合复合层和简单层的概念来讲。<br />这里不展开，进简单介绍下：</p><ul><li>可以认为默认只有一个复合图层，所有的DOM节点都是在这个复合图层下的</li><li>如果开启了硬件加速功能，可以将某个节点变成复合图层</li><li>复合图层之间的绘制互不干扰，由GPU直接控制</li><li>而简单图层中，就算是absolute等布局，变化时不影响整体的回流，但是由于在同一个图层中，仍然是会影响绘制的，因此做动画时性能仍然很低。而复合层是独立的，所以一般做动画推荐使用硬件加速</li></ul><p>更多参考：<br /><a href="https://segmentfault.com/a/1190000012925872#articleHeader16">普通图层和复合图层</a><br><a name="section-13-7"></a></p><h3 id="Chrome中的调试"><a href="#Chrome中的调试" class="headerlink" title="Chrome中的调试"></a>Chrome中的调试</h3><p>Chrome的开发者工具中，Performance中可以看到详细的渲染过程：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596829910-21624730-fe55-4792-93f0-d3ad6b197c63.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596829910-21624730-fe55-4792-93f0-d3ad6b197c63.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="section-13-8"></a></p><h3 id="资源外链的下载"><a href="#资源外链的下载" class="headerlink" title="资源外链的下载"></a>资源外链的下载</h3><p>上面介绍了html解析，渲染流程。但实际上，在解析html时，会遇到一些资源连接，此时就需要进行单独处理了<br />简单起见，这里将遇到的静态资源分为一下几大类（未列举所有）：</p><ul><li>CSS样式资源</li><li>JS脚本资源</li><li>img图片类资源</li></ul><p><strong>遇到外链时的处理</strong><br />当遇到上述的外链时，会单独开启一个下载线程去下载资源（http1.1中是每一个资源的下载都要开启一个http请求，对应一个tcp&#x2F;ip链接）<br /><strong>遇到CSS样式资源</strong><br />CSS资源的处理有几个特点：</p><ul><li>CSS下载时异步，不会阻塞浏览器构建DOM树</li><li>但是会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）</li><li>有例外，<code>media query</code>声明的CSS是不会阻塞渲染的</li></ul><p><strong>遇到JS脚本资源</strong><br />JS脚本资源的处理有几个特点：</p><ul><li>阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML</li><li>浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已</li><li>defer与async，普通的脚本是会阻塞浏览器解析的，但是可以加上defer或async属性，这样脚本就变成异步了，可以等到解析完毕后再执行</li></ul><p>注意，defer和async是有区别的： <strong>defer是延迟执行，而async是异步执行。</strong><br />简单的说（不展开）：</p><ul><li><code>async</code>是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在<code>onload</code>前，但不确定在<code>DOMContentLoaded</code>事件的前或后</li><li><code>defer</code>是延迟执行，在浏览器看起来的效果像是将脚本放在了<code>body</code>后面一样（虽然按规范应该是在<code>DOMContentLoaded</code>事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）</li></ul><p><strong>遇到img图片类资源</strong><br />遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方<br><a name="section-13-9"></a></p><h3 id="loaded和domcontentloaded"><a href="#loaded和domcontentloaded" class="headerlink" title="loaded和domcontentloaded"></a>loaded和domcontentloaded</h3><p>简单的对比：</p><ul><li>DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成)</li><li>load 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了<br><a name="section-14"></a></li></ul><h2 id="CSS的可视化格式模型"><a href="#CSS的可视化格式模型" class="headerlink" title="CSS的可视化格式模型"></a>CSS的可视化格式模型</h2><p><strong>这一部分内容很多参考《精通CSS-高级Web标准解决方案》以及参考来源</strong><br />前面提到了整体的渲染概念，但实际上文档树中的元素是按什么渲染规则渲染的，是可以进一步展开的，此部分内容即： <strong>CSS的可视化格式模型</strong><br />先了解：</p><ul><li>CSS中规定每一个元素都有自己的盒子模型（相当于规定了这个元素如何显示）</li><li>然后可视化格式模型则是把这些盒子按照规则摆放到页面上，也就是如何布局</li><li>换句话说，盒子模型规定了怎么在页面里摆放盒子，盒子的相互作用等等</li></ul><p>说到底： <strong>CSS的可视化格式模型就是规定了浏览器在页面中如何处理文档树</strong><br />关键字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">包含块（Containing Block）</span><br><span class="line">控制框（Controlling Box）</span><br><span class="line">BFC（Block Formatting Context）</span><br><span class="line">IFC（Inline Formatting Context）</span><br><span class="line">定位体系</span><br><span class="line">浮动</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>另外，CSS有三种定位机制：<code>普通流</code>，<code>浮动</code>，<code>绝对定位</code>，如无特别提及，下文中都是针对普通流中的<br><a name="section-14-1"></a></p><h3 id="包含块（Containing-Block）"><a href="#包含块（Containing-Block）" class="headerlink" title="包含块（Containing Block）"></a>包含块（Containing Block）</h3><p>一个元素的box的定位和尺寸，会与某一矩形框有关，这个框就称之为包含块。<br />元素会为它的子孙元素创建包含块，但是，并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系<br />譬如：</p><ul><li>根元素是最顶端的元素，它没有父节点，它的包含块就是初始包含块</li><li>static和relative的包含块由它最近的块级、单元格或者行内块祖先元素的内容框（content）创建</li><li>fixed的包含块是当前可视窗口</li><li>absolute的包含块由它最近的position 属性为<code>absolute</code>、<code>relative</code>或者<code>fixed</code>的祖先元素创建<ul><li>如果其祖先元素是行内元素，则包含块取决于其祖先元素的<code>direction</code>特性</li><li>如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界<br><a name="section-14-2"></a></li></ul></li></ul><h3 id="控制框（Controlling-Box）"><a href="#控制框（Controlling-Box）" class="headerlink" title="控制框（Controlling Box）"></a>控制框（Controlling Box）</h3><p>块级元素和块框以及行内元素和行框的相关概念<br /><strong>块框:</strong></p><ul><li>块级元素会生成一个块框（<code>Block Box</code>），块框会占据一整行，用来包含子box和生成的内容</li><li>块框同时也是一个块包含框（<code>Containing Box</code>），里面要么只包含块框，要么只包含行内框（不能混杂），如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围</li></ul><p>关于<strong>匿名块框</strong>的生成，示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;DIV&gt;</span><br><span class="line">Some text</span><br><span class="line">&lt;P&gt;More text</span><br><span class="line">&lt;/DIV&gt;</span><br></pre></td></tr></table></figure><p><code>div</code>生成了一个块框，包含了另一个块框<code>p</code>以及文本内容<code>Some text</code>，此时<code>Some text</code>文本会被强制加到一个匿名的块框里面，被<code>div</code>生成的块框包含（其实这个就是<code>IFC</code>中提到的行框，包含这些行内框的这一行匿名块形成的框，行框和行内框不同）<br />换句话说:<br /><strong>如果一个块框在其中包含另外一个块框，那么我们强迫它只能包含块框，因此其它文本内容生成出来的都是匿名块框（而不是匿名行内框）</strong><br /><strong>行内框：</strong></p><ul><li>一个行内元素生成一个行内框</li><li>行内元素能排在一行，允许左右有其它元素</li></ul><p>关于<strong>匿名行内框</strong>的生成，示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;P&gt;Some &lt;EM&gt;emphasized&lt;/EM&gt; text&lt;/P&gt;</span><br></pre></td></tr></table></figure><p><code>P</code>元素生成一个块框，其中有几个行内框（如<code>EM</code>），以及文本<code>Some</code>，<code>text</code>，此时会专门为这些文本生成匿名行内框<br /><strong>display属性的影响</strong><br /><code>display</code>的几个属性也可以影响不同框的生成：</p><ul><li><code>block</code>，元素生成一个块框</li><li><code>inline</code>，元素产生一个或多个的行内框</li><li><code>inline-block</code>，元素产生一个行内级块框，行内块框的内部会被当作块块来格式化，而此元素本身会被当作行内级框来格式化（这也是为什么会产生<code>BFC</code>）</li><li><code>none</code>，不生成框，不再格式化结构中，当然了，另一个<code>visibility: hidden</code>则会产生一个不可见的框</li></ul><p>总结：</p><ul><li>如果一个框里，有一个块级元素，那么这个框里的内容都会被当作块框来进行格式化，因为只要出现了块级元素，就会将里面的内容分块几块，每一块独占一行（出现行内可以用匿名块框解决）</li><li>如果一个框里，没有任何块级元素，那么这个框里的内容会被当成行内框来格式化，因为里面的内容是按照顺序成行的排列<br><a name="section-14-3"></a></li></ul><h3 id="BFC（Block-Formatting-Context）"><a href="#BFC（Block-Formatting-Context）" class="headerlink" title="BFC（Block Formatting Context）"></a>BFC（Block Formatting Context）</h3><p>FC（格式上下文）？<br />FC即格式上下文，它定义框内部的元素渲染规则，比较抽象，譬如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FC像是一个大箱子，里面装有很多元素</span><br><span class="line">箱子可以隔开里面的元素和外面的元素（所以外部并不会影响FC内部的渲染）</span><br><span class="line">内部的规则可以是：如何定位，宽高计算，margin折叠等等</span><br></pre></td></tr></table></figure><p>不同类型的框参与的FC类型不同，譬如块级框对应BFC，行内框对应IFC<br /><strong>注意，并不是说所有的框都会产生FC，而是符合特定条件才会产生，只有产生了对应的FC后才会应用对应渲染规则</strong><br /><strong>BFC规则：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在块格式化上下文中</span><br><span class="line">每一个元素左外边与包含块的左边相接触（对于从右到左的格式化，右外边接触右边）</span><br><span class="line">即使存在浮动也是如此（所以浮动元素正常会直接贴近它的包含块的左边，与普通元素重合）</span><br><span class="line">除非这个元素也创建了一个新的BFC</span><br></pre></td></tr></table></figure><p>总结几点BFC特点：</p><ol><li>内部<code>box</code>在垂直方向，一个接一个的放置</li><li>box的垂直方向由<code>margin</code>决定，属于同一个BFC的两个box间的margin会重叠</li><li>BFC区域不会与<code>float box</code>重叠（可用于排版)</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</li><li>计算BFC的高度时，浮动元素也参与计算（不会浮动坍塌）</li></ol><p>如何触发BFC？</p><ol><li>根元素</li><li><code>float</code>属性不为<code>none</code></li><li><code>position</code>为<code>absolute</code>或<code>fixed</code></li><li><code>display</code>为<code>inline-block</code>, <code>flex</code>, <code>inline-flex</code>，<code>table</code>，<code>table-cell</code>，<code>table-caption</code></li><li><code>overflow</code>不为<code>visible</code></li></ol><p>这里提下，<code>display: table</code>，它本身不产生BFC，但是它会产生匿名框（包含<code>display: table-cell</code>的框），而这个匿名框产生BFC<br />更多请自行网上搜索<br><a name="section-14-4"></a></p><h3 id="IFC（Inline-Formatting-Context）"><a href="#IFC（Inline-Formatting-Context）" class="headerlink" title="IFC（Inline Formatting Context）"></a>IFC（Inline Formatting Context）</h3><p>IFC即行内框产生的格式上下文<br /><strong>IFC规则</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在行内格式化上下文中</span><br><span class="line">框一个接一个地水平排列，起点是包含块的顶部。</span><br><span class="line">水平方向上的 margin，border 和 padding 在框之间得到保留</span><br><span class="line">框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐</span><br></pre></td></tr></table></figure><p><strong>行框</strong><br /><strong>包含那些框的长方形区域，会形成一行，叫做行框</strong><br />行框的宽度由它的包含块和其中的浮动元素决定，高度的确定由行高度计算规则决定<br />行框的规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果几个行内框在水平方向无法放入一个行框内，它们可以分配在两个或多个垂直堆叠的行框中（即行内框的分割）</span><br><span class="line">行框在堆叠时没有垂直方向上的分割且永不重叠</span><br><span class="line">行框的高度总是足够容纳所包含的所有框。不过，它可能高于它包含的最高的框（例如，框对齐会引起基线对齐）</span><br><span class="line">行框的左边接触到其包含块的左边，右边接触到其包含块的右边。</span><br></pre></td></tr></table></figure><p><strong>结合补充下IFC规则：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">浮动元素可能会处于包含块边缘和行框边缘之间</span><br><span class="line">尽管在相同的行内格式化上下文中的行框通常拥有相同的宽度（包含块的宽度），它们可能会因浮动元素缩短了可用宽度，而在宽度上发生变化</span><br><span class="line">同一行内格式化上下文中的行框通常高度不一样（如，一行包含了一个高的图形，而其它行只包含文本）</span><br><span class="line">当一行中行内框宽度的总和小于包含它们的行框的宽，它们在水平方向上的对齐，取决于 `text-align` 特性</span><br><span class="line">空的行内框应该被忽略</span><br><span class="line">即不包含文本，保留空白符，margin/padding/border非0的行内元素，</span><br><span class="line">以及其他常规流中的内容(比如，图片，inline blocks 和 inline tables)，</span><br><span class="line">并且不是以换行结束的行框，</span><br><span class="line">必须被当作零高度行框对待</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>行内元素总是会应用IFC渲染规则</li><li>行内元素会应用IFC规则渲染，譬如<code>text-align</code>可以用来居中等</li><li>块框内部，对于文本这类的匿名元素，会产生匿名行框包围，而行框内部就应用IFC渲染规则</li><li>行内框内部，对于那些行内元素，一样应用IFC渲染规则</li><li>另外，<code>inline-block</code>，会在元素外层产生IFC（所以这个元素是可以通过<code>text-align</code>水平居中的），当然，它内部则按照BFC规则渲染</li></ul><p>相比BFC规则来说，IFC可能更加抽象（因为没有那么条理清晰的规则和触发条件）<br />但总的来说，它就是行内元素自身如何显示以及在框内如何摆放的渲染规则，这样描述应该更容易理解<br><a name="section-14-5"></a></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>当然还有有一些其它内容：</p><ul><li>譬如常规流，浮动，绝对定位等区别</li><li>譬如浮动元素不包含在常规流中</li><li>譬如相对定位，绝对定位，<code>Fixed</code>定位等区别</li><li>譬如<code>z-index</code>的分层显示机制等</li></ul><p>这里不一一展开，更多请参考：<br /><a href="http://bbs.csdn.net/topics/340204423">http://bbs.csdn.net/topics/340204423</a><br><a name="section-15"></a></p><h2 id="JS引擎解析过程"><a href="#JS引擎解析过程" class="headerlink" title="JS引擎解析过程"></a>JS引擎解析过程</h2><p>前面有提到遇到JS脚本时，会等到它的执行，实际上是需要引擎解析的，这里展开描述（介绍主干流程）<br><a name="section-15-1"></a></p><h3 id="JS的解释阶段"><a href="#JS的解释阶段" class="headerlink" title="JS的解释阶段"></a>JS的解释阶段</h3><p>首先得明确： <strong>JS是解释型语音，所以它无需提前编译，而是由解释器实时运行</strong><br />引擎对JS的处理过程可以简述如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 读取代码，进行词法分析（Lexical analysis），然后将代码分解成词元（token）</span><br><span class="line">2. 对词元进行语法分析（parsing），然后将代码整理成语法树（syntax tree）</span><br><span class="line">3. 使用翻译器（translator），将代码转为字节码（bytecode）</span><br><span class="line">4. 使用字节码解释器（bytecode interpreter），将字节码转为机器码</span><br></pre></td></tr></table></figure><p>最终计算机执行的就是机器码。<br />为了提高运行速度，现代浏览器一般采用即时编译（<code>JIT-Just In Time compiler</code>）<br />即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（<code>inline cache</code>）<br />这样整个程序的运行速度能得到显著提升。<br />而且，不同浏览器策略可能还不同，有的浏览器就省略了字节码的翻译步骤，直接转为机器码（如chrome的v8）<br />总结起来可以认为是： <strong>核心的</strong><code>**JIT**</code><strong>编译器将源码编译成机器码运行</strong><br><a name="section-15-2"></a></p><h3 id="JS的预处理阶段"><a href="#JS的预处理阶段" class="headerlink" title="JS的预处理阶段"></a>JS的预处理阶段</h3><p>上述将的是解释器的整体过程，这里再提下在正式执行JS前，还会有一个预处理阶段 （譬如变量提升，分号补全等）<br />预处理阶段会做一些事情，确保JS可以正确执行，这里仅提部分：<br /><strong>分号补全</strong><br />JS执行是需要分号的，但为什么以下语句却可以正常运行呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;a&#x27;)</span><br><span class="line">console.log(&#x27;b&#x27;)</span><br></pre></td></tr></table></figure><p>原因就是JS解释器有一个<a href="http://inimino.org/~inimino/blog/javascript_semicolons">Semicolon Insertion</a>规则，它会按照一定规则，在适当的位置补充分号<br />譬如列举几条自动加分号的规则：</p><ul><li>当有换行符（包括含有换行符的多行注释），并且下一个<code>token</code>没法跟前面的语法匹配时，会自动补分号。</li><li>当有<code>&#125;</code>时，如果缺少分号，会补分号。</li><li>程序源代码结束时，如果缺少分号，会补分号。</li></ul><p>于是，上述的代码就变成了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;a&#x27;);</span><br><span class="line">console.log(&#x27;b&#x27;);</span><br></pre></td></tr></table></figure><p>所以可以正常运行<br />当然了，这里有一个经典的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function b() &#123;</span><br><span class="line">    return</span><br><span class="line">    &#123;</span><br><span class="line">        a: &#x27;a&#x27;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于分号补全机制，所以它变成了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function b() &#123;</span><br><span class="line">    return;</span><br><span class="line">    &#123;</span><br><span class="line">        a: &#x27;a&#x27;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以运行后是<code>undefined</code><br /><strong>变量提升</strong><br />一般包括函数提升和变量提升<br />譬如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = 1;</span><br><span class="line">b();</span><br><span class="line">function b() &#123;</span><br><span class="line">    console.log(&#x27;b&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">var a;</span><br></pre></td></tr></table></figure><p>经过变量提升后，就变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function b() &#123;</span><br><span class="line">    console.log(&#x27;b&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">var a;</span><br><span class="line">a = 1;</span><br><span class="line">b();</span><br></pre></td></tr></table></figure><p>这里没有展开，其实展开也可以牵涉到很多内容的<br />譬如可以提下变量声明，函数声明，形参，实参的优先级顺序，以及es6中let有关的临时死区等<br><a name="section-15-3"></a></p><h3 id="JS的执行阶段"><a href="#JS的执行阶段" class="headerlink" title="JS的执行阶段"></a>JS的执行阶段</h3><p>此阶段的内容中的图片来源：<a href="http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html">深入理解JavaScript系列（10）：JavaScript核心（晋级高手必读篇）</a><br />解释器解释完语法规则后，就开始执行，然后整个执行流程中大致包含以下概念：</p><ul><li>执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）</li><li>VO（变量对象）和AO（活动对象）</li><li>作用域链</li><li>this机制等</li></ul><p>这些概念如果深入讲解的话内容过多，因此这里仅提及部分特性<br /><strong>执行上下文简单解释</strong></p><ul><li>JS有<code>执行上下文</code>）</li><li>浏览器首次载入脚本，它将创建<code>全局执行上下文</code>，并压入执行栈栈顶（不可被弹出）</li><li>然后每进入其它作用域就创建对应的执行上下文并把它压入执行栈的顶部</li><li>一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的栈。</li><li>这样依次执行（最终都会回到全局执行上下文）</li></ul><p>譬如，如果程序执行完毕，被弹出执行栈，然后有没有被引用（没有形成闭包），那么这个函数中用到的内存就会被垃圾处理器自动回收</p><p>然后执行上下文与VO，作用域链，this的关系是：<br />每一个执行上下文，都有三个重要属性：</p><ul><li>变量对象(<code>Variable object，VO</code>)</li><li>作用域链(<code>Scope chain</code>)</li><li><code>this</code></li></ul><p><strong>VO与AO</strong><br />VO是执行上下文的属性（抽象概念），但是<strong>只有全局上下文的变量对象允许通过VO的属性名称来间接访问（因为在全局上下文里，全局对象自身就是变量对象）</strong><br />AO（<code>activation object</code>)，当函数被调用者激活，AO就被创建了<br />可以理解为：</p><ul><li>在函数上下文中：<code>VO === AO</code></li><li>在全局上下文中：<code>VO === this === global</code></li></ul><p>总的来说，VO中会存放一些变量信息（如声明的变量，函数，<code>arguments</code>参数等等）<br /><strong>作用域链</strong><br />它是执行上下文中的一个属性，原理和原型链很相似，作用很重要。<br />譬如流程简述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在函数上下文中，查找一个变量foo</span><br><span class="line">如果函数的VO中找到了，就直接使用</span><br><span class="line">否则去它的父级作用域链中（__parent__）找</span><br><span class="line">如果父级中没找到，继续往上找</span><br><span class="line">直到全局上下文中也没找到就报错</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596829648-61214bf4-f712-43b1-92ac-4a73ebee5594.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588596829648-61214bf4-f712-43b1-92ac-4a73ebee5594.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>this指针</strong><br />这也是JS的核心知识之一，由于内容过多，这里就不展开，仅提及部分<br />注意：<strong>this是执行上下文环境的一个属性，而不是某个变量对象的属性</strong><br />因此:</p><ul><li>this是没有一个类似搜寻变量的过程</li><li>当代码中使用了this，这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻</li><li>this的值只取决中进入上下文时的情况</li></ul><p>所以经典的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var baz = 200;</span><br><span class="line">var bar = &#123;</span><br><span class="line">    baz: 100,</span><br><span class="line">    foo: function() &#123;</span><br><span class="line">        console.log(this.baz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var foo = bar.foo;</span><br><span class="line">// 进入环境：global</span><br><span class="line">foo(); // 200，严格模式中会报错，Cannot read property &#x27;baz&#x27; of undefined</span><br><span class="line">// 进入环境：global bar</span><br><span class="line">bar.foo(); // 100</span><br></pre></td></tr></table></figure><p>就要明白了上面this的介绍，上述例子很好理解<br />更多参考：<br /><a href="http://www.cnblogs.com/TomXu/archive/2012/01/17/2310479.html">深入理解JavaScript系列（13）：This? Yes,this!</a><br><a name="section-15-4"></a></p><h3 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h3><p>JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理。<br />一般来说，垃圾处理器有自己的回收策略。<br />譬如对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）<br />常用的两种垃圾回收规则是：</p><ul><li>标记清除</li><li>引用计数</li></ul><p>Javascript引擎基础GC方案是（<code>simple GC</code>）：<code>mark and sweep</code>（标记清除），简单解释如下：</p><ol><li>遍历所有可访问的对象。</li><li>回收已不可访问的对象。</li></ol><p>譬如：（出自javascript高程）</p><blockquote><p>当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。<br>从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。<br>而当变量离开环境时，则将其标记为“离开环境”。<br>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。<br>然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）。<br>而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。<br>最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p></blockquote><p>关于引用计数，简单点理解：<br /><strong>跟踪记录每个值被引用的次数，当一个值被引用时，次数</strong><code>**+1**</code><strong>，减持时</strong><code>**-1**</code><strong>，下次垃圾回收器会回收次数为</strong><code>**0**</code><strong>的值的内存（当然了，容易出循环引用的bug）</strong><br /><strong>GC的缺陷</strong><br />和其他语言一样，javascript的GC策略也无法避免一个问题： <strong>GC时，停止响应其他操作</strong><br />这是为了安全考虑。<br />而Javascript的GC在<code>100ms</code>甚至以上<br />对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。<br />这就是引擎需要优化的点： <strong>避免GC造成的长时间停止响应。</strong><br /><strong>GC优化策略</strong><br />这里介绍常用到的：<strong>分代回收（Generation GC）</strong><br />目的是通过区分“临时”与“持久”对象:</p><ul><li>多回收“临时对象”区（<code>young generation</code>）</li><li>少回收“持久对象”区（<code>tenured generation</code>）</li><li>减少每次需遍历的对象，从而减少每次GC的耗时。</li></ul><p>像node v8引擎就是采用的分代回收（和java一样，作者是java虚拟机作者。）<br />更多可以参考：<br /><a href="https://zhuanlan.zhihu.com/p/33816534">V8 内存浅析</a><br><a name="section-16"></a></p><h2 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h2><p><a name="section-16-1"></a></p><h3 id="可以提到跨域"><a href="#可以提到跨域" class="headerlink" title="可以提到跨域"></a>可以提到跨域</h3><p>譬如发出网络请求时，会用AJAX，如果接口跨域，就会遇到跨域问题<br />可以参考：<br /><a href="https://segmentfault.com/a/1190000012469713">ajax跨域，这应该是最全的解决方案了</a><br><a name="section-16-2"></a></p><h3 id="可以提到web安全"><a href="#可以提到web安全" class="headerlink" title="可以提到web安全"></a>可以提到web安全</h3><p>譬如浏览器在解析HTML时，有<code>XSSAuditor</code>，可以延伸到web安全相关领域<br />可以参考：<br /><a href="https://segmentfault.com/a/1190000012693772">AJAX请求真的不安全么？谈谈Web安全与AJAX的关系。</a><br><a name="section-16-3"></a></p><h3 id="更多-1"><a href="#更多-1" class="headerlink" title="更多"></a>更多</h3><p>如可以提到<code>viewport</code>概念，讲讲物理像素，逻辑像素，CSS像素等概念<br />如熟悉Hybrid开发的话可以提及一下Hybrid相关内容以及优化<br />…<br><a name="section-17"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述这么多内容，目的是：<strong>梳理出自己的知识体系</strong><br />本文由于是前端向，所以知识梳理时有重点，很多其它的知识点都简述或略去了，重点介绍的模块总结：</p><ul><li>浏览器的进程&#x2F;线程模型、JS运行机制（这一块的详细介绍链接到了另一篇文章）</li><li>http规范（包括报文结构，头部，优化，http2.0，https等）</li><li>http缓存（单独列出来，因为它很重要）</li><li>页面解析流程（HTML解析，构建DOM，生成CSS规则，构建渲染树，渲染流程，复合层的合成，外链的处理等）</li><li>JS引擎解析过程（包括解释阶段，预处理阶段，执行阶段，包括执行上下文、VO、作用域链、this、回收机制等）</li><li>跨域相关，web安全单独链接到了具体文章，其它如CSS盒模型，viewport等仅是提及概念</li></ul><p>关于本文的价值？<br /><strong>本文是个人阶段性梳理知识体系的成果</strong>，然后加以修缮后发布成文章，因此并不确保适用于所有人员<br />但是，个人认为本文还是有一定参考价值的<br><a name="section-18"></a></p><h2 id="写在最后的话"><a href="#写在最后的话" class="headerlink" title="写在最后的话"></a>写在最后的话</h2><p>还是那句话：<strong>知识要形成体系</strong><br />梳理出知识体系后，有了一个骨架，知识点不易遗忘，而且学习新知识时也会更加迅速，更重要的是容易举一反三，可以由一个普通的问题，深挖拓展到底层原理<br />前端知识是无穷无尽的，本文也仅仅是简单梳理出一个承载知识体系的骨架而已，更多的内容仍然需要不断学习，积累<br />另外，本文结合<a href="https://segmentfault.com/a/1190000012925872">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a>这篇文章，更佳噢！<br><a name="section-19"></a></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a name="section-19-1"></a></p><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>初次发布<code>2018.03.12</code>于我个人博客上面<br /><a href="http://www.dailichun.com/2018/03/12/whenyouenteraurl.html">http://www.dailichun.com/2018/03/12/whenyouenteraurl.html</a><br><a name="section-19-2"></a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://segmentfault.com/a/1190000012925872">https://segmentfault.com/a/1190000012925872</a></li><li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/</a></li><li><a href="https://coolshell.cn/articles/9666.html">https://coolshell.cn/articles/9666.html</a></li><li><a href="http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/">http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/</a></li><li><a href="http://blog.csdn.net/dojiangv/article/details/51794535">http://blog.csdn.net/dojiangv/article/details/51794535</a></li><li><a href="http://bbs.csdn.net/topics/340204423">http://bbs.csdn.net/topics/340204423</a></li><li><a href="https://segmentfault.com/a/1190000004246731">https://segmentfault.com/a/1190000004246731</a></li><li><a href="http://www.bubuko.com/infodetail-1379568.html">http://www.bubuko.com/infodetail-1379568.html</a></li><li><a href="http://fex.baidu.com/blog/2014/05/what-happen/">http://fex.baidu.com/blog/2014/05/what-happen/</a></li><li><a href="http://www.cnblogs.com/winter-cn/archive/2013/05/21/3091127.html">http://www.cnblogs.com/winter-cn/archive/2013/05/21/3091127.html</a></li><li><a href="https://fanerge.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-webkit%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6.html">https://fanerge.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-webkit%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6.html</a></li><li><a href="http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html">http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html</a></li><li><a href="https://segmentfault.com/q/1010000000489803">https://segmentfault.com/q/1010000000489803</a></li></ul><blockquote><p>作者：撒网要见鱼<br>链接：<a href="http://www.dailichun.com/2018/03/12/whenyouenteraurl.html">http://www.dailichun.com/2018/03/12/whenyouenteraurl.html</a></p></blockquote><blockquote><p>时间：2018-03-12</p></blockquote><blockquote><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>generator函数生成器及其实现</title>
      <link href="/2023/04/24/frontend/interview/generator-han-shu-sheng-cheng-qi-ji-qi-shi-xian/"/>
      <url>/2023/04/24/frontend/interview/generator-han-shu-sheng-cheng-qi-ji-qi-shi-xian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>调用生成器函数会返回一个生成器对象，每次调用生成器对象的 next 方法会执行函数到下一次 yield 关键字停止执行，并且返回一个 { value: Value, done: boolean }的对象。本质是协程在 ES6 的实现。<br><a name="lD80g"></a></p><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><ul><li>首先调用<code>gen()</code> 生成器函数返回 g 生成器对象。</li><li>其次返回的 g 生成器对象中拥有一个 next 的方法。</li><li><strong>每当我们调用</strong><code>**g.next()**</code><strong>方法时，生成器函数紧跟着上一次进行执行，直到函数碰到 yield 关键值。</strong></li><li>yield 关键字会停止函数执行并将 yield 后的值返回作为本次调用 next 函数的 value 进行返回。</li><li>同时，如果本次调用<code>g.next()</code>导致生成器函数执行完毕，那么此时 done 会变成 true 表示该函数执行完毕，反之则为 false 。<br><a name="De3nx"></a></li></ul><h1 id="进阶语法"><a href="#进阶语法" class="headerlink" title="进阶语法"></a>进阶语法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a, <span class="string">&#x27;this is a&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> b = <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b, <span class="string">&#x27;this is b&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> c = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c, <span class="string">&#x27;this is c&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;res&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// 打印 &#123; value: 1, done: false &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&#x27;param-a&#x27;</span>)); <span class="comment">// 打印 param-a this is a &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&#x27;param-b&#x27;</span>)); <span class="comment">// 打印 param-b this is b &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&#x27;param-c&#x27;</span>)); <span class="comment">// 打印 param-c this is c &#123; value: &#x27;res&#x27;, done: true &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// 打印 &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><ul><li>定义一个生成器函数，并创建一个生成器对象。</li><li>第一次调用 <code>g.next()</code>方法时，函数执行到 <code>yield 1</code>并中断函数执行，由于代码中断，<code>a</code>的赋值语句并没有被执行。</li><li>第二次调用<code>g.next()</code>方法时，next接受传参传入一个字符串<code>param-a</code>，函数执行时从上一次中断的地方开始继续执行，也就是执行 <code>a</code>的赋值语句，从打印结果来看，<code>a</code>被赋值为字符<code>param-a</code>。</li><li>第三次调用<code>g.next()</code>方法并传入字符串<code>param-b</code>时，结果同样是变量<code>b</code>被赋值为<code>param-b</code>。</li><li>第四次调用<code>g.next()</code>方法与第二第三次的区别是，<code>return</code>语句作为返回值语句取代了<code>yield</code>语句，所以执行结果是<code>&#123; value: &#39;res&#39;, done: true &#125;</code>。</li><li>第五次调用<code>g.next()</code>，由于生成器函数已经执行完毕，所以打印<code>&#123; value: undefined, done: true &#125;</code>。</li></ul><p>从上述的分析中可以得出两个结论：</p><ol><li>当我们为 next 传递值进行调用时，传入的值会被当作上一次生成器函数暂停时 yield 关键字的返回值处理。</li><li>当生成器函数执行完毕时，原本本次调用 next 方法返回的<code>&#123;done:true,value:undefined&#125;</code>由于<code>return</code>语句变为了<code>&#123; done:true,value:&#39;res&#39;&#125;</code>。<br><a name="lmZhu"></a></li></ol><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">generatorWrap</span> = (<span class="params">fn</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="number">0</span>, <span class="comment">// 表示下一次执行生成器函数状态机switch中的下标</span></span><br><span class="line">    <span class="attr">sent</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 表示next调用时候传入的值 作为上一次yield返回值</span></span><br><span class="line">    <span class="attr">done</span>: <span class="literal">false</span>, <span class="comment">// 是否完成</span></span><br><span class="line">    <span class="comment">// 完成函数</span></span><br><span class="line">    <span class="title function_">stop</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">done</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params">param</span>) &#123;</span><br><span class="line">      <span class="comment">// 1. 修改上一次yield返回值为context.sent</span></span><br><span class="line">      ctx.<span class="property">sent</span> = param;</span><br><span class="line">      <span class="comment">// 2.执行函数 获得本次返回值</span></span><br><span class="line">      <span class="keyword">const</span> value = <span class="title function_">fn</span>(ctx);</span><br><span class="line">      <span class="comment">// 3. 返回</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">done</span>: ctx.<span class="property">done</span>,</span><br><span class="line">        value,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a, b, c;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">generatorWrap</span>(<span class="keyword">function</span> (<span class="params">ctx</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> ((ctx.<span class="property">prev</span> = ctx.<span class="property">next</span>)) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ctx.<span class="property">next</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        a = ctx.<span class="property">sent</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a, <span class="string">&#x27;this is a&#x27;</span>);</span><br><span class="line">        ctx.<span class="property">next</span> = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        b = ctx.<span class="property">sent</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(b, <span class="string">&#x27;this is b&#x27;</span>);</span><br><span class="line">        ctx.<span class="property">next</span> = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        c = ctx.<span class="property">sent</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(c, <span class="string">&#x27;this is c&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;end&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> ctx.<span class="title function_">stop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&#x27;param-a&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&#x27;param-b&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&#x27;param-c&#x27;</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDN</title>
      <link href="/2022/12/12/frontend/browser/cdn/"/>
      <url>/2022/12/12/frontend/browser/cdn/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="ttqHt"></a></p><h2 id="CDN是什么"><a href="#CDN是什么" class="headerlink" title="CDN是什么"></a>CDN是什么</h2><p>内容分发网络（Content delivery network或Content distribution network，缩写：CDN）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p><p><a name="FaHam"></a></p><h2 id="为什么需要CDN"><a href="#为什么需要CDN" class="headerlink" title="为什么需要CDN"></a>为什么需要CDN</h2><p>根本上的原因是，访问速度对互联网应用的用户体验、口碑、甚至说直接的营收都有巨大的影响，任何的企业都渴望自己站点有更快的访问速度。而HTTP传输时延对web的访问速度的影响很大，在绝大多数情况下是起决定性作用的，这是由TCP&#x2F;IP协议的一些特点决定的。物理层上的原因是光速有限、信道有限，协议上的原因有丢包、慢启动、拥塞控制等。<br />要提高访问速度，最简单的做法当然就是多设置几个服务器，让终端用户离服务器“更近”。典型的例子是各类下载网站在不同地域不同运营商设置镜像站，或者是像Google那样设置多个数据中心。但是多设几个服务器的问题也不少，一是多地部署时的困难，二是一致性没法保障，三则是管理困难、成本很高。实际上，在排除多地容灾等特殊需求的情况下，对大多数公司这种做法是不太可取的。当然，这种方案真正做好了，甚至是比后续所说的使用CDN要好的。<br />CDN是一种公共服务，他本身有很多台位于不同地域、接入不同运营商的服务器，而所谓的使用CDN实质上就是让CDN作为网站的门面，用户访问到的是CDN服务器，而不是直接访问到网站。由于CDN内部对TCP的优化、对静态资源的缓存、预取，加上用户访问CDN时，会被智能地分配到最近的节点，降低大量延迟，让访问速度可以得到很大提升。<br />这样做有什么好处呢？</p><ol><li>本地Cache加速，加快访问速度</li><li>镜像服务，消除运营商之间互联的瓶颈影响，保证不同网络的用户都能得到良好的访问质量</li><li>远程加速，自动选择cache服务器</li><li>带宽优化，分担网络流量，减轻压力，</li><li>集群抗攻击</li><li>节约成本</li></ol><p><a name="aaH0P"></a></p><h2 id="CDN的原理"><a href="#CDN的原理" class="headerlink" title="CDN的原理"></a>CDN的原理</h2><blockquote><p>CDN做了两件事，一是让用户访问最近的节点，二是从缓存或者源站获取资源</p></blockquote><p>CDN有个源站的概念，源站就是提供内容的站点(网站的真实服务器), 从源站取内容的过程叫做<strong>回源</strong>。<br />每次访问的具体流程如图（以最普通的CDN为例）<br /><a href="https://cloud.githubusercontent.com/assets/5894477/22008791/4edc00b0-dcb9-11e6-9663-ed19a3fa3182.png"><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589513075507-93ef051e-6bae-40f5-9efc-1c714ba3feb8.png#height=490&id=w8AZT&originHeight=490&originWidth=539&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=539" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589513075507-93ef051e-6bae-40f5-9efc-1c714ba3feb8.png#height=490&id=w8AZT&originHeight=490&originWidth=539&originalType=binary&ratio=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=539" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></a></p><p>具体举个例子：<br />用户在首次访问 <a href="https://assets-cdn.github.com/pinned-octocat.svg">https://assets-cdn.github.com/pinned-octocat.svg</a> , 假设不委托local DNS服务器递归查询，会经历以下几个过程</p><ol><li>浏览器检查本地有没有这个东东的有效缓存，有则使用缓存，没有有效缓存则进行对<code>assets-cdn.github.com</code>的DNS查询，获得一个 CNAME记录, <code>igithub.map.fastly.net</code>,值得注意的是，多个加速域名可以解析到同一个CNAME，CDN回源和缓存的时候考虑到了hostname，👍；</li><li>进行对<code>github.map.fastly.net</code>的DNS查询，获得一个A&#x2F;AAAA记录，给出地址<code>103.245.222.133</code>（视网站不同返回的不一样，可以有多个）, 这一步对CDN来说时十分重要的，它给出了离用户最近的边缘节点；</li><li>浏览器选一个返回的地址，然后进行真正的http请求，开始向<code>103.245.222.133</code>握手，握手完了把http请求头也发给了该边缘服务器;</li><li>边缘服务器检查自己的cache里面有没有<code>[https://assets-cdn.github.com/pinned-octocat.svg](https://assets-cdn.github.com/pinned-octocat.svg)</code>这个资源，有则返回给用户，如果没有，向CDN中心服务器发起请求;</li><li>CDN中心服务器检查自己的cache里面有没有这个资源，有则返回给边缘服务器，没有则回源;</li><li>中心服务器发现客户配置了<code>github.map.fastly.net</code>的回源地址(这个只有cdn会知道，假设是<code>xxx.xxx.xxx.xxx</code>)，就把http请求发到源站地址上，源站返回后返回给请求方;</li></ol><p>可以看出CDN加速的原理很大部分是跟DNS挂钩在一起的，CDN供应商几乎一定需要一个智能DNS服务器。CDN可以拿到所有的明文数据，所以对数据安全性、保密性要求比较高的企业会选择自建CDN或者设置NS记录，指向自建的智能DNS服务器。<br />上述步骤每一步都可以缓存，注意是每一步！ 所以CDN要清除缓存很难，因为有很多服务器上的缓存要清除。无论是用户对边缘服务器的请求，还是CDN服务器的回源都可以使用https。<br />注意，实际环境中图中每个服务器都可以是集群，甚至CDN分区域中心和总中心。</p><p><a name="1Isay"></a></p><h3 id="文件更新的原理"><a href="#文件更新的原理" class="headerlink" title="文件更新的原理"></a>文件更新的原理</h3><p>用户访问使用了 CDN 技术的文件后，在多个环节都可能会产生缓存，比如用户的浏览器中、CDN 的边缘节点等。浏览器端的缓存一般通过过期时间来自动更新；而对于 CDN 节点上缓存的更新，一般是通过源站更新后，手动触发 CDN 的缓存删除操作。</p><p><a name="oLpLA"></a></p><h2 id="使用-CDN-用CDN托管静态资源"><a href="#使用-CDN-用CDN托管静态资源" class="headerlink" title="使用 CDN (用CDN托管静态资源)"></a>使用 CDN (用CDN托管静态资源)</h2><p>（使用 CDN，抛开无用的 cookie）<br />要知道，浏览器第一次打开页面的时候，浏览器缓存是起不了作任何用的；使用CDN，效果就很明显。<br /><strong>CDN缓存，也叫网关缓存、反向代理缓存</strong>。浏览器先向CDN网关发起WEB请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态地请求转发到合适的源服务器上。<br />通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。<br />cdn从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因，提高用户访问网站的响应速度。<strong>CDN网络是在用户和服务器之间增加Cache层，主要是通过接管DNS实现,将用户的请求引导到Cache上获得源服务器的数据</strong>。<br />使用了CDN缓存后的网站的访问过程变为：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589513234285-3996bc7e-36f9-4082-ba78-86916438d850.png#height=384&id=pht4z&originHeight=384&originWidth=680&originalType=binary&ratio=1&rotation=0&showTitle=false&size=143841&status=done&style=none&title=&width=680" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589513234285-3996bc7e-36f9-4082-ba78-86916438d850.png#height=384&id=pht4z&originHeight=384&originWidth=680&originalType=binary&ratio=1&rotation=0&showTitle=false&size=143841&status=done&style=none&title=&width=680" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><ol><li>用户输入访问的域名,操作系统向 LocalDns 查询域名的ip地址;</li><li>LocalDns 向 ROOT DNS 查询域名的授权服务器(这里假设LocalDns缓存过期);</li><li>ROOT DNS将域名授权dns记录回应给 LocalDns，LocalDns得到域名的授权dns记录后,继续向域名授权dns查询域名的ip地址;</li><li>域名授权dns 查询域名记录后(一般是CNAME)，回应给 LocalDns，LocalDns 得到域名记录后,向智能调度DNS查询域名的ip地址;</li><li>智能调度DNS 根据一定的算法和策略(比如静态拓扑，容量等),将最适合的CDN节点ip地址回应给LocalDns，LocalDns将得到的域名ip地址，回应给用户端，用户得到域名ip地址后，访问站点服务器;</li><li>CDN节点服务器应答请求，将内容返回给客户端.(缓存服务器一方面在本地进行保存，以备以后使用，二方面把获取的数据返回给客户端，完成数据服务过程)</li></ol><blockquote><p>作者：<a href="https://github.com/renaesop">renaesop</a><br>链接：<a href="https://github.com/renaesop/blog/issues/1">https://github.com/renaesop/blog/issues/1</a><br>时间：2016-05-06<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据处理库</title>
      <link href="/2022/12/04/frontend/collection/shu-ju-chu-li/"/>
      <url>/2022/12/04/frontend/collection/shu-ju-chu-li/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663397468320-4d3708fb-1bdc-4a21-8185-2bdfba047021.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663397468320-4d3708fb-1bdc-4a21-8185-2bdfba047021.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="Q7mK7"></a></p><h1 id="1-工具库"><a href="#1-工具库" class="headerlink" title="1. 工具库"></a><br />1. 工具库</h1><p><a name="mqTfI"></a></p><h2 id="（1）Lodash"><a href="#（1）Lodash" class="headerlink" title="（1）Lodash"></a>（1）Lodash</h2><p>Lodash是一个一致性、模块化、高性能、提高开发者效率的JavaScript 实用工具库。Lodash 通过降低 array、number、objects、string 等等的使用难度从而让 JavaScript 变得更简单。 Lodash 的模块化方法，非常适用于：<br />●遍历 array、object 和 string；<br />●对值进行操作和检测；<br />●创建符合功能的函数。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663344960809-61ca2ecc-899f-4bf6-8d82-1b9c39b64427.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663344960809-61ca2ecc-899f-4bf6-8d82-1b9c39b64427.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="UXOpY"></a></p><h2 id="（2）Underscore-js"><a href="#（2）Underscore-js" class="headerlink" title="（2）Underscore.js"></a>（2）Underscore.js</h2><p>Underscore.js 是一个实用的 JavaScript 工具库，它提供了一整套函数式编程的实用功能，但没有扩展任何 JavaScript 内置对象，而是将数据封装在一个自定义对象中。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663345962141-8ba80bde-78a0-4036-8127-75af27fd6d03.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663345962141-8ba80bde-78a0-4036-8127-75af27fd6d03.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="GcNN6"></a></p><h2 id="（3）Ramda"><a href="#（3）Ramda" class="headerlink" title="（3）Ramda"></a>（3）Ramda</h2><p>Ramda 的目标是专门为函数式编程风格而设计，更容易创建函数式 pipeline、且从不改变用户已有数据。Ramda 主要特性如下：<br />●Ramda 强调更加纯粹的函数式风格。数据不变性和函数无副作用是其核心设计理念。这可以帮助你使用简洁、优雅的代码来完成工作。<br />●Ramda 函数本身都是自动柯里化的。这可以让你在只提供部分参数的情况下，轻松地在已有函数的基础上创建新函数。<br />●Ramda 函数参数的排列顺序更便于柯里化。要操作的数据通常在最后面。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663345263357-d4adf726-0169-4b35-9dee-5e7042068097.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663345263357-d4adf726-0169-4b35-9dee-5e7042068097.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="qZBrQ"></a></p><h2 id="（4）Collect-js"><a href="#（4）Collect-js" class="headerlink" title="（4）Collect.js"></a>（4）Collect.js</h2><p>collect.js是 JavaScript 处理数组和对象的方便且无依赖的包装类工具。其提供了常用的数组和集合的操作API，map，reduce，filter 等集合的高级方法，设计灵感来源于 Laravel Collection。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663346140487-27c42d73-9e35-48cd-b719-d4a34fa469fd.png?x-oss-process=image/resize,w_632,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663346140487-27c42d73-9e35-48cd-b719-d4a34fa469fd.png?x-oss-process=image/resize,w_632,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="B51Yr"></a></p><h1 id="2-日期"><a href="#2-日期" class="headerlink" title="2. 日期"></a>2. 日期</h1><p><a name="A8cPr"></a></p><h2 id="（1）date-fns"><a href="#（1）date-fns" class="headerlink" title="（1）date-fns"></a>（1）date-fns</h2><p>date-fns 是一个现代的 JavaScript 日期工具类库，提供了最全面、最简单和一致的工具集，用于在浏览器和 Node.js 中操作 JavaScript 日期。其具有以下特性：<br />●<strong>模块化</strong>：根据需求选择需要引用的模块<br />●<strong>不可变</strong>：date-fns 使用纯函数构建，并且始终返回一个新的日期实例，而不是更改传递的日期实例。它允许防止错误并跳过长时间的调试会话<br />●<strong>可信赖</strong>：遵循语义版本，始终向后兼容<br />●<strong>快速</strong>：轻量快速，为用户提供最佳的使用体验<br />●<strong>TypeScript &amp; Flow</strong>：date-fns 同时支持 Flow 和 TypeScript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; format, formatDistance, formatRelative, subDays &#125; <span class="keyword">from</span> <span class="string">&#x27;date-fns&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">format</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&quot;&#x27;Today is a&#x27; eeee&quot;</span>)</span><br><span class="line"><span class="comment">//=&gt; &quot;Today is a Saturday&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">formatDistance</span>(<span class="title function_">subDays</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="number">3</span>), <span class="keyword">new</span> <span class="title class_">Date</span>(), &#123; <span class="attr">addSuffix</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="comment">//=&gt; &quot;3 days ago&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">formatRelative</span>(<span class="title function_">subDays</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="number">3</span>), <span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line"><span class="comment">//=&gt; &quot;last Friday at 7:26 p.m.&quot;</span></span><br></pre></td></tr></table></figure><p><br /><strong>Github：</strong><a href="https://github.com/date-fns/date-fns">https://github.com/date-fns/date-fns</a></p><p><a name="JoInD"></a></p><h2 id="（2）Moment-js"><a href="#（2）Moment-js" class="headerlink" title="（2）Moment.js"></a>（2）Moment.js</h2><p>Moment.js 是一个简单易用的轻量级 JavaScript 日期处理类库，提供了日期格式化、解析、验证等功能。它支持在浏览器和 NodeJS 两种环境中运行。此类库能够将给定的任意日期转换成多种不同的格式，具有强大的日期计算功能，同时也内置了能显示多样的日期形式的函数。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663345546273-1a6234fd-3648-4512-8e43-be63227a78a0.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663345546273-1a6234fd-3648-4512-8e43-be63227a78a0.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="e8bFT"></a></p><h2 id="（3）Day-js"><a href="#（3）Day-js" class="headerlink" title="（3）Day.js"></a>（3）Day.js</h2><p>Day.js是一个极简的JavaScript库，可以为现代浏览器解析、验证、操作和显示日期和时间。其具有以下特点：<br />●和 Moment.js 相同的 API 和用法<br />●不可变数据 (Immutable)<br />●支持链式操作 (Chainable)<br />●国际化 I18n<br />●仅 2kb 大小的微型库<br />●全浏览器兼容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">dayjs</span>().<span class="title function_">format</span>();                                     <span class="comment">// 2020-09-08T13:42:32+08:00</span></span><br><span class="line"><span class="title function_">dayjs</span>().<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD&#x27;</span>);                         <span class="comment">// 2020-09-08</span></span><br><span class="line"><span class="title function_">dayjs</span>().<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>);                <span class="comment">// 2020-09-08 13:47:12</span></span><br><span class="line"><span class="title function_">dayjs</span>(<span class="number">1318781876406</span>).<span class="title function_">format</span>(<span class="string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>);   <span class="comment">// 2011-10-17 00</span></span><br></pre></td></tr></table></figure><p><br /><strong>Github：</strong><a href="https://github.com/iamkun/dayjs/">https://github.com/iamkun/dayjs/</a></p><p><a name="bCsN7"></a></p><h1 id="3-随机值"><a href="#3-随机值" class="headerlink" title="3. 随机值"></a>3. 随机值</h1><p><a name="jnxxN"></a></p><h2 id="（1）Chance-js"><a href="#（1）Chance-js" class="headerlink" title="（1）Chance.js"></a>（1）Chance.js</h2><p>Chance 是一个轻量级的 JavaScript 随机字符串生成器插件，可帮助减少编写单调的代码，特别是在编写自动化测试时经常需要各种随机内容。可以使用它来产生随机数、字符、字符串、名字、地址、骰子等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663346553258-2cab16aa-ec04-4108-8dae-68ad28cdf65e.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663346553258-2cab16aa-ec04-4108-8dae-68ad28cdf65e.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="zJE0S"></a></p><h2 id="（2）UUID"><a href="#（2）UUID" class="headerlink" title="（2）UUID"></a>（2）UUID</h2><p>UUID 是一个用于在 JavaScript 中生成符合 RFC 的 UUID 的实用程序库。其具有以下特点：<br />●<strong>完整</strong>：支持 RFC4122 版本 1、3、4 和 5 UUID<br />●<strong>跨平台</strong>：支持CommonJS、ECMAScript 模块和 CDN 构建；Node 12, 14, 16, 18；Chrome、Safari、Firefox、Edge 浏览器；Webpack 和 rollup.js 模块打包工具；<br />●<strong>安全</strong>：加密强度高的随机值<br />●<strong>体积小</strong>：零依赖，占用空间小<br />●<strong>CLI</strong>：包括 uuid 命令行实用程序<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663346948580-38577de8-3075-45fc-9c3f-c317ed9c25e0.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663346948580-38577de8-3075-45fc-9c3f-c317ed9c25e0.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="TdjzQ"></a></p><h2 id="（3）Nano-ID"><a href="#（3）Nano-ID" class="headerlink" title="（3）Nano ID"></a>（3）Nano ID</h2><p>nanoid 是一个小巧、安全、URL友好、唯一的 JavaScript 字符串ID生成器。其具有以下特性：<br />●<strong>小巧.<strong>130 bytes (已压缩和 gzipped)。 没有依赖。Size Limit控制大小。<br />●</strong>快速.<strong>它比 UUID 快 60%。<br />●</strong>安全.<strong>它使用加密的强随机 API。可在集群中使用。<br />●</strong>紧凑.<strong>它使用比 UUID（A-Za-z0-9_-）更大的字母表。 因此，ID 大小从36个符号减少到21个符号。<br />●</strong>易用.</strong> Nano ID 已被移植到 20种编程语言。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nanoid &#125; <span class="keyword">from</span> <span class="string">&#x27;nanoid&#x27;</span></span><br><span class="line">model.<span class="property">id</span> = <span class="title function_">nanoid</span>() <span class="comment">//=&gt; &quot;V1StGXR8_Z5jdHi6B-myT&quot;</span></span><br></pre></td></tr></table></figure><p><br /><strong>Github：</strong><a href="https://github.com/ai/nanoid">https://github.com/ai/nanoid</a></p><p><a name="OICzz"></a></p><h1 id="4-数字"><a href="#4-数字" class="headerlink" title="4. 数字"></a>4. 数字</h1><p><a name="CJBLT"></a></p><h2 id="（1）Math-js"><a href="#（1）Math-js" class="headerlink" title="（1）Math.js"></a>（1）Math.js</h2><p>Math.js 是一个强大的 JavaScript 和 Node.js 数学库。它具有支持符号计算的灵活表达式解析器，带有大量内置函数和常量，并提供了一个集成的解决方案来处理不同的数据类型，如数字、大数、复数、分数、单位和矩阵。功能强大且易于使用。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663345429885-0e72b914-e929-4b6c-abad-06635795590c.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663345429885-0e72b914-e929-4b6c-abad-06635795590c.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="eeHP5"></a></p><h2 id="（2）Numeral-js"><a href="#（2）Numeral-js" class="headerlink" title="（2）Numeral.js"></a>（2）Numeral.js</h2><p>Numeral.js 是一个用来对数值进行操作和格式化的 JS 库。可将数字格式化为货币、百分比、时间，甚至是序数词的缩写（比如1st，100th）。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663395404093-ae3d768c-0ccd-4ed3-89d9-0087808855cf.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663395404093-ae3d768c-0ccd-4ed3-89d9-0087808855cf.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="VIbiK"></a></p><h2 id="（3）Accounting-js"><a href="#（3）Accounting-js" class="headerlink" title="（3）Accounting.js"></a>（3）Accounting.js</h2><p>Accounting.js 是一个用于数字、货币和货币解析&#x2F;格式化的小型 JavaScript 库。它是轻量级的，完全可本地化的，没有依赖关系，并且在客户端或服务器端都可以很好地工作。使用独立或作为 nodeJS&#x2F;npm 和 AMD&#x2F;requireJS 模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default usage:</span></span><br><span class="line">accounting.<span class="title function_">formatMoney</span>(<span class="number">12345678</span>); <span class="comment">// $12,345,678.00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// European formatting (custom symbol and separators), can also use options object as second parameter:</span></span><br><span class="line">accounting.<span class="title function_">formatMoney</span>(<span class="number">4999.99</span>, <span class="string">&quot;€&quot;</span>, <span class="number">2</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;,&quot;</span>); <span class="comment">// €4.999,99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Negative values can be formatted nicely:</span></span><br><span class="line">accounting.<span class="title function_">formatMoney</span>(-<span class="number">500000</span>, <span class="string">&quot;£ &quot;</span>, <span class="number">0</span>); <span class="comment">// £ -500,000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple `format` string allows control of symbol position (%v = value, %s = symbol):</span></span><br><span class="line">accounting.<span class="title function_">formatMoney</span>(<span class="number">5318008</span>, &#123; <span class="attr">symbol</span>: <span class="string">&quot;GBP&quot;</span>,  <span class="attr">format</span>: <span class="string">&quot;%v %s&quot;</span> &#125;); <span class="comment">// 5,318,008.00 GBP</span></span><br></pre></td></tr></table></figure><p><br /><strong>Github：</strong><a href="https://github.com/openexchangerates/accounting.js">https://github.com/openexchangerates/accounting.js</a></p><p><a name="meSLV"></a></p><h1 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5. 字符串"></a>5. 字符串</h1><p><a name="oCUVb"></a></p><h2 id="（1）qs"><a href="#（1）qs" class="headerlink" title="（1）qs"></a>（1）qs</h2><p>qs是一个url参数转化（parse和stringify）的JavaScript库。可以把格式化的字符串转换为对象格式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;qs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(<span class="string">&#x27;assert&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = qs.<span class="title function_">parse</span>(<span class="string">&#x27;a=c&#x27;</span>);</span><br><span class="line">assert.<span class="title function_">deepEqual</span>(obj, &#123; <span class="attr">a</span>: <span class="string">&#x27;c&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = qs.<span class="title function_">stringify</span>(obj);</span><br><span class="line">assert.<span class="title function_">equal</span>(str, <span class="string">&#x27;a=c&#x27;</span>);</span><br></pre></td></tr></table></figure><p><br /><strong>Github：</strong><a href="https://github.com/ljharb/qs">https://github.com/ljharb/qs</a></p><p><a name="O8Q54"></a></p><h2 id="（2）Voca"><a href="#（2）Voca" class="headerlink" title="（2）Voca"></a>（2）Voca</h2><p>Voca 是一个用于操作字符串的 JavaScript 库。Voca 库提供了有用的函数来使字符串操作更加舒适：更改大小写、修剪、填充、slugify、拉丁化、sprintfy、截断、转义等。模块化设计允许加载整个库或单个函数以最小化应用程序构建。该库经过全面测试、有据可查并长期受支持。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="title function_">camelCase</span>(<span class="string">&#x27;bird flight&#x27;</span>);              <span class="comment">// =&gt; &#x27;birdFlight&#x27;</span></span><br><span class="line">v.<span class="title function_">sprintf</span>(<span class="string">&#x27;%s costs $%.2f&#x27;</span>, <span class="string">&#x27;Tea&#x27;</span>, <span class="number">1.5</span>); <span class="comment">// =&gt; &#x27;Tea costs $1.50&#x27;</span></span><br><span class="line">v.<span class="title function_">slugify</span>(<span class="string">&#x27;What a wonderful world&#x27;</span>);     <span class="comment">// =&gt; &#x27;what-a-wonderful-world&#x27;</span></span><br></pre></td></tr></table></figure><p><br /><strong>Github：</strong><a href="https://github.com/panzerdp/voca">https://github.com/panzerdp/voca</a></p><p><a name="Fa7TA"></a></p><h1 id="6-存储"><a href="#6-存储" class="headerlink" title="6. 存储"></a>6. 存储</h1><p><a name="GklnF"></a></p><h2 id="（1）js-cookie-js"><a href="#（1）js-cookie-js" class="headerlink" title="（1）js-cookie.js"></a>（1）js-cookie.js</h2><p>js-cookie.js 是一个用于处理浏览器 cookie 的简单、轻量级 JavaScript API。其具有以下特点：<br />●适用于所有浏览器<br />●接受任何字符<br />●经过大量测试<br />●无依赖<br />●支持ES模块<br />●支持 AMD&#x2F;CommonJS<br />●符合RFC 6265<br />●有用的维基<br />●启用自定义编码&#x2F;解码<br />●&lt; 800 字节压缩！<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663396381742-4045b423-ce34-4963-8cb3-ceedcfbf01de.png?x-oss-process=image/resize,w_632,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663396381742-4045b423-ce34-4963-8cb3-ceedcfbf01de.png?x-oss-process=image/resize,w_632,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="bW0B6"></a></p><h2 id="（2）Cookies"><a href="#（2）Cookies" class="headerlink" title="（2）Cookies"></a>（2）Cookies</h2><p>Cookies 是一个用于获取和设置 HTTP(S) cookie的node.js模块。它的特点如下：<br />●允许使用Keygrip来签署cookie，以防止篡改；<br />●延迟验证cookie，以降低成本；<br />●不允许通过不安全的套接字发送安全cookies；<br />●默认情况下，所有cookie都仅适用于HTTP，并且通过SSL发送的cookie是安全的；<br />●允许其他库在不知道签名机制的情况下访问 cookie。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Cookies</span> = <span class="built_in">require</span>(<span class="string">&#x27;cookies&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Optionally define keys to sign cookie values</span></span><br><span class="line"><span class="comment">// to prevent client tampering</span></span><br><span class="line"><span class="keyword">var</span> keys = [<span class="string">&#x27;keyboard cat&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="comment">// Create a cookies object</span></span><br><span class="line">  <span class="keyword">var</span> cookies = <span class="keyword">new</span> <span class="title class_">Cookies</span>(req, res, &#123; <span class="attr">keys</span>: keys &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get a cookie</span></span><br><span class="line">  <span class="keyword">var</span> lastVisit = cookies.<span class="title function_">get</span>(<span class="string">&#x27;LastVisit&#x27;</span>, &#123; <span class="attr">signed</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the cookie to a value</span></span><br><span class="line">  cookies.<span class="title function_">set</span>(<span class="string">&#x27;LastVisit&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toISOString</span>(), &#123; <span class="attr">signed</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!lastVisit) &#123;</span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>)</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;Welcome, first time visitor!&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>)</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;Welcome back! Nothing much changed since your last visit at &#x27;</span> + lastVisit + <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Visit us at http://127.0.0.1:3000/ !&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><br /><strong>GitHub：</strong><a href="https://github.com/pillarjs/cookies">https://github.com/pillarjs/cookies</a></p><p><a name="gT8Pv"></a></p><h1 id="7-安全"><a href="#7-安全" class="headerlink" title="7. 安全"></a>7. 安全</h1><p><a name="I0YJt"></a></p><h2 id="（1）DOMPurify"><a href="#（1）DOMPurify" class="headerlink" title="（1）DOMPurify"></a>（1）DOMPurify</h2><p>DOMPurify 是一个开源的基于DOM的快速XSS净化工具。输入HTML元素，然后通过DOM解析递归元素节点，进行净化，输出安全的HTML。 <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663347229048-8ff9cd22-334b-4633-9cd3-fa9f3bd07c6d.png?x-oss-process=image/resize,w_638,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1663347229048-8ff9cd22-334b-4633-9cd3-fa9f3bd07c6d.png?x-oss-process=image/resize,w_638,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> 数据处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何去搞前端基建</title>
      <link href="/2022/11/21/frontend/infrastructure/ru-he-qu-gao-qian-duan-ji-jian/"/>
      <url>/2022/11/21/frontend/infrastructure/ru-he-qu-gao-qian-duan-ji-jian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a href="https://juejin.cn/post/7144881028661723167#heading-22">https://juejin.cn/post/7144881028661723167#heading-22</a></p><p><a name="FN5iV"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大家好，我是<a href="https://link.juejin.cn/?target=https://github.com/YWzzy">yinhan</a>，话说当下，前端职位在近十年的磨砺之下，已是百花齐放万家争鸣，前端也不再是以前那个单纯的切图仔；<br />要问为什么不单纯，无异于 前端工程化、前端 devops、前端跨端、前端工具化、前端 CI&#x2F;CD、前端 BFF、微前端 这些技术的出现，然而这些日新月异的技术聚合，咱们可以称其为 前端基建；<br />其实无论您是想成为 高级前端工程师，还是一名 合格的 Leader，都离不开对 <strong>前端技术与业务的基础建设沉淀</strong>；<br />看完全文，我相信 <strong>您的收获会远不止于此</strong> ~<br><a name="mD7nC"></a></p><h1 id="一、什么是基建？"><a href="#一、什么是基建？" class="headerlink" title="一、什么是基建？"></a>一、什么是基建？</h1><p>基建 这个词无论身处哪个行业，基本都会存在；只是在最近几年的软件计算机行业中尤为流行；<br />在建筑行业：一幢大厦所需的地基，脚手架，一块砖、一片瓦、一袋水泥、一扇窗等等咱都可以称之为基础建设的一部分；<br />在汽车行业：一辆汽车所需的车架子、发动机、车轱辘、方向盘、门窗等等咱也可称之为基础建设的一部分；<br />那么在互联网软件行业呢？<br />笔者的理解是：在软件行业，站在广义的角度上来讲基建包含了：业务基建、工程基建、前端基建、后端基建 等等；（此处仅笔者个人理解，如果意见不一样，以你的为准）<br><a name="VUwSL"></a></p><h2 id="业务基建？"><a href="#业务基建？" class="headerlink" title="业务基建？"></a>业务基建？</h2><p>业务基建 是指公司某个业务团队层面所维护的 前端基建、后端基建、基本规范文档、产品规则、设计规范、研发流程、测试边界、上线标准以及业务中台 等等的建设；<br />业务基建 服务于整个业务团队<br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103192-d8ab0706-9dbe-409a-b3b6-e9fca379d5d5.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103192-d8ab0706-9dbe-409a-b3b6-e9fca379d5d5.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="vZHeV"></a></p><h2 id="工程基建？"><a href="#工程基建？" class="headerlink" title="工程基建？"></a>工程基建？</h2><p>工程基建 指的是业务团队内所有工程师的的一些 编码规范、api规范、前后端协作、环境部署、微服务、微前端、性能、安全防御、统计监控、可视化 等等的建设；<br />工程基建 服务于整个工程团队；<br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103192-d8ab0706-9dbe-409a-b3b6-e9fca379d5d5.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103192-d8ab0706-9dbe-409a-b3b6-e9fca379d5d5.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="工程基建"><br><a name="sUoPL"></a></p><h2 id="前端基建？"><a href="#前端基建？" class="headerlink" title="前端基建？"></a>前端基建？</h2><p>前端基建 指的是业务团队内的前端工程师执行的一些基础建设，包括了 前端规范文档、前端脚手架、前端模板、前端组件库、前端工具库、前端BFF、前端CI&#x2F;CD的构建部署、前端数据埋点 等等；<br />前端基建 仅服务于前端团队；<br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103292-69a329ee-2913-4281-90ea-8b19710ba834.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103292-69a329ee-2913-4281-90ea-8b19710ba834.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="RB8uY"></a></p><h2 id="后端基建？"><a href="#后端基建？" class="headerlink" title="后端基建？"></a>后端基建？</h2><p>后端基建 指的是业务团队内的后端工程师执行的一些基础建设，包括了 后端规范文档、后端模板、安全、日志、微服务、RESTful API、中间件、数据库、分布式、权限控制、服务器性能并发 等等；<br />注意：后端基建 仅服务于后端团队；<br><a name="YPeSd"></a></p><h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103126-d59552e2-a23e-450f-ac97-8309c2839051.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103126-d59552e2-a23e-450f-ac97-8309c2839051.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />看到这里，咱们已经明白了公司基建的一些基本分类和概括，下面我们也主要介绍下本文的主题前端基建；<br><a name="hEQFR"></a></p><h1 id="二、为什么要做前端基建？"><a href="#二、为什么要做前端基建？" class="headerlink" title="二、为什么要做前端基建？"></a>二、为什么要做前端基建？</h1><p><a name="amcFS"></a></p><h2 id="场景复现"><a href="#场景复现" class="headerlink" title="场景复现"></a>场景复现</h2><p><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103136-94a241c3-415a-417b-9c96-b64f6e5abf32.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103136-94a241c3-415a-417b-9c96-b64f6e5abf32.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="KX7VW"></a></p><h2 id="前端基建意义与作用"><a href="#前端基建意义与作用" class="headerlink" title="前端基建意义与作用"></a>前端基建意义与作用</h2><ul><li>业务复用；</li><li>提升研发效率；</li><li>规范研发流程；</li><li>团队技术提升；</li><li>团队的技术影响力；</li><li>开源建设；<br><a name="ZDuKL"></a></li></ul><h1 id="三、前端基建如何推动落地？"><a href="#三、前端基建如何推动落地？" class="headerlink" title="三、前端基建如何推动落地？"></a>三、前端基建如何推动落地？</h1><p><a name="TPbJ5"></a></p><h2 id="技术基建简要流程"><a href="#技术基建简要流程" class="headerlink" title="技术基建简要流程"></a>技术基建简要流程</h2><p>要说 前端基建，最主要的难点莫过于如何去推动落地，其中不乏需要前端同学的付出，还需要领导的支持等等，下面我给大家罗列一下大致的步骤（因团队而异）</p><ol><li><strong>要合适的同学（资源）</strong><ul><li>挨个与前端同学商议，或者自己钦点某位同学等等；而且要有动力，切勿急于求成、半途而废，注重系统思维，也千万不要找不稳定的同学（切记切记切记）</li></ul></li><li><strong>要解决的问题（问题）</strong><ul><li>针对现有公司前端人员架构、技术架构以及业务架构做对应的方案，这个没有固定的套路，不同公司所面临的问题也不一致；</li></ul></li><li><strong>要解决问题方案计划书（方案）</strong><ul><li>到目前，咱们已经有人（前端同学），也有具体想要做的事了，那么接下来很重要的一步就是出解决方案找领导确认了；</li><li>其实就类似你有一个很好 idea，写了一份特别详细的商业计划书（BP）去找投资人拉投资是一个道理；</li><li>不过最后能不能打动你的投资人，这就取决于你的 BP 做的是否够吸引人了；</li></ul></li><li><strong>要具体执行的步骤（执行）</strong><ul><li>天底下没有一蹴而就的事，工作也是，所以对于一个现有的技术团队，咱们最好是从渐进式出发，在对现有业务不影响的前提下去做增量式的研发；<br><a name="Jwfjz"></a></li></ul></li></ol><h2 id="技术基建四大特性（切记）"><a href="#技术基建四大特性（切记）" class="headerlink" title="技术基建四大特性（切记）"></a>技术基建四大特性（切记）</h2><ul><li>技术的健全性</li><li>基建的稳定性</li><li>研发的效率性</li><li>业务的体验性</li></ul><p>到这里，我相信大家对前端基建已有初步的了解，可能会有同学已经想跃跃欲试了，但是前端基建到底有些什么呢？咱们一起往下看。<br><a name="E6zrL"></a></p><h1 id="四、前端基建都有什么？"><a href="#四、前端基建都有什么？" class="headerlink" title="四、前端基建都有什么？"></a>四、前端基建都有什么？</h1><p>前端基建 在每个公司甚者每个业务团队都会有差异，其中有 技术栈的差异，有编码的差异，有文档注释的差异 等等；<br />为了迎合主要的前端基建市场，结合我司以及大部分公司的基建所需，下面给大家介绍一些符合大众的常用基建部分（后续会持续更新）；<br />下面所有分类只会简单介绍，详细相关文章会在《<a href="https://juejin.cn/column/7139087916306792462">前端搞基建</a>》专栏后续发表（敬请期待…）；<br><a name="McB2d"></a></p><h2 id="1-前端规范（Standard）"><a href="#1-前端规范（Standard）" class="headerlink" title="1. 前端规范（Standard）"></a>1. 前端规范（Standard）</h2><p>正所谓：前端不规范，后面看着办 ~<br />我相信规范两个词，是所有同学的噩梦，怕他不规范，又怕他太规范，这可真是难为死这个规范了；<br /><strong>假设招聘现有三个候选人，你会选择哪个呢？</strong></p><ul><li>一名 <strong>“摆烂”</strong> 的程序员，写的代码能运行就行；</li><li>一名 <strong>“合格”</strong> 的程序员，写的代码能运行且无 BUG；</li><li>一名 <strong>“优秀”</strong> 的程序员，写的代码能运行无 BUG 且可读性、可维护性、可复用性都高；</li></ul><p>答案显而易见 ~<br /><strong>前端规范的意义：</strong></p><ul><li>降低开发的成本；</li><li>保证代码的一致性；</li><li>提升团队的整体效率；</li></ul><p><strong>前端规范有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103622-9e027779-344f-40f3-b7c6-ef32bc760582.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103622-9e027779-344f-40f3-b7c6-ef32bc760582.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="KQ0yz"></a></p><h2 id="2-前端文档（Document）"><a href="#2-前端文档（Document）" class="headerlink" title="2.前端文档（Document）"></a>2.前端文档（Document）</h2><p>其实在许许多多的小型公司，文档缺失是一项必不可少的问题；无论是 业务文档，还是 技术文档，还是 其它文档等等；<br /><strong>问题点：</strong></p><ul><li>有些公司招人进来上午安环境，下午直接开始撸需求代码；</li><li>有些公司的新人来公司一个月了竟然还不知道公司组织架构与业务划分；</li><li>有些公司老对新几乎无交集，全靠新人猜，一个需求做下来竟然不知道做的什么，只知道一直很忙；</li><li>有些公司在安排员工去开发另一个项目业务，竟然无从下手，不知所措；</li><li>……</li></ul><p>所以一个合格的公司文档是必不可少的，无论是 新人自治，还是老带新，业务转岗 等等；<br /><strong>前端文档的意义：</strong></p><ul><li>对新人友好，快速上手；</li><li>快速融入团队；</li><li>快速了解业务；</li></ul><p><strong>前端文档有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103692-08d1ea0a-9cb6-42fd-b628-6c8afcc5decb.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103692-08d1ea0a-9cb6-42fd-b628-6c8afcc5decb.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="rgekp"></a></p><h2 id="3-前端项目模板管理（Templates）"><a href="#3-前端项目模板管理（Templates）" class="headerlink" title="3. 前端项目模板管理（Templates）"></a>3. 前端项目模板管理（Templates）</h2><p>前端项目模板 说直白点就是，公司前端所对应的项目模板，以便快速创建项目；<br /><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103909-f0324e60-6e8d-42e4-bfc0-2d4f640104e7.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103909-f0324e60-6e8d-42e4-bfc0-2d4f640104e7.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>前端项目模板主要意义：</strong></p><ul><li>快速创建项目，提升效率；</li><li>项目技术栈统一，方便管理；</li></ul><p><strong>前端项目模板有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103939-19ed21a0-0ad9-4652-a66e-1a5a47ba12f6.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157103939-19ed21a0-0ad9-4652-a66e-1a5a47ba12f6.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="Jonae"></a></p><h2 id="4-前端脚手架（CLI）"><a href="#4-前端脚手架（CLI）" class="headerlink" title="4. 前端脚手架（CLI）"></a>4. 前端脚手架（CLI）</h2><p>前端脚手架 作为衡量一个成熟前端团队的标准，我相信很多前端er 都对他已经很了解了；<br />但是目前市面上对脚手架的应用我相信90%以上的团队仅限用于项目的快速创建，也就是使用现成的模板通过命令行快速搭建；<br />那么我们做这个脚手架是不是已经做到了 资源最大化 呢？<br />显然是没有的，如何去做我会在后续的文章中详解，大家敬请期待…<br /><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104008-f0a7309d-38b3-4737-8ec3-5d47561a8d7c.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104008-f0a7309d-38b3-4737-8ec3-5d47561a8d7c.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>前端脚手架的意义：</strong></p><ul><li>快速搭建项目；</li><li>技术栈统一；</li><li>规范代码风格；</li><li>提升研发效率；</li><li>自动化；</li></ul><p><strong>前端脚手架有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104029-0ba5548c-0c68-4d58-ab7a-31619236f947.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104029-0ba5548c-0c68-4d58-ab7a-31619236f947.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="tVBKN"></a></p><h2 id="5-前端组件库（UI-Design）"><a href="#5-前端组件库（UI-Design）" class="headerlink" title="5. 前端组件库（UI Design）"></a>5. 前端组件库（UI Design）</h2><p>前端 UI 组件库：在开源社区有数不胜数的组件库，例如 Ant Design、Element UI、Vant UI 等等（实在太多啦），如果你觉得某个组件库很适合用在你的项目，那么你将少一半的开发时间，是不是摸鱼的时间又多了一半呢？<br />但是在一些中大型的公司，他们<strong>有他们的标准，不可能去使用一些现成的组件库；</strong><br />而且现成的一些开源组件库中的样式与交互达不到公司设计师的要求，所以这时候 为了统一业务的设计规范与样式，咱们可以马不停蹄地赶紧向领导去提一提搞一个组件库试试看咯！<br /><strong>场景重现：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104069-53f50ff9-f30f-4268-a334-6c5be44c5958.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104069-53f50ff9-f30f-4268-a334-6c5be44c5958.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>前端组件库的意义：</strong></p><ul><li>组件复用，提升研发效率；</li></ul><p><strong>前端组件库有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104279-b0e414ba-41cd-40a2-812f-312baa3e3ae9.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104279-b0e414ba-41cd-40a2-812f-312baa3e3ae9.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="KTnoC"></a></p><h2 id="6-前端响应式设计-or-自适应设计"><a href="#6-前端响应式设计-or-自适应设计" class="headerlink" title="6. 前端响应式设计 or 自适应设计"></a>6. 前端响应式设计 or 自适应设计</h2><p>响应式设计（Responseive Design） 指的是一个网站同一页面在不同屏幕尺寸下有不同的布局；一套代码能在所有终端能够正常展示，并不是为每个终端做一个特定版本，响应式是为解决移动互联网浏览器而诞生的。<br />自适应设计（Adaptive web design） 需要开发多套界面，通过检测视口以及设备，来判断当前访问的设备是pc端与移动端，从而返回不同的页面。<br /><strong>前端响应式设计：</strong></p><ul><li>一套代码提升研发效率；</li><li>不同分辨率设备灵活性强；</li><li>快速适配多端；</li></ul><p><strong>前端自适应设计：</strong></p><ul><li>设计与体验较好；</li><li>性能相对好；</li></ul><p>注意：<br />一个项目到底是用<strong>响应式设计</strong>，还是<strong>自适应设计</strong>，这个取决于项目的排版和设计的出入程度;<br />所以如果公司PC端和H5端的排版设计有较大的出入还是建议使用自适应设计；反之可以考虑响应式设计；<br />切入盲目选择；<br><a name="BxqK1"></a></p><h2 id="7-前端工具库（类-Hooks-x2F-Utils）"><a href="#7-前端工具库（类-Hooks-x2F-Utils）" class="headerlink" title="7. 前端工具库（类 Hooks &#x2F; Utils）"></a>7. 前端工具库（类 Hooks &#x2F; Utils）</h2><p>开源社区有数不胜数的 前端工具库，如 Day.js、axios、loadsh 等等，只是其中功能未必是你想要的；<br />而且许多 前端工具库边界考量范围大，这样就增加库的体积，明明我想要的只是一个简单的功能，可还是引入了整个库，这样就得不偿失；<br />可能有同学要说不是有 Tree Shaking 了吗，难道有了 按需引入 有了 Tree Shaking 我们就可以为所欲为了吗<br />一些中大型企业团队为了复用某些工具方法，提升研发效率，一般都会封装一个工具库，身为一个合格的基建搬砖工，前端工具库怎么能少得了呢？<br /><strong>前端工具库的意义：</strong></p><ul><li>工具方法复用，提升研发效率；</li><li>减少代码量；</li><li>团队技术提升；</li></ul><p><strong>前端工具库有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104353-bb2fc1f6-f90d-45c8-a43b-84f7669b4a25.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104353-bb2fc1f6-f90d-45c8-a43b-84f7669b4a25.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="jMjja"></a></p><h2 id="8-前端工具自动化（Tools）"><a href="#8-前端工具自动化（Tools）" class="headerlink" title="8. 前端工具自动化（Tools）"></a>8. 前端工具自动化（Tools）</h2><p>可能会有同学疑惑，这个前端工具和上面的前端工具不是一样的吗？</p><ul><li>前端工具自动化 主要针对的代码上层的格式、规范、测试方面的自动化工具；</li><li>前端工具库 主要针对的是代码层面的方法复用工具，所以其本质上有较为明显的区别；</li></ul><p><strong>场景重现：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104390-f3548c35-c620-4714-bddd-382c922b2fa7.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104390-f3548c35-c620-4714-bddd-382c922b2fa7.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>前端工具自动化的意义：</strong></p><ul><li>代码质量与风格的统一；</li><li>自动化编码流程；</li><li>提升效率；</li></ul><p><strong>前端工具自动化有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104522-0bf97777-e7cb-48c0-a396-4168c51df863.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104522-0bf97777-e7cb-48c0-a396-4168c51df863.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="ijHEN"></a></p><h2 id="9-接口数据聚合（BFF）"><a href="#9-接口数据聚合（BFF）" class="headerlink" title="9. 接口数据聚合（BFF）"></a>9. 接口数据聚合（BFF）</h2><p>前端 BFF（Backends For Frontends） 即服务于前端的后端，也称聚合层或者中间层；<br />主要将后端复杂的微服务，聚合成对各种不同用户端（无线&#x2F;Web&#x2F;H5&#x2F;第三方等）友好和统一的API；<br /><strong>场景重现：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104879-08251786-380c-412c-927f-2b56044a3fc5.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104879-08251786-380c-412c-927f-2b56044a3fc5.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>前端 BFF 的意义：</strong></p><ul><li>聚合 API，释放后端；</li><li>解耦合各个业务；</li><li>后端微服务引入；</li><li>易维护和修改 API；</li><li>更好的安全性；</li><li>更好的前端错误处理；</li></ul><p><strong>前端 BFF 的简单架构：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104856-218c8b92-661a-4429-afb4-cc433e88e198.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104856-218c8b92-661a-4429-afb4-cc433e88e198.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="i5C8n"></a></p><h2 id="10-前端-SSR-推进"><a href="#10-前端-SSR-推进" class="headerlink" title="10. 前端 SSR 推进"></a>10. 前端 SSR 推进</h2><p>服务器端渲染（Server-Side Rendering） 是指由服务端完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。<br />简单理解就是html是由服务端写出，可以动态改变页面内容，即所谓的动态页面。早年的 <a href="https://link.juejin.cn/?target=https://baike.baidu.com/item/php/9337">php</a>、<a href="https://link.juejin.cn/?target=https://baike.baidu.com/item/asp/128906">asp</a> 、<a href="https://link.juejin.cn/?target=https://baike.baidu.com/item/jsp/141543">jsp</a> 这些 Server Page 都是 SSR 的。<br />由于公司主要是C端用户，而且 SEO 要求极高，所以在前后端分离的情况下，SSR 就必不可少了 ~<br /><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104999-c2d07874-ea37-4813-afce-dc789679d052.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104999-c2d07874-ea37-4813-afce-dc789679d052.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>前端 SSR 的目的：</strong></p><ul><li>前后端分离；</li><li>首屏加载速度快；</li><li>利于 SEO；<br><a name="BfMuC"></a></li></ul><h2 id="11-前端自动化构建部署（CI-x2F-CD）"><a href="#11-前端自动化构建部署（CI-x2F-CD）" class="headerlink" title="11. 前端自动化构建部署（CI&#x2F;CD）"></a>11. 前端自动化构建部署（CI&#x2F;CD）</h2><p>前端 CI&#x2F;CD 一般是指持续集成、部署、发布的一个过程；<br />用白话文讲，就是你每次 git commit 代码后，都会自动的为你部署项目至 测试环境、预生产环境、生产环境，不用你每次手动的去打包后 cv 到多个服务器和环境；<br /><strong>前端 CI&#x2F;CD 的意义：</strong></p><ul><li>提高开发人员生产力；</li><li>自动化发布；</li><li>提高代码质量；</li><li>更快地提供更新；</li></ul><p><strong>前端 CI&#x2F;CD 有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104802-556c26a8-3069-4925-b6db-b9c778169476.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157104802-556c26a8-3069-4925-b6db-b9c778169476.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="T8JYg"></a></p><h2 id="12-全链路前端监控-x2F-数据埋点系统"><a href="#12-全链路前端监控-x2F-数据埋点系统" class="headerlink" title="12. 全链路前端监控&#x2F;数据埋点系统"></a>12. 全链路前端监控&#x2F;数据埋点系统</h2><p>在大部分 To C 的项目中，我相信产品和运营都需要 统计线上产品在用户中的行为和使用情况，因为这样可以更快的去了解用户群里的使用情况，从而升级和迭代产品，使其更加贴近用户。<br /><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105105-05d4158c-135d-43dc-b293-fa82fe4c55a8.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105105-05d4158c-135d-43dc-b293-fa82fe4c55a8.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>前端监控&#x2F;数据埋点的目的是：</strong></p><ul><li>实现精准的点对点营销；</li><li>可以做相关的分类统计；</li><li>为用户画像的构建提供数据支持；</li><li>指导产品研发以及优化用户体验；</li></ul><p><strong>前端监控&#x2F;数据埋点有哪些数据？</strong></p><ul><li>行为数据：时间、地点、人物、交互、交互的内容；</li><li>质量数据：浏览器加载情况、错误异常等；</li><li>环境数据：浏览器相关的元数据以及地理、运营商等；</li><li>运营数据：PV、UV、转化率、留存率（很直观的数据）；<br><a name="Sxzk0"></a></li></ul><h2 id="13-前端可视化平台"><a href="#13-前端可视化平台" class="headerlink" title="13. 前端可视化平台"></a>13. 前端可视化平台</h2><p>前端可视化 字面意义理解就是用肉眼可见的就称呼为前端可视化；即所见即所得；<br />笔者这里的理解 前端可视化 包括了 数据可视化、图形可视化、VR 全景可视化、中后台视觉可视化 等等；<br />其中每一个都需要花费大量的人力与精力，如果你想全方面的从入门到精通，可以看看<a href="https://juejin.cn/user/712139263189303">月影大佬</a>的可视化教程。<br />目前公司在基于前端基建这块，所做的可视化主要是基于大家的工作流程以及工作效率所做的一个 工程可视化平台；<br /><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105264-c330d510-e0bb-4882-8e2c-17dab219e8cc.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105264-c330d510-e0bb-4882-8e2c-17dab219e8cc.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>前端工程可视化平台的目的：</strong></p><ul><li>方便项目管理；</li><li>高效提升工作效率；</li><li>一键搞定CI&#x2F;CD流；</li></ul><p><strong>前端工程可视化平台有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157106022-5dcbd2ae-bdeb-4334-ae93-72e2be9d51fc.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157106022-5dcbd2ae-bdeb-4334-ae93-72e2be9d51fc.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="yQgmu"></a></p><h2 id="14-前端性能优化"><a href="#14-前端性能优化" class="headerlink" title="14. 前端性能优化"></a>14. 前端性能优化</h2><p>性能优化这个词，我相信只要是程序员，多多少少都听过，而且都经历过；<br />如果你的项目是 ToB 项目，可能性能优化不会做到极致；<br />但是你的项目是 ToC 项目呢，那性能优化是不是就是一个你必须要考量的点呢？<br /><strong>场景重现：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105522-3c778742-f481-4770-84a8-f1b5e7d5ef4b.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105522-3c778742-f481-4770-84a8-f1b5e7d5ef4b.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />好家伙，用户直接崩溃，这是什么破网站，这么 🌶 🐔 ；<br /><strong>前端性能优化的意义：</strong></p><ul><li>页面加载的更快；</li><li>更好的用户体验；</li><li>降低服务器负荷；</li><li>提升编码的能力；</li></ul><p><strong>前端性能优化都有什么？</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105542-6d141ec1-7eaf-4ab8-8de3-52a6c6ee9ba9.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105542-6d141ec1-7eaf-4ab8-8de3-52a6c6ee9ba9.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="MUaAD"></a></p><h2 id="15-前端低代码平台搭建（建设中）"><a href="#15-前端低代码平台搭建（建设中）" class="headerlink" title="15. 前端低代码平台搭建（建设中）"></a>15. 前端低代码平台搭建（建设中）</h2><p>维基百科定义：低代码开发平台（LCDP） 本身也是一种软件，它为开发者提供了一个创建应用软件的开发环境；与传统编写代码的 IDE 不同，低代码开发平台提供更易用的可视化 IDE。<br />简单来讲，低代码（Low Code）就是一种可视化搭建系统，从字面意思来讲，一是可视化；二是少写代码。<br />无代码（No Code） 同样从字面上来理解，一是可视化，二是不写代码。<br /><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105642-c5437ded-0deb-4a53-a281-4bbf3a0fa599.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105642-c5437ded-0deb-4a53-a281-4bbf3a0fa599.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>前端低代码平台的意义：</strong></p><ul><li><strong>降低开发成本；</strong></li><li><strong>所见即所得；</strong></li><li><strong>一站式研发；</strong></li><li><strong>技术收敛；</strong></li><li><strong>专业门槛低；</strong></li><li><strong>对新人友好，上手快；</strong></li></ul><p>注意：<br />低代码平台一般较针对于一些业务使用率较大且多是 ToB 的平台，所以判断当前系统是否需要使用低代码平台，建议在有大量业务的支撑前提下，否则得不偿失；<br />用新技术，更多的不是因为先进，而是适合。<br><a name="A5dpY"></a></p><h2 id="16-微前端（Micro-App）"><a href="#16-微前端（Micro-App）" class="headerlink" title="16. 微前端（Micro App）"></a>16. 微前端（Micro App）</h2><p>微前端（Micro-Frontends） 并没有定义框架或 API，它其实是一个类似 微服务架构 的概念；将 微服务 的概念扩展到了前端世界；<br />说微服务可能有些前端同学会感觉陌生，以咱们前端的角度一句话概括就是： 将您的大型前端应用拆分为多个小型前端应用，这样每个小型前端应用都有自己的仓库，可以专注于单一的某个功能；<br />需要强调的是，尽管我们将前端应用拆分为多个项目，但它们最终还是会被集成到一个单页前端应用程序中；因此，通过使用微前端架构，您不会在用户体验上有任何损失，只会有过之而无不及；<br /><strong>场景一：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105710-811e06bd-d9a4-46d2-8b21-60123228e6e4.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105710-811e06bd-d9a4-46d2-8b21-60123228e6e4.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br /><strong>为什么要用微前端：</strong></p><ul><li>技术上的灵活选择；</li><li>更快的且独立的部署；</li><li>团队代码的相互隔离；</li><li>并行开发和团队的自治；</li><li>项目的增量升级；</li></ul><p><strong>微前端的价值：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105978-9c61f61b-26cb-474e-a3fd-7187874549e7.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105978-9c61f61b-26cb-474e-a3fd-7187874549e7.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><strong>》</strong><br><a name="CHHyo"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于前端基建，在每个公司基建部分都会有所差异，有纯自动化一条龙的，有半自动化的等等；<br />但是如果我们细心的会发现，在几乎所有大中厂中，基建部分都不会少了 前端规范、前端文档、前端脚手架、前端组件库、前端工具库，所以如果实在是公司资源与业务限制，这几个还是值得去一探究竟的。<br />其实很多公司基建都不是一触而蹴的，基本上都是在常年累月的业务当中去 发现问题，定位问题，最后解决问题，然后在这个过程当中自然而然的沉淀出前端各个面向的基础设施，团队成员也会在这个过程当中找到适合自己的前端领域，并且深耕下去。<br />该系列会是一个持续更新系列，关于 前端基建，笔者主要会从如下图几个方面讲解，如果您想第一时间看到我的更新文章，可以<a href="https://juejin.cn/user/2305054774145918/columns">关注我</a>和我的《<a href="https://juejin.cn/column/7139087916306792462">前端要搞基建</a>》专栏<br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105961-c45c173c-41ce-4af5-a4d6-9494fb10a98c.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2023/webp/300943/1675157105961-c45c173c-41ce-4af5-a4d6-9494fb10a98c.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="wOatq"></a></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compatible </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>条件语句的优化</title>
      <link href="/2022/10/19/frontend/js/skill/tiao-jian-yu-ju-de-you-hua/"/>
      <url>/2022/10/19/frontend/js/skill/tiao-jian-yu-ju-de-you-hua/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>在日常的开发中，我们经常会编写一些条件语句，过多的 if…else会导致代码难以理解和维护，今天来分享几个优化条件语句的小技巧！</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1656768200664-7732e949-019b-42ac-b730-8d256e68053d.png?x-oss-process=image/resize,w_720,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1656768200664-7732e949-019b-42ac-b730-8d256e68053d.png?x-oss-process=image/resize,w_720,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="nvHwa"></a></p><h2 id="1-Array-includes"><a href="#1-Array-includes" class="headerlink" title="1. Array.includes"></a><br />1. Array.includes</h2><p>来看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">animal</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (animal == <span class="string">&#x27;lion&#x27;</span> || animal == <span class="string">&#x27;dog&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;dog&#x27;</span>);</span><br></pre></td></tr></table></figure><p><br />在test方法中包含一个 if 语句，用来判断传入的参数animal是不是lion或者dog。这么写从语法上是没问题的，但是如果 if 的判断条件中不只有两个动物，而是有四只动物。如果继续使用 || 与运算符来写的话，代码就会很难维护并且看起来非常不优雅：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (animal == <span class="string">&#x27;lion&#x27;</span> || animal == <span class="string">&#x27;dog&#x27;</span> || animal == <span class="string">&#x27;cow&#x27;</span> || animal == <span class="string">&#x27;cat&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />对于这种需要对同一个变量进行多次判断的条件语句，可以使用数组的<code>includes()</code>方法来优化，该方法可以用于确定数组中是否存在指定元素，如果存在指定的元素，就会返回 <code>true</code>，如果不存在就会返回 <code>false</code>。使用 <code>includes() </code>来修改写上面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([<span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;cow&#x27;</span>, <span class="string">&#x27;lion&#x27;</span>].<span class="title function_">includes</span>(animal)) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />这样代码看起来就简洁了很多，并且如果想继续增加其他的动物，只需在数组中继续增加元素即可。</p><p><a name="jodGR"></a></p><h2 id="2-Array-every"><a href="#2-Array-every" class="headerlink" title="2. Array.every"></a>2. Array.every</h2><p>来看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cars = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;car1&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;car2&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;car3&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;purple&#x27;</span> &#125;</span><br><span class="line">];</span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">cars</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> isAllblue = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> cars) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAllblue) <span class="keyword">break</span>;</span><br><span class="line">        isAllblue = (c.<span class="property">color</span> == <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> isAllblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(cars);</span><br></pre></td></tr></table></figure><p><br />JavaScript 中的数组提供了<code>every()</code>方法，该方法用于检查数组中所有元素是否满足给定条件。当每个数组元素都满足给定条件时会返回 <code>true</code>，否则会返回<code>false</code>。可以使用该方法来优化上面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cars = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;car1&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;car2&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;car3&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;purple&#x27;</span> &#125;</span><br><span class="line">];</span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">cars</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> cars.<span class="title function_">every</span>(<span class="function"><span class="params">c</span> =&gt;</span> c.<span class="property">color</span> == <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(cars);</span><br></pre></td></tr></table></figure><p><a name="bHb3k"></a></p><h2 id="3-尽早-return"><a href="#3-尽早-return" class="headerlink" title="3. 尽早 return"></a>3. 尽早 return</h2><p>在 JavaScript 中，尽早 <code>return</code>是一种将函数体减少<code>else</code>语句的简单方法。来看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">fruit, quantity</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> redFruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;strawberry&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;cranberries&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fruit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (redFruits.<span class="title function_">includes</span>(fruit)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (quantity &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;big quantity&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;No fruit!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="literal">null</span>); <span class="comment">// error: No fruits</span></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;apple&#x27;</span>); <span class="comment">// red</span></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;apple&#x27;</span>, <span class="number">20</span>); <span class="comment">// red, big quantity</span></span><br></pre></td></tr></table></figure><p>来使用这种模式来优化上面的代码，可以在无效条件时尽早返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">fruit, quantity</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> redFruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;strawberry&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;cranberries&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!fruit) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;No fruit!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (redFruits.<span class="title function_">includes</span>(fruit)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (quantity &gt; <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;big quantity&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以进一步优化，如果 redFruits 中不包含fruit，就提前返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">fruit, quantity</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> redFruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;strawberry&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;cranberries&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!fruit) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;No fruit!&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!redFruits.<span class="title function_">includes</span>(fruit)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (quantity &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;big quantity&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />可以看到，使用这种模式可以消除不必要的<code>else</code>语句，使得函数更加清晰和简洁。</p><p><a name="qChhR"></a></p><h2 id="4-三元运算符"><a href="#4-三元运算符" class="headerlink" title="4. 三元运算符"></a>4. 三元运算符</h2><p>对于上面例子中的函数，可以使用 JavaScript 的三元运算符来重构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">IsRed</span>(<span class="params">someObject</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> someObject !== <span class="string">&#x27;object&#x27;</span> || someObject.<span class="property">color</span> !== <span class="string">&#x27;Red&#x27;</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />对于上面的三元表达式，还可以进行简化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">IsRed</span>(<span class="params">someObject</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(<span class="keyword">typeof</span> someObject !== <span class="string">&#x27;object&#x27;</span> || someObject.<span class="property">color</span> !== <span class="string">&#x27;Red&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />对于这种<code>if...else</code>块中都分别只有一个表达式的情况，就可以使用三元表达式来简化<code>if...else</code>语句。</p><p><a name="k49Zr"></a></p><h2 id="5-switch…case"><a href="#5-switch…case" class="headerlink" title="5. switch…case"></a>5. switch…case</h2><p>来看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printCars</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (color === <span class="string">&#x27;red&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;Rcar1&#x27;</span>, <span class="string">&#x27;Rcar2&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (color === <span class="string">&#x27;blue&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;Bcar1&#x27;</span>, <span class="string">&#x27;Bcar2&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (color === <span class="string">&#x27;purple&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;Pcar1&#x27;</span>, <span class="string">&#x27;Pcar2&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />对于这种if的判断条件中都是针对一个变量进行判断的情况，可以使用<code>switch...case</code>来简化：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printCars</span>(<span class="params">color</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;red&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;Rcar1&#x27;</span>, <span class="string">&#x27;Rcar2&#x27;</span>];</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;blue&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;Bcar1&#x27;</span>, <span class="string">&#x27;Bcar2&#x27;</span>];</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;purple&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">&#x27;Pcar1&#x27;</span>, <span class="string">&#x27;Pcar2&#x27;</span>];</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="BYUiF"></a></p><h2 id="6-Map-x2F-Object"><a href="#6-Map-x2F-Object" class="headerlink" title="6. Map&#x2F;Object"></a>6. Map&#x2F;Object</h2><p>对于上面的代码，可以使用对象来继续优化：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> carColor = &#123;</span><br><span class="line">    <span class="attr">red</span>: [<span class="string">&#x27;Rcar1&#x27;</span>, <span class="string">&#x27;Rcar2&#x27;</span>],</span><br><span class="line">    <span class="attr">blue</span>: [<span class="string">&#x27;Bcar1&#x27;</span>, <span class="string">&#x27;Bcar2&#x27;</span>],</span><br><span class="line">    <span class="attr">purple</span>: [<span class="string">&#x27;Pcar1&#x27;</span>, <span class="string">&#x27;Pcar2&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printcars</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> carColor[color] || [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">printcars</span>());       <span class="comment">// []</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">printcars</span>(<span class="string">&#x27;red&#x27;</span>));  <span class="comment">// [&#x27;Rcar1&#x27;，&#x27;Rcar2&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">printcars</span>(<span class="string">&#x27;blue&#x27;</span>)); <span class="comment">// [&#x27;Bcar1&#x27;，&#x27;Bcar2&#x27;]</span></span><br></pre></td></tr></table></figure><p><br />也可以使用 Map 来实现相同的结果：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> carColor = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    .<span class="title function_">set</span>(<span class="string">&#x27;red&#x27;</span>, [<span class="string">&#x27;Rcar1&#x27;</span>, <span class="string">&#x27;Rcar2&#x27;</span>])</span><br><span class="line">    .<span class="title function_">set</span>(<span class="string">&#x27;blue&#x27;</span>, [<span class="string">&#x27;Bcar1&#x27;</span>, <span class="string">&#x27;Bcar2&#x27;</span>])</span><br><span class="line">    .<span class="title function_">set</span>(<span class="string">&#x27;purple&#x27;</span>, [<span class="string">&#x27;Pcar1&#x27;</span>, <span class="string">&#x27;Pcar2&#x27;</span>]);</span><br><span class="line">  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printcars</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> carColor.<span class="title function_">get</span>(color) || [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">printcars</span>());       <span class="comment">// []</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">printcars</span>(<span class="string">&#x27;red&#x27;</span>));  <span class="comment">// [&#x27;Rcar1&#x27;，&#x27;Rcar2&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">printcars</span>(<span class="string">&#x27;blue&#x27;</span>)); <span class="comment">// [&#x27;Bcar1&#x27;，&#x27;Bcar2&#x27;]</span></span><br></pre></td></tr></table></figure><p><a name="NtN8P"></a></p><h2 id="7-默认函数参数和解构"><a href="#7-默认函数参数和解构" class="headerlink" title="7. 默认函数参数和解构"></a>7. 默认函数参数和解构</h2><p>来看下面的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">flower, quantity</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!flower) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> num = quantity || <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;num&#125;</span>朵<span class="subst">$&#123;flower&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="title function_">check</span>(<span class="string">&#x27;玫瑰&#x27;</span>);    <span class="comment">// 1朵玫瑰</span></span><br><span class="line"><span class="title function_">check</span>(<span class="string">&#x27;茉莉&#x27;</span>, <span class="number">2</span>); <span class="comment">// 2朵茉莉</span></span><br></pre></td></tr></table></figure><p><br />可以使用函数默认参数来简化上面的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">flower, quantity = <span class="number">1</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!flower) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;quantity&#125;</span>朵<span class="subst">$&#123;flower&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">check</span>(<span class="string">&#x27;玫瑰&#x27;</span>);    <span class="comment">// 1朵玫瑰</span></span><br><span class="line"><span class="title function_">check</span>(<span class="string">&#x27;茉莉&#x27;</span>, <span class="number">2</span>); <span class="comment">// 2朵茉莉</span></span><br></pre></td></tr></table></figure><p><br />那如果<code>flower</code>参数是一个对象怎么办呢？来看下面的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">flower</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (flower &amp;&amp; flower.<span class="property">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(flower.<span class="property">name</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;unknown&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">check</span>(<span class="literal">undefined</span>);  <span class="comment">// unknown</span></span><br><span class="line"><span class="title function_">check</span>(&#123;&#125;);  <span class="comment">// unknown</span></span><br></pre></td></tr></table></figure><p><br />可以从对象中解构需要的属性：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">&#123;name&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="property">log</span> (name || <span class="string">&#x27;unknown&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="title function_">check</span>(<span class="literal">undefined</span>);  <span class="comment">// unknown</span></span><br><span class="line"><span class="title function_">check</span>(&#123;&#125;);  <span class="comment">// unknown</span></span><br><span class="line"><span class="title function_">check</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;玫瑰&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125;);  <span class="comment">// 玫瑰</span></span><br></pre></td></tr></table></figure><p><br />在函数中需要<code>flower</code>对象中的<code>name</code>属性，可以使用<code>&#123;name&#125;</code>来解构该参数。除此之外，还是用<code>&#123;&#125;</code>来作为参数的默认值，这样在<code>check(undefined)</code>时，也就是参数不是对象时，参数默认为一个空对象，否则就会报错，因为<code>undefined</code>中没有<code>name</code>属性。</p><p><a name="wmCKq"></a></p><h2 id="8-逻辑与运算符"><a href="#8-逻辑与运算符" class="headerlink" title="8. 逻辑与运算符"></a>8. 逻辑与运算符</h2><p>来看下面的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &lt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">100</span> &amp;&amp; c === <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br />对于逻辑与运算符，其左侧的条件如果为<code>false</code>，就会直接发生短路，不再继续往后执行；如果左侧的条件为<code>true</code>，就会返回其右侧的计算结果。所以，对于这种 <code>if</code>中只有一行表达式的情况，可以使用逻辑与运算符来简化，其中左侧为判断条件，右侧是要执行的逻辑：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a &lt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">100</span> &amp;&amp; c === <span class="number">10</span>) &amp;&amp; <span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><p><br /><strong>参考：</strong><br />1<a href="https://www.digitalocean.com/community/posts/5-tips-to-write-better-conditionals-in-javascript">https://www.digitalocean.com/community/posts/5-tips-to-write-better-conditionals-in-javascript</a><br />2<a href="https://www.geeksforgeeks.org/tips-for-writing-better-conditionals-in-javascript/">https://www.geeksforgeeks.org/tips-for-writing-better-conditionals-in-javascript/</a></p><br /> ]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拖拽排序库</title>
      <link href="/2022/08/16/frontend/collection/tuo-zhuai-pai-xu-ku/"/>
      <url>/2022/08/16/frontend/collection/tuo-zhuai-pai-xu-ku/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="PhFl1"></a></p><h1 id="1-React-Beautiful-Dnd"><a href="#1-React-Beautiful-Dnd" class="headerlink" title="1. React Beautiful Dnd"></a>1. React Beautiful Dnd</h1><p>react-beautiful-dnd 是一款美观且简单易用的 React 列表拖拽库。其动画效果自然，性能优秀，简洁而强大的 API，易于上手，与标准浏览器的互动性非常好。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1658845658074-c11cf3bf-38e6-40be-a4b4-445c8898d079.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1658845658074-c11cf3bf-38e6-40be-a4b4-445c8898d079.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="NpcJr"></a></p><h1 id="2-Sortable"><a href="#2-Sortable" class="headerlink" title="2. Sortable"></a>2. Sortable</h1><p>Sortable 是一个 JavaScript 拖拽库，用于在现代浏览器和触摸设备上对拖放列表进行重新排序。支持 Meteor、AngularJS、React、Polymer、Vue、Ember、Knockout 和任何 CSS 库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658845354776-d9e504e8-1a16-4a69-b5aa-1d7b458a12be.png?x-oss-process=image/resize,w_778,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658845354776-d9e504e8-1a16-4a69-b5aa-1d7b458a12be.png?x-oss-process=image/resize,w_778,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="SdSue"></a></p><h1 id="3-Dragula"><a href="#3-Dragula" class="headerlink" title="3. Dragula"></a>3. Dragula</h1><p>Dragula 是一个 JavaScript 库，实现了网页上的拖放功能。提供 JavaScript、AngularJS 和 React 版本。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658846116809-5f5ed7f0-2b78-4108-a99c-7f22dc5a6123.png?x-oss-process=image/resize,w_786,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658846116809-5f5ed7f0-2b78-4108-a99c-7f22dc5a6123.png?x-oss-process=image/resize,w_786,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="KMplr"></a></p><h1 id="4-React-DnD"><a href="#4-React-DnD" class="headerlink" title="4. React DnD"></a>4. React DnD</h1><p>React DnD是 React 和 Redux 核心作者 Dan Abramov 创造的一组React 高阶组件，可帮助我们构建复杂的拖放界面，同时保持组件解耦。它可以在应用程序的不同部分之间通过拖动传输数据，并且组件会更改其外观和应用状态以响应拖放事件。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658844194608-80d5a46d-2ef5-4f67-9db6-73638e8165a8.png?x-oss-process=image/resize,w_949,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658844194608-80d5a46d-2ef5-4f67-9db6-73638e8165a8.png?x-oss-process=image/resize,w_949,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="cSH6e"></a></p><h1 id="5-Vue-Draggable"><a href="#5-Vue-Draggable" class="headerlink" title="5. Vue.Draggable"></a>5. Vue.Draggable</h1><p>Vue.Draggable 是基于 Sortable.js 的 Vue 拖放组件。它允许拖放和视图模型数组同步，基于并提供 Sortable.js 的所有功能。该库适用于Vue 2，如果想在 Vue 3 中使用该库，可以访问：<a href="https://github.com/SortableJS/vue.draggable.next">https://github.com/SortableJS/vue.draggable.next</a>。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1658845095630-ba6a45c9-fe9b-45cd-8ccf-ea7618a3f069.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1658845095630-ba6a45c9-fe9b-45cd-8ccf-ea7618a3f069.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="wCevg"></a></p><h1 id="6-interact-js"><a href="#6-interact-js" class="headerlink" title="6. interact.js"></a>6. interact.js</h1><p>interact.js 是一个适用于现代浏览器的 JavaScript 拖放库，支持调整大小和多点触控手势，具有惯性和捕捉功能。为了尽可能多地提供控制，它尝试提供一个简单、灵活的API，该 API 提供移动元素所需的所有拖拽API。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658845930134-ecc4b6d9-9195-497c-8a66-a503c4aa8d9f.png?x-oss-process=image/resize,w_933,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658845930134-ecc4b6d9-9195-497c-8a66-a503c4aa8d9f.png?x-oss-process=image/resize,w_933,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="TwrSp"></a></p><h1 id="7-React-Draggable"><a href="#7-React-Draggable" class="headerlink" title="7. React Draggable"></a>7. React Draggable</h1><p>React-Draggable 库简单易用，将 CSS 中的transform应用于 React 组件，允许我们在 UI 中拖动组件。它有不同的 props 可以让你改变组件的行为，是创建直观、用户友好界面的绝佳选择。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1658844929818-c8bf8b77-056d-4830-bb8c-36fcc966a31f.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1658844929818-c8bf8b77-056d-4830-bb8c-36fcc966a31f.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="GSj3v"></a></p><h1 id="8-React-Sortable-Tree"><a href="#8-React-Sortable-Tree" class="headerlink" title="8. React Sortable Tree"></a>8. React Sortable Tree</h1><p>React Sortable Tree 是一个用于对分层数据进行拖放式可排序表示的React组件。它支持单选多选，鼠标拖拽子集到新合集，模糊搜索等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1658846422180-4a092775-e056-4f74-a4cc-4807f0696dc7.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1658846422180-4a092775-e056-4f74-a4cc-4807f0696dc7.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><br /> ]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> 拖拽排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域的产生于解决</title>
      <link href="/2022/08/05/solution/kua-yu-de-chan-sheng-yu-jie-jue/"/>
      <url>/2022/08/05/solution/kua-yu-de-chan-sheng-yu-jie-jue/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="FoJXO"></a></p><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p><strong>跨域</strong>，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。<br /><strong>同源策略</strong>：是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。所谓的同源，指的是协议、域名、端口相同。浏览器处于安全方面的考虑，只允许本域名下的接口交互，不同源的客户端脚本，在没有明确授权的情况下，不能读写对方的资源。</p><p><a name="ThR4U"></a></p><h3 id="同源策略限制的内容"><a href="#同源策略限制的内容" class="headerlink" title="同源策略限制的内容"></a>同源策略限制的内容</h3><ul><li>Cookie , LocalStorage ,IndexedDB等存储性内容。</li><li>DOM节点</li><li>AJAX请求发送后,非同源会被浏览器拦截。<br />但是有三个标签是允许跨域加载资源:</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">XXX</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">XXX</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">XXX</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="Isv8E"></a></p><h3 id="跨域产生的原因"><a href="#跨域产生的原因" class="headerlink" title="跨域产生的原因"></a>跨域产生的原因</h3><p>浏览器遵从同源策略，限制 <code>ajax</code> 跨域的原因在于 <code>ajax</code> 网络请求是可以携带 <code>cookie</code> 的（通过设置 <code>withCredentials</code> 为 <code>true</code> ），比如用户打开了浏览器，登录了 <code>weibo.com</code> ，然后又打开了<code>baidu.com</code>，这时候百度首页内的 <code>js</code> ，向 <code>weibo.com</code> 用 <code>withCredentials</code> 为 <code>true</code> 的 <code>ajax</code> 方式提交一个 <code>post</code> 请求，是会携带浏览器和 <code>weibo.com</code> 之间的 <code>cookie</code> 的，所以浏览器就默认禁止了 <code>ajax</code> 跨域。<br />只有当 <strong>protocol（协议）、domain（域名）、port（端口）三者一致，</strong>才是同源。</p><p><a name="9QSxe"></a></p><h3 id="反向代理和正向代理"><a href="#反向代理和正向代理" class="headerlink" title="反向代理和正向代理"></a>反向代理和正向代理</h3><p><a name="ubDH4"></a></p><h4 id="反向代理-隐藏真实的服务器端"><a href="#反向代理-隐藏真实的服务器端" class="headerlink" title="反向代理:隐藏真实的服务器端"></a>反向代理:隐藏真实的服务器端</h4><p>类似场景：拨打总机号，然后一层层转接到分机<br />真实场景：访问淘宝—》反向代理服务器—》转发到真实的服务器—》返回资源给反向代理服务器—》返回给客户端<br><a name="iSzu3"></a></p><h4 id="正向代理：隐藏真实的客户端"><a href="#正向代理：隐藏真实的客户端" class="headerlink" title="正向代理：隐藏真实的客户端"></a>正向代理：隐藏真实的客户端</h4><p>类似场景：A问B借钱，B不肯，A拜托B的挚友C帮忙，C问B借到了钱，然后把钱给了A，而B并不知道实际是A借的钱<br />真实场景：客户端请求访问 facebook.com,无法访问到资源，这时借助代理，代理请求facebook的资源，然后发送给客户端，facebook.com并不知道真正的客户端是谁</p><p><a name="eJ8uM"></a></p><h2 id="跨域的解决方案"><a href="#跨域的解决方案" class="headerlink" title="跨域的解决方案"></a>跨域的解决方案</h2><p><a name="PQI7q"></a></p><h3 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h3><p><a name="7Qz7u"></a></p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Nginx 通过反向代理的方式保证当前域，能获取到静态资源和接口，不关心是怎么获取的。<br /><a href="https://www.yuque.com/snb/efe/yignkl?view=doc_embed">Nginx 从入门到实践</a><br /><a href="https://www.yuque.com/snb/efe/oz2qqg?view=doc_embed">nginx反向代理和负载均衡策略实战案例</a><br /><img src="https://cdn.nlark.com/yuque/0/2020/svg/164572/1591152392946-59e6393b-18d8-410d-8402-3e3d64406a8b.svg" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/svg/164572/1591152392946-59e6393b-18d8-410d-8402-3e3d64406a8b.svg" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="RwELo"></a></p><h4 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">  <span class="attribute">server_name</span>  www.xxx.com;</span><br><span class="line">  <span class="attribute">index</span> index.html index.htm default.html default.htm;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#ERROR-PAGE-START  错误页配置，可以注释、删除或修改</span></span><br><span class="line"> <span class="comment">#error_page 404 /www/wwwroot/index.html;</span></span><br><span class="line">  </span><br><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">    <span class="comment">#proxy_pass http://abc.xx.com;</span></span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="attribute">root</span> /www/wwwroot/proxy.test;</span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$url</span>/ /index.html = <span class="number">404</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="section">location</span><span class="regexp"> ^~</span> /api/ &#123;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Connection <span class="variable">$connection_upgrade</span>;</span><br><span class="line">    <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#持久化连接相关配置</span></span><br><span class="line">    <span class="comment">#proxy_connect_timeout 30s;</span></span><br><span class="line">    <span class="comment">#proxy_read_timeout 86400s;</span></span><br><span class="line">    <span class="comment">#proxy_send_timeout 30s;</span></span><br><span class="line">    <span class="comment">#proxy_http_version 1.1;</span></span><br><span class="line">    <span class="comment">#proxy_set_header Upgrade $http_upgrade;</span></span><br><span class="line">    <span class="comment">#proxy_set_header Connection $connection_upgrade;</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">proxy_pass</span> http://app-api;</span><br><span class="line">    <span class="attribute">proxy_intercepe_errors</span> <span class="literal">on</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="ZSWIQ"></a></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>前端代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  axios.<span class="property">defaults</span>.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br><span class="line">  getlist.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&quot;/api/list&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  login.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    axios.<span class="title function_">post</span>(<span class="string">&quot;/api/login&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>后端代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&quot;/api/list&quot;</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = &#123;</span><br><span class="line">    <span class="attr">data</span>: [&#123; <span class="attr">name</span>: <span class="string">&quot;test&quot;</span> &#125;]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&quot;/api/login&quot;</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.<span class="property">cookies</span>.<span class="title function_">set</span>(<span class="string">&quot;token&quot;</span>, token, &#123;</span><br><span class="line">    <span class="attr">expires</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(+<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">  ctx.<span class="property">body</span> = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&quot;success&quot;</span>,</span><br><span class="line">    <span class="attr">code</span>: <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="uBkSN"></a></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><a name="ONXWn"></a></p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS（cross-origin resource sharing），跨源资源共享（一般俗称『跨域请求』），跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器<strong>「不同的域、协议或端口」</strong>请求一个资源时，资源会发起一个<strong>「跨域 HTTP 请求</strong>。 <br />MDN 上的介绍 (<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)%E3%80%82">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)。</a><br />而在 cors 中会有 <strong>简单请求</strong> 和 <strong>预检请求（preflighted requests）</strong>的概念。<br /><strong>浏览器支持情况：</strong>当你使用 IE&lt;&#x3D;9, Opera&lt;12, or Firefox&lt;3.5 或者更加老的浏览器，这个时候请使用 JSONP 。</p><p><a name="WQy3Q"></a></p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>不会触发 CORS <strong>预检请求</strong>。这样的请求为“<strong>简单请求</strong>”，请注意，该术语并不属于 Fetch （其中定义了 CORS）规范。<br />若请求满足所有下述条件，则该请求可视为“<strong>简单请求</strong>”：</p><ul><li><strong>HTTP 方法</strong>只能是 GET、HEAD 或 POST；</li><li><strong>HTTP 头</strong>只能是 Accept&#x2F;Accept-Language&#x2F;Conent-Language&#x2F;Content-Type&#x2F;DPR&#x2F;Downlink&#x2F;Save-Data&#x2F;Viewport-Width&#x2F;Width；</li><li><strong>Content-Type 头</strong>只能是 text&#x2F;plain、multipart&#x2F;form-data 或 application&#x2F;x-www-form-urlencoded。</li><li>请求中的任意 <code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器；<code>XMLHttpRequestUpload</code> 对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问。</li><li>请求中没有使用 <code>ReadableStream</code> 对象。</li></ul><p><a name="Zbdfr"></a></p><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>除以上情况外的。</p><p>看上去很是复杂。那么怎么理解这些限制呢？<br />其实，<strong>简单请求就是普通 HTML Form 在不依赖脚本的情况下可以发出的请求</strong>，比如表单的 method 如果指定为 POST ，可以用 enctype 属性指定用什么方式对表单内容进行编码，合法的值就是前述这三种。<br /><strong>非简单请求就是普通 HTML Form 无法实现的请求。</strong>比如 PUT 方法、需要其他的内容编码方式、自定义头之类的。</p><p>对于服务器来说，第一，许多服务器压根没打算给跨源用。当然你不给 CORS 响应头，浏览器也不会使用响应结果，但是请求本身可能已经造成了后果。所以最好是默认禁止跨源请求。<br />第二，要回答某个请求是否接受跨源，可能涉及额外的计算逻辑。这个逻辑可能很简单，比如一律放行。也可能比较复杂，结果可能取决于哪个资源哪种操作来自哪个 origin。对浏览器来说，就是某个资源是否允许跨源这么简单；对服务器来说，计算成本却可大可小。所以我们希望最好不用每次请求都让服务器劳神计算。<br />CORS-preflight 就是这样一种机制，浏览器先单独请求一次，询问服务器某个资源是否可以跨源，如果不允许的话就不发实际的请求。注意先许可再请求等于默认禁止了跨源请求。如果允许的话，浏览器会记住，然后发实际请求，且之后每次就都直接请求而不用再询问服务器否可以跨源了。于是，服务器想支持跨源，就只要针对 preflight 进行跨源许可计算。本身真正的响应代码则完全不管这个事情。并且因为 preflight 是许可式的，也就是说如果服务器不打算接受跨源，什么事情都不用做。<br />但是这机制只能限于非简单请求。在处理简单请求的时候，如果服务器不打算接受跨源请求，不能依赖 CORS-preflight 机制。因为不通过 CORS，普通表单也能发起简单请求，所以默认禁止跨源是做不到的。<br />既然如此，简单请求发 preflight 就没有意义了，就算发了服务器也省不了后续每次的计算，反而在一开始多了一次 preflight。<br />有些人把简单请求不需要 preflight 理解为『向下兼容』。这也不能说错。但严格来说，并不是『为了向下兼容』而不能发。理论上浏览器可以区别对待表单请求和非表单请求 —— 对传统的跨源表单提交不发 preflight，从而保持兼容，只对非表单跨源请求发 preflight。<br />但这样做并没有什么好处，反而把事情搞复杂了。比如本来你可以直接用脚本发跨源普通请求，尽管（在服务器默认没有跨源处理的情况下）你无法得到响应结果，但是你的需求可能只是发送无需返回，比如打个日志。但现在如果服务器不理解 preflight 你就干不了这个事情了。<br />而且如果真的这样做，服务器就变成了默认允许跨源表单，如果想控制跨源，还是得（跟原本一样）直接在响应处理中执行跨源计算逻辑；另一方面服务器又需要增加对 preflight 请求的响应支持，执行类似的跨源计算逻辑以控制来自非表单的相同跨源请求。服务器通常没有区分表单&#x2F;非表单差异的需求，这样搞纯粹是折腾服务器端工程师。<br />所以简单请求不发 preflight 不是因为不能兼容，而是因为兼容的前提下发 preflight 对绝大多数服务器应用来说没有意义，反而把问题搞复杂了。</p><p><a name="UdvCE"></a></p><h4 id="Node-中的解决方案"><a href="#Node-中的解决方案" class="headerlink" title="Node 中的解决方案"></a>Node 中的解决方案</h4><p><a name="hIxcn"></a></p><h5 id="原生方式"><a href="#原生方式" class="headerlink" title="原生方式"></a>原生方式</h5><p>我们来看下后端部分的解决方案。<code>Node</code> 中 <code>CORS</code> 的解决代码.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, ctx.<span class="property">headers</span>.<span class="property">origin</span>);</span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">&quot;Access-Control-Request-Method&quot;</span>, <span class="string">&quot;PUT,POST,GET,DELETE,OPTIONS&quot;</span>);</span><br><span class="line">  ctx.<span class="title function_">set</span>(</span><br><span class="line">    <span class="string">&quot;Access-Control-Allow-Headers&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Origin, X-Requested-With, Content-Type, Accept, cc&quot;</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (ctx.<span class="property">method</span> === <span class="string">&quot;OPTIONS&quot;</span>) &#123;</span><br><span class="line">    ctx.<span class="property">status</span> = <span class="number">204</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="97yOf"></a></p><h5 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h5><p>为了方便也可以直接使用中间件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&quot;koa-cors&quot;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>());</span><br></pre></td></tr></table></figure><p><a name="U4oIw"></a></p><h5 id="关于-cors-的-cookie-问题"><a href="#关于-cors-的-cookie-问题" class="headerlink" title="关于 cors 的 cookie 问题"></a>关于 cors 的 cookie 问题</h5><p>想要传递 <code>cookie</code> 需要满足 3 个条件<br />1.web 请求设置<code>withCredentials</code><br />这里默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 <code>withCredentials</code> 来进行传递 <code>cookie</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生 xml 的设置方式</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// axios 设置方式</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>2.<code>Access-Control-Allow-Credentials</code> 为 <code>true</code><br />3.<code>Access-Control-Allow-Origin</code>为非 <code>*</code><br />这里请求的方式，在 <code>chrome</code> 中是能看到返回值的，但是只要不满足以上其一，浏览器会报错，获取不到返回值。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589176797624-53050b7f-68f9-4d79-b68f-70b5e2a29bfa.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589176797624-53050b7f-68f9-4d79-b68f-70b5e2a29bfa.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#x27;http://127.0.0.1:8080/api/corslist&#x27; from origin &#x27;http://127.0.0.1:8000&#x27; has been blocked by CORS policy: The value of the &#x27;Access-Control-Allow-Credentials&#x27; header in the response is &#x27;&#x27; which must be &#x27;true&#x27; when the request&#x27;s credentials mode is &#x27;include&#x27;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589176807272-38d18a37-775a-4b63-bc69-d677a0add511.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589176807272-38d18a37-775a-4b63-bc69-d677a0add511.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#x27;http://127.0.0.1:8080/api/corslist&#x27; from origin &#x27;http://127.0.0.1:8000&#x27; has been blocked by CORS policy: The value of the &#x27;Access-Control-Allow-Origin&#x27; header in the response must not be the wildcard &#x27;*&#x27; when the request&#x27;s credentials mode is &#x27;include&#x27;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589176815558-f9434297-a007-4a69-b00f-920142a35cda.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589176815558-f9434297-a007-4a69-b00f-920142a35cda.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="ljQmC"></a></p><h4 id="前端示例"><a href="#前端示例" class="headerlink" title="前端示例"></a>前端示例</h4><p>分别演示一下前端部分 <code>简单请求</code> 和 <code>非简单请求</code></p><p><a name="KzKmL"></a></p><h5 id="简单请求-1"><a href="#简单请求-1" class="headerlink" title="简单请求"></a>简单请求</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  axios.<span class="title function_">get</span>(<span class="string">&quot;http://127.0.0.1:8080/api/corslist&quot;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="jZPPo"></a></p><h5 id="非简单请求-1"><a href="#非简单请求-1" class="headerlink" title="非简单请求"></a>非简单请求</h5><p>这里我们加入了一个非集合内的 <code>header</code> 头 <code>cc</code> 来达到非简单请求的目的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  axios.<span class="title function_">get</span>(<span class="string">&quot;http://127.0.0.1:8080/api/corslist&quot;</span>, &#123; <span class="attr">header</span>: &#123; <span class="attr">cc</span>: <span class="string">&quot;xxx&quot;</span> &#125; &#125;);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589176826917-6898e954-0a04-47fe-b3d1-2cc1c5bff30b.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589176826917-6898e954-0a04-47fe-b3d1-2cc1c5bff30b.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="C1AVM"></a></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>1、 在新版的 chrome 中，如果你发送了复杂请求，你却看不到 <code>options</code> 请求。可以在这里设置 <code>chrome://flags/#out-of-blink-cors</code> 设置成 <code>disbale</code> ，重启浏览器。对于非简单请求就能看到 <code>options</code> 请求了。<br />2、 一般情况下后端接口是不会开启这个跨域头的，除非是一些与用户无关的不太重要的接口。</p><p><a name="SGGpx"></a></p><h3 id="Node-正向代理"><a href="#Node-正向代理" class="headerlink" title="Node 正向代理"></a>Node 正向代理</h3><p>代理的思路为，利用服务端请求不会跨域的特性，让接口和当前站点同域。<br /><strong>代理前</strong><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589176895466-02944916-21d4-4954-9611-3e7d1a11814d.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589176895466-02944916-21d4-4954-9611-3e7d1a11814d.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />这样，所有的资源以及请求都在一个域名下了。<br><a name="wOcP4"></a></p><h4 id="cli-工具中的代理"><a href="#cli-工具中的代理" class="headerlink" title="cli 工具中的代理"></a>cli 工具中的代理</h4><p><a name="LoJVV"></a></p><h5 id="1-Webpack-4-x"><a href="#1-Webpack-4-x" class="headerlink" title="1) Webpack (4.x)"></a>1) Webpack (4.x)</h5><p>在<code>webpack</code>中可以配置<code>proxy</code>来快速获得接口代理的能力。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="string">&quot;./index.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;dist&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">port</span>: <span class="number">8000</span>,</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&quot;/api&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&quot;http://localhost:8080&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;index.html&quot;</span>,</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&quot;webpack.html&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前端接口请求省略。<br />脚手架中都会有关于代理的详细配置，这里省略。这些配置都是有着共同的底层包 <code>http-proxy-middleware</code> ，里面需要用到的各种 <code>websocket</code> ，<code>rewrite</code> 等功能，直接看这个库的配置就可以了。<br><a name="E68in"></a></p><h4 id="使用自己的代理工具"><a href="#使用自己的代理工具" class="headerlink" title="使用自己的代理工具"></a>使用自己的代理工具</h4><p><strong>cors-anywhere</strong><br /><strong>服务端：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Listen on a specific host via the HOST environment variable</span></span><br><span class="line"><span class="keyword">var</span> host = process.<span class="property">env</span>.<span class="property">HOST</span> || <span class="string">&quot;0.0.0.0&quot;</span>;</span><br><span class="line"><span class="comment">// Listen on a specific port via the PORT environment variable</span></span><br><span class="line"><span class="keyword">var</span> port = process.<span class="property">env</span>.<span class="property">PORT</span> || <span class="number">7777</span>;</span><br><span class="line"><span class="keyword">var</span> cors_proxy = <span class="built_in">require</span>(<span class="string">&quot;cors-anywhere&quot;</span>);</span><br><span class="line">cors_proxy</span><br><span class="line">  .<span class="title function_">createServer</span>(&#123;</span><br><span class="line">    <span class="attr">originWhitelist</span>: [], <span class="comment">// Allow all origins</span></span><br><span class="line">    <span class="attr">requireHeader</span>: [<span class="string">&quot;origin&quot;</span>, <span class="string">&quot;x-requested-with&quot;</span>],</span><br><span class="line">    <span class="attr">removeHeaders</span>: [<span class="string">&quot;cookie&quot;</span>, <span class="string">&quot;cookie2&quot;</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">listen</span>(port, host, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Running CORS Anywhere on &quot;</span> + host + <span class="string">&quot;:&quot;</span> + port);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><strong>前端代码：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">  axios.<span class="property">defaults</span>.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">  getlist.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    axios</span></span><br><span class="line"><span class="language-javascript">      .<span class="title function_">get</span>(<span class="string">&quot;http://127.0.0.1:7777/http://127.0.0.1:8080/api/corslist&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">      .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript">  login.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    axios.<span class="title function_">post</span>(<span class="string">&quot;http://127.0.0.1:7777/http://127.0.0.1:8080/api/login&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>效果展示：</strong><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589184916263-4d343acc-4804-45b0-9e9d-296d430341f6.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589184916263-4d343acc-4804-45b0-9e9d-296d430341f6.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br><a name="c-charles"></a></p><h4 id="charles"><a href="#charles" class="headerlink" title="charles"></a>charles</h4><p><a name="lWcvV"></a></p><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>这是一个测试、开发的神器。<a href="https://juejin.im/post/5b8350b96fb9a019d9246c4c">介绍与使用</a><br />利用 charles 进行跨域，本质就是请求的拦截与代理。<br />在 <code>tools/map remote</code> 中设置代理<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589185019849-762cb0a5-1010-4925-8a33-216d57bc0ac1.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589185019849-762cb0a5-1010-4925-8a33-216d57bc0ac1.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="kzdel"></a></p><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><p><a name="rdguw"></a></p><h5 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;getlist&quot;</span>&gt;</span>获取列表<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;login&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/axios/0.19.2/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  axios.<span class="property">defaults</span>.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">  getlist.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    axios.<span class="title function_">get</span>(<span class="string">&quot;/api/corslist&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript">  login.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    axios.<span class="title function_">post</span>(<span class="string">&quot;/api/login&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="pdvPw"></a></p><h5 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">router.get(&quot;/api/corslist&quot;, async ctx =&gt; &#123;</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    data: [&#123; name: &quot;秋风的笔记&quot; &#125;]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">router.post(&quot;/api/login&quot;, async ctx =&gt; &#123;</span><br><span class="line">  ctx.cookies.set(&quot;token&quot;, token, &#123;</span><br><span class="line">    expires: new Date(+new Date() + 1000 * 60 * 60 * 24 * 7)</span><br><span class="line">  &#125;);</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    msg: &quot;成功&quot;,</span><br><span class="line">    code: 0</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="sNw7N"></a></p><h5 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h5><p>访问 <a href="http://localhost:8000/charles">http://localhost:8000/charles</a><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589185019811-c9644b6e-6fab-4115-bc8a-f46fca8dddc0.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589185019811-c9644b6e-6fab-4115-bc8a-f46fca8dddc0.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="KYmI3"></a></p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p><code>JSONP</code> 主要就是利用了 <code>script</code> 标签没有跨域限制的这个特性来完成的。<br><a name="mLEgV"></a></p><h4 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h4><p>仅支持 GET 方法，如果想使用完整的 REST 接口，请使用 CORS 或者其他代理方式。<br><a name="redp6"></a></p><h4 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h4><p>1.前端定义解析函数（例如 jsonpCallback&#x3D;function(){….}）<br />2.通过 params 形式包装请求参数，并且声明执行函数(例如 cb&#x3D;jsonpCallback)<br />3.后端获取前端声明的执行函数（jsonpCallback），并以带上参数并调用执行函数的方式传递给前端。<br><a name="oM4cK"></a></p><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>后端实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.<span class="property">path</span> === <span class="string">&quot;/api/jsonp&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; cb, msg &#125; = ctx.<span class="property">query</span>;</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">`<span class="subst">$&#123;cb&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(&#123; msg &#125;)&#125;</span>)`</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><p>普通 js 示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">jsonpCallback</span> = <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">src</span>=<span class="string">&quot;http://localhost:8080/api/jsonp?msg=hello&amp;cb=jsonpCallback&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>JQuery Ajax 示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.bootcss.com/jquery/3.5.0/jquery.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  $.<span class="title function_">ajax</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">url</span>: <span class="string">&quot;http://localhost:8080/api/jsonp&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">dataType</span>: <span class="string">&quot;jsonp&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">msg</span>: <span class="string">&quot;hello&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">jsonp</span>: <span class="string">&quot;cb&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><a name="aRz5M"></a></p><h4 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h4><p>其实这就是 js 的魔法<br />我们先来看最简单的 js 调用。嗯，很自然的调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">jsonpCallback</span> = <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  jsonpCallback(&#123; a: 1 &#125;);</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们稍稍改造一下，外链的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">jsonpCallback</span> = <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:8080/api/a.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">// http://localhost:8080/api/a.js jsonpCallback(&#123;a:1&#125;);</span></span><br></pre></td></tr></table></figure><p>我们再改造一下，我们把这个外链的 js 就当做是一个动态的接口，因为本身资源和接口一样，是一个请求，也包含各种参数，也可以动态化返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">jsonpCallback</span> = <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:8080/api/a.js?a=123&amp;cb=sonpCallback&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">// http://localhost:8080/api/a.js jsonpCallback(&#123;a:123&#125;);</span></span><br></pre></td></tr></table></figure><p>你仔细品，细细品，是不是 jsonp 有的优势就是 script 加载 js 的优势，加载的方式只不过换了一种说法。这也告诉我们一个道理，很多东西并没有那么神奇，是在你所学的知识范围内。就好比，桃树和柳树，如果你把他们当成很大跨度的东西去记忆理解，那么世上这么多树，你真的要累死了，你把他们都当成是树，哦吼？你会突然发现，你对世界上所有的树都有所了解，他们都会长叶子，光合作用….当然也有个例，但是你只需要去记忆这些细微的差别，抓住主干。。。嗯，反正就这么个道理。</p><p><a name="zCLt6"></a></p><h3 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h3><p><a href="http://dev.w3.org/html5/websockets/">WebSocket</a> 规范定义了一种 API，可在网络浏览器和服务器之间建立“套接字”连接。简单地说：客户端和服务器之间存在持久的连接，而且双方都可以随时开始发送数据。详细教程可以看 <a href="https://www.html5rocks.com/zh/tutorials/websockets/basics/">https://www.html5rocks.com/zh/tutorials/websockets/basics/</a><br />这种方式本质没有使用了 HTTP 的响应头, 因此也没有跨域的限制，没有什么过多的解释直接上代码吧。<br />前端部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">let</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:8080&quot;</span>);</span><br><span class="line">  socket.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    socket.<span class="title function_">send</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  socket.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>后端部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const WebSocket = require(&quot;ws&quot;);</span><br><span class="line">const server = new WebSocket.Server(&#123; port: 8080 &#125;);</span><br><span class="line">server.on(&quot;connection&quot;, function(socket) &#123;</span><br><span class="line">  socket.on(&quot;message&quot;, function(data) &#123;</span><br><span class="line">    socket.send(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="8tAHi"></a></p><h3 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h3><p><strong>window.postMessage()</strong> 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 (两个页面的模数 <code>[Document.domain](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/domain)</code>设置为相同的值) 时，这两个脚本才能相互通信。<strong>window.postMessage()</strong> 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。<br><a name="K6jTM"></a></p><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>1.页面和其打开的新窗口的数据传递<br />2.多窗口之间消息传递<br />3.页面与嵌套的 iframe 消息传递<br><a name="tw30z"></a></p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>详细用法看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage</a><br /><code>otherWindow.postMessage(message, targetOrigin, [transfer]);</code></p><ul><li>otherWindow: 其他窗口的一个引用，比如 iframe 的 contentWindow 属性、执行<a href="https://developer.mozilla.org/en-US/docs/DOM/window.open">window.open</a>返回的窗口对象、或者是命名过或数值索引的<a href="https://developer.mozilla.org/en-US/docs/DOM/window.frames">window.frames</a>。</li><li>message: 将要发送到其他 window 的数据。</li><li>targetOrigin: 通过窗口的 origin 属性来指定哪些窗口能接收到消息事件.</li><li>transfer(可选) : 是一串和 message 同时传递的 <code>[Transferable](https://developer.mozilla.org/zh-CN/docs/Web/API/Transferable)</code> 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权<br><a name="HkkTp"></a></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;http://localhost:8080&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onload</span>=<span class="string">&quot;load()&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">load</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    iframe.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(<span class="string">&quot;秋风的笔记&quot;</span>, <span class="string">&quot;http://localhost:8080&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onmessage</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>another.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onmessage</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>); <span class="comment">// 秋风的笔记</span></span></span><br><span class="line"><span class="language-javascript">    e.<span class="property">source</span>.<span class="title function_">postMessage</span>(e.<span class="property">data</span>, e.<span class="property">origin</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="irBuk"></a></p><h3 id="document-domain-Iframe"><a href="#document-domain-Iframe" class="headerlink" title="document.domain + Iframe"></a>document.domain + Iframe</h3><p>从第 7 种到第 9 种方式，我觉得别人的写的已经很好了，为了完整性，我就拿别人的了。如有雷同….（不对，就是雷同….）不要说不出来。<br /><strong>该方式只能用于二级域名相同的情况下，比如</strong><code>**a.test.com**</code><strong>和</strong><code>**b.test.com**</code><strong>适用于该方式</strong>。 只需要给页面添加 <code>document.domain =&#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.   baidu.  com     .</span><br><span class="line">三级域  二级域   顶级域   根域</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// a.test.com</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  helloa</span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">&quot;http://b.test.com/b.html&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">onload</span>=<span class="string">&quot;load()&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">&quot;frame&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;test.com&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">load</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(frame.<span class="property">contentWindow</span>.<span class="property">a</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// b.test.com</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  hellob</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;test.com&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> a = <span class="number">100</span>;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="za19h"></a></p><h3 id="window-location-hash-Iframe"><a href="#window-location-hash-Iframe" class="headerlink" title="window.location.hash + Iframe"></a>window.location.hash + Iframe</h3><p><a name="C4kD7"></a></p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>原理就是通过 url 带 hash ，通过一个非跨域的中间页面来传递数据。<br><a name="U752Q"></a></p><h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h4><p>一开始 a.html 给 c.html 传一个 hash 值，然后 c.html 收到 hash 值后，再把 hash 值传递给 b.html，最后 b.html 将结果放到 a.html 的 hash 值中。 同样的，a.html 和 b.htm l 是同域的，都是 <code>http://localhost:8000</code>，而 c.html 是<code>http://localhost:8080</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// a.html</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:8080/hash/c.html#name1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">hash</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onhashchange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">hash</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// b.html</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">parent</span>.<span class="property">parent</span>.<span class="property">location</span>.<span class="property">hash</span> = location.<span class="property">hash</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// c.html</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">hash</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;iframe&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  iframe.<span class="property">src</span> = <span class="string">&quot;http://localhost:8000/hash/b.html#name2&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a name="uIldR"></a></p><h3 id="window-name-Iframe"><a href="#window-name-Iframe" class="headerlink" title="window.name + Iframe"></a>window.name + Iframe</h3><p>window 对象的 name 属性是一个很特别的属性，当该 window 的 location 变化，然后重新加载，它的 name 属性可以依然保持不变。<br />其中 a.html 和 b.html 是同域的，都是<code>http://localhost:8000</code>，而 c.html 是<code>http://localhost:8080</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// a.html</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;http://localhost:8080/name/c.html&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onload</span>=<span class="string">&quot;load()&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> first = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">load</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (first) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span></span><br><span class="line"><span class="language-javascript">      iframe.<span class="property">src</span> = <span class="string">&quot;http://localhost:8000/name/b.html&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">      first = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(iframe.<span class="property">contentWindow</span>.<span class="property">name</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>b.html 为中间代理页，与 a.html 同域，内容为空。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// b.html</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// c.html</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&quot;秋风的笔记&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><p><a name="U3CTa"></a></p><h3 id="浏览器开启跨域（解决提出问题的人）"><a href="#浏览器开启跨域（解决提出问题的人）" class="headerlink" title="浏览器开启跨域（解决提出问题的人）"></a>浏览器开启跨域（解决提出问题的人）</h3><p><strong>非特殊必要情况，不建议使用。</strong><br><a name="windows"></a></p><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">找到你安装的目录</span><br><span class="line">.\Google\Chrome\Application\chrome.exe --disable-web-security --user-data-dir=xxxx</span><br></pre></td></tr></table></figure><p><a name="mac"></a></p><h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h4><p><code>~/Downloads/chrome-data</code> 这个目录可以自定义.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Google\ Chrome\ Canary.app/Contents/MacOS/Google\ Chrome\ Canary  --disable-web-security --user-data-dir=~/Downloads/chrome-data</span><br></pre></td></tr></table></figure><p><a name="pQ3iJ"></a></p><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><p><a name="l0jyI"></a></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p> <a href="https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650590313&idx=1&sn=e3fb1d08745d09afa06ffa7db44910d5&scene=21#wechat_redirect">CORS 为什么要区分『简单请求』和『预检请求』？</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
          <category> 浏览器 </category>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html常见兼容问题</title>
      <link href="/2022/07/30/compatible/html-compatible/"/>
      <url>/2022/07/30/compatible/html-compatible/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="fwfFj"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>iphoneX的“刘海”为相机和其他组件留出了空间，同时在底部也留有可操作区域。其实对于 web 前端来说，刘海在绝大多数的场景下是可以不用处理的，因为 safari 或客户端（微信，手Q等）的 statusBar 已经替我们抹平了顶部刘海，我们只需要关心底部的可操作区域，因为如果页面底部有按钮的话，就会被可操作区域给挡住。<br><a name="MGMfZ"></a></p><h3 id="iPhoneX之变化"><a href="#iPhoneX之变化" class="headerlink" title="iPhoneX之变化"></a>iPhoneX之变化</h3><p><a name="yXFoK"></a></p><h4 id="1-屏幕尺寸、分辨率"><a href="#1-屏幕尺寸、分辨率" class="headerlink" title="1. 屏幕尺寸、分辨率"></a>1. 屏幕尺寸、分辨率</h4><p>追求全面屏的 iPhone X 此次启用 5.8 英寸的超视网膜高清显示屏，458ppi 的屏幕像素密度。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635168-afbcb6c4-7f5f-46bf-a1a4-6fbb06a145e4.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635168-afbcb6c4-7f5f-46bf-a1a4-6fbb06a145e4.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />竖屏时像素分辨率达到了 1125px × 2436px（375pt × 812pt @3x），可以发现 iPhone X 的宽度与原来的 iPhone 7 等 4.7 英寸屏的宽度是一致的，而高度却大了 145pt，长宽比也由原来常见的 16 : 9 变成了 13 : 6。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635317-3044724c-c0e4-4f6a-9b7f-34072df4e91c.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635317-3044724c-c0e4-4f6a-9b7f-34072df4e91c.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="gssKl"></a></p><h4 id="2-顶部刘海"><a href="#2-顶部刘海" class="headerlink" title="2.顶部刘海"></a>2.顶部刘海</h4><p>新版本的 iPhone 顶部有高度为 30pt 的黑色圆角条来放置扬声器、前置摄像头及各种传感器等，江湖人称 「刘海儿」，这也意味着原页面此处的内容有可能会被遮挡导致显示欠佳，进而影响用户体验，所以这也是我们需要关注的一个适配点。<br />刘海在绝大多数的场景下是可以不用处理的，因为 safari 或客户端（微信，手Q等）的 statusBar 已经替我们抹平了顶部刘海。<br><a name="xJ7kr"></a></p><h4 id="3-虚拟-Home-键"><a href="#3-虚拟-Home-键" class="headerlink" title="3.虚拟 Home 键"></a>3.虚拟 Home 键</h4><p>iPhone X 取消了以往的实体圆形 home 键，取而代之的是在屏幕底部一条 134pt × 5pt 的虚拟指示条。整个虚拟 Home 键也占据了一个高度 34pt 的保留区域。<br />原来实体 Home 键的单击返回桌面、双击唤起多任务处理、长按启动 Siri 等等基础功能操作，也幻化成了不同的手势操作或新技术替代，具体交互手势将在下节详述。而为了增强手势的操作感，整个虚拟 Home 键也占据了一个高度 34pt 的保留区域。<br />而在非特定条件下，这个虚拟指示条无论在横、竖屏中都将是强制性设计元素出现在屏幕底部上，意味着这设计中必须考虑好周围元素与它的兼容，因此，这又是我们适配过程中的另一个关注点。只有在需要获得沉浸式体验（如播放视频、查看图片）时，才会建议开发者可以虚拟指示条 「自动隐藏」功能。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635248-bb443c96-fa7e-4cb0-8658-e9f810cd41fd.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635248-bb443c96-fa7e-4cb0-8658-e9f810cd41fd.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="w2Klj"></a></p><h4 id="4-安全区域"><a href="#4-安全区域" class="headerlink" title="4.安全区域"></a>4.安全区域</h4><p>根据上述顶部刘海、虚拟 home 键的不同要求，Apple 提供了横、竖屏状态下的安全区域视觉规范。</p><ul><li>竖屏：竖屏时候，除去屏幕最顶部往下 44pt，底部往上 34pt 后，中间部分视为安全区域。</li><li>横屏：而横屏时候则相对复杂一些，因为虚拟指示条通常情况下都是出现在屏幕底部，所以不仅屏幕左右会留出 44pt 的空白位置，屏幕底部也会留出 21pt 的位置。</li></ul><p>至于为什么没有 “刘海儿” 一侧也会留出空白位置，则是 Apple 认为，“刘海儿”出现于左侧或右侧并不确定，让安全区域中的内容居中显示，可以避免屏幕旋转所造成的 UI 元素位置变化。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635212-b26f4b24-0508-4a49-949c-68e341db7424.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635212-b26f4b24-0508-4a49-949c-68e341db7424.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="ZRb8e"></a></p><h3 id="适配方案"><a href="#适配方案" class="headerlink" title="适配方案"></a>适配方案</h3><p>了解到 iPhone X 这边变化之后，我们大致可以知道需要在于安全区域布局、全屏图缩放裁切以及边界交互手势做相关的适配。在 iOS11 中我们可以使用 viewport-fit&#x3D;cover + safe-area-inset-*，<br><a name="xTEji"></a></p><h4 id="关于viewport-fit"><a href="#关于viewport-fit" class="headerlink" title="关于viewport-fit"></a>关于viewport-fit</h4><p>viewport-fit 可以设置可视视窗的大小，它有三个属性值：</p><ul><li>Auto：默认值。这个值不影响初始布局视窗，整个 Web 页面是可视的，与Contain表现一致。</li><li>Contain：最初的布局视窗和视觉布局视窗被设置为最大的矩形（左图）。</li><li>Cover：初始布局视窗和视觉布局视窗被设置为设备物理屏幕的限定矩形（右图）。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635183-fb3978a6-de41-4ae6-b070-8589ee304007.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635183-fb3978a6-de41-4ae6-b070-8589ee304007.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="s5zDN"></a></p><h4 id="关于-safe-area-inset"><a href="#关于-safe-area-inset" class="headerlink" title="关于 safe-area-inset-*"></a>关于 safe-area-inset-*</h4><p>各种 iPhone x 都是不规则形状，我们如何控制页面元素到安全区域呢？Apple 把安全区域的位置通过 css 属性提供给了开发者，它们可以通过CSS的constant( )函数来完成：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635694-436826a6-fcfc-4a5c-baf9-bac3a995e66c.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635694-436826a6-fcfc-4a5c-baf9-bac3a995e66c.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><ul><li>constant(safe-area-inset-top)：在Viewport顶部的安全区域内设置量（CSS像素）</li><li>constant(safe-area-inset-bottom)：在Viewport底部的安全区域内设置量（CSS像素）</li><li>constant(safe-area-inset-left)：在Viewport左边的安全区域内设置量（CSS像素）</li><li>constant(safe-area-inset-right)：在Viewport右边的安全区域内设置量（CSS像素）</li><li><br /></li></ul><p>简单来说我们可以通过 constant( ) 可以获取到非安全边距，再结合 padding 或 margin 来控制页面元素避开非安全区域。 Webkit 在 iOS11 中新增 CSS Functions: env( ) 替代 constant( )，文档中推荐使用 env( )，而 constant( ) 从 Safari Techology Preview 41 和 iOS11.2 Beta 开始会被弃用。在不支持 env( ) 的浏览器中，会自动忽略这一样式规则，不影响网页正常的渲染。为了达到最大兼容目的，我们可以 constant( ) 和 env( ) 同时使用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.footerClass</span> &#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">constant</span>(safe-area-inset-bottom); <span class="comment">/* iOS 11.0 */</span></span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-inset-bottom); <span class="comment">/* iOS 11.2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="lVFnh"></a></p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><a name="ei1Oe"></a></p><h4 id="1-设置网页在可视区域的布局方式"><a href="#1-设置网页在可视区域的布局方式" class="headerlink" title="1.设置网页在可视区域的布局方式"></a>1.设置网页在可视区域的布局方式</h4><p>新增 viweport-fit 属性，使得页面内容完全覆盖整个窗口：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; <span class="attribute">content</span>=&quot;<span class="attribute">width</span>=device-<span class="attribute">width</span>, initial-scale=<span class="number">1.0</span>, viewport-fit=cover, minimum-scale=<span class="number">1</span>, maximum-scale=<span class="number">1.0</span>, user-scalable=<span class="number">0</span>&quot;&gt;</span><br></pre></td></tr></table></figure><p><a name="YdtfC"></a></p><h4 id="2-让主体内容控制在安全区域内"><a href="#2-让主体内容控制在安全区域内" class="headerlink" title="2.让主体内容控制在安全区域内"></a>2.让主体内容控制在安全区域内</h4><p>假设我们的底部按钮高度是50px：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="built_in">env</span>(safe-area-inset-top);</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="built_in">env</span>(safe-area-inset-right);</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">50px</span>;  <span class="comment">/* 兼容不支持 env( ) 的设备  */</span></span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">calc</span>(<span class="built_in">env</span>(safe-area-inset-bottom) + <span class="number">50px</span>); <span class="comment">/* 在 iphone x + 中本句才会生效 */</span></span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="built_in">env</span>(safe-area-inset-left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个关键点：</p><ol><li>写在前面的 padding-bottom: 50px 为了兼容没有底部胡子的设备，让主体内容偏移出底部按钮的高度，避免按钮遮挡内容。</li><li><code>padding-bottom: calc(env(safe-area-inset-bottom) + 50px);</code> 计算 底部非安全区域距离 与 底部按钮高度 之和 来做为 <code>padding-bottom</code>值，如果设备支持 env，那么 calc 会计算出一个合法的值，本句的优先级则最高，会覆盖前面的 <code>padding-bottom: 50px</code>。否则 calc 会计算出一个不合法的值，则本句声明不会生效。这样在不支持 env 设备中也可以达到兼容的目的。</li></ol><p>目前到这，在横屏场景下左侧的内容就不会被刘海遮挡住了：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635706-86150bda-7c7b-445b-8d0e-c11ff52e1d77.png#averageHue=%238c9c83&clientId=u30bf360d-bf01-4&from=paste&id=uf3b439d5&originHeight=544&originWidth=960&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf1e4d04d-c750-41c8-8b26-eda83b6e1c8&title=" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635706-86150bda-7c7b-445b-8d0e-c11ff52e1d77.png#averageHue=%238c9c83&clientId=u30bf360d-bf01-4&from=paste&id=uf3b439d5&originHeight=544&originWidth=960&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf1e4d04d-c750-41c8-8b26-eda83b6e1c8&title=" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="nvhAH"></a></p><h4 id="3-底部按钮的处理"><a href="#3-底部按钮的处理" class="headerlink" title="3.底部按钮的处理"></a>3.底部按钮的处理</h4><p>首先给底部按钮一个外层容器 .btn-container ，设置样式时其中有几点比较关键：</p><ol><li>设置<code>padding-bottom: env(safe-area-inset-bottom);</code>增加一个 padding 值，让底部向外扩展一个非安全区域的距离。</li><li>设置<code>background: #FFF</code> 让整个 <code>.btn-container</code>背景为白色（包括刚新增的 <code>padding-bottom</code> 的区域）这样就可以遮挡住了底部内容。</li><li>设置 <code>box-sizing: content-box;</code>，因为在通常情况下 css 在 reset 阶段一般都设置了<code>* &#123;box-sizing: border-box;&#125;</code>这样一来设置 padding 就不能向外扩展距离了，所以在这里我们要把他改回 <code>content-box</code>。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn-container</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#FFF</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="built_in">env</span>(safe-area-inset-bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#00c340</span>;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果如图所示<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635866-dc17d470-498c-41cb-b62e-4095ded62ab9.png#averageHue=%2399a694&clientId=u30bf360d-bf01-4&from=paste&id=u918115cd&originHeight=960&originWidth=544&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u87459362-8a26-445e-b7fd-dc906a20d61&title=" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635866-dc17d470-498c-41cb-b62e-4095ded62ab9.png#averageHue=%2399a694&clientId=u30bf360d-bf01-4&from=paste&id=u918115cd&originHeight=960&originWidth=544&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u87459362-8a26-445e-b7fd-dc906a20d61&title=" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>在 safari 中，页面往上稍滑动一点，出现 safari 的操作栏后，底部按钮依然会紧贴着操作栏：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635821-83d98fec-a439-45dc-bace-df3849d54600.png#averageHue=%238c9484&clientId=u30bf360d-bf01-4&from=paste&id=u44f16efe&originHeight=799&originWidth=453&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u72633772-beb4-4a1b-8a0e-e8023da51b1&title=" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/300943/1666081635821-83d98fec-a439-45dc-bace-df3849d54600.png#averageHue=%238c9484&clientId=u30bf360d-bf01-4&from=paste&id=u44f16efe&originHeight=799&originWidth=453&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u72633772-beb4-4a1b-8a0e-e8023da51b1&title=" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="AYsAZ"></a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/a1e8c7cf8821">如何适配 iPhone X</a><br /><a href="https://link.juejin.cn/?target=https://www.w3.org/TR/css-round-display-1/%23viewport-fit-descriptor">CSS Round Display Level 1</a><br /><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/conflicting/Web/CSS/@viewport_a33ee59ffd8336ffb3336900dea02e9f">viewport-fit</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compatible </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大文件上传和断点续传</title>
      <link href="/2022/06/21/solution/da-wen-jian-shang-chuan-he-duan-dian-xu-chuan/"/>
      <url>/2022/06/21/solution/da-wen-jian-shang-chuan-he-duan-dian-xu-chuan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="WK3tc"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这段时间面试官都挺忙的，频频出现在博客文章标题，虽然我不是特别想蹭热度，但是实在想不到好的标题了-。-，蹭蹭就蹭蹭 :)<br />事实上我在面试的时候确实被问到了这个问题，而且是一道在线 coding 的编程题，当时虽然思路正确，可惜最终也并不算完全答对<br />结束后花了一段时间整理了下思路，那么究竟该如何实现一个大文件上传，以及在上传中如何实现断点续传的功能呢？<br />本文将从零搭建前端和服务端，实现一个大文件上传和断点续传的 demo<br />前端：<code>vue</code> <code>element-ui</code><br />服务端：<code>nodejs</code><br /><code>文章有误解的地方，欢迎指出，将在第一时间改正，有更好的实现方式希望留下你的评论</code><br><a name="Jwoal"></a></p><h1 id="大文件上传"><a href="#大文件上传" class="headerlink" title="大文件上传"></a>大文件上传</h1><p><a name="XRJsf"></a></p><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><p><a name="qPQ6M"></a></p><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>前端大文件上传网上的大部分文章已经给出了解决方案，核心是<code>利用 Blob.prototype.slice</code> 方法，和数组的 slice 方法相似，调用的 slice 方法可以返回<code>原文件的某个切片</code><br />这样我们就可以根据预先设置好的切片最大数量将文件切分为一个个切片，然后借助 http 的可并发性，同时上传多个切片，这样从原本传一个大文件，变成了<code>同时</code>传多个小的文件切片，可以大大减少上传时间<br />另外由于是并发，传输到服务端的顺序可能会发生变化，所以我们还需要给每个切片记录顺序<br><a name="ZNFD9"></a></p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端需要负责接受这些切片，并在接收到所有切片后<code>合并</code>切片<br />这里又引伸出两个问题</p><ol><li>何时合并切片，即切片什么时候传输完成</li><li>如何合并切片</li></ol><p>第一个问题需要前端进行配合，前端在每个切片中都携带切片最大数量的信息，当服务端接受到这个数量的切片时自动合并，也可以额外发一个请求主动通知服务端进行切片的合并<br />第二个问题，具体如何合并切片呢？这里可以使用 nodejs 的 读写流（readStream&#x2F;writeStream），将所有切片的流传输到最终文件的流里<br /><code>talk is cheap,show me the code</code>，接着我们用代码实现上面的思路<br><a name="ncRhr"></a></p><h2 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h2><p>前端使用 Vue 作为开发框架，对界面没有太大要求，原生也可以，考虑到美观使用 element-ui 作为 UI 框架<br><a name="Tk50G"></a></p><h3 id="上传控件"><a href="#上传控件" class="headerlink" title="上传控件"></a>上传控件</h3><p>首先创建选择文件的控件，监听 change 事件以及上传按钮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; @change=&quot;handleFileChange&quot; /&gt;</span><br><span class="line">      &lt;el-button @click=&quot;handleUpload&quot;&gt;上传&lt;/el-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data: () =&gt; (&#123;</span><br><span class="line">      container: &#123;</span><br><span class="line">        file: null</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleFileChange(e) &#123;</span><br><span class="line">        const [file] = e.target.files;</span><br><span class="line">        if (!file) return;</span><br><span class="line">        Object.assign(this.$data, this.$options.data());</span><br><span class="line">        this.container.file = file;</span><br><span class="line">      &#125;,</span><br><span class="line">      async handleUpload() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300740-6910ec20-d65c-43f8-8267-b7cd21ab7694.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300740-6910ec20-d65c-43f8-8267-b7cd21ab7694.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="Ks79D"></a></p><h3 id="请求逻辑"><a href="#请求逻辑" class="headerlink" title="请求逻辑"></a>请求逻辑</h3><p>考虑到通用性，这里没有用第三方的请求库，而是用原生 XMLHttpRequest 做一层简单的封装来发请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">request(&#123;</span><br><span class="line">  url,</span><br><span class="line">  method = &quot;post&quot;,</span><br><span class="line">  data,</span><br><span class="line">  headers = &#123;&#125;,</span><br><span class="line">  requestList</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    const xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(method, url);</span><br><span class="line">    Object.keys(headers).forEach(key =&gt;</span><br><span class="line">      xhr.setRequestHeader(key, headers[key])</span><br><span class="line">                                );</span><br><span class="line">    xhr.send(data);</span><br><span class="line">    xhr.onload = e =&gt; &#123;</span><br><span class="line">      resolve(&#123;</span><br><span class="line">        data: e.target.response</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="sH0vD"></a></p><h3 id="上传切片"><a href="#上传切片" class="headerlink" title="上传切片"></a>上传切片</h3><p>接着实现比较重要的上传功能，上传需要做两件事</p><ul><li>对文件进行切片</li><li>将切片传输给服务端</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; @change=&quot;handleFileChange&quot; /&gt;</span><br><span class="line">      &lt;el-button @click=&quot;handleUpload&quot;&gt;上传&lt;/el-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  + const SIZE = 10 * 1024 * 1024; // 切片大小</span><br><span class="line">  export default &#123;</span><br><span class="line">    data: () =&gt; (&#123;</span><br><span class="line">      container: &#123;</span><br><span class="line">        file: null</span><br><span class="line">      &#125;，</span><br><span class="line">           data: []</span><br><span class="line">    &#125;),</span><br><span class="line">    methods: &#123;</span><br><span class="line">      request() &#123;&#125;,</span><br><span class="line">      handleFileChange() &#123;&#125;,</span><br><span class="line">          // 生成文件切片</span><br><span class="line">          createFileChunk(file, size = SIZE) &#123;</span><br><span class="line">           const fileChunkList = [];</span><br><span class="line">        let cur = 0;</span><br><span class="line">        while (cur &lt; file.size) &#123;</span><br><span class="line">            fileChunkList.push(&#123; file: file.slice(cur, cur + size) &#125;);</span><br><span class="line">            cur += size;</span><br><span class="line">          &#125;</span><br><span class="line">        return fileChunkList;</span><br><span class="line">      &#125;,</span><br><span class="line">       // 上传切片</span><br><span class="line">        async uploadChunks() &#123;</span><br><span class="line">          const requestList = this.data</span><br><span class="line">             .map((&#123; chunk，hash &#125;) =&gt; &#123;</span><br><span class="line">                  const formData = new FormData();</span><br><span class="line">                  formData.append(&quot;chunk&quot;, chunk);</span><br><span class="line">                  formData.append(&quot;hash&quot;, hash);</span><br><span class="line">                  formData.append(&quot;filename&quot;, this.container.file.name);</span><br><span class="line">                  return &#123; formData &#125;;</span><br><span class="line">                &#125;)</span><br><span class="line">              .map(async (&#123; formData &#125;) =&gt;</span><br><span class="line">                  this.request(&#123;</span><br><span class="line">                      url: &quot;http://localhost:3000&quot;,</span><br><span class="line">                      data: formData</span><br><span class="line">                      &#125;)</span><br><span class="line">                );</span><br><span class="line">          await Promise.all(requestList); // 并发切片</span><br><span class="line">        &#125;,</span><br><span class="line">          async handleUpload() &#123;</span><br><span class="line">            if (!this.container.file) return;</span><br><span class="line">            const fileChunkList = this.createFileChunk(this.container.file);</span><br><span class="line">            this.data = fileChunkList.map((&#123; file &#125;，index) =&gt; (&#123;</span><br><span class="line">                chunk: file,</span><br><span class="line">                hash: this.container.file.name + &quot;-&quot; + index // 文件名 + 数组下标</span><br><span class="line">                &#125;));</span><br><span class="line">            await this.uploadChunks();</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当点击上传按钮时，调用 <code>createFileChunk</code> 将文件切片，切片数量通过文件大小控制，这里设置 10MB，也就是说 100 MB 的文件会被分成 10 个切片<br />createFileChunk 内使用 while 循环和 slice 方法将切片放入 <code>fileChunkList</code> 数组中返回<br />在生成文件切片时，需要给每个切片一个标识作为 hash，这里暂时使用<code>文件名 + 下标</code>，这样后端可以知道当前切片是第几个切片，用于之后的合并切片<br />随后调用 <code>uploadChunks</code> 上传所有的文件切片，将文件切片，切片 hash，以及文件名放入 FormData 中，再调用上一步的 <code>request</code> 函数返回一个 proimise，最后调用 Promise.all 并发上传所有的切片<br><a name="KHpY4"></a></p><h3 id="发送合并请求"><a href="#发送合并请求" class="headerlink" title="发送合并请求"></a>发送合并请求</h3><p>这里使用整体思路中提到的第二种合并切片的方式，即前端主动通知服务端进行合并，所以前端还需要额外发请求，服务端接受到这个请求时主动合并切片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; @change=&quot;handleFileChange&quot; /&gt;</span><br><span class="line">      &lt;el-button @click=&quot;handleUpload&quot;&gt;上传&lt;/el-button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data: () =&gt; (&#123;</span><br><span class="line">      container: &#123;</span><br><span class="line">        file: null</span><br><span class="line">      &#125;,</span><br><span class="line">      data: []</span><br><span class="line">    &#125;),</span><br><span class="line">    methods: &#123;</span><br><span class="line">      request() &#123;&#125;,</span><br><span class="line">      handleFileChange() &#123;&#125;,</span><br><span class="line">      createFileChunk() &#123;&#125;,</span><br><span class="line">      // 上传切片，同时过滤已上传的切片</span><br><span class="line">      async uploadChunks() &#123;</span><br><span class="line">        const requestList = this.data</span><br><span class="line">          .map((&#123; chunk，hash &#125;) =&gt; &#123;</span><br><span class="line">            const formData = new FormData();</span><br><span class="line">            formData.append(&quot;chunk&quot;, chunk);</span><br><span class="line">            formData.append(&quot;hash&quot;, hash);</span><br><span class="line">            formData.append(&quot;filename&quot;, this.container.file.name);</span><br><span class="line">            return &#123; formData &#125;;</span><br><span class="line">          &#125;)</span><br><span class="line">          .map(async (&#123; formData &#125;) =&gt;</span><br><span class="line">            this.request(&#123;</span><br><span class="line">              url: &quot;http://localhost:3000&quot;,</span><br><span class="line">              data: formData</span><br><span class="line">            &#125;)</span><br><span class="line">              );</span><br><span class="line">        await Promise.all(requestList);</span><br><span class="line">              // 合并切片</span><br><span class="line">        await this.mergeRequest();</span><br><span class="line">      &#125;,</span><br><span class="line">        async mergeRequest() &#123;</span><br><span class="line">            await this.request(&#123;</span><br><span class="line">                url: &quot;http://localhost:3000/merge&quot;,</span><br><span class="line">                 headers: &#123;</span><br><span class="line">                      &quot;content-type&quot;: &quot;application/json&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                                       data: JSON.stringify(&#123;</span><br><span class="line">                                              filename: this.container.file.name</span><br><span class="line">                                              &#125;)</span><br><span class="line">                                        &#125;);</span><br><span class="line">            &#125;,    </span><br><span class="line">      async handleUpload() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><a name="W8bY3"></a></p><h2 id="服务端部分"><a href="#服务端部分" class="headerlink" title="服务端部分"></a>服务端部分</h2><p>简单使用 http 模块搭建服务端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;);</span><br><span class="line">  const server = http.createServer();</span><br><span class="line">  server.on(&quot;request&quot;, async (req, res) =&gt; &#123;</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);</span><br><span class="line">  if (req.method === &quot;OPTIONS&quot;) &#123;</span><br><span class="line">  res.status = 200;</span><br><span class="line">  res.end();</span><br><span class="line">  return;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  server.listen(3000, () =&gt; console.log(&quot;正在监听 3000 端口&quot;));</span><br></pre></td></tr></table></figure><p><a name="NckM5"></a></p><h3 id="接受切片"><a href="#接受切片" class="headerlink" title="接受切片"></a>接受切片</h3><p>使用 <code>multiparty</code> 包处理前端传来的 FormData<br />在 multiparty.parse 的回调中，files 参数保存了 FormData 中文件，fields 参数保存了 FormData 中非文件的字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;);</span><br><span class="line">  const path = require(&quot;path&quot;);</span><br><span class="line">  const fse = require(&quot;fs-extra&quot;);</span><br><span class="line">  const multiparty = require(&quot;multiparty&quot;);</span><br><span class="line">  const server = http.createServer();</span><br><span class="line">  + const UPLOAD_DIR = path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;); // 大文件存储目录</span><br><span class="line">  server.on(&quot;request&quot;, async (req, res) =&gt; &#123;</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);</span><br><span class="line">  if (req.method === &quot;OPTIONS&quot;) &#123;</span><br><span class="line">  res.status = 200;</span><br><span class="line">  res.end();</span><br><span class="line">  return;</span><br><span class="line">  &#125;</span><br><span class="line">  +  const multipart = new multiparty.Form();</span><br><span class="line">  +  multipart.parse(req, async (err, fields, files) =&gt; &#123;</span><br><span class="line">  +    if (err) &#123;</span><br><span class="line">  +      return;</span><br><span class="line">  +    &#125;</span><br><span class="line">  +    const [chunk] = files.chunk;</span><br><span class="line">  +    const [hash] = fields.hash;</span><br><span class="line">  +    const [filename] = fields.filename;</span><br><span class="line">  +    const chunkDir = path.resolve(UPLOAD_DIR, filename);</span><br><span class="line">  +   // 切片目录不存在，创建切片目录</span><br><span class="line">  +    if (!fse.existsSync(chunkDir)) &#123;</span><br><span class="line">  +      await fse.mkdirs(chunkDir);</span><br><span class="line">  +    &#125;</span><br><span class="line">  +      // fs-extra 专用方法，类似 fs.rename 并且跨平台</span><br><span class="line">  +      // fs-extra 的 rename 方法 windows 平台会有权限问题</span><br><span class="line">  +      // https://github.com/meteor/meteor/issues/7852#issuecomment-255767835</span><br><span class="line">  +      await fse.move(chunk.path, `$&#123;chunkDir&#125;/$&#123;hash&#125;`);</span><br><span class="line">  +    res.end(&quot;received file chunk&quot;);</span><br><span class="line">  +  &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  server.listen(3000, () =&gt; console.log(&quot;正在监听 3000 端口&quot;));</span><br><span class="line">  复制代码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300724-04872720-0840-4492-b665-47ac9f945492.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300724-04872720-0840-4492-b665-47ac9f945492.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="grG7L"></a></p><h3 id="合并切片"><a href="#合并切片" class="headerlink" title="合并切片"></a>合并切片</h3><p>在接收到前端发送的合并请求后，服务端将文件夹下的所有切片进行合并</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;);</span><br><span class="line">  const path = require(&quot;path&quot;);</span><br><span class="line">  const fse = require(&quot;fs-extra&quot;);</span><br><span class="line">  const server = http.createServer();</span><br><span class="line">  const UPLOAD_DIR = path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;); // 大文件存储目录</span><br><span class="line">   const resolvePost = req =&gt;</span><br><span class="line">     new Promise(resolve =&gt; &#123;</span><br><span class="line">       let chunk = &quot;&quot;;</span><br><span class="line">       req.on(&quot;data&quot;, data =&gt; &#123;</span><br><span class="line">         chunk += data;</span><br><span class="line">       &#125;);</span><br><span class="line">       req.on(&quot;end&quot;, () =&gt; &#123;</span><br><span class="line">         resolve(JSON.parse(chunk));</span><br><span class="line">       &#125;);</span><br><span class="line">     &#125;);</span><br><span class="line">   const pipeStream = (path, writeStream) =&gt;</span><br><span class="line">    new Promise(resolve =&gt; &#123;</span><br><span class="line">      const readStream = fse.createReadStream(path);</span><br><span class="line">      readStream.on(&quot;end&quot;, () =&gt; &#123;</span><br><span class="line">        fse.unlinkSync(path);</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;);</span><br><span class="line">      readStream.pipe(writeStream);</span><br><span class="line">    &#125;);</span><br><span class="line">  // 合并切片</span><br><span class="line">   const mergeFileChunk = async (filePath, filename, size) =&gt; &#123;</span><br><span class="line">    const chunkDir = path.resolve(UPLOAD_DIR, filename);</span><br><span class="line">    const chunkPaths = await fse.readdir(chunkDir);</span><br><span class="line">    // 根据切片下标进行排序</span><br><span class="line">    // 否则直接读取目录的获得的顺序可能会错乱</span><br><span class="line">    chunkPaths.sort((a, b) =&gt; a.split(&quot;-&quot;)[1] - b.split(&quot;-&quot;)[1]);</span><br><span class="line">    await Promise.all(</span><br><span class="line">      chunkPaths.map((chunkPath, index) =&gt;</span><br><span class="line">        pipeStream(</span><br><span class="line">          path.resolve(chunkDir, chunkPath),</span><br><span class="line">          // 指定位置创建可写流</span><br><span class="line">          fse.createWriteStream(filePath, &#123;</span><br><span class="line">            start: index * size,</span><br><span class="line">            end: (index + 1) * size</span><br><span class="line">          &#125;)</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">    fse.rmdirSync(chunkDir); // 合并后删除保存切片的目录</span><br><span class="line">  &#125;;</span><br><span class="line">  server.on(&quot;request&quot;, async (req, res) =&gt; &#123;</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">  res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);</span><br><span class="line">  if (req.method === &quot;OPTIONS&quot;) &#123;</span><br><span class="line">  res.status = 200;</span><br><span class="line">  res.end();</span><br><span class="line">  return;</span><br><span class="line">  &#125;</span><br><span class="line">     if (req.url === &quot;/merge&quot;) &#123;</span><br><span class="line">       const data = await resolvePost(req);</span><br><span class="line">       const &#123; filename,size &#125; = data;</span><br><span class="line">       const filePath = path.resolve(UPLOAD_DIR, `$&#123;filename&#125;`);</span><br><span class="line">       await mergeFileChunk(filePath, filename);</span><br><span class="line">       res.end(</span><br><span class="line">         JSON.stringify(&#123;</span><br><span class="line">           code: 0,</span><br><span class="line">           message: &quot;file merged success&quot;</span><br><span class="line">         &#125;)</span><br><span class="line">       );</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  server.listen(3000, () =&gt; console.log(&quot;正在监听 3000 端口&quot;));</span><br></pre></td></tr></table></figure><p>由于前端在发送合并请求时会携带文件名，服务端根据文件名可以找到上一步创建的切片文件夹<br />接着使用 fs.createWriteStream 创建一个可写流，可写流文件名就是<strong>切片文件夹名 + 后缀名</strong>组合而成<br />随后遍历整个切片文件夹，将切片通过 fs.createReadStream 创建可读流，传输合并到目标文件中<br />值得注意的是每次可读流都会传输到可写流的指定位置，这是通过 createWriteStream 的第二个参数 start&#x2F;end 控制的，目的是能够并发合并多个可读流到可写流中，这样即使流的顺序不同也能传输到正确的位置，所以这里还需要让前端在请求的时候多提供一个 size 参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">mergeRequest</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000/merge&quot;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">      +         <span class="attr">size</span>: <span class="variable constant_">SIZE</span>,</span><br><span class="line">      <span class="attr">filename</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300704-6beb554c-7db6-4401-96d9-7c92bf363f67.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300704-6beb554c-7db6-4401-96d9-7c92bf363f67.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />至此一个简单的大文件上传就完成了，接下来我们再此基础上扩展一些额外的功能<br><a name="Pjd1l"></a></p><h2 id="显示上传进度条"><a href="#显示上传进度条" class="headerlink" title="显示上传进度条"></a>显示上传进度条</h2><p>上传进度分两种，一个是每个切片的上传进度，另一个是整个文件的上传进度，而整个文件的上传进度是基于每个切片上传进度计算而来，所以我们先实现切片的上传进度<br><a name="rIKCx"></a></p><h3 id="切片进度条"><a href="#切片进度条" class="headerlink" title="切片进度条"></a>切片进度条</h3><p>XMLHttpRequest 原生支持上传进度的监听，只需要监听 upload.onprogress 即可，我们在原来的 request 基础上传入 onProgress 参数，给 XMLHttpRequest 注册监听事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xhr</span></span><br><span class="line"><span class="title function_">request</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  url,</span></span><br><span class="line"><span class="params">  method = <span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="params">  data,</span></span><br><span class="line"><span class="params">  headers = &#123;&#125;,</span></span><br><span class="line"><span class="params">  +      onProgress = e =&gt; e,</span></span><br><span class="line"><span class="params">  requestList</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    +       xhr.<span class="property">upload</span>.<span class="property">onprogress</span> = onProgress;</span><br><span class="line">    xhr.<span class="title function_">open</span>(method, url);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(headers).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span></span><br><span class="line">      xhr.<span class="title function_">setRequestHeader</span>(key, headers[key])</span><br><span class="line">                                );</span><br><span class="line">    xhr.<span class="title function_">send</span>(data);</span><br><span class="line">    xhr.<span class="property">onload</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(&#123;</span><br><span class="line">        <span class="attr">data</span>: e.<span class="property">target</span>.<span class="property">response</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于每个切片都需要触发独立的监听事件，所以还需要一个工厂函数，根据传入的切片返回不同的监听函数<br />在原先的前端上传逻辑中新增监听函数部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上传切片，同时过滤已上传的切片</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">uploadChunks</span>(<span class="params">uploadedList = []</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> requestList = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">    .<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; chunk,hash,index &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&quot;chunk&quot;</span>, chunk);</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&quot;hash&quot;</span>, hash);</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&quot;filename&quot;</span>, <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span>);</span><br><span class="line">              <span class="keyword">return</span> &#123; formData,index &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">        .<span class="title function_">map</span>(<span class="keyword">async</span> (&#123; formData,index &#125;) =&gt;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>: formData，</span><br><span class="line">                  <span class="attr">onProgress</span>: <span class="variable language_">this</span>.<span class="title function_">createProgressHandler</span>(<span class="variable language_">this</span>.<span class="property">data</span>[index]),</span><br><span class="line">      &#125;)</span><br><span class="line">                );</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(requestList);</span><br><span class="line">  <span class="comment">// 合并切片</span></span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">mergeRequest</span>();</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">handleUpload</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> fileChunkList = <span class="variable language_">this</span>.<span class="title function_">createFileChunk</span>(<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = fileChunkList.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; file &#125;，index</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">chunk</span>: file,</span><br><span class="line">        index,</span><br><span class="line">    <span class="attr">hash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span> + <span class="string">&quot;-&quot;</span> + index</span><br><span class="line">           <span class="attr">percentage</span>:<span class="number">0</span></span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">uploadChunks</span>();</span><br><span class="line">&#125;    </span><br><span class="line"><span class="title function_">createProgressHandler</span>(<span class="params">item</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">           item.<span class="property">percentage</span> = <span class="built_in">parseInt</span>(<span class="title class_">String</span>((e.<span class="property">loaded</span> / e.<span class="property">total</span>) * <span class="number">100</span>));</span><br><span class="line">       &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>每个切片在上传时都会通过监听函数更新 data 数组对应元素的 percentage 属性，之后把将 data 数组放到视图中展示即可<br><a name="yNvn5"></a></p><h3 id="文件进度条"><a href="#文件进度条" class="headerlink" title="文件进度条"></a>文件进度条</h3><p>将每个切片已上传的部分累加，除以整个文件的大小，就能得出当前文件的上传进度，所以这里使用 Vue 计算属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="title function_">uploadPercentage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span> || !<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> loaded = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">      .<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">size</span> * item.<span class="property">percentage</span>)</span><br><span class="line">      .<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>((loaded / <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">size</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>最终视图如下<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300712-d2e412fa-ed42-4452-98fb-c5a728d44a55.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300712-d2e412fa-ed42-4452-98fb-c5a728d44a55.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="rI21c"></a></p><h1 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h1><p>断点续传的原理在于前端&#x2F;服务端需要<code>记住</code>已上传的切片，这样下次上传就可以跳过之前已上传的部分，有两种方案实现记忆的功能</p><ul><li>前端使用 localStorage 记录已上传的切片 hash</li><li>服务端保存已上传的切片 hash，前端每次上传前向服务端获取已上传的切片</li></ul><p>第一种是前端的解决方案，第二种是服务端，而前端方案有一个缺陷，如果换了个浏览器就失去了记忆的效果，所以这里选取后者<br><a name="GWcjL"></a></p><h2 id="生成-hash"><a href="#生成-hash" class="headerlink" title="生成 hash"></a>生成 hash</h2><p>无论是前端还是服务端，都必须要生成文件和切片的 hash，<code>之前我们使用文件名 + 切片下标作为切片 hash</code>，这样做文件名一旦修改就失去了效果，而事实上只要文件内容不变，hash 就不应该变化，所以正确的做法是<code>根据文件内容生成 hash</code>，所以我们修改一下 hash 的生成规则<br />这里用到另一个库 <code>spark-md5</code>，它可以根据文件内容计算出文件的 hash 值，另外考虑到如果上传一个超大文件，读取文件内容计算 hash 是非常耗费时间的，并且会<code>引起 UI 的阻塞</code>，导致页面假死状态，所以我们使用 web-worker 在 worker 线程计算 hash，这样用户仍可以在主界面正常的交互<br />由于实例化 web-worker 时，参数是一个 js 文件路径且不能跨域，所以我们单独创建一个 hash.js 文件放在 public 目录下，另外在 worker 中也是不允许访问 dom 的，但它提供了<code>importScripts</code> 函数用于导入外部脚本，通过它导入 spark-md5</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /public/hash.js</span></span><br><span class="line">self.importScripts(<span class="string">&quot;/spark-md5.min.js&quot;</span>); <span class="comment">// 导入脚本</span></span><br><span class="line"><span class="comment">// 生成文件 hash</span></span><br><span class="line">self.<span class="property">onmessage</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; fileChunkList &#125; = e.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">const</span> spark = <span class="keyword">new</span> self.<span class="property">SparkMD5</span>.<span class="title class_">ArrayBuffer</span>();</span><br><span class="line">  <span class="keyword">let</span> percentage = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">loadNext</span> = index =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">    reader.<span class="title function_">readAsArrayBuffer</span>(fileChunkList[index].<span class="property">file</span>);</span><br><span class="line">    reader.<span class="property">onload</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      count++;</span><br><span class="line">      spark.<span class="title function_">append</span>(e.<span class="property">target</span>.<span class="property">result</span>);</span><br><span class="line">      <span class="keyword">if</span> (count === fileChunkList.<span class="property">length</span>) &#123;</span><br><span class="line">        self.<span class="title function_">postMessage</span>(&#123;</span><br><span class="line">          <span class="attr">percentage</span>: <span class="number">100</span>,</span><br><span class="line">          <span class="attr">hash</span>: spark.<span class="title function_">end</span>()</span><br><span class="line">        &#125;);</span><br><span class="line">        self.<span class="title function_">close</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        percentage += <span class="number">100</span> / fileChunkList.<span class="property">length</span>;</span><br><span class="line">        self.<span class="title function_">postMessage</span>(&#123;</span><br><span class="line">          percentage</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 递归计算下一个切片</span></span><br><span class="line">        <span class="title function_">loadNext</span>(count);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">loadNext</span>(<span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在 worker 线程中，接受文件切片 fileChunkList，利用 FileReader 读取每个切片的 ArrayBuffer 并不断传入 spark-md5 中，每计算完一个切片通过 postMessage 向主线程发送一个进度事件，全部完成后将最终的 hash 发送给主线程<br /><code>spark-md5 需要根据所有切片才能算出一个 hash 值，不能直接将整个文件放入计算，否则即使不同文件也会有相同的 hash，具体可以看官方文档</code><br /><a href="https://www.npmjs.com/package/spark-md5">spark-md5</a><br />接着编写主线程与 worker 线程通讯的逻辑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+    <span class="comment">// 生成文件 hash（web-worker）</span></span><br><span class="line">  +    <span class="title function_">calculateHash</span>(<span class="params">fileChunkList</span>) &#123;</span><br><span class="line">    +      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      +       <span class="comment">// 添加 worker 属性</span></span><br><span class="line">        +        <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">worker</span> = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;/hash.js&quot;</span>);</span><br><span class="line">      +        <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">worker</span>.<span class="title function_">postMessage</span>(&#123; fileChunkList &#125;);</span><br><span class="line">      +        <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">worker</span>.<span class="property">onmessage</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        +          <span class="keyword">const</span> &#123; percentage, hash &#125; = e.<span class="property">data</span>;</span><br><span class="line">        +          <span class="variable language_">this</span>.<span class="property">hashPercentage</span> = percentage;</span><br><span class="line">        +          <span class="keyword">if</span> (hash) &#123;</span><br><span class="line">          +            <span class="title function_">resolve</span>(hash);</span><br><span class="line">        +          &#125;</span><br><span class="line">          +        &#125;;</span><br><span class="line">      +      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">handleUpload</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> fileChunkList = <span class="variable language_">this</span>.<span class="title function_">createFileChunk</span>(<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>);</span><br><span class="line">  +     <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span> = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">calculateHash</span>(fileChunkList);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = fileChunkList.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; file &#125;，index</span>) =&gt;</span> (&#123;</span><br><span class="line">    +       <span class="attr">fileHash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span>,</span><br><span class="line">    <span class="attr">chunk</span>: file,</span><br><span class="line">    <span class="attr">hash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span> + <span class="string">&quot;-&quot;</span> + index, <span class="comment">// 文件名 + 数组下标</span></span><br><span class="line">    <span class="attr">percentage</span>:<span class="number">0</span></span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">uploadChunks</span>();</span><br><span class="line">&#125;   </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>主线程使用 <code>postMessage</code> 给 worker 线程传入所有切片 fileChunkList，并监听 worker 线程发出的 postMessage 事件拿到文件 hash<br />加上显示计算 hash 的进度条，看起来像这样<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300867-a57f7705-b2a5-4b7b-b47a-3e31dcff830f.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300867-a57f7705-b2a5-4b7b-b47a-3e31dcff830f.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="Yej4T"></a></p><h2 id="文件秒传"><a href="#文件秒传" class="headerlink" title="文件秒传"></a>文件秒传</h2><p>在实现断点续传前先简单介绍一下文件秒传<br />所谓的文件秒传，即在服务端已经存在了上传的资源，所以当用户<code>再次上传</code>时会直接提示上传成功<br />文件秒传需要依赖上一步生成的 hash，即在<code>上传前</code>，先计算出文件 hash，并把 hash 发送给服务端进行验证，由于 hash 的唯一性，所以一旦服务端能找到 hash 相同的文件，则直接返回上传成功的信息即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">async</span> <span class="title function_">verifyUpload</span>(<span class="params">filename, fileHash</span>) &#123;</span><br><span class="line">       <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">           <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000/verify&quot;</span>,</span><br><span class="line">         <span class="attr">headers</span>: &#123;</span><br><span class="line">               <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">             &#125;,</span><br><span class="line">                <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">                     filename,</span><br><span class="line">                      fileHash</span><br><span class="line">                    &#125;)</span><br><span class="line">                 &#125;);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(data);</span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">handleUpload</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> fileChunkList = <span class="variable language_">this</span>.<span class="title function_">createFileChunk</span>(<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span> = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">calculateHash</span>(fileChunkList);</span><br><span class="line">       <span class="keyword">const</span> &#123; shouldUpload &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">verifyUpload</span>(</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span>,</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span></span><br><span class="line">         );</span><br><span class="line">       <span class="keyword">if</span> (!shouldUpload) &#123;</span><br><span class="line">           <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;秒传：上传成功&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = fileChunkList.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; file &#125;, index</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">fileHash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span>,</span><br><span class="line">    index,</span><br><span class="line">    <span class="attr">hash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span> + <span class="string">&quot;-&quot;</span> + index,</span><br><span class="line">    <span class="attr">chunk</span>: file,</span><br><span class="line">    <span class="attr">percentage</span>: <span class="number">0</span></span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">uploadChunks</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>秒传其实就是给用户看的障眼法，实质上根本没有上传<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300741-7b208cf0-fd2b-4877-9aab-a3c7fa60dc41.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300741-7b208cf0-fd2b-4877-9aab-a3c7fa60dc41.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />服务端的逻辑非常简单，新增一个验证接口，验证文件是否存在即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+ const extractExt = filename =&gt;</span><br><span class="line">+  filename.slice(filename.lastIndexOf(&quot;.&quot;), filename.length); // 提取后缀名</span><br><span class="line">const UPLOAD_DIR = path.resolve(__dirname, &quot;..&quot;, &quot;target&quot;); // 大文件存储目录</span><br><span class="line">const resolvePost = req =&gt;</span><br><span class="line">  new Promise(resolve =&gt; &#123;</span><br><span class="line">    let chunk = &quot;&quot;;</span><br><span class="line">    req.on(&quot;data&quot;, data =&gt; &#123;</span><br><span class="line">      chunk += data;</span><br><span class="line">    &#125;);</span><br><span class="line">    req.on(&quot;end&quot;, () =&gt; &#123;</span><br><span class="line">      resolve(JSON.parse(chunk));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">server.on(&quot;request&quot;, async (req, res) =&gt; &#123;</span><br><span class="line">  if (req.url === &quot;/verify&quot;) &#123;</span><br><span class="line">+    const data = await resolvePost(req);</span><br><span class="line">+    const &#123; fileHash, filename &#125; = data;</span><br><span class="line">+    const ext = extractExt(filename);</span><br><span class="line">+    const filePath = path.resolve(UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;ext&#125;`);</span><br><span class="line">+    if (fse.existsSync(filePath)) &#123;</span><br><span class="line">+      res.end(</span><br><span class="line">+        JSON.stringify(&#123;</span><br><span class="line">+          shouldUpload: false</span><br><span class="line">+        &#125;)</span><br><span class="line">+      );</span><br><span class="line">+    &#125; else &#123;</span><br><span class="line">+      res.end(</span><br><span class="line">+        JSON.stringify(&#123;</span><br><span class="line">+          shouldUpload: true</span><br><span class="line">+        &#125;)</span><br><span class="line">+      );</span><br><span class="line">+    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(3000, () =&gt; console.log(&quot;正在监听 3000 端口&quot;));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><a name="fh147"></a></p><h2 id="暂停上传"><a href="#暂停上传" class="headerlink" title="暂停上传"></a>暂停上传</h2><p>讲完了生成 hash 和文件秒传，回到断点续传<br />断点续传顾名思义即断点 + 续传，所以我们第一步先实现“断点”，也就是暂停上传<br />原理是使用 XMLHttpRequest 的 <code>abort</code> 方法，可以取消一个 xhr 请求的发送，为此我们需要将上传每个切片的 xhr 对象保存起来，我们再改造一下 request 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">request</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  url,</span></span><br><span class="line"><span class="params">  method = <span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="params">  data,</span></span><br><span class="line"><span class="params">  headers = &#123;&#125;,</span></span><br><span class="line"><span class="params">  onProgress = e =&gt; e,</span></span><br><span class="line"><span class="params">  +     requestList</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    xhr.<span class="property">upload</span>.<span class="property">onprogress</span> = onProgress;</span><br><span class="line">    xhr.<span class="title function_">open</span>(method, url);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(headers).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span></span><br><span class="line">      xhr.<span class="title function_">setRequestHeader</span>(key, headers[key])</span><br><span class="line">                                );</span><br><span class="line">    xhr.<span class="title function_">send</span>(data);</span><br><span class="line">    xhr.<span class="property">onload</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      +          <span class="comment">// 将请求成功的 xhr 从列表中删除</span></span><br><span class="line">        +          <span class="keyword">if</span> (requestList) &#123;</span><br><span class="line">          +            <span class="keyword">const</span> xhrIndex = requestList.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item === xhr);</span><br><span class="line">      +            requestList.<span class="title function_">splice</span>(xhrIndex, <span class="number">1</span>);</span><br><span class="line">      +          &#125;</span><br><span class="line">    <span class="title function_">resolve</span>(&#123;</span><br><span class="line">      <span class="attr">data</span>: e.<span class="property">target</span>.<span class="property">response</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  +        <span class="comment">// 暴露当前 xhr 给外部</span></span><br><span class="line">    +        requestList?.<span class="title function_">push</span>(xhr);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样在上传切片时传入 requestList 数组作为参数，request 方法就会将所有的 xhr 保存在数组中了<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300757-94a96d06-f062-4781-88ba-43e341f88d21.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300757-94a96d06-f062-4781-88ba-43e341f88d21.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />每当一个切片上传成功时，将对应的 xhr 从 requestList 中删除，所以 requestList 中只保存<code>正在上传切片的 xhr</code><br />之后新建一个暂停按钮，当点击按钮时，调用保存在 requestList 中 xhr 的 abort 方法，即取消并清空所有正在上传的切片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handlePause() &#123;</span><br><span class="line">    this.requestList.forEach(xhr =&gt; xhr?.abort());</span><br><span class="line">    this.requestList = [];</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300759-fb955ace-99a2-48ae-bc2e-0007baf433ac.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300759-fb955ace-99a2-48ae-bc2e-0007baf433ac.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="zm3d9"></a></p><h2 id="恢复上传"><a href="#恢复上传" class="headerlink" title="恢复上传"></a>恢复上传</h2><p>之前在介绍断点续传的时提到使用第二种服务端存储的方式实现续传<br />由于当文件切片上传后，服务端会建立一个文件夹存储所有上传的切片，所以每次前端上传前可以调用一个接口，服务端将已上传的切片的切片名返回，前端再跳过这些已经上传切片，这样就实现了“续传”的效果<br />而这个接口可以和之前秒传的验证接口合并，前端每次上传前发送一个验证的请求，返回两种结果</p><ul><li>服务端已存在该文件，不需要再次上传</li><li>服务端不存在该文件或者已上传部分文件切片，通知前端进行上传，并把<strong>已上传</strong>的文件切片返回给前端</li></ul><p>所以我们改造一下之前文件秒传的服务端验证接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">extractExt</span> = filename =&gt;</span><br><span class="line">  filename.<span class="title function_">slice</span>(filename.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;.&quot;</span>), filename.<span class="property">length</span>); <span class="comment">// 提取后缀名</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">UPLOAD_DIR</span> = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;..&quot;</span>, <span class="string">&quot;target&quot;</span>); <span class="comment">// 大文件存储目录</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">resolvePost</span> = req =&gt;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> chunk = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      chunk += data;</span><br><span class="line">    &#125;);</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(chunk));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">+  <span class="comment">// 返回已经上传切片名列表</span></span><br><span class="line">  + <span class="keyword">const</span> <span class="title function_">createUploadedList</span> = <span class="keyword">async</span> fileHash =&gt;</span><br><span class="line">    +   fse.<span class="title function_">existsSync</span>(path.<span class="title function_">resolve</span>(<span class="variable constant_">UPLOAD_DIR</span>, fileHash))</span><br><span class="line">    +    ? <span class="keyword">await</span> fse.<span class="title function_">readdir</span>(path.<span class="title function_">resolve</span>(<span class="variable constant_">UPLOAD_DIR</span>, fileHash))</span><br><span class="line">    +    : [];</span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&quot;request&quot;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.<span class="property">url</span> === <span class="string">&quot;/verify&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">resolvePost</span>(req);</span><br><span class="line">    <span class="keyword">const</span> &#123; fileHash, filename &#125; = data;</span><br><span class="line">    <span class="keyword">const</span> ext = <span class="title function_">extractExt</span>(filename);</span><br><span class="line">    <span class="keyword">const</span> filePath = path.<span class="title function_">resolve</span>(<span class="variable constant_">UPLOAD_DIR</span>, <span class="string">`<span class="subst">$&#123;fileHash&#125;</span><span class="subst">$&#123;ext&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">if</span> (fse.<span class="title function_">existsSync</span>(filePath)) &#123;</span><br><span class="line">      res.<span class="title function_">end</span>(</span><br><span class="line">        <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">          <span class="attr">shouldUpload</span>: <span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.<span class="title function_">end</span>(</span><br><span class="line">        <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">          <span class="attr">shouldUpload</span>: <span class="literal">true</span>，</span><br><span class="line">            +         <span class="attr">uploadedList</span>: <span class="keyword">await</span> <span class="title function_">createUploadedList</span>(fileHash)</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;正在监听 3000 端口&quot;</span>));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>接着回到前端，前端有两个地方需要调用验证的接口</p><ul><li>点击上传时，检查是否需要上传和已上传的切片</li><li>点击暂停后的恢复上传，返回已上传的切片</li></ul><p>新增恢复按钮并改造原来上传切片的逻辑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">type</span>=<span class="string">&quot;file&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">@<span class="attr">change</span>=<span class="string">&quot;handleFileChange&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;handleUpload&quot;</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;handlePause&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;isPaused&quot;</span>&gt;</span>暂停<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  +      <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;handleResume&quot;</span> <span class="attr">v-else</span>&gt;</span>恢复<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  //...</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">  +   <span class="keyword">async</span> <span class="title function_">handleResume</span>(<span class="params"></span>) &#123;</span><br><span class="line">  +      <span class="keyword">const</span> &#123; uploadedList &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">verifyUpload</span>(</span><br><span class="line">    +        <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span>,</span><br><span class="line">    +        <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span></span><br><span class="line">    +      );</span><br><span class="line">  +      <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">uploadChunks</span>(uploadedList);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">handleUpload</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> fileChunkList = <span class="variable language_">this</span>.<span class="title function_">createFileChunk</span>(<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span> = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">calculateHash</span>(fileChunkList);</span><br><span class="line">  +     <span class="keyword">const</span> &#123; shouldUpload, uploadedList &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">verifyUpload</span>(</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span>,</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (!shouldUpload) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;秒传：上传成功&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = fileChunkList.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; file &#125;, index</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">fileHash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span>,</span><br><span class="line">    index,</span><br><span class="line">    <span class="attr">hash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span> + <span class="string">&quot;-&quot;</span> + index,</span><br><span class="line">    <span class="attr">chunk</span>: file，</span><br><span class="line">      <span class="attr">percentage</span>: <span class="number">0</span></span><br><span class="line">&#125;));</span><br><span class="line">+      <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">uploadChunks</span>(uploadedList);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 上传切片，同时过滤已上传的切片</span></span><br><span class="line">+   <span class="keyword">async</span> <span class="title function_">uploadChunks</span>(<span class="params">uploadedList = []</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> requestList = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">    +        .<span class="title function_">filter</span>(<span class="function">(<span class="params">&#123; hash &#125;</span>) =&gt;</span> !uploadedList.<span class="title function_">includes</span>(hash))</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; chunk, hash, index &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&quot;chunk&quot;</span>, chunk);</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&quot;hash&quot;</span>, hash);</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&quot;filename&quot;</span>, <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span>);</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&quot;fileHash&quot;</span>, <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span>);</span><br><span class="line">      <span class="keyword">return</span> &#123; formData, index &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="keyword">async</span> (&#123; formData, index &#125;) =&gt;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>: formData,</span><br><span class="line">        <span class="attr">onProgress</span>: <span class="variable language_">this</span>.<span class="title function_">createProgressHandler</span>(<span class="variable language_">this</span>.<span class="property">data</span>[index]),</span><br><span class="line">        <span class="attr">requestList</span>: <span class="variable language_">this</span>.<span class="property">requestList</span></span><br><span class="line">      &#125;)</span><br><span class="line">        );</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(requestList);</span><br><span class="line">  <span class="comment">// 之前上传的切片数量 + 本次上传的切片数量 = 所有切片数量时</span></span><br><span class="line">  <span class="comment">// 合并切片</span></span><br><span class="line">  +      <span class="keyword">if</span> (uploadedList.<span class="property">length</span> + requestList.<span class="property">length</span> === <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">mergeRequest</span>();</span><br><span class="line">    +      &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里给原来上传切片的函数新增 uploadedList 参数，即上图中服务端返回的切片名列表，通过 filter 过滤掉已上传的切片，并且由于新增了已上传的部分，所以之前合并接口的触发条件做了一些改动<br />到这里断点续传的功能基本完成了<br><a name="BsZm5"></a></p><h2 id="进度条改进"><a href="#进度条改进" class="headerlink" title="进度条改进"></a>进度条改进</h2><p>虽然实现了断点续传，但还需要修改一下进度条的显示规则，否则在暂停上传&#x2F;接收到已上传切片时的进度条会出现偏差<br><a name="1s458"></a></p><h3 id="切片进度条-1"><a href="#切片进度条-1" class="headerlink" title="切片进度条"></a>切片进度条</h3><p>由于在点击上传&#x2F;恢复上传时，会调用验证接口返回已上传的切片，所以需要将已上传切片的进度变成 100%</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">handleUpload</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> fileChunkList = <span class="variable language_">this</span>.<span class="title function_">createFileChunk</span>(<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span> = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">calculateHash</span>(fileChunkList);</span><br><span class="line">  <span class="keyword">const</span> &#123; shouldUpload, uploadedList &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">verifyUpload</span>(</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">name</span>,</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (!shouldUpload) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;秒传：上传成功&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">data</span> = fileChunkList.<span class="title function_">map</span>(<span class="function">(<span class="params">&#123; file &#125;, index</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">fileHash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span>,</span><br><span class="line">    index,</span><br><span class="line">    <span class="attr">hash</span>: <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">hash</span> + <span class="string">&quot;-&quot;</span> + index,</span><br><span class="line">    <span class="attr">chunk</span>: file,</span><br><span class="line">    +       <span class="attr">percentage</span>: uploadedList.<span class="title function_">includes</span>(index) ? <span class="number">100</span> : <span class="number">0</span></span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">uploadChunks</span>(uploadedList);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>uploadedList 会返回已上传的切片，在遍历所有切片时判断当前切片是否在已上传列表里即可<br><a name="5zH8x"></a></p><h3 id="文件进度条-1"><a href="#文件进度条-1" class="headerlink" title="文件进度条"></a>文件进度条</h3><p>之前说到文件进度条是一个计算属性，根据所有切片的上传进度计算而来，这就遇到了一个问题<br /><img src="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300751-3d3e923f-9638-4755-9d41-66ecff57f507.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/webp/164572/1588598300751-3d3e923f-9638-4755-9d41-66ecff57f507.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />当点击恢复时，由于重新创建了 xhr 导致切片进度清零，所以总进度条就会倒退<br />解决方案是创建一个“假”的进度条，这个假进度条基于文件进度条，但只会停止和增加，然后给用户展示这个假的进度条<br />这里我们使用 Vue 的监听属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">fakeUploadPercentage</span>: <span class="number">0</span></span><br><span class="line">&#125;),</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="title function_">uploadPercentage</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span> || !<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> loaded = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">      .<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">size</span> * item.<span class="property">percentage</span>)</span><br><span class="line">      .<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>((loaded / <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">file</span>.<span class="property">size</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,  </span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">      <span class="title function_">uploadPercentage</span>(<span class="params">now</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (now &gt; <span class="variable language_">this</span>.<span class="property">fakeUploadPercentage</span>) &#123;</span><br><span class="line">              <span class="variable language_">this</span>.<span class="property">fakeUploadPercentage</span> = now;</span><br><span class="line">            &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当 uploadPercentage 即真的文件进度条增加时，fakeUploadPercentage 也增加，一旦文件进度条后退，假的进度条只需停止即可<br />至此一个大文件上传 + 断点续传的解决方案就完成了<br><a name="93wr5"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大文件上传</p><ul><li>前端上传大文件时使用 Blob.prototype.slice 将文件切片，并发上传多个切片，最后发送一个合并的请求通知服务端合并切片</li><li>服务端接收切片并存储，收到合并请求后使用流将切片合并到最终文件</li><li>原生 XMLHttpRequest 的 upload.onprogress 对切片上传进度的监听</li><li>使用 Vue 计算属性根据每个切片的进度算出整个文件的上传进度</li></ul><p>断点续传</p><ul><li>使用 spark-md5 根据文件内容算出文件 hash</li><li>通过 hash 可以判断服务端是否已经上传该文件，从而直接提示用户上传成功（秒传）</li><li>通过 XMLHttpRequest 的 abort 方法暂停切片的上传</li><li>上传前服务端返回已经上传的切片名，前端跳过这些切片的上传<br><a name="tYWqU"></a></li></ul><h1 id="反馈的问题"><a href="#反馈的问题" class="headerlink" title="反馈的问题"></a>反馈的问题</h1><p>部分功能由于不方便测试，这里列出评论区收集到的一些问题，有兴趣的朋友可以提出你的想法&#x2F;写个 demo 进一步交流</p><ul><li>没有做切片上传失败的处理</li><li>使用 web socket 由服务端发送进度信息</li><li>打开页面没有自动获取上传切片，而需要主动再次上传一次后才显示<br><a name="vczKu"></a></li></ul><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p>源代码增加了一些按钮的状态，交互更加友好，文章表达比较晦涩的地方可以跳转到源代码查看<br /><a href="https://github.com/yeyan1996/file-upload">file-upload</a></p><p><a name="toFhM"></a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://juejin.im/post/5da14778f265da5bb628e590">写给新手前端的各种文件上传攻略，从小图片到大文件断点续传</a><br /><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice">Blob.slice</a></p><blockquote><p>链接：<a href="https://juejin.im/post/5dff8a26e51d4558105420ed">https://juejin.im/post/5dff8a26e51d4558105420ed</a><br>来源：掘金<br>时间：2020-01-13</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
          <category> 浏览器 </category>
          
          <category> 解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 大文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代浏览器内部揭秘</title>
      <link href="/2022/03/16/frontend/browser/xian-dai-liu-lan-qi-nei-bu-jie-mi/"/>
      <url>/2022/03/16/frontend/browser/xian-dai-liu-lan-qi-nei-bu-jie-mi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="f3a2f325"></a></p><h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><p>从高级视角对浏览器架构与多进程架构的优点进行阐述。我们也对 Chrome 中与多进程架构密切相关的服务化与站点隔离进行了讲解。<br><a name="5c888d03"></a></p><h2 id="CPU、GPU、内存和多进程体系结构"><a href="#CPU、GPU、内存和多进程体系结构" class="headerlink" title="CPU、GPU、内存和多进程体系结构"></a>CPU、GPU、内存和多进程体系结构</h2><p>这一博客系列由四部分组成，将从高级体系结构到渲染流程的细节来窥探 Chrome 浏览器的内部。如果你曾对浏览器是如何将代码转化为具有功能的网站，或者你并不确定为何建议使用某一技术来提升性能，那么本系列就是为你准备的。</p><p>本文作为此系列的第一部分，将介绍核心计算术语与 Chrome 的多进程体系架构。</p><p><strong>提示：</strong> 如果你已熟悉 CPU&#x2F;GPU，进程&#x2F;线程的相关概念，可以直接跳到<a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84">浏览器架构</a>部分开始阅读。</p><p><a name="b70385d9"></a></p><h2 id="计算机的核心是-CPU-与-GPU"><a href="#计算机的核心是-CPU-与-GPU" class="headerlink" title="计算机的核心是 CPU 与 GPU"></a>计算机的核心是 CPU 与 GPU</h2><p>为了了解浏览器运行的环境，我们需要了解几个计算机部件以及它们的作用。</p><p><a name="CPU"></a></p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615206916-bd6e36d0-2361-45d1-8003-41e113c8a57f.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615206916-bd6e36d0-2361-45d1-8003-41e113c8a57f.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 1：4 个 CPU 核心作为办公人员，坐在办公桌前处理各自的工作</p><p>第一个需要了解的计算机部件是 <strong>中央处理器（Central Processing Unit）</strong>，或简称为 <strong>CPU</strong>。CPU 可以看作是计算机的大脑。一个 CPU 核心如图中的办公人员，可以逐一解决很多不同任务。它可以在解决从数学到艺术一切任务的同时还知道如何响应客户要求。过去 CPU 大多是单芯片的，一个核心就像存在于同芯片的另一个 CPU。随着现代硬件发展，你经常会有不止一个内核，为你的手机和笔记本电脑提供更多的计算能力。</p><p><a name="GPU"></a></p><h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615214916-e56c86c5-73d2-435b-a15d-a4d054a497e9.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615214916-e56c86c5-73d2-435b-a15d-a4d054a497e9.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 2：许多带特定扳手的 GPU 内核意味着它们只能处理有限任务</p><p><strong>图形处理器</strong>（<strong>Graphics Processing Unit</strong>，简称为 <strong>GPU</strong>）是计算机的另一部件。与 CPU 不同，GPU 擅长同时处理跨内核的简单任务。顾名思义，它最初是为解决图形而开发的。这就是为什么在图形环境中“使用 GPU” 或 “GPU 支持”都与快速渲染和顺滑交互有关。近年来随着 GPU 加速计算的普及，仅靠 GPU 一己之力也使得越来越多的计算成为可能。</p><p>当你在电脑或手机上启动应用时，是 CPU 和 GPU 为应用供能。通常情况下应用是通过操作系统提供的机制在 CPU 和 GPU 上运行。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615221906-3c30dd92-c25a-4932-988d-b43103afd2f4.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615221906-3c30dd92-c25a-4932-988d-b43103afd2f4.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 3：三层计算机体系结构。底部是机器硬件，中间是操作系统，顶部是应用程序。</p><p><a name="0db1a238"></a></p><h2 id="在进程和线程上执行程序"><a href="#在进程和线程上执行程序" class="headerlink" title="在进程和线程上执行程序"></a>在进程和线程上执行程序</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615229734-f013746e-2986-422f-a34c-14e878197431.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615229734-f013746e-2986-422f-a34c-14e878197431.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图四：进程作为边界框，线程作为抽象鱼在进程中游动</p><p>在深入学习浏览器架构之前需要了解的另一个理论是进程与线程。进程可以被描述为是一个应用的执行程序。线程存在于进程并执行程序任意部分。</p><p>启动应用时会创建一个进程。程序也许会创建一个或多个线程来帮助它工作，这是可选的。操作系统为进程提供了一个可以使用的“一块”内存，所有应用程序状态都保存在该私有内存空间中。关闭应用程序时，相应的进程也会消失，操作系统会释放内存。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/svg/164572/1599615438699-00069387-aaa0-4594-95fd-1875d9d4b287.svg#height=469&id=fyFkB&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=252656&status=done&style=none&title=&width=853" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/svg/164572/1599615438699-00069387-aaa0-4594-95fd-1875d9d4b287.svg#height=469&id=fyFkB&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=252656&status=done&style=none&title=&width=853" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="1..svg"></p><p>图 5 ：进程使用内存空间和存储应用数据的示意图</p><p>进程可以请求操作系统启动另一个进程来执行不同的任务。此时，内存中的不同部分会分给新进程。如果两个进程需要对话，他们可以通过<strong>进程间通信</strong>（<strong>IPC</strong>）来进行。许多应用都是这样设计的，所以如果一个工作进程失去响应，该进程就可以在不停止应用程序不同部分的其他进程运行的情况下重新启动。<br /><img src="https://cdn.nlark.com/yuque/0/2020/svg/164572/1599615773729-459bc3e3-9d03-4af9-a5d0-5a11276a034f.svg#height=470&id=caSEM&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=293505&status=done&style=none&title=&width=855" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/svg/164572/1599615773729-459bc3e3-9d03-4af9-a5d0-5a11276a034f.svg#height=470&id=caSEM&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=293505&status=done&style=none&title=&width=855" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="2.svg"></p><p>图 6：独立进程通过 IPC 通信示意图</p><p><a name="c4f5cabc"></a></p><h2 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h2><p>那么如何通过进程和线程构建 web 浏览器呢？它可能由一个拥有很多线程的进程，或是一些通过 IPC 通信的不同线程的进程。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615781904-137d5260-8f05-4773-9a44-1e650ac38709.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615781904-137d5260-8f05-4773-9a44-1e650ac38709.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 7：不同浏览器架构的进程&#x2F;线程示意图</p><p>这里需要注意的重要一点是，这些不同的架构是实现细节。关于如何构建 web 浏览器并不存在标准规范。一个浏览器的构建方法可能与另一个迥然不同。</p><p>在本博客系列中，我们使用下图所示的 Chrome 近期架构进行阐述。</p><p>顶部是浏览器进程，它与处理应用其它模块任务的进程进行协调。对于渲染进程来说，创建了多个渲染进程并分配给了每个标签页。直到最近，Chrome 在可能的情况下给每个标签页分配一个进程。而现在它试图给每个站点分配一个进程，包括 iframe（参见<a href="#%E6%AF%8F%E4%B8%AA-iframe-%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B--%E7%AB%99%E7%82%B9%E9%9A%94%E7%A6%BB">站点隔离</a>）。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615789037-3b5c5445-dc91-4673-bbbd-55d5f618fc0c.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615789037-3b5c5445-dc91-4673-bbbd-55d5f618fc0c.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 8：Chrome 的多进程架构示意图。渲染进程下显示了多个层，表明 Chrome 为每个标签页运行多个渲染进程。</p><p><a name="51b19fbc"></a></p><h2 id="进程各自控制什么？"><a href="#进程各自控制什么？" class="headerlink" title="进程各自控制什么？"></a>进程各自控制什么？</h2><p>下表展示每个 Chrome 进程与各自控制的内容：</p><table><thead><tr><th>进程</th><th>控制</th></tr></thead><tbody><tr><td>浏览器</td><td>控制应用中的 “Chrome” 部分，包括地址栏，书签，回退与前进按钮。以及处理 web 浏览器不可见的特权部分，如网络请求与文件访问。</td></tr><tr><td>渲染</td><td>控制标签页内网站展示。</td></tr><tr><td>插件</td><td>控制站点使用的任意插件，如 Flash。</td></tr><tr><td>GPU</td><td>处理独立于其它进程的 GPU 任务。GPU 被分成不同进程，因为 GPU 处理来自多个不同应用的请求并绘制在相同表面。</td></tr></tbody></table><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615796495-74e3b320-3435-410e-af32-f60c66a1b8d2.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615796495-74e3b320-3435-410e-af32-f60c66a1b8d2.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 9：不同进程指向浏览器 UI 的不同部分</p><p>还有更多进程如扩展进程与应用进程。如果你想要了解有多少进程运行在你的 Chrome 浏览器中，可以点击右上角的选项菜单图标，选择更多工具，然后选择任务管理器。然后会打开一个窗口，其中列出了当前正在运行的进程以及它们当前的 CPU&#x2F;内存使用量。</p><p><a name="66ec77ef"></a></p><h2 id="Chrome-多进程架构的优点"><a href="#Chrome-多进程架构的优点" class="headerlink" title="Chrome 多进程架构的优点"></a>Chrome 多进程架构的优点</h2><p>前文中提到了 Chrome 使用多个渲染进程。最简单的情况下，你可以想象每个标签页都有自己的渲染进程。假设你打开了三个标签页，每个标签页都拥有自己独立的渲染进程。如果某个标签页失去响应，你可以关掉这个标签页，此时其它标签页依然运行着，可以正常使用。如果所有标签页都运行在同一进程上，那么当某个失去响应，所有标签页都会失去响应。这样的体验很糟糕。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/svg/164572/1599615825071-23986c0a-3ff0-424c-b4b4-d198b010ea9f.svg#height=572&id=jj7Fj&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=112568&status=done&style=none&title=&width=1041" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/svg/164572/1599615825071-23986c0a-3ff0-424c-b4b4-d198b010ea9f.svg#height=572&id=jj7Fj&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=112568&status=done&style=none&title=&width=1041" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="3.svg"></p><p>图 10：如图所示每个标签页上运行的渲染进程</p><p>把浏览器工作分成多个进程的另一好处是安全性与沙箱化。由于操作系统提供了限制进程权限的方法，浏览器就可以用沙箱保护某些特定功能的进程。例如，Chrome 浏览器限制处理任意用户输入的进程(如渲染器进程)对任意文件的访问。</p><p>由于进程有自己的私有内存空间，所以它们通常包含公共基础设施的拷贝(如 V8，它是 Chrome 的 JavaScript 引擎)。这意味着使用了更多的内存，如果它们是同一进程中的线程，就无法共享这些拷贝。为了节省内存，Chrome 对可加速的内存数量进行了限制。具体限制数值依设备可提供的内存与 CPU 能力而定，但是当 Chrome 运行时达到限制时，会开始在同一站点的不同标签页上运行同一进程。</p><p><a name="f48608af"></a></p><h2 id="节省更多内存-——-Chrome-中的服务化"><a href="#节省更多内存-——-Chrome-中的服务化" class="headerlink" title="节省更多内存 —— Chrome 中的服务化"></a>节省更多内存 —— Chrome 中的服务化</h2><p>同样的方法也适用于浏览器进程。Chrome 正在经历架构变革，它转变为将浏览器程序的每一模块作为一个服务来运行，从而可以轻松实现进程的拆解或聚合。</p><p>通常观点是当 Chrome 运行在强力硬件上时，它会将每个服务分解到不同进程中，从而提升稳定性，但是如果 Chrome 运行在资源有限的设备上时，它会将服务聚合到一个进程中从而节省了内存占用。在这一架构变革实现前，类似的整合进程以减少内存使用的方法已经在 Android 类平台上使用。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/svg/164572/1599615881070-8a96f98c-ee7c-4809-b631-c6000a1f2efb.svg#height=547&id=U2F2c&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=335942&status=done&style=none&title=&width=995" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/svg/164572/1599615881070-8a96f98c-ee7c-4809-b631-c6000a1f2efb.svg#height=547&id=U2F2c&originHeight=150&originWidth=273&originalType=binary&ratio=1&rotation=0&showTitle=false&size=335942&status=done&style=none&title=&width=995" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="4.svg"></p><p>图 11： Chrome 的服务化图，将不同的服务移动到多个进程和单个浏览器进程中</p><p><a name="a6731ad1"></a></p><h2 id="每个-iframe-的渲染进程-——-站点隔离"><a href="#每个-iframe-的渲染进程-——-站点隔离" class="headerlink" title="每个 iframe 的渲染进程 —— 站点隔离"></a>每个 iframe 的渲染进程 —— 站点隔离</h2><p><a href="https://developers.google.com/web/updates/2018/07/site-isolation">站点隔离</a> 是近期引入到 Chrome 中的一个功能，它为每个 iframe 运行一个单独的渲染进程。我们已经讨论了许久每个标签页的渲染进程，它允许跨站点 iframe 运行在一个单独的渲染进程，在不同站点中共享内存。运行 a.com 与 b.com 在同一渲染进程中看起来还 ok。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">同源策略</a> 是 web 的核心安全模型。同源策略确保站点在未得到其它站点许可的情况下不能获取其数据。安全攻击的一个主要目标就是绕过同源策略。进程隔离是分离站点的最高效的手段。随着 <a href="https://developers.google.com/web/updates/2018/02/meltdown-spectre">Meltdown and Spectre</a> 的出现，使用进程来分离站点愈发势在必行。Chrome 67 版本后，桌面版 Chrome 都默认开启了站点隔离，每个标签页的 iframe 都有一个单独的渲染进程。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615869857-83aa8ae0-9caa-4c58-b746-5e6ead89bfe3.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599615869857-83aa8ae0-9caa-4c58-b746-5e6ead89bfe3.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 12：站点隔离示意图，多个渲染进程指向站点内的 iframe</p><p>启用站点隔离是多年来工程人员努力的结果。站点隔离并不只是分配不同的渲染进程这么简单。它从根本上改变了 iframe 的通信方式。在一个页面上打开开发者工具，让 iframe 在不同的进程上运行，这意味着开发者工具必须在幕后工作，以使它看起来无缝。即使运行一个简单的 Ctrl + F 来查找页面中的一个单词，也意味着在不同的渲染器进程中进行搜索。你可以看到为什么浏览器工程师把发布站点隔离功能作为一个重要里程碑！</p><p><a name="25f9c7fa"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一部分从高级视角对浏览器架构与多进程架构的优点进行阐述。我们也对 Chrome 中与多进程架构密切相关的服务化与站点隔离进行了讲解。下一部分中，我们将开始深入了解进程与线程中到底发生了什么才能使网站得以呈现。</p><p><a name="QWTre"></a></p><h1 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h1><p>在这一部分中，我们研究了导航过程中发生了什么，以及你的 Web 应用代码（例如响应头和客户端 JavaScript）如何与浏览器交互。了解浏览器通过网络获取数据的步骤，可以更容易地理解为什么开发导航预加载等 API。<br><a name="8ab505b2"></a></p><h2 id="导航时发生了什么"><a href="#导航时发生了什么" class="headerlink" title="导航时发生了什么"></a>导航时发生了什么</h2><p>这是关于 Chrome 内部工作的 4 篇博客系列的第 2 篇。在<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/inside-look-at-modern-web-browser-part1.md">上一篇文章</a>中，我们研究了不同的进程和线程如何处理浏览器的不同部分。在这篇文章中，我们会更深入研究每个进程和线程如何进行通信以展示网站。</p><p>让我们看一个网络浏览的简单用例：你在浏览器中键入 URL，然后浏览器从互联网获取数据并显示一个页面。在这篇文章中，我们将重点放在用户请求站点和浏览器准备渲染页面部分 —— 亦即导航。</p><p><a name="411db4a0"></a></p><h2 id="它以浏览器进程开始"><a href="#它以浏览器进程开始" class="headerlink" title="它以浏览器进程开始"></a>它以浏览器进程开始</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616629080-71613c80-dc9d-4060-ab0c-4881b94a2d82.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616629080-71613c80-dc9d-4060-ab0c-4881b94a2d82.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 1：顶部是浏览器 UI，底部是拥有 UI、网络和存储线程的浏览器进程图</p><p>正如我们在<a href="https://developers.google.com/web/updates/2018/09/inside-browser-part1">第 1 部分：CPU、GPU、内存和多进程架构</a>中所述，tab 外的一切都被浏览器进程处理。浏览器进程有很多线程，例如绘制浏览器按钮和输入栏的 UI 线程、处理网络栈以从因特网获取数据的网络线程、控制文件访问的存储线程等。当你在地址栏中键入 URL 时，你的输入将由浏览器进程的 UI 线程处理。</p><p><a name="ed797f7d"></a></p><h2 id="一个简单导航"><a href="#一个简单导航" class="headerlink" title="一个简单导航"></a>一个简单导航</h2><p><a name="a58a4caa"></a></p><h3 id="第-1-步：处理输入"><a href="#第-1-步：处理输入" class="headerlink" title="第 1 步：处理输入"></a>第 1 步：处理输入</h3><p>当用户开始在地址栏键入时，UI 线程要问的第一件事是 “这是一次搜索查询还是一个 URL 地址？”。在 Chrome 中，地址栏同时也是一个搜索输入栏，所以 UI 线程需要解析和决定把你的请求发送到搜索引擎，或是你要请求的网站。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616639583-201e787d-6b70-475c-ad10-f1c89fcbef26.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616639583-201e787d-6b70-475c-ad10-f1c89fcbef26.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 1：UI 线程询问输入内容是搜索查询还是 URL 地址</p><p><a name="b6e4ae45"></a></p><h3 id="第-2-步：开始导航"><a href="#第-2-步：开始导航" class="headerlink" title="第 2 步：开始导航"></a>第 2 步：开始导航</h3><p>当用户按下 Enter 键时，UI 线程启用网络调取去获取站点内容。加载动画会显示在标签页的一角，网络线程会通过适当的协议，像 DNS 查找和为请求建立 TLS 连接。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616647692-f5f7ac6a-56da-4c97-a0be-0037caaee21a.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616647692-f5f7ac6a-56da-4c97-a0be-0037caaee21a.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 2：UI 线程告诉网络线程要导航到 mysite.com</p><p>在这时，网络线程可能会收到像 HTTP 301 那样的服务器重定向头。这种情况下，网络线程会告诉 UI 线程，服务器正在请求重定向。然后，另一个 URL 请求会被启动。</p><p><a name="3d24bd80"></a></p><h3 id="第-3-步：读取响应"><a href="#第-3-步：读取响应" class="headerlink" title="第 3 步：读取响应"></a>第 3 步：读取响应</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616655237-2b7498c1-ada4-4ce9-a5a6-bc15d0a23d78.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616655237-2b7498c1-ada4-4ce9-a5a6-bc15d0a23d78.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 3：包含 Content-Type 的响应头以及作为实际数据的 payload</p><p>一旦开始收到响应主体（payload），网络线程会在必要时查看数据流的前几个字节。响应报文的 Content-Type 字段会声明数据的类型，但是它有可能会丢失或者错误，所以就有了 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME 类型嗅探</a>来解决这个问题。这是<a href="https://cs.chromium.org/chromium/src/net/base/mime_sniffer.cc?sq=package:chromium&dr=CS&l=5">源码</a>中评论的“棘手的问题”。你可以阅读注释看一下不同浏览器是怎么匹配 content-type 和 payload 的。</p><p>如果响应是一个 HTML 文件，那么下一步就会把数据传给渲染进程，但是如果是一个压缩文件或是其他文件，那么意味着它是一个下载请求，因此需要将数据传递给下载管理器。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616663436-4894518e-5d3a-4188-aa23-500219fbf360.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616663436-4894518e-5d3a-4188-aa23-500219fbf360.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 4：网络线程询问一个响应数据是否是从安全网站来的 HTML</p><p>此时也会进行 <a href="https://safebrowsing.google.com/">SafeBrowsing</a> 检查。如果域名和响应数据似乎匹配到一个已知的恶意网站，那么网络线程会显示一个警告页面。除此之外，还会发生 <a href="https://www.chromium.org/Home/chromium-security/corb-for-developers"><strong>C</strong>ross <strong>O</strong>rigin <strong>R</strong>ead <strong>B</strong>locking（<strong>CORB</strong>）</a>检查，以确保敏感的跨域数据不被传给渲染进程。</p><p><a name="173d1c10"></a></p><h3 id="第-4-步：查找渲染进程"><a href="#第-4-步：查找渲染进程" class="headerlink" title="第 4 步：查找渲染进程"></a>第 4 步：查找渲染进程</h3><p>一旦所有的检查执行完毕并且网络线程确信浏览器会导航到请求的站点，网络线程会告诉 UI 线程所有的数据准备完毕。UI 线程会寻找渲染进程去开始渲染 web 页面。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616671566-4f5fb6f4-6e70-49d8-815e-123eba318282.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616671566-4f5fb6f4-6e70-49d8-815e-123eba318282.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 5：网络线程告诉 UI 线程去查找渲染进程</p><p>由于网络请求会花费几百毫秒才获取回响应，因此可以应用一个优化措施。当第 2 步 UI 线程正发送一个 URL 请求给网络线程时，它已经知道它们会导航到哪个站点。在网络请求的同时，UI 并行地线程尝试主动寻找或开启一个渲染进程。这样，如果一切按预期进行，渲染进程在网络线程接受到数据时就已经处于待命状态。如果导航跨域重定向，这个待命进程也许不会被用到，这种情况下也许会用到另一个进程。</p><p><a name="100537ff"></a></p><h3 id="第-5-步：提交导航"><a href="#第-5-步：提交导航" class="headerlink" title="第 5 步：提交导航"></a>第 5 步：提交导航</h3><p>现在数据和渲染进程已经就绪，浏览器进程会发送一个 IPC（进程间通信）到渲染进程去提交导航。它也会传递数据流，所以渲染进程可以保持接收 HTML 数据。一旦浏览器进程收到渲染进程已经提交的确认消息，导航完毕并且文档加载解析开始。</p><p>这时，地址栏已经更新，安全指示器和站点设置 UI 会反映新页面的站点信息。此标签页的 session 历史记录会被更新，所以前进&#x2F;后退按钮会走向刚导航过的站点。当你关闭标签页或者窗口，为了优化 tab&#x2F;session 的还原，session 历史被保存在硬盘上。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616678923-54b99257-537d-4270-a328-80990815d56a.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616678923-54b99257-537d-4270-a328-80990815d56a.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 6：浏览器和渲染进程间的 IPC，请求渲染页面。</p><p><a name="7803eae1"></a></p><h3 id="额外的步骤：初始加载完毕"><a href="#额外的步骤：初始加载完毕" class="headerlink" title="额外的步骤：初始加载完毕"></a>额外的步骤：初始加载完毕</h3><p>一旦导航被提交，渲染进程开始加载资源和渲染页面。我们将在下一篇文章中讲解这个阶段发生什么的细节。一旦渲染进程渲染“完毕”。它会发送一个 IPC 返回给浏览器进程（这会在页面所有的 frame 的 <code>onload</code> 事件已经触发和执行完毕后发生）。这时，UI 线程停止标签页上的加载动画。</p><p>我之所以说“结束”，是因为客户端 JavaScript 可以在这时之后仍然加载额外的资源并且渲染新视图。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616687543-a2d03be1-4e28-4723-9d7c-6872a3f1b2db.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616687543-a2d03be1-4e28-4723-9d7c-6872a3f1b2db.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 7：渲染进程发送 IPC 到浏览器进程通知页面“已被加载”</p><p><a name="36edc000"></a></p><h2 id="导航到另一个站点"><a href="#导航到另一个站点" class="headerlink" title="导航到另一个站点"></a>导航到另一个站点</h2><p>简单导航已经完毕！但是用户在地址栏输入另一个 URL 会怎样呢？好吧，浏览器进程会执行相同的步骤来导航到一个不同的站点。但是在它做这个之前，它会检查当前已经渲染的站点是否关心 <code>[beforeunload](https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload)</code> 事件。</p><p><code>beforeunload</code> 可以在你试图导航离开或关闭标签页时创建“离开此站点？”警告。包括你的 JavaScript 代码，所有标签页内的东西都是由渲染进程处理，所以当新的导航请求到来时，浏览器进程必须要跟当前的渲染进程核对。</p><p><strong>注意：</strong> 不要添加无条件的 <code>beforeunload</code> 处理程序。它会产生更多延迟，因为处理程序需要在导航开始之前执行。应仅在需要时添加此事件处理程序，例如如果需要警告用户他们可能会丢失他们在页面上输入的数据。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616695201-b12476a2-7646-4e29-8767-12181fee08bb.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616695201-b12476a2-7646-4e29-8767-12181fee08bb.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 8：浏览器进程向渲染进程发送 IPC 告诉它将要导航到另一个站点</p><p>如果渲染进程已经启动了导航（像用户点击一个链接或者客户端 JavaScript 运行 <code>window.location = &quot;https://newsite.com&quot;</code>），渲染进程会先检查 <code>beforeunload</code> 事件处理程序。然后，它会像浏览器处理启动导航一样执行相同的步骤。唯一不同的是导航请求是由渲染进程发送到浏览器进程的。</p><p>当新导航到的站点不同于当前已渲染的站点时，会调用一个独立的渲染进程来处理新导航，同时保持当前的渲染进程来处理类似 <code>unload</code> 的事件。有关更多信息，请查看<a href="https://developers.google.com/web/updates/2018/07/page-lifecycle-api#overview_of_page_lifecycle_states_and_events">页面生命周期概览</a>以及如何使用<a href="https://developers.google.com/web/updates/2018/07/page-lifecycle-api">页面生命周期 API</a> 挂钩事件。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616702471-aa906884-5366-4bd6-b6ab-dd048ad7cb2e.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616702471-aa906884-5366-4bd6-b6ab-dd048ad7cb2e.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 9：2 个 IPC（从浏览器进程到新渲染进程）告知渲染页面并告知旧渲染进程卸载</p><p><a name="029568fa"></a></p><h2 id="如果有-Service-Worker"><a href="#如果有-Service-Worker" class="headerlink" title="如果有 Service Worker"></a>如果有 Service Worker</h2><p>最近对导航过程的改变是引入了 <a href="https://developers.google.com/web/fundamentals/primers/service-workers/">service worker</a>。service worker 是一种在你的应用代码中编写网络代理的方法；允许 Web 开发者更好地控制本地缓存内容以及何时从网络获取新数据。如果将 service worker 设置为从缓存加载页面，则无需从网络请求数据。</p><p>要记住的重要部分是 Service Worker 是在渲染进程中运行的 JavaScript 代码。但是当导航请求进入时，浏览器进程如何知道该站点有 service worker？</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616710231-89d5d6a3-5827-4717-8076-71367fde731b.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616710231-89d5d6a3-5827-4717-8076-71367fde731b.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 10：浏览器进程中的网络线程查找 service worker 作用域</p><p>当注册一个 service worker 时，保持 service worker 的作用域作为一个引用（你可以在这篇文章 <a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle">The Service Worker Lifecycle</a> 中阅读更多关于作用域的知识）。当一个导航发生时，网络线程用已注册的 service worker 作用域来检查域名，如果已经为该 URL 注册了一个 service worker，UI 线程会找一个渲染线程来执行 service worker 的代码。service worker 可能从缓存中加载数据，无需从网络请求数据，或者可以从网络请求新资源。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616718334-55df6bb4-02d3-4095-8f23-e85d12575e97.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616718334-55df6bb4-02d3-4095-8f23-e85d12575e97.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 11：浏览器中的 UI 线程启动渲染进程来处理 service workers；然后，渲染进程中的工作线程从网络请求数据</p><p><a name="8f24f2b0"></a></p><h2 id="导航预加载"><a href="#导航预加载" class="headerlink" title="导航预加载"></a>导航预加载</h2><p>你可以看到，如果 service worker 最终决定从网络请求数据，则浏览器进程和渲染器进程之间的往返可能会导致延迟。<a href="https://developers.google.com/web/updates/2017/02/navigation-preload">导航预加载</a>是一种通过与 service worker 启动并行加载资源来加速此过程的机制。它用一个头部来标记这些请求，允许服务器决定为这些请求发送不同的内容；例如，只更新数据而不是完整文档。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616726140-177b3ee3-c297-4992-99e7-4f01fee661f0.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616726140-177b3ee3-c297-4992-99e7-4f01fee661f0.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 12：浏览器进程中的 UI 线程启动渲染进程以在并行启动网络请求的同时处理 service worker</p><p><a name="sZRMf"></a></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>在这一部分中，我们研究了导航过程中发生了什么，以及你的 Web 应用代码（例如响应头和客户端 JavaScript）如何与浏览器交互。了解浏览器通过网络获取数据的步骤，可以更容易地理解为什么开发导航预加载等 API。在下一部分，我们将深入探讨浏览器如何分析 HTML&#x2F;CSS&#x2F;JavaScript 以渲染页面。</p><p><a name="KOvVu"></a></p><h1 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h1><p>研究了渲染管道从解析到合成的整个过程，希望现在你能自主地去了解更多关于网站性能优化的信息。<br><a name="8c6116f2"></a></p><h2 id="渲染进程的内部机制"><a href="#渲染进程的内部机制" class="headerlink" title="渲染进程的内部机制"></a>渲染进程的内部机制</h2><p>这是关于浏览器工作原理博客系列四部分中的第三部分。之前，我们介绍了<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/inside-look-at-modern-web-browser-part1.md">多进程架构</a>和<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/inside-browser-part2.md">导航流</a>。在这篇文章中，我们将一探渲染进程的内部机制。</p><p>渲染进程涉及 Web 性能的许多方面。由于渲染进程的流程太复杂，因此本文只进行概述。如果你想深入了解，可以在 <a href="https://developers.google.com/web/fundamentals/performance/why-performance-matters/">the Performance section of Web Fundamentals</a> 找到相关资源。</p><p><a name="18e79a87"></a></p><h2 id="渲染进程处理网站内容"><a href="#渲染进程处理网站内容" class="headerlink" title="渲染进程处理网站内容"></a>渲染进程处理网站内容</h2><p>渲染进程负责标签页内发生的所有事情。在渲染进程中，主线程处理服务器发送到用户的大部分代码。如果你使用 web worker 或 service worker，部分 JavaScript 将由工作线程处理。合成和光栅线程也在渲染进程内运行，以高效，流畅地呈现页面。</p><p>渲染进程的核心工作是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616941594-ca3421d9-31e1-4abd-92fd-779a23dae629.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616941594-ca3421d9-31e1-4abd-92fd-779a23dae629.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 1：渲染进程内部包含主线程、工作线程、合成线程和光栅线程</p><p><a name="a183a12f"></a></p><h2 id="解析（Parsing）"><a href="#解析（Parsing）" class="headerlink" title="解析（Parsing）"></a>解析（Parsing）</h2><p><a name="f9a2b4e6"></a></p><h3 id="DOM-的构建"><a href="#DOM-的构建" class="headerlink" title="DOM 的构建"></a>DOM 的构建</h3><p>当渲染进程收到导航的提交消息并开始接收 HTML 数据时，主线程开始解析文本字符串（HTML）并将其转换为文档对象模型（<strong>DOM</strong>）。</p><p>DOM 是一个页面在浏览器内部表现，也是 Web 开发人员可以通过 JavaScript 与之交互的数据结构和 API。</p><p>将 HTML 到 DOM 的解析由 <a href="https://html.spec.whatwg.org/">HTML Standard</a> 规定。你可能已经注意到，将 HTML 提供给浏览器这一过程从不会引发错误。像 <code>Hi! &lt;b&gt;I&#39;m &lt;i&gt;Chrome&lt;/b&gt;!&lt;/i&gt;</code> 这样的错误标记，会被理解为 <code>Hi! &lt;b&gt;I&#39;m &lt;i&gt;Chrome&lt;/i&gt;&lt;/b&gt;&lt;i&gt;!&lt;/i&gt;</code>，这是因为 HTML 规范会优雅地处理这些错误。如果你好奇这是如何做到的，可以阅读 <a href="https://html.spec.whatwg.org/multipage/parsing.html#an-introduction-to-error-handling-and-strange-cases-in-the-parser">An introduction to error handling and strange cases in the parser</a> 的 HTML 规范部分。</p><p><a name="d50d30c4"></a></p><h3 id="子资源加载"><a href="#子资源加载" class="headerlink" title="子资源加载"></a>子资源加载</h3><p>网站通常使用图像、CSS 和 JavaScript 等外部资源，这些文件需要从网络或缓存加载。在解析构建 DOM 时，主线程<strong>会</strong>按处理顺序逐个请求它们，但为了加快速度，“预加载扫描器（preload scanner）”会同时运行。如果 HTML 文档中有 <code>&lt;img&gt;</code> 或 <code>&lt;link&gt;</code> 之类的内容，则预加载扫描器会查看由 HTML 解析器生成的标记，并在浏览器进程中向网络线程发送请求。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616952605-b7b99bd3-bb18-4210-a9a7-fccc901e9247.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616952605-b7b99bd3-bb18-4210-a9a7-fccc901e9247.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 2：主线程解析 HTML 并构建 DOM 树</p><p><a name="f8b53b9a"></a></p><h3 id="JavaScript-阻塞解析"><a href="#JavaScript-阻塞解析" class="headerlink" title="JavaScript 阻塞解析"></a>JavaScript 阻塞解析</h3><p>当 HTML 解析器遇到 <code>&lt;script&gt;</code> 标记时，会暂停解析 HTML 文档，开始加载、解析并执行 JavaScript 代码。为什么？因为JavaScript 可以使用诸如 <code>document.write()</code> 的方法来改写文档，这会改变整个 DOM 结构（HTML 规范里的 <a href="https://html.spec.whatwg.org/multipage/parsing.html#overview-of-the-parsing-model">overview of the parsing model</a> 中有一张不错的图片）。这就是 HTML 解析器必须等待 JavaScript 运行后再继续解析 HTML 文档原因。如果你对 JavaScript 执行中发生的事情感到好奇，可以看看 <a href="https://mathiasbynens.be/notes/shapes-ics">V8 团队就此发表的演讲和博客文章</a>。</p><p><a name="c202620e"></a></p><h2 id="提示浏览器如何加载资源"><a href="#提示浏览器如何加载资源" class="headerlink" title="提示浏览器如何加载资源"></a>提示浏览器如何加载资源</h2><p>Web 开发者可以通过多种方式向浏览器发送提示，以便很好地加载资源。如果你的 JavaScript 不使用 <code>document.write()</code>，你可以在 <code>&lt;script&gt;</code> 标签添加 <code>[async](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-async)</code> 或 <code>[defer](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-defer)</code> 属性，这样浏览器会异步加载运行 JavaScript 代码，而不阻塞解析。如果合适，你也可以使用 <a href="https://developers.google.com/web/fundamentals/primers/modules">JavaScript 模块</a>。可以使用 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 告知浏览器当前导航肯定需要该资源，并且你希望尽快下载。有关详细信息请参阅 <a href="https://developers.google.com/web/fundamentals/performance/resource-prioritization">Resource Prioritization – Getting the Browser to Help You</a>。</p><p><a name="89480b0f"></a></p><h2 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h2><p>只拥有 DOM 不足以确定页面的外观，因为我们会在 CSS 中设置页面元素的样式。主线程解析 CSS 并确定每个 DOM 节点计算后的样式。这是有关基于 CSS 选择器对每个元素应用何种样式的信息，这可以在 DevTools 的 <code>computed</code> 部分中看到。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616966199-811ab322-812e-4302-a1f8-e191bc2e8e42.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616966199-811ab322-812e-4302-a1f8-e191bc2e8e42.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 3：主线程解析 CSS 以添加计算后样式</p><p>即使你不提供任何 CSS，每个 DOM 节点都具有计算样式。像 <code>&lt;h1&gt;</code> 标签看起来比 <code>&lt;h2&gt;</code> 标签大，每个元素都有 margin，这是因为浏览器具有默认样式表。如果你想知道更多 Chrome 的默认 CSS，<a href="https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/css/html.css">可以在这里看到源代码</a>。</p><p><a name="5aefca55"></a></p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>现在，渲染进程知道每个节点的样式和文档的结构，但这不足以渲染页面。想象一下，你正试图通过手机向朋友描述一幅画：“这里有一个大红圈和一个小蓝方块”，这并不能让你的朋友知道这幅画究竟长什么样。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616974801-873a48df-424e-48d5-b663-465acdde0a3b.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616974801-873a48df-424e-48d5-b663-465acdde0a3b.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 4：一个人站在一幅画前，电话线与另一个人相连</p><p>布局是计算元素几何形状的过程。主线程遍历 DOM，计算样式并创建布局树，其中包含 x y 坐标和边界框大小等信息。布局树可能与 DOM 树结构类似，但它仅包含页面上可见内容相关的信息。如果一个元素应用了 <code>display：none</code>，那么该元素不是布局树的一部分（但 <code>visibility：hidden</code> 的元素在布局树中）。类似地，如果应用了如 <code>p::before&#123;content:&quot;Hi!&quot;&#125;</code> 的伪类，则即使它不在 DOM 中，也包含于布局树中。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616983665-27566c02-307e-47de-af21-e1e2b8bea6f8.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599616983665-27566c02-307e-47de-af21-e1e2b8bea6f8.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 5：主线程遍历计算样式后的 DOM 树，以此生成布局树</p><p><img src="https://cdn.nlark.com/yuque/0/2020/gif/164572/1599617069400-412be90b-f35e-4136-9057-673b42f6b644.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/164572/1599617069400-412be90b-f35e-4136-9057-673b42f6b644.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="3-1.gif"></p><p>图 6：由于换行而移动的盒子布局</p><p>确定页面布局是一项很有挑战性的任务。即使是从上到下的块流这样最简单的页面布局，也必须考虑字体的大小以及换行位置，这些因素会影响段落的大小和形状，进而影响下一个段落的位置。</p><p>CSS 可以使元素浮动到一侧、隐藏溢出的元素、更改书写方向。你可以想象这一阶段的任务之艰巨。Chrome 浏览器有整个工程师团队负责布局。<a href="https://www.youtube.com/watch?v=Y5Xa4H2wtVA">BlinkOn 会议的一些访谈</a>记录了他们工作的细节，有兴趣可以了解一下，挺有趣的。</p><p><a name="b196b7cf"></a></p><h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617001845-6fe976a9-f8e4-4d52-b9e8-8f0cbf23a41f.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617001845-6fe976a9-f8e4-4d52-b9e8-8f0cbf23a41f.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 7：一个人拿着笔站在画布前，思考着她应该先画圆形还是先画方形</p><p>拥有 DOM、样式和布局仍然不足以渲染页面。假设你正在尝试重现一幅画。你知道元素的大小、形状和位置，但你仍需要判断绘制它们的顺序。</p><p>例如，可以为某些元素设置 <code>z-index</code>，此时按 HTML 中编写的元素的顺序绘制会导致错误的渲染。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617009442-2a9605de-fe23-4173-9d68-7cd9560d1eec.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617009442-2a9605de-fe23-4173-9d68-7cd9560d1eec.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 8：因为没有考虑 z-index，页面元素按 HTML 标记的顺序出现，导致错误的渲染图像</p><p>在绘制步骤中，主线程遍历布局树创建绘制记录。绘制记录是绘图过程的记录，就像是“背景优先，然后是文本，然后是矩形”。如果你使用过 JavaScript 绘制了 <code>&lt;canvas&gt;</code> 元素，那么这个过程对你来说可能很熟悉。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617017546-6e89e4ed-fde3-42eb-a85f-40dceaab9d6e.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617017546-6e89e4ed-fde3-42eb-a85f-40dceaab9d6e.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 9：主线程遍历布局树并生成绘制记录</p><p><a name="2778d675"></a></p><h3 id="更新渲染管道的成本很高"><a href="#更新渲染管道的成本很高" class="headerlink" title="更新渲染管道的成本很高"></a>更新渲染管道的成本很高</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617114971-f2dbbb36-7fab-4d96-8ae9-d697b6d07676.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617114971-f2dbbb36-7fab-4d96-8ae9-d697b6d07676.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 10：DOM + Style、布局和绘制树的生成顺序</p><p>渲染管道中最重要的事情是：每个步骤中，前一个操作的结果用于后一个操作创建新数据。例如，如果布局树中的某些内容发生改变，需要为文档的受影响部分重新生成“绘制”指令。</p><p>如果要为元素设置动画，则浏览器必须在每个帧之间运行这些操作。大多数显示器每秒刷新屏幕 60 次（60 fps），当屏幕每帧都在变化，人眼会觉得动画很流畅。但是，如果动画丢失了中间一些帧，页面看起来就会卡顿（janky）。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617121888-038a6c49-8dd3-46a1-925b-39347a5121e7.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617121888-038a6c49-8dd3-46a1-925b-39347a5121e7.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 11：时间轴上的动画帧</p><p>即使渲染操作能跟上屏幕刷新，这些计算也会在主线程上运行，这意味着当你的应用程序运行 JavaScript 时动画可能会被阻塞。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617129751-f70ab9bb-06b1-4dd8-8e3c-39dfe9b26911.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617129751-f70ab9bb-06b1-4dd8-8e3c-39dfe9b26911.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 12：时间轴上的动画帧，但 JavaScript 阻塞了一帧</p><p>你可以将 JavaScript 操作划分为小块，并使用 <code>requestAnimationFrame()</code> 在每个帧上运行。有关此主题的更多信息，请参阅 <a href="https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution">Optimize JavaScript Execution</a>。你也可以<a href="https://www.youtube.com/watch?v=X57mh8tKkgE">在 Web Worker 中运行 JavaScript</a> 以避免阻塞主线程。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617137709-2c3a4a12-e63b-4872-abb7-5e92e3396b95.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617137709-2c3a4a12-e63b-4872-abb7-5e92e3396b95.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 13：时间轴上较小的 JavaScript 块与动画帧一起运行</p><p><a name="c29e4097"></a></p><h2 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h2><p><a name="f9dca3c4"></a></p><h3 id="如何绘制一个页面？"><a href="#如何绘制一个页面？" class="headerlink" title="如何绘制一个页面？"></a>如何绘制一个页面？</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617165140-bc377abc-2cc4-4c1c-b61f-7f20b57fe9d3.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617165140-bc377abc-2cc4-4c1c-b61f-7f20b57fe9d3.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 14：简单光栅处理示意动画</p><p>现在浏览器知道文档的结构、每个元素的样式、页面的几何形状和绘制顺序，它是如何绘制页面的？把这些信息转换为屏幕上的像素，我们称为光栅化。</p><p>处理这种情况的一种简单的方法是，先在光栅化视窗内的画面，如果用户滚动页面，则移动光栅框，并光栅化填充缺少的部分。这就是 Chrome 首次发布时处理光栅化的方式。但是，现代浏览器会运行一个更复杂的过程，我们称为合成。</p><p><a name="9d33d874"></a></p><h3 id="什么是合成"><a href="#什么是合成" class="headerlink" title="什么是合成"></a>什么是合成</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/gif/164572/1599617193349-1b1eec0e-9282-43d0-a626-d4250586804c.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/gif/164572/1599617193349-1b1eec0e-9282-43d0-a626-d4250586804c.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="3-5.gif"></p><p>图 15：合成处理示意动画</p><p>合成是一种将页面的各个部分分层，分别光栅化，并在称为合成线程的单独线程中合成为页面的技术。如果发生滚动，由于图层已经光栅化，因此它所要做的只是合成一个新帧。动画也可以以相同的方式（移动图层和合成新帧）实现。</p><p>你可以在 DevTools 使用 <a href="https://blog.logrocket.com/eliminate-content-repaints-with-the-new-layers-panel-in-chrome-e2c306d4d752?gi=cd6271834cea">Layers 面板</a> 看看你的网站如何被分层。</p><p><a name="a58f1691"></a></p><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>为了分清哪些元素位于哪些图层，主线程遍历布局树创建图层树（此部分在 DevTools 性能面板中称为“Update Layer Tree”）。如果页面的某些部分应该是单独图层（如滑入式侧面菜单）但没拆分出来，你可以使用 CSS 中的 <code>will-change</code> 属性来提示浏览器。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617197636-f2905a7f-fe09-4b8d-95f1-d20b42e03a6e.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617197636-f2905a7f-fe09-4b8d-95f1-d20b42e03a6e.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 16：主线程遍历布局树生成图层树</p><p>你可能想要为每个元素都分层，但是合成大量的图层可能会比每帧都光栅化页面的刷新方式更慢，因此测量应用程序的渲染性能至关重要。有关这个主题的更多信息，请参阅 <a href="https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count">Stick to Compositor-Only Properties and Manage Layer Count</a>。</p><p><a name="df1192c3"></a></p><h3 id="主线程的光栅化和合成"><a href="#主线程的光栅化和合成" class="headerlink" title="主线程的光栅化和合成"></a>主线程的光栅化和合成</h3><p>一旦创建了图层树并确定了绘制顺序，主线程就会将该信息提交给合成线程。接着，合成线程会光栅化每个图层。一个图层可能会跟整个页面一样大，因此合成线程将它们分块后发送到光栅线程。光栅线程光栅化每个小块后会将它们存储在显存中。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617205653-985b211a-9023-4b91-8f6e-818351f26d57.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617205653-985b211a-9023-4b91-8f6e-818351f26d57.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图17：光栅线程创建分块的位图并发送到 GPU</p><p>合成线程会给不同的光栅线程设置优先级，以便视窗（或附近）内的画面可以先被光栅化。图层还具有多个不同分辨率的块，可以处理放大操作等动作。</p><p>一旦块被光栅化，合成线程会收集这些块的信息（称为<strong>绘制四边形</strong>）创建<strong>合成帧</strong>。</p><p>绘制四边形</p><p>包含诸如图块在内存中的位置，以及合成时绘制图块在页面中的位置等信息。</p><p>合成帧</p><p>一个绘制四边形的集合，代表一个页面的一帧。</p><p>接着，合成帧通过 IPC（进程间通讯）提交给浏览器进程。此时，可以从 UI 线程或其他插件的渲染进程添加另一个合成帧。这些合成器帧被发送到 GPU 然后在屏幕上显示。如果接收到滚动事件，合成线程会创建另一个合成帧发送到 GPU。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617214337-c98717ad-57a9-457c-a936-0926ab93ce12.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617214337-c98717ad-57a9-457c-a936-0926ab93ce12.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 18：合成线程创建合成帧，将其发送到浏览器进程，再接着发送到 GPU</p><p>合成的好处是它可以在不涉及主线程的情况下完成。合成线程不需要等待样式计算或 JavaScript 执行。这就是为什么<a href="https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/">仅合成动画</a>被认为是流畅性能的最佳选择。如果需要再次计算布局或绘制，则必须涉及主线程。</p><p><a name="eNBNH"></a></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>在这一部分中，我们研究了渲染管道从解析到合成的整个过程，希望现在你能自主地去了解更多关于网站性能优化的信息。<br />在本系列的下一部分也是最后一部分中，我们将更详细地介绍合成线程，看看当用户移动或点击鼠标时会发生什么。</p><p><a name="Yw4q0"></a></p><h1 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h1><p><a name="5f05a04d"></a></p><h2 id="用户输入行为与合成器"><a href="#用户输入行为与合成器" class="headerlink" title="用户输入行为与合成器"></a>用户输入行为与合成器</h2><p>内部揭秘系列博客对现代浏览器如何处理代码、显示页面展开探讨。该系列博客共四篇，这是最后一篇。在上篇博客里，我们了解了 <a href="https://developers.google.com/web/updates/2018/09/inside-browser-part3">渲染进程与合成器</a>。这里我们将一窥当用户输入行为发生时，合成器如何继续保障交互流畅。</p><p><a name="24e93a7e"></a></p><h2 id="浏览器视角下的输入事件"><a href="#浏览器视角下的输入事件" class="headerlink" title="浏览器视角下的输入事件"></a>浏览器视角下的输入事件</h2><p>听到“输入事件”这个字眼，你脑海里闪现的恐怕只是输入文本或点击鼠标。但在浏览器眼中，输入意味着一切用户行为。不单滚动鼠标滑轮是输入事件，触摸屏幕、滑动鼠标同样也是用户输入事件。</p><p>诸如触摸屏幕之类用户手势产生时，浏览器进程会率先将其捕获。然而浏览器进程所掌握的信息仅限于行为发生的区域，因为标签页里的内容都由渲染进程负责处理，所以浏览器进程会将事件类型（如 <code>touchstart</code>）及其坐标发送给渲染进程。渲染进程会寻至事件目标，运行其事件监听器，妥善地处理事件。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617571139-45d3ac9d-6abe-4772-8e68-c68fec9ef28a.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617571139-45d3ac9d-6abe-4772-8e68-c68fec9ef28a.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 1：输入事件由浏览器进程发往渲染进程</p><p><a name="50c136ae"></a></p><h2 id="合成器接收输入事件"><a href="#合成器接收输入事件" class="headerlink" title="合成器接收输入事件"></a>合成器接收输入事件</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617588105-c1fafd40-4006-4e45-9ba7-db24977c7317.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617588105-c1fafd40-4006-4e45-9ba7-db24977c7317.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 2：悬于页面图层的视图窗口</p><p>在上篇文章里，我们探讨了合成器如何通过合成栅格化图层，实现流畅的页面滚动。如果页面上没有添加任何事件监听，合成器线程会创建独立于主线程的新合成帧。但要是页面上添加了事件监听呢？合成器线程又是如何得知事件是否需要处理的？</p><p><a name="7d55be63"></a></p><h2 id="理解非立即可滚动区"><a href="#理解非立即可滚动区" class="headerlink" title="理解非立即可滚动区"></a>理解非立即可滚动区</h2><p>因为运行 JavaScript 脚本是主线程的工作，所以页面合成后，合成线程会将页面里添加了事件监听的区域标记为“非立即可滚动区”。有了这个信息，如果输入事件发生在这一区域，合成线程可以确定应将其发往主线程处理。如输入事件发生在这一区域之外，合成线程则确定无需等待主线程，而继续合成新帧。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617639083-b50d9822-736d-4f27-922a-0bccc18f94d3.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617639083-b50d9822-736d-4f27-922a-0bccc18f94d3.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 3：非立即可滚动区输入描述示意图</p><p><a name="4e7abbc5"></a></p><h3 id="设置事件处理器时须注意"><a href="#设置事件处理器时须注意" class="headerlink" title="设置事件处理器时须注意"></a>设置事件处理器时须注意</h3><p>web 开发中常用的事件处理模式是事件代理。因为事件会冒泡，所以你可以在最顶层的元素中添加一个事件处理器，用来代理事件目标产生的任务。下面这样的代码，你可能见过，或许也写过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.body.addEventListener(&#x27;touchstart&#x27;, </span><br><span class="line">event =&gt; &#123;</span><br><span class="line">    if (event.target === area) &#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样只需添加一个事件处理器，即可监听所有元素，的确十分省事。然而，如果站在浏览器的角度去考量，这等于把整个页面都标记成了“非立即可滚动区”，意味着即便你设计的应用本不必理会页面上一些区域的输入行为，合成线程也必须在每次输入事件产生后与主线程通信并等待返回。如此则得不偿失，使原本能保障页面滚动流畅的合成器没了用武之地。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617652730-c7bc2e88-1e9d-4752-a4a0-88268a4c3729.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617652730-c7bc2e88-1e9d-4752-a4a0-88268a4c3729.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 4：非立即可滚动区覆盖整个页面下的输入描述示意图</p><p>你可以给事件监听添加一个 <code>[passive:true](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Improving_scrolling_performance_with_passive_listeners)</code> 选项 ，将这种负面效果最小化。这会提示浏览器你想继续在主线程中监听事件，但合成器不必停滞等候，可接着创建新的合成帧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.body.addEventListener(&#x27;touchstart&#x27;, event =&gt; &#123;</span><br><span class="line">    if (event.target === area) &#123;</span><br><span class="line">        event.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;, &#123;passive: true&#125;);</span><br></pre></td></tr></table></figure><p><a name="8309d096"></a></p><h2 id="检查事件是否可撤销"><a href="#检查事件是否可撤销" class="headerlink" title="检查事件是否可撤销"></a>检查事件是否可撤销</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617659981-dab98eae-dba4-4e00-ac04-1b94e4aabf75.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617659981-dab98eae-dba4-4e00-ac04-1b94e4aabf75.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 5：部分区域仅可水平方向滚动的网页</p><p>设想一下这种情形：页面上有一个盒子，你要将其滚动方向限制为水平滚动。</p><p>为目标事件设置 <code>passive:true</code> 选项可让页面滚动平滑，但在你使用 <code>preventDefault</code> 以限制滚动方向时，垂直方向滚动可能已经触发。使用 <code>event.cancelable</code> 方法可以检查并阻止这种情况发生。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">document.body.addEventListener(&#x27;pointermove&#x27;, event =&gt; &#123;</span><br><span class="line">    if (event.cancelable) &#123;</span><br><span class="line">        event.preventDefault(); // 阻止默认的滚动行为</span><br><span class="line">        /*</span><br><span class="line">        *  这里设置程序执行任务</span><br><span class="line">        */</span><br><span class="line">    &#125; </span><br><span class="line">&#125;, &#123;passive:: true&#125;);</span><br></pre></td></tr></table></figure><p>或者，你也可以应用 <code>touch-action</code> 这类 CSS 规则，完全地将事件处理器屏蔽掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#area &#123; </span><br><span class="line">  touch-action: pan-x; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="063d68e2"></a></p><h2 id="定位事件目标"><a href="#定位事件目标" class="headerlink" title="定位事件目标"></a>定位事件目标</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617668976-70fe0d91-6607-4a0a-a71d-bb2231465a3d.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617668976-70fe0d91-6607-4a0a-a71d-bb2231465a3d.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 6：主线程检查绘制记录查询坐标 x、y 处绘制内容</p><p>合成器将输入事件发送至主线程后，首先运行的是命中检测。命中检测会使用渲染进程中产生的绘制记录数据，找出事件发生坐标下的内容。</p><p><a name="d791b565"></a></p><h2 id="降低往主线程发送事件的频率"><a href="#降低往主线程发送事件的频率" class="headerlink" title="降低往主线程发送事件的频率"></a>降低往主线程发送事件的频率</h2><p>之前的文章里，我们探讨了常见显示屏如何以每秒 60 帧的频率刷新，以及我们要怎样与其刷新频率保持步调一致，以营造出流畅的动画效果。而对于用户的输入行为，常见触摸屏设备的事件传输频率为每秒 60~120 次，常见鼠标设备的事件传输频率为每秒 100 次。可见，输入事件有着比显示屏幕更高的保真度。</p><p>如果一连串 <code>touchmove</code> 这样的事件以每秒 120 次的频率发送往主线程，那么可能会触发过量的命中检测及 JavaScript 脚本执行。相形而言，我们的屏幕刷新率则更为低下。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617676154-ac76c52a-fb38-42e3-baea-718f9fb25b52.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617676154-ac76c52a-fb38-42e3-baea-718f9fb25b52.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 7：大量事件涌入合成帧时间轴会造成页面闪烁</p><p>为了降低往主线程中传递过量调用，Chrome 会合并这些连续事件（如：<code>wheel</code>, <code>mousewheel</code>, <code>mousemove</code>, <code>pointermove</code>, <code>touchmove</code> 等），并将其延迟至下一次 <code>requestAnimationFrame</code> 前发送。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617682519-c93cb336-12a1-4698-bdd4-082700a99498.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617682519-c93cb336-12a1-4698-bdd4-082700a99498.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 8：相同的时间轴下事件被合并且延迟发送</p><p>所有独立的事件，如: <code>keydown</code>, <code>keyup</code>, <code>mouseup</code>, <code>mousedown</code>, <code>touchstart</code>, 及  <code>touchend</code> 则会立即发往主线程。</p><p><a name="0cc9abc4"></a></p><h2 id="使用-getCoalescedEvents-获取帧内事件"><a href="#使用-getCoalescedEvents-获取帧内事件" class="headerlink" title="使用 getCoalescedEvents 获取帧内事件"></a>使用 <code>getCoalescedEvents</code> 获取帧内事件</h2><p>事件合并可帮助大多数 web 应用构建良好的用户体验。然而，如果你开发的是一个绘图类应用，需要基于 <code>touchmove</code> 事件的坐标绘制线路，那么在你试图画下一根光滑的线条时，区间内的一些坐标点也可能会因事件合并而丢失。这时，你可以使用目标事件的  <code>getCoalescedEvents</code> 方法获取事件合并后的信息。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617699750-626e95d0-1729-4d8f-8025-b26d06e648aa.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617699750-626e95d0-1729-4d8f-8025-b26d06e648aa.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>图 9：左为流畅的触摸手势路径、右为事件合并后的有限路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;pointermove&#x27;, event =&gt; &#123;</span><br><span class="line">    const events = event.getCoalescedEvents();</span><br><span class="line">    for (let event of events) &#123;</span><br><span class="line">        const x = event.pageX;</span><br><span class="line">        const y = event.pageY;</span><br><span class="line">        // 使用 x、y 坐标画线</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a name="fc0952b5"></a></p><h2 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a>后续步骤</h2><p>本系列文章里，我们探讨了很多关于 web 浏览器内部的工作原理。如果之前你从来没想过：为什么 Devtools 推荐在事件处理器上添加 <code>&#123;passive:true&#125;</code> 选项、为什么有时须在 script 标签里添加 <code>async</code> 属性？那么我希望这一系列文章能帮助你了解，为什么传递这些信息给浏览器能让其提供更为迅捷流畅的 web 体验。</p><p><a name="f5a9afa0"></a></p><h3 id="使用-Lighthouse"><a href="#使用-Lighthouse" class="headerlink" title="使用 Lighthouse"></a>使用 Lighthouse</h3><p>如果你想构建出对浏览器更为友好的代码，却一直毫无头绪，那么不妨先从使用 <a href="https://developers.google.com/web/tools/lighthouse/">Lighthouse</a> 开始。Lighthouse 是个可以帮助你审查网站工具，并且能提供页面性能报告。性能报告会告诉你什么地方处理得当，什么地方有待提升。浏览审查列表也能让你了解浏览器着力关注的重点所在。</p><p><a name="ffa7e0b9"></a></p><h3 id="学习如何评测性能"><a href="#学习如何评测性能" class="headerlink" title="学习如何评测性能"></a>学习如何评测性能</h3><p>对于不同的站点，桎梏其性能之处可能不尽相同，所以专门为你自己的站点定制化一套性能评测方案，并择优选取技术应用，是重中之重。Chrome 的 Devtools 团队就 <a href="https://developers.google.com/web/tools/chrome-devtools/speed/get-started">如何测试你的站点性能</a> 撰有相关教程可供参阅。</p><p><a name="fcb2f19e"></a></p><h3 id="为你的站点添加-Feature-Policy"><a href="#为你的站点添加-Feature-Policy" class="headerlink" title="为你的站点添加 Feature Policy"></a>为你的站点添加 Feature Policy</h3><p>如果你想进一步采用更多方案，<a href="https://developers.google.com/web/updates/2018/06/feature-policy">Feature Policy</a> 是一个新的 web 平台，可在开发时为你保驾护航。开启 feature policy 可以限制应用行为，并使你远离诸多技术弊端。举个例子，如果你想确保应用不会阻塞解析，那么可以采用同步脚本方案运行应用。开启 <code>sync-script:&#39;none&#39;</code> 后，导致解析阻塞的 JavaScript 脚本会被阻止运行。这就确保了你的代码不会阻塞解析，浏览器也无须考虑暂停运行解析器。</p><p><a name="Rz4Sx"></a></p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617711586-2fa803a0-4b32-4415-89b4-2343084793e4.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1599617711586-2fa803a0-4b32-4415-89b4-2343084793e4.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>刚踏上开发之路时，我几乎只关注怎样去写代码、怎样提升自己的生产效率。诚然，这些事情很重要，但与此同时我们也应当思考浏览器会怎么去处理我们书写的代码。现代浏览器一直致力探索如何提供更好的用户体验。书写对浏览器友好的代码，反过来也能提供友好的用户体验。路漫漫其修远兮，希望我们能携手共进，构建出对浏览器更为友好的代码。</p><p><a name="8JBIM"></a></p><h1 id="文章出处"><a href="#文章出处" class="headerlink" title="文章出处"></a>文章出处</h1><blockquote><ul><li>原文地址1：<a href="https://developers.google.com/web/updates/2018/09/inside-browser-part1">Inside look at modern web browser (part 1)</a></li><li>原文地址2：<a href="https://developers.google.com/web/updates/2018/09/inside-browser-part2">Inside look at modern web browser (part 2)</a></li><li>原文地址3：<a href="https://developers.google.com/web/updates/2018/09/inside-browser-part3">Inside look at modern web browser (part 3)</a></li><li>原文地址4：<a href="https://developers.google.com/web/updates/2018/09/inside-browser-part4">Inside look at modern web browser (part 4)</a></li><li>原文作者：<a href="https://developers.google.com/web/resources/contributors/kosamari">Mariko Kosaka</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li><li>本文永久链接1：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/inside-look-at-modern-web-browser-part1.md">https://github.com/xitu/gold-miner/blob/master/TODO1/inside-look-at-modern-web-browser-part1.md</a> （译者：<a href="https://github.com/Colafornia">Colafornia</a>，校对者：<a href="https://github.com/CoderMing">CoderMing</a> <a href="https://github.com/sakila1012">sakila1012</a>，2020.07.18）</li><li>本文永久链接2：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/inside-browser-part2.md">https://github.com/xitu/gold-miner/blob/master/TODO1/inside-browser-part2.md</a> （译者：<a href="https://github.com/CoolRice">CoolRice</a>，校对者：<a href="https://github.com/ThomasWhyne">ThomasWhyne</a>, <a href="https://github.com/tian-li">tian-li</a>）</li><li>本文永久链接3：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/inside-browser-part3.md">https://github.com/xitu/gold-miner/blob/master/TODO1/inside-browser-part3.md</a> （译者：<a href="https://github.com/ssshooter">ssshooter</a>，校对者：<a href="https://github.com/ThomasWhyne">ThomasWhyne</a>, <a href="https://github.com/CoolRice">CoolRice</a>）</li><li>本文永久链接4：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/inside-browser-part4.md">https://github.com/xitu/gold-miner/blob/master/TODO1/inside-browser-part4.md</a>（译者：<a href="https://github.com/ThomasWhyne">ThomasWhyne</a>，校对者：<a href="https://github.com/llp0574">llp0574</a> <a href="https://github.com/CoolRice">CoolRice</a>，2020.07.11）</li></ul></blockquote><p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></p><blockquote><p>对译文进行修改并 PR，也可获得相应奖励积分。文章的 <strong>本文永久链接 即为本文在 GitHub 上的 MarkDown 链接。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件处理库</title>
      <link href="/2022/02/19/frontend/collection/wen-jian-chu-li-ku/"/>
      <url>/2022/02/19/frontend/collection/wen-jian-chu-li-ku/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657475987133-286486e5-844e-4459-b79b-f49d1cba4619.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657475987133-286486e5-844e-4459-b79b-f49d1cba4619.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="SCtXi"></a></p><h1 id="1-PDF"><a href="#1-PDF" class="headerlink" title="1. PDF"></a>1. PDF</h1><p><a name="bgIJx"></a></p><h2 id="（1）PDF-js"><a href="#（1）PDF-js" class="headerlink" title="（1）PDF.js"></a>（1）PDF.js</h2><p>PDF.js是使用 HTML5 构建的可移植文档格式 (PDF) 查看器。它由社区驱动并受 Mozilla 支持，目标是创建一个通用的、基于 Web 标准的平台来解析和呈现 PDF。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657462054009-7480ac84-c28e-4909-8bc9-b68eb38206ad.png?x-oss-process=image/resize,w_886,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657462054009-7480ac84-c28e-4909-8bc9-b68eb38206ad.png?x-oss-process=image/resize,w_886,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="R5YQW"></a></p><h2 id="（2）jsPDF"><a href="#（2）jsPDF" class="headerlink" title="（2）jsPDF"></a>（2）jsPDF</h2><p>jsPDF 是一个使用 JavaScript 语言生成 PDF 的开源库，是一个用于生成 PDF 的领先的 HTML5 客户端解决方案。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657462911906-fe4483d1-dde4-416b-b7f0-4cb6b69c4b41.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657462911906-fe4483d1-dde4-416b-b7f0-4cb6b69c4b41.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="XMA9o"></a></p><h2 id="（3）pdfmake"><a href="#（3）pdfmake" class="headerlink" title="（3）pdfmake"></a>（3）pdfmake</h2><p>在纯 JavaScript 中用于服务器端和客户端的 PDF 文档生成库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657463503527-9a884951-1607-41ab-abb2-d2e771d67685.png?x-oss-process=image/resize,w_883,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657463503527-9a884951-1607-41ab-abb2-d2e771d67685.png?x-oss-process=image/resize,w_883,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="fOlFT"></a></p><h2 id="（4）pdf-lib"><a href="#（4）pdf-lib" class="headerlink" title="（4）pdf-lib"></a>（4）pdf-lib</h2><p>pdf-lib 可以在任何 JavaScript 环境中创建和修改 PDF 文档。它旨在解决 JavaScript 生态系统对 PDF 操作（尤其是 PDF修改）缺乏强大支持的问题。可以用于任何现代 JavaScript 运行时，如 Node、Browser、Deno 和 React Native 等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657464689492-3b177db2-cee9-41d6-8ffc-8bd2b44a2cd1.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657464689492-3b177db2-cee9-41d6-8ffc-8bd2b44a2cd1.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="PhJsV"></a></p><h2 id="（5）pdfkit"><a href="#（5）pdfkit" class="headerlink" title="（5）pdfkit"></a>（5）pdfkit</h2><p>PDFKit 是一个用于 Node 和浏览器的 PDF 文档生成库，可以轻松创建复杂的多页可打印文档。API 包含可链接性，并包括低级功能以及更高级别功能的抽象。PDFKit API 的设计很简单，因此生成复杂的文档通常只需几个函数调用即可。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657466430038-5ca36f4e-4545-4170-ac1c-444ec2a64178.png?x-oss-process=image/resize,w_884,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657466430038-5ca36f4e-4545-4170-ac1c-444ec2a64178.png?x-oss-process=image/resize,w_884,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="cCWP1"></a></p><h2 id="（6）react-pdf"><a href="#（6）react-pdf" class="headerlink" title="（6）react-pdf"></a>（6）react-pdf</h2><p>react-pdf 是一个用于在浏览器和服务器上创建 PDF 文件的 React 渲染器。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657466736878-9b0118ac-e15c-4b26-b1ba-f0cb6a1acb17.png?x-oss-process=image/resize,w_889,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657466736878-9b0118ac-e15c-4b26-b1ba-f0cb6a1acb17.png?x-oss-process=image/resize,w_889,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="USiuc"></a></p><h1 id="2-图片"><a href="#2-图片" class="headerlink" title="2. 图片"></a>2. 图片</h1><p><a name="vRH4Y"></a></p><h2 id="（1）sharp"><a href="#（1）sharp" class="headerlink" title="（1）sharp"></a>（1）sharp</h2><p>sharp 是一个高性能的 Node.js 图像处理库，调整 JPEG、PNG、WebP、AVIF 和 TIFF 图像大小的最快模块。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657467735827-7527b2f3-8471-4c97-a84c-1900fd3ef594.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657467735827-7527b2f3-8471-4c97-a84c-1900fd3ef594.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="Wuc0D"></a></p><h2 id="（2）cropperjs"><a href="#（2）cropperjs" class="headerlink" title="（2）cropperjs"></a>（2）cropperjs</h2><p>cropperjs 是一个 JavaScript 图像裁剪器，支持29个裁剪选项、27种方法、6个事件、缩放、旋转等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657467979410-53c12b48-bdfb-4257-a409-5fe0f1e2cb8a.png?x-oss-process=image/resize,w_762,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657467979410-53c12b48-bdfb-4257-a409-5fe0f1e2cb8a.png?x-oss-process=image/resize,w_762,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="COSjr"></a></p><h2 id="（3）tui-image-editor"><a href="#（3）tui-image-editor" class="headerlink" title="（3）tui.image-editor"></a>（3）tui.image-editor</h2><p>tui.image-editor 是一个使用 HTML5 Canvas 的全功能图像编辑器。它易于使用并提供强大的过滤器。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657470118701-f578d232-862e-4979-8f85-2127f5ed383e.png?x-oss-process=image/resize,w_785,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657470118701-f578d232-862e-4979-8f85-2127f5ed383e.png?x-oss-process=image/resize,w_785,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="UpEt9"></a></p><h2 id="（4）compressorjs"><a href="#（4）compressorjs" class="headerlink" title="（4）compressorjs"></a>（4）compressorjs</h2><p>JavaScript 图像压缩器。使用浏览器原生的 canvas.toBlob API 来做压缩工作，即<strong>有损压缩</strong>，<strong>异步</strong>压缩，在不同的浏览器有<strong>不同的压缩效果</strong>。一般在客户端上传之前使用这个来预压缩图片。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657470473998-eef98daf-f592-48ef-a6df-7a61faf1b993.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657470473998-eef98daf-f592-48ef-a6df-7a61faf1b993.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="RIzaU"></a></p><h2 id="（5）viewerjs"><a href="#（5）viewerjs" class="headerlink" title="（5）viewerjs"></a>（5）viewerjs</h2><p>viewerjs 是一个 JavaScript 图像查看器，支持52个查看选项、23种操作方法、17个事件、旋转、移动、缩放等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657470620499-aabeb917-4a5e-4c94-ab74-6a3138c504f1.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657470620499-aabeb917-4a5e-4c94-ab74-6a3138c504f1.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="sndoJ"></a></p><h2 id="（6）omagesloaded"><a href="#（6）omagesloaded" class="headerlink" title="（6）omagesloaded"></a>（6）omagesloaded</h2><p>omagesloaded 是一个用来检查图像何时加载的 JavaScript 库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657471110588-c5c5e359-f553-46c4-b4f2-1835344fc9ef.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657471110588-c5c5e359-f553-46c4-b4f2-1835344fc9ef.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="jP85V"></a></p><h1 id="3-音视频"><a href="#3-音视频" class="headerlink" title="3. 音视频"></a>3. 音视频</h1><p><a name="pjgYP"></a></p><h2 id="（1）video-js"><a href="#（1）video-js" class="headerlink" title="（1）video.js"></a>（1）video.js</h2><p>Video.js 是一个为 HTML5 世界从头开始构建的网络视频播放器。它支持 HTML5 视频和媒体源扩展，以及其他播放技术，如 YouTube 和 Vimeo（通过插件）。它支持在台式机和移动设备上播放视频。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657471942627-408eba4b-d082-471a-b3b4-f0efacb7f8cd.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657471942627-408eba4b-d082-471a-b3b4-f0efacb7f8cd.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="Fr7fR"></a></p><h2 id="（2）plyr"><a href="#（2）plyr" class="headerlink" title="（2）plyr"></a>（2）plyr</h2><p>Plyr 是一个简单、轻量级、可访问和可定制的 HTML5、YouTube 和 Vimeo 媒体播放器，支持现代浏览器。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657472049651-78b61867-72c5-4c3a-87ce-ec90030b6ea9.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657472049651-78b61867-72c5-4c3a-87ce-ec90030b6ea9.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="XricI"></a></p><h2 id="（3）MediaElement-js"><a href="#（3）MediaElement-js" class="headerlink" title="（3）MediaElement.js"></a>（3）MediaElement.js</h2><p>MediaElement.js 是一个HTML5 <audio> 或 <video> 播放器，支持 MP4、WebM 和 MP3 以及 HLS、Dash、YouTube、Facebook、SoundCloud 等，具有通用 HTML5 MediaElement API，可在所有浏览器中实现一致的 UI。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657474380271-9f1985bd-8b0d-4c1e-835c-475e07e645ff.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657474380271-9f1985bd-8b0d-4c1e-835c-475e07e645ff.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="Mg1IY"></a></p><h2 id="（4）xgplayer"><a href="#（4）xgplayer" class="headerlink" title="（4）xgplayer"></a>（4）xgplayer</h2><p>西瓜播放器是一个Web视频播放器类库，它本着一切都是组件化的原则设计了独立可拆卸的 UI 组件。更重要的是它不只是在 UI 层有灵活的表现，在功能上也做了大胆的尝试：摆脱视频加载、缓冲、格式支持对 video 的依赖。尤其是在 mp4 点播上做了较大的努力，让本不支持流式播放的 mp4 能做到分段加载，这就意味着可以做到清晰度无缝切换、加载控制、节省视频流量。同时，它也集成了对 flv、hls、dash 的点播和直播支持。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657474785135-58850b84-8d64-4369-bec6-e8fad6a12324.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657474785135-58850b84-8d64-4369-bec6-e8fad6a12324.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="ahc2Y"></a></p><h2 id="（5）DPlayer"><a href="#（5）DPlayer" class="headerlink" title="（5）DPlayer"></a>（5）DPlayer</h2><p>DPlayer 是一款可爱的 HTML5 弹幕视频播放器，可帮助人们轻松构建视频和弹幕。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657475030777-0158c4ce-8b7f-47ec-8ced-c6b42c886561.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657475030777-0158c4ce-8b7f-47ec-8ced-c6b42c886561.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="oGCb6"></a></p><h2 id="（6）Howler-js"><a href="#（6）Howler-js" class="headerlink" title="（6）Howler.js"></a>（6）Howler.js</h2><p>howler.js 是一个现代 web 音频库。它默认为Web Audio API并回退到HTML5 Audio。这使得在所有平台上使用 JavaScript 处理音频变得容易且可靠。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657475185845-b716fd84-288a-4d30-b6b0-a25d414e0470.png?x-oss-process=image/resize,w_825,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657475185845-b716fd84-288a-4d30-b6b0-a25d414e0470.png?x-oss-process=image/resize,w_825,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="tGLJ3"></a></p><h1 id="4-表格"><a href="#4-表格" class="headerlink" title="4. 表格"></a>4. 表格</h1><p><a name="TECiK"></a></p><h2 id="（1）Handsontable"><a href="#（1）Handsontable" class="headerlink" title="（1）Handsontable"></a>（1）Handsontable</h2><p>Handsontable 是一个具有电子表格外观的 JavaScript 数据网格组件。适用于 React、Angular 和 Vue。它结合了数据网格功能和类似电子表格的 UX。它提供数据绑定、数据验证、过滤、排序和 CRUD 操作。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657475321627-76340bd7-4945-4ed6-b264-1d21407149e2.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657475321627-76340bd7-4945-4ed6-b264-1d21407149e2.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="hxqQt"></a></p><h2 id="（2）ag-grid"><a href="#（2）ag-grid" class="headerlink" title="（2）ag-grid"></a>（2）ag-grid</h2><p>AG Grid 是一个功能齐全且高度可定制的 JavaScript 数据网格。它提供了出色的性能，没有第三方依赖，并且可以与所有主要的 JavaScript 框架顺利集成。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657475416320-cda2c2fb-dc15-4e43-b2b8-964da68955ab.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657475416320-cda2c2fb-dc15-4e43-b2b8-964da68955ab.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="hGmxF"></a></p><h2 id="（3）x-spreadsheet"><a href="#（3）x-spreadsheet" class="headerlink" title="（3）x-spreadsheet"></a>（3）x-spreadsheet</h2><p>x-spreadsheet 是一个基于 Web 的 JavaScript（canvas）电子表格。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476078361-e291876e-157f-4d5c-a230-47a6c867dcc0.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476078361-e291876e-157f-4d5c-a230-47a6c867dcc0.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="pM7eq"></a></p><h2 id="（4）cheetah-grid"><a href="#（4）cheetah-grid" class="headerlink" title="（4）cheetah-grid"></a>（4）cheetah-grid</h2><p>cheetah-grid 是最快的 Web 开源数据表。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476161536-3abbcc9b-40ec-4330-83a3-dbc662f172fe.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476161536-3abbcc9b-40ec-4330-83a3-dbc662f172fe.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="wM1Y9"></a></p><h2 id="（5）ExcelJS"><a href="#（5）ExcelJS" class="headerlink" title="（5）ExcelJS"></a>（5）ExcelJS</h2><p>ExcelJS 是一个Excel电子表格文件逆向工程项目。可以读取，操作并写入电子表格数据和样式到 XLSX 和 JSON 文件。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476349708-5d038e35-8c1d-4726-a4a6-0d3daec3766f.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476349708-5d038e35-8c1d-4726-a4a6-0d3daec3766f.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="TILeH"></a></p><h2 id="（6）SheetJS"><a href="#（6）SheetJS" class="headerlink" title="（6）SheetJS"></a>（6）SheetJS</h2><p>SheetJS 是一个简化的电子表格，用意用来阅读、编辑和导出电子表格，其适用于 Web 浏览器和服务器，在 Office 365 中受 Microsoft 信任。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476602182-8862bc28-5862-42bb-b917-cfc188e0eec9.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476602182-8862bc28-5862-42bb-b917-cfc188e0eec9.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="hBUZq"></a></p><h1 id="5-文件上传"><a href="#5-文件上传" class="headerlink" title="5. 文件上传"></a>5. 文件上传</h1><p><a name="lEYA1"></a></p><h2 id="（1）Uppy"><a href="#（1）Uppy" class="headerlink" title="（1）Uppy"></a>（1）Uppy</h2><p>Uppy 是一款时尚的模块化 JavaScript 文件上传器，可与任何应用程序无缝集成。它速度快，具有易于理解的 API，让您不必担心比构建文件上传器更重要的问题。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476760136-38d64640-c83e-469b-98c0-8ebaf58a40f0.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476760136-38d64640-c83e-469b-98c0-8ebaf58a40f0.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="hsOOV"></a></p><h2 id="（2）filepond"><a href="#（2）filepond" class="headerlink" title="（2）filepond"></a>（2）filepond</h2><p>filepond 是一个用于上传文件的 JavaScript 库，优化图像以加快上传速度，并提供出色、可访问、如丝般流畅的用户体验。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476974714-7f19e9ea-26e2-4935-a857-aafb7eff4848.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657476974714-7f19e9ea-26e2-4935-a857-aafb7eff4848.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="lSr89"></a></p><h2 id="（3）Dropzone"><a href="#（3）Dropzone" class="headerlink" title="（3）Dropzone"></a>（3）Dropzone</h2><p>Dropzone 是一个 JavaScript 库，可以将任何 HTML 元素转换为 dropzone。这意味着用户可以将文件拖放到上面，Dropzone 将显示文件预览和上传进度，并通过 XHR 为你处理上传。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477025569-e6733b01-7842-4a1e-a9cb-02b6515ff278.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477025569-e6733b01-7842-4a1e-a9cb-02b6515ff278.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="NrCXI"></a></p><h2 id="（4）vue-upload-component"><a href="#（4）vue-upload-component" class="headerlink" title="（4）vue-upload-component"></a>（4）vue-upload-component</h2><p>vue-upload-component 是一个用于 Vue.js 的上传组件，支持多文件上传，上传目录，拖拽上传，拖拽目录，以及支持同时上传多个文件等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477195745-7a45c682-dbc4-46e7-a100-9b572e0b4148.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477195745-7a45c682-dbc4-46e7-a100-9b572e0b4148.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="i3uNl"></a></p><h2 id="（5）Uppload"><a href="#（5）Uppload" class="headerlink" title="（5）Uppload"></a>（5）Uppload</h2><p>Uppload 是一个更好的 JavaScript 图片上传器。它具有 30 多个插件的高度可定制性，完全免费和开源，并且可以与任何文件上传后端一起使用。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477331697-b633a214-5304-446a-a921-2c5f94ba08c7.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477331697-b633a214-5304-446a-a921-2c5f94ba08c7.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="VHo89"></a></p><h2 id="（6）react-dropzone"><a href="#（6）react-dropzone" class="headerlink" title="（6）react-dropzone"></a>（6）react-dropzone</h2><p>react-dropzone 是一个为 React 量身定制的，基于HTML5 的 drop &amp;&amp; drag API，可以实现拖拽上传文件的 JavaScript 库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477486722-9616e88f-0889-4512-bbe4-703fd462f74b.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477486722-9616e88f-0889-4512-bbe4-703fd462f74b.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="kdKSz"></a></p><h1 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h1><p><a name="aCKIb"></a></p><h2 id="（1）JSZip"><a href="#（1）JSZip" class="headerlink" title="（1）JSZip"></a>（1）JSZip</h2><p>JSZip 是一个使用 JavaScript 创建、读取和编辑 .zip 文件的库，具有可爱而简单的 API。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477589748-3d6503c3-d76f-44c4-9f3a-0c15b1a6d28c.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477589748-3d6503c3-d76f-44c4-9f3a-0c15b1a6d28c.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="OidiE"></a></p><h2 id="（2）docxtemplater"><a href="#（2）docxtemplater" class="headerlink" title="（2）docxtemplater"></a>（2）docxtemplater</h2><p>docxtemplater 是一个从 docx&#x2F;pptx 模板生成 docx&#x2F;pptx 文档的库。它可以用数据替换 {placeholders} 并且还支持循环和条件。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477829197-4b9a5388-8966-4e34-a492-f15bc4816485.png?x-oss-process=image/resize,w_882,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477829197-4b9a5388-8966-4e34-a492-f15bc4816485.png?x-oss-process=image/resize,w_882,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="fv8rX"></a></p><h2 id="（3）textract"><a href="#（3）textract" class="headerlink" title="（3）textract"></a>（3）textract</h2><p>textract 是一个 node.js 模块，用于从 html、pdf、doc、docx、xls、xlsx、csv、pptx、png、jpg、gif、rtf 等中提取文本。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477790788-15e888ca-153e-4527-b209-cd147ffbb850.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477790788-15e888ca-153e-4527-b209-cd147ffbb850.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="OrXng"></a></p><h2 id="（4）PptxGenJS"><a href="#（4）PptxGenJS" class="headerlink" title="（4）PptxGenJS"></a>（4）PptxGenJS</h2><p>PptxGenJS 是一个使用功能强大、简洁的 JavaScript API 创建 PowerPoint 演示文稿。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477876415-677a8519-d32f-4c40-97d8-7e03df74db21.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657477876415-677a8519-d32f-4c40-97d8-7e03df74db21.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="EShJw"></a></p><h2 id="（5）officegen"><a href="#（5）officegen" class="headerlink" title="（5）officegen"></a>（5）officegen</h2><p>officegen 是一个用于 JavaScript 中 Word (docx)、PowerPoint (pptx) 和 Excell (xlsx) 的独立 Office Open XML 文件（Microsoft Office 2007 及更高版本）生成器。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657478146268-be5fbfc2-cced-420c-83ab-7850444598b5.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657478146268-be5fbfc2-cced-420c-83ab-7850444598b5.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="wlC6r"></a></p><h2 id="（6）PapaParse"><a href="#（6）PapaParse" class="headerlink" title="（6）PapaParse"></a>（6）PapaParse</h2><p>PapaParse 是一个快速而强大的 CSV（分隔文本）解析器，可以优雅地处理大文件和格式错误的输入。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657478027071-66df0d49-f1c8-48cb-afbb-f43701ff4975.png?x-oss-process=image/resize,w_841,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1657478027071-66df0d49-f1c8-48cb-afbb-f43701ff4975.png?x-oss-process=image/resize,w_841,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><br /> ]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> 文件处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js常见兼容问题</title>
      <link href="/2021/12/21/compatible/js-compatible/"/>
      <url>/2021/12/21/compatible/js-compatible/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><a name="aqBRj"></a><h3 id="iPhone7用for…in-遍历数组失效"><a href="#iPhone7用for…in-遍历数组失效" class="headerlink" title="iPhone7用for…in 遍历数组失效"></a>iPhone7用for…in 遍历数组失效</h3><p>问题描述：最初学习使用js时，觉得<code>for...in</code>遍历比<code>for循环</code>简洁，后期在用户反馈后发现iPhone7不支持用for…in遍历数组<br />解决方式： 改为<code>for循环</code>遍历</p><p><a name="kiAHW"></a></p><h3 id="移动端点击事件300-ms延迟问题"><a href="#移动端点击事件300-ms延迟问题" class="headerlink" title="移动端点击事件300 ms延迟问题"></a>移动端点击事件300 ms延迟问题</h3><p>问题描述：移动端web网页是有300ms延迟的，往往会造成按钮点击延迟甚至是点击失效。<br />解决方式：</p><ul><li>fastclick可以解决在手机上点击事件的300ms延迟</li><li>zepto.js的touch模块，tap事件也是为了解决在click的延迟问题</li></ul><p><a name="nK6Db"></a></p><h3 id="audio-和-video-在-ios-和-andriod-中自动播放"><a href="#audio-和-video-在-ios-和-andriod-中自动播放" class="headerlink" title="audio 和 video 在 ios 和 andriod 中自动播放"></a>audio 和 video 在 ios 和 andriod 中自动播放</h3><p>出于优化用户体验，苹果系统和安卓系统通常都会禁止自动播放和禁止页面加载时使用 JS 触发播放，必须由用户主动点击页面才可以触发播放。通过给页面根元素加touchstart的监听事件实现触发播放</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;html&#x27;</span>).<span class="title function_">one</span>(<span class="string">&#x27;touchstart&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  audio.<span class="title function_">play</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a name="aIKcn"></a></p><h3 id="iOS-上拉边界下拉出现空白"><a href="#iOS-上拉边界下拉出现空白" class="headerlink" title="iOS 上拉边界下拉出现空白"></a>iOS 上拉边界下拉出现空白</h3><p>问题描述：手指按住屏幕下拉，屏幕顶部会多出一块白色区域。手指按住屏幕上拉，底部多出一块白色区域。<br />产生原因：在 iOS 中，手指按住屏幕上下拖动，会触发 touchmove 事件。这个事件触发的对象是整个 webview 容器，容器自然会被拖动，剩下的部分会成空白。<br />解决方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;touchmove&#x27;</span>,</span><br><span class="line">  <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">_isScroller</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 阻止默认事件</span></span><br><span class="line">    e.<span class="title function_">preventDefault</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">passive</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a name="emtPB"></a></p><h3 id="ios-日期转换-NAN-的问题"><a href="#ios-日期转换-NAN-的问题" class="headerlink" title="ios 日期转换 NAN 的问题"></a>ios 日期转换 NAN 的问题</h3><p>将日期字符串的格式符号替换成’&#x2F;‘</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;yyyy-MM-dd&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/-/g</span>, <span class="string">&#x27;/&#x27;</span>)</span><br></pre></td></tr></table></figure><p><a name="ibcS5"></a></p><h3 id="软键盘问题"><a href="#软键盘问题" class="headerlink" title="软键盘问题"></a>软键盘问题</h3><p><a name="oXllV"></a></p><h4 id="iOS-系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格"><a href="#iOS-系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格" class="headerlink" title="iOS 系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格"></a>iOS 系统中文输入法输入英文时，字母之间可能会出现一个六分之一空格</h4><p>解决方式：可以通过正则去掉</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">value</span>.<span class="title function_">replace</span>(<span class="regexp">/\u2006/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure><p><a name="Qmh75"></a></p><h4 id="IOS-键盘弹起挡住原来的视图"><a href="#IOS-键盘弹起挡住原来的视图" class="headerlink" title="IOS 键盘弹起挡住原来的视图"></a>IOS 键盘弹起挡住原来的视图</h4><p>解决方式：</p><ul><li>可以通过监听移动端软键盘弹起 Element.scrollIntoViewIfNeeded（Boolean）方法用来将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域。 如果该元素已经在浏览器窗口的可见区域内，则不会发生滚动。</li><li>true，则元素将在其所在滚动区的可视区域中居中对齐。</li><li>false，则元素将与其所在滚动区的可视区域最近的边缘对齐。 根据可见区域最靠近元素的哪个边缘，元素的顶部将与可见区域的顶部边缘对准，或者元素的底部边缘将与可见区域的底部边缘对准。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">activeElement</span>.<span class="property">tagName</span> === <span class="string">&#x27;INPUT&#x27;</span> ||</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">activeElement</span>.<span class="property">tagName</span> === <span class="string">&#x27;TEXTAREA&#x27;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&#x27;scrollIntoView&#x27;</span> <span class="keyword">in</span> <span class="variable language_">document</span>.<span class="property">activeElement</span>) &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">activeElement</span>.<span class="title function_">scrollIntoView</span>(<span class="literal">false</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">activeElement</span>.<span class="title function_">scrollIntoViewIfNeeded</span>(<span class="literal">false</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a name="RQUuS"></a></p><h4 id="onkeyUp-和-onKeydown-兼容性问题"><a href="#onkeyUp-和-onKeydown-兼容性问题" class="headerlink" title="onkeyUp 和 onKeydown 兼容性问题"></a>onkeyUp 和 onKeydown 兼容性问题</h4><p>IOS 中 input 键盘事件 keyup、keydown、等支持不是很好, 用 input 监听键盘 keyup 事件，在安卓手机浏览器中没有问题，但是在 ios 手机浏览器中用输入法输入之后，并未立刻相应 keyup 事件</p><p><a name="vb5qX"></a></p><h4 id="IOS12-输入框难以点击获取焦点，弹不出软键盘"><a href="#IOS12-输入框难以点击获取焦点，弹不出软键盘" class="headerlink" title="IOS12 输入框难以点击获取焦点，弹不出软键盘"></a>IOS12 输入框难以点击获取焦点，弹不出软键盘</h4><p>定位找到问题是 fastclick.js 对 IOS12 的兼容性，可在 fastclick.js 源码或者 main.js 做以下修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">FastClick</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">focus</span> = <span class="keyword">function</span>(<span class="params">targetElement</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> length</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    deviceIsIOS &amp;&amp;</span><br><span class="line">    targetElement.<span class="property">setSelectionRange</span> &amp;&amp;</span><br><span class="line">    targetElement.<span class="property">type</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;date&#x27;</span>) !== <span class="number">0</span> &amp;&amp;</span><br><span class="line">    targetElement.<span class="property">type</span> !== <span class="string">&#x27;time&#x27;</span> &amp;&amp;</span><br><span class="line">    targetElement.<span class="property">type</span> !== <span class="string">&#x27;month&#x27;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    length = targetElement.<span class="property">value</span>.<span class="property">length</span></span><br><span class="line">    targetElement.<span class="title function_">setSelectionRange</span>(length, length)</span><br><span class="line">    targetElement.<span class="title function_">focus</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    targetElement.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="vo5o5"></a></p><h4 id="IOS-键盘收起时页面没用回落，底部会留白"><a href="#IOS-键盘收起时页面没用回落，底部会留白" class="headerlink" title="IOS 键盘收起时页面没用回落，底部会留白"></a>IOS 键盘收起时页面没用回落，底部会留白</h4><p>通过监听键盘回落时间滚动到原来的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;focusout&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//input输入框弹起软键盘的解决方案。</span></span><br><span class="line"><span class="keyword">var</span> bfscrolltop = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span></span><br><span class="line">$(<span class="string">&#x27;input&#x27;</span>)</span><br><span class="line">  .<span class="title function_">focus</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollHeight</span></span><br><span class="line">    <span class="comment">//console.log(document.body.scrollTop);</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">blur</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> = bfscrolltop</span><br><span class="line">    <span class="comment">//console.log(document.body.scrollTop);</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="ALt6l"></a></p><h4 id="IOS-下-fixed-失效"><a href="#IOS-下-fixed-失效" class="headerlink" title="IOS 下 fixed 失效"></a>IOS 下 fixed 失效</h4><p>问题描述：软键盘唤起后，页面的 fixed 元素将失效，变成了 absolute，所以当页面超过一屏且滚动时，失效的 fixed 元素就会跟随滚动了。不仅限于 type&#x3D;text 的输入框，凡是软键盘（比如时间日期选择、select 选择等等）被唤起，都会遇到同样地问题。 解决方法: 不让页面滚动，而是让主体部分自己滚动,主体部分高度设为 100%，overflow:scroll</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;warper&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;main&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fix-bottom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.warper</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">  -webkit-<span class="attribute">overflow</span>-scrolling: touch; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fix-bottom</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compatible </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async_await及其实现</title>
      <link href="/2021/10/10/frontend/interview/async-await-ji-qi-shi-xian/"/>
      <url>/2021/10/10/frontend/interview/async-await-ji-qi-shi-xian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>async和await关键字让我们可以用一种更简洁的方式写出基于Promise的异步行为，而无需刻意地链式调用promise。<br><a name="ZFkH2"></a></p><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p><code>Promise B</code>需要接受 <code>Promise A</code>的返回值作为下一步计算的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">promiseA</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promiseB</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">`value: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>在没有async/await时，需要嵌套调用`Promise.then()`</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">promiseA</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">promiseB</span>(res).<span class="title function_">then</span>(<span class="function"><span class="params">res2</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res2)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><pre><code>使用`async/await`: </code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fun</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">promiseA</span>();</span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">await</span> <span class="title function_">promiseB</span>(res);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fun</span>()</span><br></pre></td></tr></table></figure><p>对比起来，async&#x2F;await 更像是在同步处理异步问题，更符合人的阅读直觉。<br><a name="Sg7kZ"></a></p><h1 id="函数生成器模拟实现"><a href="#函数生成器模拟实现" class="headerlink" title="函数生成器模拟实现"></a>函数生成器模拟实现</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">promise1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promise2</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&quot;value:&quot;</span> + value);</span><br><span class="line">      <span class="comment">// reject(&quot;错误&quot;);</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promise3</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;value:&quot;</span> + value);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">readFile</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="keyword">yield</span> <span class="title function_">promise1</span>();</span><br><span class="line">  <span class="keyword">const</span> value2 = <span class="keyword">yield</span> <span class="title function_">promise2</span>(value);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">yield</span> <span class="title function_">promise3</span>(value2);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncGen</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> g = <span class="title function_">fn</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">param</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; value, done &#125; = g.<span class="title function_">next</span>(param);</span><br><span class="line">      <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">        <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(value).<span class="title function_">then</span>(</span><br><span class="line">          <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">next</span>(res);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(param);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncGen</span>(readFile).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res),</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里前端开发规范</title>
      <link href="/2021/10/07/frontend/a-li-qian-duan-kai-fa-gui-fan/"/>
      <url>/2021/10/07/frontend/a-li-qian-duan-kai-fa-gui-fan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>目录</p><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E5%A3%B0%E6%98%8E">声明</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83">前端代码规范</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E5%89%8D%E7%AB%AF-js-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83">前端 JS 项目开发规范</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%B8%80%E3%80%81%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6">一、编程规约</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%B8%80%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">(一)命名规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#111-%E9%A1%B9%E7%9B%AE%E5%91%BD%E5%90%8D">1.1.1 项目命名</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#112-%E7%9B%AE%E5%BD%95%E5%91%BD%E5%90%8D">1.1.2 目录命名</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#113-js%E3%80%81css%E3%80%81scss%E3%80%81html%E3%80%81png-%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D">1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#114-%E5%91%BD%E5%90%8D%E4%B8%A5%E8%B0%A8%E6%80%A7">1.1.4 命名严谨性</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%BA%8Chtml-%E8%A7%84%E8%8C%83-%EF%BC%88vue-template-%E5%90%8C%E6%A0%B7%E9%80%82%E7%94%A8%EF%BC%89">(二)HTML 规范 （Vue Template 同样适用）</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#121-html-%E7%B1%BB%E5%9E%8B">1.2.1 HTML 类型</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#122-%E7%BC%A9%E8%BF%9B">1.2.2 缩进</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#123-%E5%88%86%E5%9D%97%E6%B3%A8%E9%87%8A">1.2.3 分块注释</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#124-%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE">1.2.4 语义化标签</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#125-%E5%BC%95%E5%8F%B7">1.2.5 引号</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%B8%89-css-%E8%A7%84%E8%8C%83">(三) CSS 规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#131-%E5%91%BD%E5%90%8D">1.3.1 命名</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#132-%E9%80%89%E6%8B%A9%E5%99%A8">1.3.2 选择器</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#133-%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E7%BC%A9%E5%86%99%E5%B1%9E%E6%80%A7">1.3.3 尽量使用缩写属性</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#134-%E6%AF%8F%E4%B8%AA%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E5%B1%9E%E6%80%A7%E7%8B%AC%E5%8D%A0%E4%B8%80%E8%A1%8C">1.3.4 每个选择器及属性独占一行</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#135-%E7%9C%81%E7%95%A50%E5%90%8E%E9%9D%A2%E7%9A%84%E5%8D%95%E4%BD%8D">1.3.5 省略0后面的单位</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#136-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8id%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E5%85%A8%E5%B1%80%E6%A0%87%E7%AD%BE%E9%80%89%E6%8B%A9%E5%99%A8%E9%98%B2%E6%AD%A2%E6%B1%A1%E6%9F%93%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F">1.3.6 避免使用ID选择器及全局标签选择器防止污染全局样式</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E5%9B%9B-less-%E8%A7%84%E8%8C%83">(四) LESS 规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#141-%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87">1.4.1 代码组织</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1%E5%B0%86%E5%85%AC%E5%85%B1less%E6%96%87%E4%BB%B6%E6%94%BE%E7%BD%AE%E5%9C%A8stylelesscommon%E6%96%87%E4%BB%B6%E5%A4%B9">1)将公共less文件放置在style&#x2F;less&#x2F;common文件夹</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2%E6%8C%89%E4%BB%A5%E4%B8%8B%E9%A1%BA%E5%BA%8F%E7%BB%84%E7%BB%87">2)按以下顺序组织</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#142-%E9%81%BF%E5%85%8D%E5%B5%8C%E5%A5%97%E5%B1%82%E7%BA%A7%E8%BF%87%E5%A4%9A">1.4.2 避免嵌套层级过多</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%BA%94-javascript-%E8%A7%84%E8%8C%83">(五) Javascript 规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#151-%E5%91%BD%E5%90%8D">1.5.1 命名</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1-%E9%87%87%E7%94%A8%E5%B0%8F%E5%86%99%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D-lowercamelcase%EF%BC%8C%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E5%9D%87%E4%B8%8D%E8%83%BD%E4%BB%A5%E4%B8%8B%E5%88%92%E7%BA%BF%EF%BC%8C%E4%B9%9F%E4%B8%8D%E8%83%BD%E4%BB%A5%E4%B8%8B%E5%88%92%E7%BA%BF%E6%88%96%E7%BE%8E%E5%85%83%E7%AC%A6%E5%8F%B7%E7%BB%93%E6%9D%9F">1) 采用小写驼峰命名 lowerCamelCase，代码中的命名均不能以下划线，也不能以下划线或美元符号结束</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2-%E6%96%B9%E6%B3%95%E5%90%8D%E3%80%81%E5%8F%82%E6%95%B0%E5%90%8D%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E9%83%BD%E7%BB%9F%E4%B8%80%E4%BD%BF%E7%94%A8-lowercamelcase-%E9%A3%8E%E6%A0%BC%EF%BC%8C%E5%BF%85%E9%A1%BB%E9%81%B5%E4%BB%8E%E9%A9%BC%E5%B3%B0%E5%BD%A2%E5%BC%8F%E3%80%82">2) 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#3-%E5%B8%B8%E9%87%8F%E5%91%BD%E5%90%8D%E5%85%A8%E9%83%A8%E5%A4%A7%E5%86%99%EF%BC%8C%E5%8D%95%E8%AF%8D%E9%97%B4%E7%94%A8%E4%B8%8B%E5%88%92%E7%BA%BF%E9%9A%94%E5%BC%80%EF%BC%8C%E5%8A%9B%E6%B1%82%E8%AF%AD%E4%B9%89%E8%A1%A8%E8%BE%BE%E5%AE%8C%E6%95%B4%E6%B8%85%E6%A5%9A%EF%BC%8C%E4%B8%8D%E8%A6%81%E5%AB%8C%E5%90%8D%E5%AD%97%E9%95%BF%E3%80%82">3) 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#152-%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F">1.5.2 代码格式</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1-%E4%BD%BF%E7%94%A8-2-%E4%B8%AA%E7%A9%BA%E6%A0%BC%E8%BF%9B%E8%A1%8C%E7%BC%A9%E8%BF%9B">1) 使用 2 个空格进行缩进</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2-%E4%B8%8D%E5%90%8C%E9%80%BB%E8%BE%91%E3%80%81%E4%B8%8D%E5%90%8C%E8%AF%AD%E4%B9%89%E3%80%81%E4%B8%8D%E5%90%8C%E4%B8%9A%E5%8A%A1%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B9%8B%E9%97%B4%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E7%A9%BA%E8%A1%8C%E5%88%86%E9%9A%94%E5%BC%80%E6%9D%A5%E4%BB%A5%E6%8F%90%E5%8D%87%E5%8F%AF%E8%AF%BB%E6%80%A7%E3%80%82">2) 不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#153-%E5%AD%97%E7%AC%A6%E4%B8%B2">1.5.3 字符串</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#154-%E5%AF%B9%E8%B1%A1%E5%A3%B0%E6%98%8E">1.5.4 对象声明</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1%E4%BD%BF%E7%94%A8%E5%AD%97%E9%9D%A2%E5%80%BC%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">1)使用字面值创建对象</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2-%E4%BD%BF%E7%94%A8%E5%AD%97%E9%9D%A2%E9%87%8F%E6%9D%A5%E4%BB%A3%E6%9B%BF%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E5%99%A8">2) 使用字面量来代替对象构造器</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#155-%E4%BD%BF%E7%94%A8-es67">1.5.5 使用 ES6,7</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#156-%E6%8B%AC%E5%8F%B7">1.5.6 括号</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#157-undefined-%E5%88%A4%E6%96%AD">1.5.7 undefined 判断</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#158-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E5%92%8C%E5%BE%AA%E7%8E%AF%E6%9C%80%E5%A4%9A%E4%B8%89%E5%B1%82">1.5.8 条件判断和循环最多三层</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#159-this-%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%91%BD%E5%90%8D">1.5.9 this 的转换命名</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1510-%E6%85%8E%E7%94%A8-consolelog">1.5.10 慎用 console.log</a></li></ul></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%BA%8C%E3%80%81vue-%E9%A1%B9%E7%9B%AE%E8%A7%84%E8%8C%83">二、Vue 项目规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%B8%80-vue-%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80">(一) Vue 编码基础</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#211-%E7%BB%84%E4%BB%B6%E8%A7%84%E8%8C%83">2.1.1. 组件规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1-%E7%BB%84%E4%BB%B6%E5%90%8D%E4%B8%BA%E5%A4%9A%E4%B8%AA%E5%8D%95%E8%AF%8D%E3%80%82">1) 组件名为多个单词。</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2-%E7%BB%84%E4%BB%B6%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%BA-pascal-case-%E6%A0%BC%E5%BC%8F">2) 组件文件名为 pascal-case 格式</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#3-%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%BA-base-%E5%BC%80%E5%A4%B4%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%AE%8C%E6%95%B4%E5%8D%95%E8%AF%8D%E8%80%8C%E4%B8%8D%E6%98%AF%E7%BC%A9%E5%86%99%E3%80%82">3) 基础组件文件名为 base 开头，使用完整单词而不是缩写。</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#4-%E5%92%8C%E7%88%B6%E7%BB%84%E4%BB%B6%E7%B4%A7%E5%AF%86%E8%80%A6%E5%90%88%E7%9A%84%E5%AD%90%E7%BB%84%E4%BB%B6%E5%BA%94%E8%AF%A5%E4%BB%A5%E7%88%B6%E7%BB%84%E4%BB%B6%E5%90%8D%E4%BD%9C%E4%B8%BA%E5%89%8D%E7%BC%80%E5%91%BD%E5%90%8D">4) 和父组件紧密耦合的子组件应该以父组件名作为前缀命名</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#5-%E5%9C%A8-template-%E6%A8%A1%E7%89%88%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%BA%94%E4%BD%BF%E7%94%A8-pascalcase-%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%BD%BF%E7%94%A8%E8%87%AA%E9%97%AD%E5%90%88%E7%BB%84%E4%BB%B6%E3%80%82">5) 在 Template 模版中使用组件，应使用 PascalCase 模式，并且使用自闭合组件。</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#6-%E7%BB%84%E4%BB%B6%E7%9A%84-data-%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0">6) 组件的 data 必须是一个函数</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#7-prop-%E5%AE%9A%E4%B9%89%E5%BA%94%E8%AF%A5%E5%B0%BD%E9%87%8F%E8%AF%A6%E7%BB%86">7) Prop 定义应该尽量详细</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#8-%E4%B8%BA%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE%E4%BD%9C%E7%94%A8%E5%9F%9F">8) 为组件样式设置作用域</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#9-%E5%A6%82%E6%9E%9C%E7%89%B9%E6%80%A7%E5%85%83%E7%B4%A0%E8%BE%83%E5%A4%9A%EF%BC%8C%E5%BA%94%E8%AF%A5%E4%B8%BB%E5%8A%A8%E6%8D%A2%E8%A1%8C%E3%80%82">9) 如果特性元素较多，应该主动换行。</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#212-%E6%A8%A1%E6%9D%BF%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F">2.1.2. 模板中使用简单的表达式</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#213-%E6%8C%87%E4%BB%A4%E9%83%BD%E4%BD%BF%E7%94%A8%E7%BC%A9%E5%86%99%E5%BD%A2%E5%BC%8F">2.1.3 指令都使用缩写形式</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#214-%E6%A0%87%E7%AD%BE%E9%A1%BA%E5%BA%8F%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4">2.1.4 标签顺序保持一致</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#215-%E5%BF%85%E9%A1%BB%E4%B8%BA-v-for-%E8%AE%BE%E7%BD%AE%E9%94%AE%E5%80%BC-key">2.1.5 必须为 v-for 设置键值 key</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#216-v-show-%E4%B8%8E-v-if-%E9%80%89%E6%8B%A9">2.1.6 v-show 与 v-if 选择</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#217-script-%E6%A0%87%E7%AD%BE%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E9%A1%BA%E5%BA%8F">2.1.7 script 标签内部结构顺序</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#218-vue-router-%E8%A7%84%E8%8C%83">2.1.8 Vue Router 规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0">1) 页面跳转数据传递使用路由参数</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2-%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%88%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%89%E6%9C%BA%E5%88%B6">2) 使用路由懒加载（延迟加载）机制</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#3-router-%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">3) router 中的命名规范</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#4-router-%E4%B8%AD%E7%9A%84-path-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">4) router 中的 path 命名规范</a></li></ul></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#%E4%BA%8C-vue-%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83">(二) Vue 项目目录规范</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#221-%E5%9F%BA%E7%A1%80">2.2.1 基础</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#222-%E4%BD%BF%E7%94%A8-vue-cli-%E8%84%9A%E6%89%8B%E6%9E%B6">2.2.2 使用 Vue-cli 脚手架</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#223-%E7%9B%AE%E5%BD%95%E8%AF%B4%E6%98%8E">2.2.3 目录说明</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1-api-%E7%9B%AE%E5%BD%95">1) api 目录</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2-assets-%E7%9B%AE%E5%BD%95">2) assets 目录</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#3-components-%E7%9B%AE%E5%BD%95">3) components 目录</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#4-constants-%E7%9B%AE%E5%BD%95">4) constants 目录</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#5-router-%E4%B8%8E-store-%E7%9B%AE%E5%BD%95">5) router 与 store 目录</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#6-views-%E7%9B%AE%E5%BD%95">6) views 目录</a></li></ul></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#224-%E6%B3%A8%E9%87%8A%E8%AF%B4%E6%98%8E">2.2.4 注释说明</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#225-%E5%85%B6%E4%BB%96">2.2.5 其他</a><ul><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#1-%E5%B0%BD%E9%87%8F%E4%B8%8D%E8%A6%81%E6%89%8B%E5%8A%A8%E6%93%8D%E4%BD%9C-dom">1) 尽量不要手动操作 DOM</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13200530.html#2-%E5%88%A0%E9%99%A4%E6%97%A0%E7%94%A8%E4%BB%A3%E7%A0%81">2) 删除无用代码</a></li></ul></li></ul></li></ul></li></ul><p><a name="IACrB"></a></p><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><blockquote><p>从某位 up 主那里嫖来的，转载一下，留个印象，日后再看，具体地址忘了， ，，后续再补</p></blockquote><p><a name="pa9JL"></a></p><h1 id="前端代码规范"><a href="#前端代码规范" class="headerlink" title="前端代码规范"></a>前端代码规范</h1><p>Front Standard Guide<br><a name="ceipr"></a></p><h1 id="前端-JS-项目开发规范"><a href="#前端-JS-项目开发规范" class="headerlink" title="前端 JS 项目开发规范"></a>前端 JS 项目开发规范</h1><p>规范的目的是为了编写高质量的代码，让你的团队成员每天得心情都是愉悦的，大家在一起是快乐的。<br />引自《阿里规约》的开头片段：<br /><em>—-现代软件架构的复杂性需要协同开发完成，如何高效地协同呢？无规矩不成方圆，无规范难以协同，比如，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全，试想如果没有限速，没有红绿灯，谁还敢上路行驶。对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的统一方式一起做事，提升协作效率，降低沟通成本。代码的字里行间流淌的是软件系统的血液，质量的提升是尽可能少踩坑，杜绝踩重复的坑，切实提升系统稳定性，码出质量。</em><br><a name="itBp8"></a></p><h1 id="一、编程规约"><a href="#一、编程规约" class="headerlink" title="一、编程规约"></a>一、编程规约</h1><p><a name="YKrNh"></a></p><h3 id="一-命名规范"><a href="#一-命名规范" class="headerlink" title="(一)命名规范"></a>(一)命名规范</h3><p><a name="tQAwT"></a></p><h4 id="1-1-1-项目命名"><a href="#1-1-1-项目命名" class="headerlink" title="1.1.1 项目命名"></a>1.1.1 项目命名</h4><p>全部采用小写方式， 以中划线分隔。<br />正例：<code>mall-management-system</code><br />反例：<code>mall_management-system / mallManagementSystem</code><br><a name="pRoTq"></a></p><h4 id="1-1-2-目录命名"><a href="#1-1-2-目录命名" class="headerlink" title="1.1.2 目录命名"></a>1.1.2 目录命名</h4><p>全部采用小写方式， 以中划线分隔，有复数结构时，要采用复数命名法， 缩写不用复数<br />正例： <code>scripts / styles / components / images / utils / layouts / demo-styles / demo-scripts / img / doc</code><br />反例： <code>script / style / demo_scripts / demoStyles / imgs / docs</code><br />【特殊】VUE 的项目中的 components 中的组件目录，使用 kebab-case 命名<br />正例： <code>head-search / page-loading / authorized / notice-icon</code><br />反例： <code>HeadSearch / PageLoading</code><br />【特殊】VUE 的项目中的除 components 组件目录外的所有目录也使用 kebab-case 命名<br />正例： <code>page-one / shopping-car / user-management</code><br />反例： <code>ShoppingCar / UserManagement</code><br><a name="rddhB"></a></p><h4 id="1-1-3-JS、CSS、SCSS、HTML、PNG-文件命名"><a href="#1-1-3-JS、CSS、SCSS、HTML、PNG-文件命名" class="headerlink" title="1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名"></a>1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名</h4><p>全部采用小写方式， 以中划线分隔<br />正例： <code>render-dom.js / signup.css / index.html / company-logo.png</code><br />反例： <code>renderDom.js / UserManagement.html</code><br><a name="Odhei"></a></p><h4 id="1-1-4-命名严谨性"><a href="#1-1-4-命名严谨性" class="headerlink" title="1.1.4 命名严谨性"></a>1.1.4 命名严谨性</h4><p>代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用<br />正例：<code>henan / luoyang / rmb 等国际通用的名称，可视同英文。</code><br />反例：<code>DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3</code><br /><strong>杜绝完全不规范的缩写，避免望文不知义：</strong><br />反例：AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。<br><a name="Bif0f"></a></p><h3 id="二-HTML-规范-（Vue-Template-同样适用）"><a href="#二-HTML-规范-（Vue-Template-同样适用）" class="headerlink" title="(二)HTML 规范 （Vue Template 同样适用）"></a>(二)HTML 规范 （Vue Template 同样适用）</h3><p><a name="wviLN"></a></p><h4 id="1-2-1-HTML-类型"><a href="#1-2-1-HTML-类型" class="headerlink" title="1.2.1 HTML 类型"></a>1.2.1 HTML 类型</h4><p>推荐使用 HTML5 的文档类型申明： .<br />（建议使用 text&#x2F;html 格式的 HTML。避免使用 XHTML。XHTML 以及它的属性，比如 application&#x2F;xhtml+xml 在浏览器中的应用支持与优化空间都十分有限）。</p><ul><li>规定字符编码</li><li>IE 兼容模式</li><li>规定字符编码</li><li>doctype 大写</li></ul><p>正例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot; /&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Page title&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;img src=&quot;images/company-logo.png&quot; alt=&quot;Company&quot; /&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><a name="pyaOp"></a></p><h4 id="1-2-2-缩进"><a href="#1-2-2-缩进" class="headerlink" title="1.2.2 缩进"></a>1.2.2 缩进</h4><p>缩进使用 2 个空格（一个 tab）<br />嵌套的节点应该缩进。<br><a name="KsTsF"></a></p><h4 id="1-2-3-分块注释"><a href="#1-2-3-分块注释" class="headerlink" title="1.2.3 分块注释"></a>1.2.3 分块注释</h4><p>在每一个块状元素，列表元素和表格元素后，加上一对 HTML 注释。注释格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a name=&quot;VlgQK&quot;&gt;&lt;/a&gt;</span><br><span class="line">### 1.2.4 语义化标签</span><br><span class="line">HTML5 中新增很多语义化标签，所以优先使用语义化标签，避免一个页面都是 div 或者 p 标签&lt;br /&gt;正例</span><br></pre></td></tr></table></figure><header></header><footer></footer><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反例</span><br></pre></td></tr></table></figure><div>  <p></p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;a name=&quot;zVtmd&quot;&gt;&lt;/a&gt;</span><br><span class="line">#### 1.2.5 引号</span><br><span class="line">使用双引号(&quot; &quot;) 而不是单引号(’ &#x27;) 。&lt;br /&gt;正例： ``&lt;br /&gt;反例： ``</span><br><span class="line">&lt;a name=&quot;xGJTL&quot;&gt;&lt;/a&gt;</span><br><span class="line">### (三) CSS 规范</span><br><span class="line">&lt;a name=&quot;KfxnO&quot;&gt;&lt;/a&gt;</span><br><span class="line">#### 1.3.1 命名</span><br><span class="line"></span><br><span class="line">- 类名使用小写字母，以中划线分隔</span><br><span class="line">- id 采用驼峰式命名</span><br><span class="line">- scss 中的变量、函数、混合、placeholder 采用驼峰式命名</span><br><span class="line"></span><br><span class="line">ID 和 class 的名称总是使用可以反应元素目的和用途的名称，或其他通用的名称，代替表象和晦涩难懂的名称&lt;br /&gt;不推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>.fw-800 {  font-weight: 800;}.red {  color: red;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐:</span><br><span class="line"></span><br></pre></td></tr></table></figure>.heavy {  font-weight: 800;}.important {  color: red;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;wNraB&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.3.2 选择器</span><br><span class="line"></span><br><span class="line">1)css 选择器中避免使用标签名&lt;br /&gt;从结构、表现、行为分离的原则来看，应该尽量避免 css 中出现 HTML 标签，并且在 css 选择器中出现标签名会存在潜在的问题。&lt;br /&gt;2)很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。然而，在任何情况下，这是一个非常不好的做法。如果你不写很通用的，需要匹配到 DOM 末端的选择器， 你应该总是考虑直接子选择器。&lt;br /&gt;不推荐:</span><br><span class="line"></span><br></pre></td></tr></table></figure>.content .title {  font-size: 2rem;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐:</span><br><span class="line"></span><br></pre></td></tr></table></figure>.content > .title {  font-size: 2rem;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;uXLBl&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.3.3 尽量使用缩写属性</span><br><span class="line"></span><br><span class="line">不推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>border-top-style: none;font-family: palatino, georgia, serif;font-size: 100%;line-height: 1.6;padding-bottom: 2em;padding-left: 1em;padding-right: 1em;padding-top: 0;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>border-top: 0;font: 100%/1.6 palatino, georgia, serif;padding: 0 1em 2em;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;yp9l7&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.3.4 每个选择器及属性独占一行</span><br><span class="line"></span><br><span class="line">不推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>button{  width:100px;height:50px;color:#fff;background:#00a0e9;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>button{  width:100px;  height:50px;  color:#fff;  background:#00a0e9;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;UNEPQ&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.3.5 省略0后面的单位</span><br><span class="line"></span><br><span class="line">不推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>div{  padding-bottom: 0px;  margin: 0em;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>div{  padding-bottom: 0;  margin: 0;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;osdhZ&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.3.6 避免使用ID选择器及全局标签选择器防止污染全局样式</span><br><span class="line"></span><br><span class="line">不推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>#header{  padding-bottom: 0px;  margin: 0em;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>.header{  padding-bottom: 0px;  margin: 0em;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;z9fVV&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">### (四) LESS 规范</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;VEupf&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.4.1 代码组织</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;WMJWc&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 1)将公共less文件放置在style/less/common文件夹</span><br><span class="line"></span><br><span class="line">例:// color.less,common.less</span><br><span class="line">&lt;a name=&quot;oQbGV&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 2)按以下顺序组织</span><br><span class="line"></span><br><span class="line">1、@import;&lt;br /&gt;2、变量声明;&lt;br /&gt;3、样式声明;</span><br><span class="line"></span><br></pre></td></tr></table></figure>@import "mixins/size.less";@default-text-color: #333;.page {  width: 960px;  margin: 0 auto;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;ND8fs&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.4.2 避免嵌套层级过多</span><br><span class="line"></span><br><span class="line">将嵌套深度限制在3级。对于超过4级的嵌套，给予重新评估。这可以避免出现过于详实的CSS选择器。&lt;br /&gt;避免大量的嵌套规则。当可读性受到影响时，将之打断。推荐避免出现多于20行的嵌套规则出现&lt;br /&gt;不推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>.main{  .title{    .name{       color:#fff    }  }}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">推荐：</span><br><span class="line"></span><br></pre></td></tr></table></figure>.main-title{   .name{      color:#fff   }}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;RoBJW&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">### (五) Javascript 规范</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;FqMuc&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.1 命名</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;rGyyc&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 1) 采用小写驼峰命名 lowerCamelCase，代码中的命名均不能以下划线，也不能以下划线或美元符号结束</span><br><span class="line"></span><br><span class="line">反例： `_name / name_ / name$`</span><br><span class="line">&lt;a name=&quot;UCs3Y&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 2) 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式</span><br><span class="line"></span><br><span class="line">正例： `localValue / getHttpMessage() / inputUserId`&lt;br /&gt;*_**其中 method 方法命名必须是 动词 或者 动词+名词 形式***_&lt;br /&gt;正例：`saveShopCarData /openShopCarInfoDialog`&lt;br /&gt;反例：`save / open / show / go`&lt;br /&gt;*_**特此说明，增删查改，详情统一使用如下 5 个单词，不得使用其他（目的是为了统一各个端）***_</span><br><span class="line"></span><br></pre></td></tr></table></figure>add / update / delete / detail / get<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**附： 函数方法常用的动词:**</span><br><span class="line"></span><br></pre></td></tr></table></figure>get 获取/set 设置,add 增加/remove 删除create 创建/destory 移除start 启动/stop 停止open 打开/close 关闭,read 读取/write 写入load 载入/save 保存,create 创建/destroy 销毁begin 开始/end 结束,backup 备份/restore 恢复import 导入/export 导出,split 分割/merge 合并inject 注入/extract 提取,attach 附着/detach 脱离bind 绑定/separate 分离,view 查看/browse 浏览edit 编辑/modify 修改,select 选取/mark 标记copy 复制/paste 粘贴,undo 撤销/redo 重做insert 插入/delete 移除,add 加入/append 添加clean 清理/clear 清除,index 索引/sort 排序find 查找/search 搜索,increase 增加/decrease 减少play 播放/pause 暂停,launch 启动/run 运行compile 编译/execute 执行,debug 调试/trace 跟踪observe 观察/listen 监听,build 构建/publish 发布input 输入/output 输出,encode 编码/decode 解码encrypt 加密/decrypt 解密,compress 压缩/decompress 解压缩pack 打包/unpack 解包,parse 解析/emit 生成connect 连接/disconnect 断开,send 发送/receive 接收download 下载/upload 上传,refresh 刷新/synchronize 同步update 更新/revert 复原,lock 锁定/unlock 解锁check out 签出/check in 签入,submit 提交/commit 交付push 推/pull 拉,expand 展开/collapse 折叠begin 起始/end 结束,start 开始/finish 完成enter 进入/exit 退出,abort 放弃/quit 离开obsolete 废弃/depreciate 废旧,collect 收集/aggregate 聚集<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;U6BUP&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 3) 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长</span><br><span class="line"></span><br><span class="line">正例： `MAX_STOCK_COUNT`&lt;br /&gt;反例： `MAX_COUNT`</span><br><span class="line">&lt;a name=&quot;XZqGC&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.2 代码格式</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;v5DOh&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 1) 使用 2 个空格进行缩进</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>if (x < y) {  x += 10;} else {  x += 1;}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;FZldi&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 2) 不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性</span><br><span class="line">&gt;</span><br><span class="line">&gt; 说明：任何情形，没有必要插入多个空行进行隔开。</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;j7Oi0&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.3 字符串</span><br><span class="line"></span><br><span class="line">统一使用单引号(‘)，不使用双引号(“)。这在创建 HTML 字符串非常有好处：&lt;br /&gt;正例:</span><br><span class="line"></span><br></pre></td></tr></table></figure>let str = 'foo';let testDiv = '<div id="test"></div>';<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例:</span><br><span class="line"></span><br></pre></td></tr></table></figure>let str = 'foo';let testDiv = "<div id='test'></div>";<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;jf452&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.4 对象声明</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;n1rh3&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 1)使用字面值创建对象</span><br><span class="line"></span><br><span class="line">正例： `let user = &#123;&#125;;`&lt;br /&gt;反例： `let user = new Object();`</span><br><span class="line">&lt;a name=&quot;fgjiv&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 2) 使用字面量来代替对象构造器</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>var user = {  age: 0,  name: 1,  city: 3};<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>var user = new Object();user.age = 0;user.name = 0;user.city = 0;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;zlHHq&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.5 使用 ES6,7</span><br><span class="line"></span><br><span class="line">必须优先使用 ES6,7 中新增的语法糖和函数。这将简化你的程序，并让你的代码更加灵活和可复用。</span><br><span class="line">&gt; 必须强制使用 ES6, ES7 的新语法，比如箭头函数、await/async ， 解构， let ， for…of 等等</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;epQwk&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.6 括号</span><br><span class="line"></span><br><span class="line">下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try, catch, finally, with。&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>if (condition) {  doSomething();}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>if (condition) doSomething();<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;IXqXg&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.7 undefined 判断</span><br><span class="line"></span><br><span class="line">永远不要直接使用 undefined 进行变量判断；使用 typeof 和字符串’undefined’对变量进行判断。&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>if (typeof person === 'undefined') {    ...}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>if (person === undefined) {    ...}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;JgaPE&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.8 条件判断和循环最多三层</span><br><span class="line"></span><br><span class="line">条件判断能使用三目运算符和逻辑运算符解决的，就不要使用条件判断，但是谨记不要写太长的三目运算符。如果超过 3 层请抽成函数，并写清楚注释。</span><br><span class="line">&lt;a name=&quot;kAFRZ&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.9 this 的转换命名</span><br><span class="line"></span><br><span class="line">对上下文 this 的引用只能使用’self’来命名</span><br><span class="line">&lt;a name=&quot;suHfw&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 1.5.10 慎用 console.log</span><br><span class="line"></span><br><span class="line">因 console.log 大量使用会有性能问题，所以在非 webpack 项目中谨慎使用 log 功能</span><br><span class="line">&lt;a name=&quot;Vcg1U&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"># 二、Vue 项目规范</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;l5N8N&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">### (一) Vue 编码基础</span><br><span class="line"></span><br><span class="line">vue 项目规范以 Vue 官方规范 （[https://cn.vuejs.org/v2/style-guide/）](https://cn.vuejs.org/v2/style-guide/%EF%BC%89) 中的 A 规范为基础，在其上面进行项目开发，故所有代码均遵守该规范。</span><br><span class="line">&gt; 请仔仔细细阅读 Vue 官方规范，切记，此为第一步。</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;I83ZE&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.1. 组件规范</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;hoScD&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 1) 组件名为多个单词</span><br><span class="line"></span><br><span class="line">组件名应该始终是多个单词组成（大于等于 2），且命名规范为`KebabCase`格式。&lt;br /&gt;这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>export default {  name: 'TodoItem'  // ...};<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>export default {  name: 'Todo',  // ...}export default {  name: 'todo-item',  // ...}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;qn0tj&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 2) 组件文件名为 pascal-case 格式</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>components/|- my-component.vue<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>components/|- myComponent.vue|- MyComponent.vue<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;ZelRK&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 3) 基础组件文件名为 base 开头，使用完整单词而不是缩写</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>components/|- base-button.vue|- base-table.vue|- base-icon.vue<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>components/|- MyButton.vue|- VueTable.vue|- Icon.vue<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;nrDxd&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 4) 和父组件紧密耦合的子组件应该以父组件名作为前缀命名</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>components/|- todo-list.vue|- todo-list-item.vue|- todo-list-item-button.vue|- user-profile-options.vue （完整单词）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>components/|- TodoList.vue|- TodoItem.vue|- TodoButton.vue|- UProfOpts.vue （使用了缩写）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;vPzyN&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 5) 在 Template 模版中使用组件，应使用 PascalCase 模式，并且使用自闭合组件</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><!-- 在单文件组件、字符串模板和 JSX 中 --><MyComponent /><Row><table :column="data"/></Row><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><my-component /> <row><table :column="data"/></row><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;Rdrdy&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 6) 组件的 data 必须是一个函数</span><br><span class="line"></span><br><span class="line">当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。 因为如果直接是一个对象的话，子组件之间的属性值会互相影响。&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>export default {  data () {    return {      name: 'jack'    }  }}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>export default {  data: {    name: 'jack'  }}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;iGRed&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 7) Prop 定义应该尽量详细</span><br><span class="line"></span><br><span class="line">- 必须使用 camelCase 驼峰命名</span><br><span class="line">- 必须指定类型</span><br><span class="line">- 必须加上注释，表明其含义</span><br><span class="line">- 必须加上 required 或者 default，两者二选其一</span><br><span class="line">- 如果有业务需要，必须加上 validator 验证</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>props: {  // 组件状态，用于控制组件的颜色   status: {     type: String,     required: true,     validator: function (value) {       return [         'succ',         'info',         'error'       ].indexOf(value) !== -1     }   },    // 用户级别，用于显示皇冠个数   userLevel：{      type: String,      required: true   }}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;Qavrp&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 8) 为组件样式设置作用域</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><template>  <button class="btn btn-close">X</button></template><!-- 使用 `scoped` 特性 --><style scoped>  .btn-close {    background-color: red;  }</style><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><template>  <button class="btn btn-close">X</button></template><!-- 没有使用 `scoped` 特性 --><style>  .btn-close {    background-color: red;  }</style><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;PyIFU&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 9) 如果特性元素较多，应该主动换行</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><MyComponent foo="a" bar="b" baz="c"    foo="a" bar="b" baz="c"    foo="a" bar="b" baz="c" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><MyComponent foo="a" bar="b" baz="c" foo="a" bar="b" baz="c" foo="a" bar="b" baz="c" foo="a" bar="b" baz="c"/><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;iUoBM&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.2. 模板中使用简单的表达式</span><br><span class="line"></span><br><span class="line">组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><template>  <p></p></template>// 复杂表达式已经移入一个计算属性computed: {  normalizedFullName: function () {    return this.fullName.split(' ').map(function (word) {      return word[0].toUpperCase() + word.slice(1)    }).join(' ')  }}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><template>  <p>       {          fullName.split(' ').map(function (word) {             return word[0].toUpperCase() + word.slice(1)           }).join(' ')        }  </p></template><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;tpW6a&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.3 指令都使用缩写形式</span><br><span class="line"></span><br><span class="line">指令推荐都使用缩写形式，(用 : 表示 v-bind: 、用 @ 表示 v-on: 和用 # 表示 v-slot:)&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><input  @input="onInput"  @focus="onFocus"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><input  v-on:input="onInput"  @focus="onFocus"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;XKmR7&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.4 标签顺序保持一致</span><br><span class="line"></span><br><span class="line">单文件组件应该总是让标签顺序保持为 `&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><template>...</template><script>...</script><style>...</style><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><template>...</template><style>...</style><script>...</script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;kJIqE&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.5 必须为 v-for 设置键值 key</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;wBAPB&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.6 v-show 与 v-if 选择</span><br><span class="line"></span><br><span class="line">如果运行时，需要非常频繁地切换，使用 v-show ；如果在运行时，条件很少改变，使用 v-if。</span><br><span class="line">&lt;a name=&quot;KxH9Y&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.7 script 标签内部结构顺序</span><br><span class="line"></span><br><span class="line">components &gt; props &gt; data &gt; computed &gt; watch &gt; filter &gt; 钩子函数（钩子函数按其执行顺序） &gt; methods</span><br><span class="line">&lt;a name=&quot;QvXxX&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.1.8 Vue Router 规范</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;NQAOl&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 1) 页面跳转数据传递使用路由参数</span><br><span class="line"></span><br><span class="line">页面跳转，例如 A 页面跳转到 B 页面，需要将 A 页面的数据传递到 B 页面，推荐使用 路由参数进行传参，而不是将需要传递的数据保存 vuex，然后在 B 页面取出 vuex 的数据，因为如果在 B 页面刷新会导致 vuex 数据丢失，导致 B 页面无法正常显示数据。&lt;br /&gt;正例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>let id = ' 123';this.$router.push({ name: 'userCenter', query: { id: id } });<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;vMEBJ&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 2) 使用路由懒加载（延迟加载）机制</span><br><span class="line"></span><br></pre></td></tr></table></figure>{        path: '/uploadAttachment',        name: 'uploadAttachment',        meta: {          title: '上传附件'        },        component: () => import('@/view/components/uploadAttachment/index.vue')      },<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;rrKVt&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 3) router 中的命名规范</span><br><span class="line"></span><br><span class="line">path、childrenPoints 命名规范采用`kebab-case`命名规范（尽量vue文件的目录结构保持一致，因为目录、文件名都是`kebab-case`，这样很方便找到对应的文件）&lt;br /&gt;name 命名规范采用`KebabCase`命名规范且和component组件名保持一致！（因为要保持keep-alive特性，keep-alive按照component的name进行缓存，所以两者必须高度保持一致）</span><br><span class="line"></span><br></pre></td></tr></table></figure>// 动态加载export const reload = [  {    path: '/reload',    name: 'reload',    component: Main,    meta: {      title: '动态加载',      icon: 'icon iconfont'    },    children: [      {        path: '/reload/smart-reload-list',        name: 'SmartReloadList',        meta: {          title: 'SmartReload',          childrenPoints: [            {              title: '查询',              name: 'smart-reload-search'            },            {              title: '执行reload',              name: 'smart-reload-update'            },            {              title: '查看执行结果',              name: 'smart-reload-result'            }          ]        },        component: () =>          import('@/views/reload/smart-reload/smart-reload-list.vue')      }    ]  }];<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;Qz6x3&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 4) router 中的 path 命名规范</span><br><span class="line"></span><br><span class="line">path除了采用`kebab-case`命名规范以外，必须以 / 开头，即使是children里的path也要以 / 开头。如下示例</span><br><span class="line"></span><br><span class="line">- &lt;br /&gt;</span><br><span class="line"></span><br><span class="line">目的：&lt;br /&gt;经常有这样的场景：某个页面有问题，要立刻找到这个vue文件，如果不用以/开头，path为parent和children组成的，可能经常需要在router文件里搜索多次才能找到，而如果以/开头，则能立刻搜索到对应的组件&lt;br /&gt;*</span><br><span class="line"></span><br></pre></td></tr></table></figure>{    path: '/file',    name: 'File',    component: Main,    meta: {      title: '文件服务',      icon: 'ios-cloud-upload'    },    children: [      {        path: '/file/file-list',        name: 'FileList',        component: () => import('@/views/file/file-list.vue')      },      {        path: '/file/file-add',        name: 'FileAdd',        component: () => import('@/views/file/file-add.vue')      },      {        path: '/file/file-update',        name: 'FileUpdate',        component: () => import('@/views/file/file-update.vue')      }    ]  }<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;XO9zt&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">### (二) Vue 项目目录规范</span><br><span class="line"></span><br><span class="line">&lt;a name=&quot;WZHqs&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.2.1 基础</span><br><span class="line"></span><br><span class="line">vue 项目中的所有命名一定要与后端命名统一。&lt;br /&gt;比如权限：后端 privilege, 前端无论 router , store, api 等都必须使用 privielege 单词！</span><br><span class="line">&lt;a name=&quot;rttWc&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.2.2 使用 Vue-cli 脚手架</span><br><span class="line"></span><br><span class="line">使用 vue-cli3 来初始化项目，项目名按照上面的命名规范。</span><br><span class="line">&lt;a name=&quot;cCzVN&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">#### 2.2.3 目录说明</span><br><span class="line"></span><br><span class="line">目录名按照上面的命名规范，其中 components 组件用大写驼峰，其余除 components 组件目录外的所有目录均使用 kebab-case 命名。</span><br><span class="line"></span><br></pre></td></tr></table></figure>src                               源码目录|-- api                              所有api接口|-- assets                           静态资源，images, icons, styles等|-- components                       公用组件|-- config                           配置信息|-- constants                        常量信息，项目所有Enum, 全局常量等|-- directives                       自定义指令|-- filters                          过滤器，全局工具|-- datas                            模拟数据，临时存放|-- lib                              外部引用的插件存放及修改文件|-- mock                             模拟接口，临时存放|-- plugins                          插件，全局使用|-- router                           路由，统一管理|-- store                            vuex, 统一管理|-- themes                           自定义样式主题|-- views                            视图目录|   |-- role                             role模块名|   |-- |-- role-list.vue                    role列表页面|   |-- |-- role-add.vue                     role新建页面|   |-- |-- role-update.vue                  role更新页面|   |-- |-- index.less                      role模块样式|   |-- |-- components                      role模块通用组件文件夹|   |-- employee                         employee模块<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;lBRiA&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 1) api 目录</span><br><span class="line"></span><br><span class="line">- 文件、变量命名要与后端保持一致。</span><br><span class="line">- 此目录对应后端 API 接口，按照后端一个 controller 一个 api js 文件。若项目较大时，可以按照业务划分子目录，并与后端保持一致。</span><br><span class="line">- api 中的方法名字要与后端 api url 尽量保持语义高度一致性。</span><br><span class="line">- 对于 api 中的每个方法要添加注释，注释与后端 swagger 文档保持一致。</span><br><span class="line"></span><br><span class="line">正例：&lt;br /&gt;后端 url： EmployeeController.java</span><br><span class="line"></span><br></pre></td></tr></table></figure>/employee/add/employee/delete/{id}/employee/update<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">前端： employee.js</span><br><span class="line"></span><br></pre></td></tr></table></figure>// 添加员工  addEmployee: (data) => {    return postAxios('/employee/add', data)  },  // 更新员工信息  updateEmployee: (data) => {    return postAxios('/employee/update', data)  },    // 删除员工  deleteEmployee: (employeeId) => {    return postAxios('/employee/delete/' + employeeId)   },<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;FUcNR&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 2) assets 目录</span><br><span class="line"></span><br><span class="line">assets 为静态资源，里面存放 images, styles, icons 等静态资源，静态资源命名格式为 kebab-case</span><br><span class="line"></span><br></pre></td></tr></table></figure>|assets|-- icons|-- images|   |-- background-color.png|   |-- upload-header.png|-- styles<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;QRtKi&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 3) components 目录</span><br><span class="line"></span><br><span class="line">此目录应按照组件进行目录划分，目录命名为 KebabCase，组件命名规则也为 KebabCase</span><br><span class="line"></span><br></pre></td></tr></table></figure>|components|-- error-log|   |-- index.vue|   |-- index.less|-- markdown-editor|   |-- index.vue|   |-- index.js|-- kebab-case<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;OD26G&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 4) constants 目录</span><br><span class="line"></span><br><span class="line">此目录存放项目所有常量，如果常量在 vue 中使用，请使用 vue-enum 插件([https://www.npmjs.com/package/vue-enum](https://www.npmjs.com/package/vue-enum))&lt;br /&gt;目录结构：</span><br><span class="line"></span><br></pre></td></tr></table></figure>|constants|-- index.js|-- role.js|-- employee.js<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例子： employee.js</span><br><span class="line"></span><br></pre></td></tr></table></figure>export const EMPLOYEE_STATUS = {  NORMAL: {    value: 1,    desc: '正常'  },  DISABLED: {    value: 1,    desc: '禁用'  },  DELETED: {    value: 2,    desc: '已删除'  }};export const EMPLOYEE_ACCOUNT_TYPE = {  QQ: {    value: 1,    desc: 'QQ登录'  },  WECHAT: {    value: 2,    desc: '微信登录'  },  DINGDING: {    value: 3,    desc: '钉钉登录'  },  USERNAME: {    value: 4,    desc: '用户名密码登录'  }};export default {  EMPLOYEE_STATUS,  EMPLOYEE_ACCOUNT_TYPE};<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name=&quot;XPGn4&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 5) router 与 store 目录</span><br><span class="line"></span><br><span class="line">这两个目录一定要将业务进行拆分，不能放到一个 js 文件里。&lt;br /&gt;router 尽量按照 views 中的结构保持一致&lt;br /&gt;store 按照业务进行拆分不同的 js 文件</span><br><span class="line">&lt;a name=&quot;aCZ5V&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">##### 6) views 目录</span><br><span class="line"></span><br><span class="line">- 命名要与后端、router、api 等保持一致</span><br><span class="line">- components 中组件要使用 PascalCase 规则</span><br><span class="line"></span><br></pre></td></tr></table></figure>|-- views                            视图目录|   |-- role                             role模块名|   |   |-- role-list.vue                    role列表页面|   |   |-- role-add.vue                     role新建页面|   |   |-- role-update.vue                  role更新页面|   |   |-- index.less                      role模块样式|   |   |-- components                      role模块通用组件文件夹|   |   |   |-- role-header.vue                        role头部组件|   |   |   |-- role-modal.vue                         role弹出框组件|   |-- employee                         employee模块|   |-- behavior-log                      行为日志log模块|   |-- code-generator                    代码生成器模块```<p><a name="SdZof"></a></p><h4 id="2-2-4-注释说明"><a href="#2-2-4-注释说明" class="headerlink" title="2.2.4 注释说明"></a>2.2.4 注释说明</h4><p>整理必须加注释的地方</p><ul><li>公共组件使用说明</li><li>api 目录的接口 js 文件必须加注释</li><li>store 中的 state, mutation, action 等必须加注释</li><li>vue 文件中的 template 必须加注释，若文件较大添加 start end 注释</li><li>vue 文件的 methods，每个 method 必须添加注释</li><li>vue 文件的 data, 非常见单词要加注释<br><a name="flWca"></a></li></ul><h4 id="2-2-5-其他"><a href="#2-2-5-其他" class="headerlink" title="2.2.5 其他"></a>2.2.5 其他</h4><p><a name="J7MHY"></a></p><h5 id="1-尽量不要手动操作-DOM"><a href="#1-尽量不要手动操作-DOM" class="headerlink" title="1) 尽量不要手动操作 DOM"></a>1) 尽量不要手动操作 DOM</h5><p>因使用 vue 框架，所以在项目开发中尽量使用 vue 的数据驱动更新 DOM，尽量（不到万不得已）不要手动操作 DOM，包括：增删改 dom 元素、以及更改样式、添加事件等。<br><a name="Bv2v1"></a></p><h5 id="2-删除无用代码"><a href="#2-删除无用代码" class="headerlink" title="2) 删除无用代码"></a>2) 删除无用代码</h5><p>因使用了 git&#x2F;svn 等代码版本工具，对于无用代码必须及时删除，例如：一些调试的 console 语句、无用的弃用功能代码。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 库</title>
      <link href="/2021/09/19/frontend/collection/vue-ku/"/>
      <url>/2021/09/19/frontend/collection/vue-ku/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658249113976-aac50b99-5921-4a3b-a7e8-0ebadac449dd.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658249113976-aac50b99-5921-4a3b-a7e8-0ebadac449dd.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="SiTly"></a></p><h1 id="1-状态管理"><a href="#1-状态管理" class="headerlink" title="1. 状态管理"></a><br />1. 状态管理</h1><p><a name="fzcN6"></a></p><h2 id="（1）Pinia"><a href="#（1）Pinia" class="headerlink" title="（1）Pinia"></a>（1）Pinia</h2><p>Pinia 是最新一代的 Vue 轻量级状态管理库。它适用于 Vue 2.x 和 Vue 3.x。它是 Vue 官方成员在2019年11月重新设计的一个状态存储库，它允许你跨组件&#x2F;页面共享状态，并且是响应式的，类似于 Vuex。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658240532615-2a0e69d6-67b6-4fc7-86f0-85ede2ca5efc.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658240532615-2a0e69d6-67b6-4fc7-86f0-85ede2ca5efc.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="D8Dnn"></a></p><h2 id="（2）Vuex"><a href="#（2）Vuex" class="headerlink" title="（2）Vuex"></a><br />（2）Vuex</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658240637248-ebca700a-c553-47f0-a1b0-f4c29c182a4b.png?x-oss-process=image/resize,w_957,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658240637248-ebca700a-c553-47f0-a1b0-f4c29c182a4b.png?x-oss-process=image/resize,w_957,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="fBZ7u"></a></p><h2 id="（3）vuex-persist"><a href="#（3）vuex-persist" class="headerlink" title="（3）vuex-persist"></a><br />（3）vuex-persist</h2><p>vuex-persistedstate 是一个支持 Typescript 的Vuex插件，使你能够将应用程序的状态保存到持久存储中，例如 Cookies 或 localStorage。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658241184423-55a6ddf9-29fe-425c-8fe6-6e99b04fe714.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658241184423-55a6ddf9-29fe-425c-8fe6-6e99b04fe714.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="EFDw2"></a></p><h1 id="2-表单"><a href="#2-表单" class="headerlink" title="2. 表单"></a><br />2. 表单</h1><p><a name="Hl6Xo"></a></p><h2 id="（1）VeeValidate"><a href="#（1）VeeValidate" class="headerlink" title="（1）VeeValidate"></a>（1）VeeValidate</h2><p>vee-validate 是Vue.js的表单验证库，它允许验证输入并以熟悉的声明式样式或使用组合函数构建更好的表单 UI。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244322020-a5806224-d508-42c7-b040-dcf5a2f227b4.png?x-oss-process=image/resize,w_952,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244322020-a5806224-d508-42c7-b040-dcf5a2f227b4.png?x-oss-process=image/resize,w_952,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="OkqPQ"></a></p><h2 id="（2）vue-form-making"><a href="#（2）vue-form-making" class="headerlink" title="（2）vue-form-making"></a><br />（2）vue-form-making</h2><p>vue-form-making 是一个基于 vue 和 element-ui 实现的可视化表单设计器，使用了最新的前端技术栈，内置了 i18n 国际化解决方案，可以让表单开发简单而高效。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244554598-4310d3e7-3091-4310-9c3b-70e5de91317b.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244554598-4310d3e7-3091-4310-9c3b-70e5de91317b.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="vMXrC"></a></p><h2 id="（3）FormKit"><a href="#（3）FormKit" class="headerlink" title="（3）FormKit"></a><br />（3）FormKit</h2><p>FormKit 是一个面向 Vue 开发人员的表单创作框架，它使构建高质量的生产就绪表单的速度提高了 10 倍。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244690324-e745f913-a5f9-47e2-854f-9bae60ecef5f.png?x-oss-process=image/resize,w_954,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244690324-e745f913-a5f9-47e2-854f-9bae60ecef5f.png?x-oss-process=image/resize,w_954,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="iYuba"></a></p><h1 id="3-文档"><a href="#3-文档" class="headerlink" title="3. 文档"></a><br />3. 文档</h1><p><a name="diAh4"></a></p><h2 id="（1）VitePress"><a href="#（1）VitePress" class="headerlink" title="（1）VitePress"></a>（1）VitePress</h2><p>VitePress 是 VuePress 的继承者，建立在vite 之上。目前，正处于alpha阶段。它已经适合开箱即用的文档使用，但配置和主题 API 可能仍会在次要版本之间发生变化。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658241882514-095613ba-77a2-4793-9c49-b5a3dd9d0045.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658241882514-095613ba-77a2-4793-9c49-b5a3dd9d0045.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="rI8Zb"></a></p><h2 id="（2）VuePress"><a href="#（2）VuePress" class="headerlink" title="（2）VuePress"></a>（2）VuePress</h2><p>VuePress 是一个基于 Vue 的轻量级静态网站生成器，以及为编写技术文档而优化的默认主题。 它是为了满足 Vue 自己的子项目文档的需求而创建的。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658241791565-51890648-63e4-47bc-8581-479e5a4aeafc.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658241791565-51890648-63e4-47bc-8581-479e5a4aeafc.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="S7MNQ"></a></p><h2 id="（3）Gridsome"><a href="#（3）Gridsome" class="headerlink" title="（3）Gridsome"></a>（3）Gridsome</h2><p>Gridsome 是一个基于 Vue.js 构建的 Jamstack 框架，它让开发人员可以轻松地构建静态生成的网站和应用程序，这些网站和应用程序天生速度快。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658247087501-fe2c275f-e7be-4011-8618-6e3f6da4ac9b.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658247087501-fe2c275f-e7be-4011-8618-6e3f6da4ac9b.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="KD3jT"></a></p><h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a><br />4. 测试</h1><p><a name="dyNRp"></a></p><h2 id="（1）Vitest"><a href="#（1）Vitest" class="headerlink" title="（1）Vitest"></a>（1）Vitest</h2><p>Vitest 是一个由 Vite 提供支持的极速单元测试框架。其和 Vite 的配置、转换器、解析器和插件保持一致，具有开箱即用的 TypeScript &#x2F; JSX 支持。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658242281270-7d006534-6f79-48cc-ac3a-1ab58b1af72e.png?x-oss-process=image/resize,w_954,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658242281270-7d006534-6f79-48cc-ac3a-1ab58b1af72e.png?x-oss-process=image/resize,w_954,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="lvZ5P"></a></p><h2 id="（2）Jest"><a href="#（2）Jest" class="headerlink" title="（2）Jest"></a><br />（2）Jest</h2><p>Jest 是一个全面的 JavaScript 测试解决方案，专注于简洁明快。适用于大多数 JavaScript 项目。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658242600801-d9bcf342-7c55-426c-8694-4da4b9653686.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658242600801-d9bcf342-7c55-426c-8694-4da4b9653686.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="ebERg"></a></p><h2 id="（3）Mocha"><a href="#（3）Mocha" class="headerlink" title="（3）Mocha"></a><br />（3）Mocha</h2><p>mocha是一个功能丰富的javascript测试框架，运行在node.js和浏览器中，使异步测试变得简单有趣。Mocha测试连续运行，允许灵活和准确的报告，同时将未捕获的异常映射到正确的测试用例。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658242834462-44236ea1-0527-46b9-8ecb-e51ad65ef5ad.png?x-oss-process=image/resize,w_945,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658242834462-44236ea1-0527-46b9-8ecb-e51ad65ef5ad.png?x-oss-process=image/resize,w_945,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="GkI1w"></a></p><h1 id="5-可视化"><a href="#5-可视化" class="headerlink" title="5. 可视化"></a><br />5. 可视化</h1><p><a name="WHM2e"></a></p><h2 id="（1）Vue-ChartJS"><a href="#（1）Vue-ChartJS" class="headerlink" title="（1）Vue ChartJS"></a>（1）Vue ChartJS</h2><p>vue-chartjs 是一个 Vue 对于 Chart.js 的封装，让用户可以在Vue中轻松使用Chart.js，很简单的创建可复用的图表组件，非常适合需要简单的图表并尽可能快地运行的人。 vue-chartjs抽象了基本逻辑，同时也暴露了Chart.js对象，让用户获得最大的灵活性。它支持 Vue 3 和 Vue 2。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658243328737-ef5294c0-4185-41a0-9567-421c5f583e29.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658243328737-ef5294c0-4185-41a0-9567-421c5f583e29.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="KuLA0"></a></p><h2 id="（2）Apache-ECharts"><a href="#（2）Apache-ECharts" class="headerlink" title="（2）Apache ECharts"></a><br />（2）Apache ECharts</h2><p>Apache ECharts 是一款基于Javascript的数据可视化图表库，提供直观，生动，可交互，可个性化定制的数据可视化图表。它是用纯 JavaScript 编写的，基于zrender，是一个全新的轻量级画布库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658243634219-bdf272dd-a253-4d6d-9eca-bc1dd0292d32.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658243634219-bdf272dd-a253-4d6d-9eca-bc1dd0292d32.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="rqUhQ"></a></p><h2 id="（3）Vue-ECharts"><a href="#（3）Vue-ECharts" class="headerlink" title="（3）Vue-ECharts"></a><br />（3）Vue-ECharts</h2><p>Vue-ECharts 是 Apache ECharts 的 Vue.js 组件。使用 Apache ECharts 5，同时支持 Vue.js 2&#x2F;3。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658243888856-bb73498b-d853-43a7-b10a-e1c2e1fd0e28.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658243888856-bb73498b-d853-43a7-b10a-e1c2e1fd0e28.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="NHWLF"></a></p><h2 id="（4）Trois"><a href="#（4）Trois" class="headerlink" title="（4）Trois"></a><br />（4）Trois</h2><p>Trois 是一个基于 Three.JS 的 Vue 3 可视化库，它是一个流行的 WebGL 库。 Three.JS 对桌面和移动设备都有很好的支持。 该库允许我们使用 VueJS 组件轻松为网站创建 3D 效果。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658245369189-f6e12dc5-63a8-436a-829d-5832407e4054.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658245369189-f6e12dc5-63a8-436a-829d-5832407e4054.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="LCfns"></a></p><h1 id="6-组件"><a href="#6-组件" class="headerlink" title="6. 组件"></a><br />6. 组件</h1><p><a name="CZ9Hk"></a></p><h2 id="（1）Vue-Grid-Layout"><a href="#（1）Vue-Grid-Layout" class="headerlink" title="（1）Vue Grid Layout"></a>（1）Vue Grid Layout</h2><p>vue-grid-layout 是一个网格布局系统，类似于 Gridster，用于 Vue.js。 <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244016211-ff1879e4-67aa-4b8c-b66c-4a4a8527bd09.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244016211-ff1879e4-67aa-4b8c-b66c-4a4a8527bd09.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="WblsY"></a></p><h2 id="（2）Vue-Draggable"><a href="#（2）Vue-Draggable" class="headerlink" title="（2）Vue Draggable"></a><br />（2）Vue Draggable</h2><p>Vue Draggable 是一个基于 Sortable.js 的 Vue 拖拽组件。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244136335-2177ad07-f931-4128-b3b6-759d17f87f5d.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244136335-2177ad07-f931-4128-b3b6-759d17f87f5d.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="yejts"></a></p><h2 id="（3）Vue-Tour"><a href="#（3）Vue-Tour" class="headerlink" title="（3）Vue Tour"></a><br />（3）Vue Tour</h2><p>Vue Tour 是一个轻量级、简单且可定制的导览插件，可与 Vue.js 一起使用。它提供了一种快速简便的方法来指导用户完成你的应用程序。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244866751-55d7e307-be4d-458e-8728-68e668d16875.png?x-oss-process=image/resize,w_953,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244866751-55d7e307-be4d-458e-8728-68e668d16875.png?x-oss-process=image/resize,w_953,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（4）Swiper.js</strong><br />Swiper 是一款免费以及轻量级的移动设备触控滑块的框架，使用硬件加速过渡。主要使用与移动端的网站、网页应用程序，以及原生的应用程序。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244941098-1d009d31-ee3e-4ddb-a30d-47084d4fdc87.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658244941098-1d009d31-ee3e-4ddb-a30d-47084d4fdc87.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="AEitf"></a></p><h2 id="（5）vue-easytable"><a href="#（5）vue-easytable" class="headerlink" title="（5）vue-easytable"></a><br />（5）vue-easytable</h2><p>该库提供了一个功能齐全且高度可定制的表格组件&#x2F;数据网格。它支持许多功能，如虚拟滚动、列固定、标题固定、标题分组、过滤器、排序、单元格省略号、行扩展、行复选框等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658246173207-b8a6cdb5-ba20-4cfa-a43e-d6ab58cd817a.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658246173207-b8a6cdb5-ba20-4cfa-a43e-d6ab58cd817a.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="ymS5x"></a></p><h1 id="7-UI-组件"><a href="#7-UI-组件" class="headerlink" title="7. UI 组件"></a><br />7. UI 组件</h1><p><a name="YPNro"></a></p><h2 id="（1）Element-Plus"><a href="#（1）Element-Plus" class="headerlink" title="（1）Element Plus"></a>（1）Element Plus</h2><p>Element Plus，由饿了么大前端团队开源出品的一套为开发者、设计师和产品经理准备的基于 Vue 3.0 的组件库，Element Plus 是基于 Vue3 面向设计师和开发者的组件库，提供了配套设计资源，帮助你的网站快速成型。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658236849005-d22c295f-4efa-4bab-aeb7-e845a79840cd.png?x-oss-process=image/resize,w_780,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658236849005-d22c295f-4efa-4bab-aeb7-e845a79840cd.png?x-oss-process=image/resize,w_780,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="OvSFU"></a></p><h2 id="（2）Vuetify"><a href="#（2）Vuetify" class="headerlink" title="（2）Vuetify"></a>（2）Vuetify</h2><p>Vuetify 是一个基于 Vue.js 精心打造 UI 组件库，整套 UI 设计为 Material 风格。能够让没有任何设计技能的开发者创造出时尚的 Material 风格界面。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658236907279-ca0790f0-a9da-4b06-9a05-aacda6929c5a.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658236907279-ca0790f0-a9da-4b06-9a05-aacda6929c5a.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="yf71Z"></a></p><h2 id="（3）Vant"><a href="#（3）Vant" class="headerlink" title="（3）Vant"></a><br />（3）Vant</h2><p>Vant 是一套轻量、可靠的移动端组件库。通过 Vant，可以快速搭建出风格统一的页面，提升开发效率，支持 Vue 3。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658237411801-6a82c357-2294-4489-8652-d0d7152f8333.png?x-oss-process=image/resize,w_955,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658237411801-6a82c357-2294-4489-8652-d0d7152f8333.png?x-oss-process=image/resize,w_955,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="l6DSl"></a></p><h2 id="（4）Naive-UI"><a href="#（4）Naive-UI" class="headerlink" title="（4）Naive UI"></a><br />（4）Naive UI</h2><p>Naive UI 是一款基于当前比较新的 Vue 3.0&#x2F;TypeScript 技栈开发的前端 UI 组件库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658237717771-66f44c93-f6de-432a-8fea-74ac4f4c2a1c.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658237717771-66f44c93-f6de-432a-8fea-74ac4f4c2a1c.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="EWKvZ"></a></p><h1 id="8-动画"><a href="#8-动画" class="headerlink" title="8. 动画"></a><br />8. 动画</h1><p><a name="RlDbD"></a></p><h2 id="（1）Animate-css"><a href="#（1）Animate-css" class="headerlink" title="（1）Animate.css"></a>（1）Animate.css</h2><p>animate.css 是一个使用CSS3的animation制作的动画效果的CSS集合，里面预设了很多种常用的动画，且使用非常简单。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658237855634-9e42760e-330e-4174-9672-31fd389f0b40.png?x-oss-process=image/resize,w_957,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658237855634-9e42760e-330e-4174-9672-31fd389f0b40.png?x-oss-process=image/resize,w_957,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="zAOTJ"></a></p><h2 id="（2）Greensock"><a href="#（2）Greensock" class="headerlink" title="（2）Greensock"></a><br />（2）Greensock</h2><p>GreenSock是一个JavaScript动画库，可轻松对HTML元素进行动画处理。 用于创建高性能，零依赖性，跨浏览器动画，声称在超过 400 万个网站中使用。 <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238145678-e4baca0c-0a7d-45be-8741-246abfb71bbe.png?x-oss-process=image/resize,w_795,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238145678-e4baca0c-0a7d-45be-8741-246abfb71bbe.png?x-oss-process=image/resize,w_795,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="FyOdE"></a></p><h2 id="（3）Popmotion"><a href="#（3）Popmotion" class="headerlink" title="（3）Popmotion"></a><br />（3）Popmotion</h2><p>Popmotion 是一个只有12KB的 JavaScript 运动引擎，可以用来实现动画，物理效果和输入跟踪。原生的DOM支持：CSS，SVG，SVG路径和DOM属性的支持，开箱即用。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238362468-c97fe309-02bc-4cfe-8818-601d03e0ac8d.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238362468-c97fe309-02bc-4cfe-8818-601d03e0ac8d.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="Uo62F"></a></p><h2 id="（4）Vue-Kinesis"><a href="#（4）Vue-Kinesis" class="headerlink" title="（4）Vue Kinesis"></a><br />（4）Vue Kinesis</h2><p>Vue Kinesis 支持使用 Vue.js 轻松创建复杂的交互式动画，其支持 Vue 3。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238626259-c41830ba-7488-4d4b-bdad-afeb51426550.png?x-oss-process=image/resize,w_957,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238626259-c41830ba-7488-4d4b-bdad-afeb51426550.png?x-oss-process=image/resize,w_957,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="Ptqhj"></a></p><h1 id="9-图标"><a href="#9-图标" class="headerlink" title="9. 图标"></a><br />9. 图标</h1><p><a name="Mrqcu"></a></p><h2 id="（1）IconPark"><a href="#（1）IconPark" class="headerlink" title="（1）IconPark"></a>（1）IconPark</h2><p>IconPark 提供超过 2400 个高质量图标，还提供了每个图标的含义和来源的描述，便于开发者使用。除此之外，该网站还可以自定义图标，这是与其他图标网站与众不同的地方。该图标库是字节跳动旗下的技术驱动图标样式的开源图标库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238892165-34d2445d-91f9-4184-8b2b-6a6f1a1b24e2.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238892165-34d2445d-91f9-4184-8b2b-6a6f1a1b24e2.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="wrSdh"></a></p><h2 id="（2）Font-Awesome"><a href="#（2）Font-Awesome" class="headerlink" title="（2）Font Awesome"></a><br />（2）Font Awesome</h2><p>Font Awesome 提供了可缩放的矢量图标，可以使用CSS所提供的所有特性对它们进行更改，包括：大小、颜色、阴影或者其它任何支持的效果。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238892145-d72b28e0-8701-464e-b691-8b938b91fdc2.png?x-oss-process=image/resize,w_838,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238892145-d72b28e0-8701-464e-b691-8b938b91fdc2.png?x-oss-process=image/resize,w_838,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="NXs0v"></a></p><h2 id="（3）Ionicons"><a href="#（3）Ionicons" class="headerlink" title="（3）Ionicons"></a><br />（3）Ionicons</h2><p>Ionicons 是一个完全开源的图标集，是知名混合开发框架 Ionic Framework 内置的图标库，包含 1300 个设计优雅、风格统一的高质量图标，能满足大多数的业务场景。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238892220-50e3abe8-88ce-4cb5-a169-5852a9168ea0.png?x-oss-process=image/resize,w_792,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238892220-50e3abe8-88ce-4cb5-a169-5852a9168ea0.png?x-oss-process=image/resize,w_792,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="Ytpi7"></a></p><h2 id="（4）Bootstrap-Icons"><a href="#（4）Bootstrap-Icons" class="headerlink" title="（4）Bootstrap Icons"></a><br />（4）Bootstrap Icons</h2><p>Bootstrap Icons 是 Bootstrap 开源的 SVG 图标库，此图标库起初专门针对其组件（从表单控件到导航）和文档进行定制设计和构建，现在可以免费用于任何项目。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238892194-7bb1c0dd-f6e3-4acc-a42b-d81066841b10.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658238892194-7bb1c0dd-f6e3-4acc-a42b-d81066841b10.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="bSFKx"></a></p><h1 id="10-富文本编辑器"><a href="#10-富文本编辑器" class="headerlink" title="10. 富文本编辑器"></a><br />10. 富文本编辑器</h1><p><a name="ugxR9"></a></p><h2 id="（1）Tiptap"><a href="#（1）Tiptap" class="headerlink" title="（1）Tiptap"></a>（1）Tiptap</h2><p>Tiptap 是一个基于 Vue 的无渲染的富文本编辑器，它基于 Prosemirror，完全可扩展且无渲染。可以轻松地将自定义节点添加为Vue组件。使用无渲染组件（函数式组件），几乎完全控制标记和样式。菜单的外观或在DOM中的显示位置。这完全取决于使用者。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658239070542-7d1881e5-6895-48e3-835b-60347593c1e7.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658239070542-7d1881e5-6895-48e3-835b-60347593c1e7.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="iKndu"></a></p><h2 id="（2）Quill-js"><a href="#（2）Quill-js" class="headerlink" title="（2）Quill.js"></a><br />（2）Quill.js</h2><p>Quill.js 是一个具有跨平台和跨浏览器支持的富文本编辑器。凭借其可扩展架构和富有表现力的 API，可以完全自定义它以满足个性化的需求。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658239127493-66aaeb22-6fe3-4efb-a41d-36f444b8137f.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658239127493-66aaeb22-6fe3-4efb-a41d-36f444b8137f.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="JszhF"></a></p><h2 id="（3）TinyMCE"><a href="#（3）TinyMCE" class="headerlink" title="（3）TinyMCE"></a><br />（3）TinyMCE</h2><p>TinyMCE 是一个热门的富文本编辑器。它的目标是帮助其他开发人员构建精美的 Web 内容解决方案。它易于集成，可以部署在基于云的、自托管或混合环境中。该设置使得合并诸如 Angular、React 和 Vue 等框架成为可能。它还可以使用 50 多个插件进行扩展，每个插件都有 100 多个自定义选项。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658239167968-a3ca0fe5-d35a-404f-968c-5a78c8ab6ac9.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658239167968-a3ca0fe5-d35a-404f-968c-5a78c8ab6ac9.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="srS3i"></a></p><h2 id="（4）CKEditor-5"><a href="#（4）CKEditor-5" class="headerlink" title="（4）CKEditor 5"></a><br />（4）CKEditor 5</h2><p>CKEditor 是一个强大的富文本编辑器框架，具有模块化架构、现代集成和协作编辑等功能。它可以通过基于插件的架构进行扩展，从而可以将必要的内容处理功能引入。它是在 ES6 中从头开始编写的，并且具有出色的 webpack支持。可以使用与Angular、React和Vue.js的原生集成。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658239213415-71bfed0f-d331-471a-bacc-beecf4548811.png?x-oss-process=image/resize,w_853,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658239213415-71bfed0f-d331-471a-bacc-beecf4548811.png?x-oss-process=image/resize,w_853,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="RoXN9"></a></p><h1 id="11-服务端渲染"><a href="#11-服务端渲染" class="headerlink" title="11. 服务端渲染"></a><br />11. 服务端渲染</h1><p><a name="o4GBT"></a></p><h2 id="（1）Nuxt-js"><a href="#（1）Nuxt-js" class="headerlink" title="（1）Nuxt.js"></a>（1）Nuxt.js</h2><p>Nuxt.js 是一个基于 Vue.js 的通用应用框架。通过对客户端&#x2F;服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI 渲染。它预设了利用 Vue.js 开发服务端渲染的应用所需要的各种配置。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658239456606-2e79a410-44dc-4551-a754-03d333d79615.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658239456606-2e79a410-44dc-4551-a754-03d333d79615.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="iTCSa"></a></p><h2 id="（2）SSR"><a href="#（2）SSR" class="headerlink" title="（2）SSR"></a><br />（2）SSR</h2><p>ssr 框架是为前端框架在服务端渲染的场景下所打造的开箱即用的服务端渲染框架。面向 Serverless，同时支持 React，Vue2，Vue3。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658240199585-5d031fd6-2d20-4c2a-b798-e362be63c7fe.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658240199585-5d031fd6-2d20-4c2a-b798-e362be63c7fe.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="FTEyM"></a></p><h2 id="（3）Vue-meta"><a href="#（3）Vue-meta" class="headerlink" title="（3）Vue-meta"></a><br />（3）Vue-meta</h2><p>Vue-meta 是 Vue.js 的一个插件，它可以帮助你使用 SSR 支持管理 Vue.js 组件中的 HTML 元数据。Vue-meta 使用 Vue 的内置响应性使管理应用程序的元数据变得简单。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658243064630-bf87b19d-815b-46ee-a47e-5f90e287c24f.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658243064630-bf87b19d-815b-46ee-a47e-5f90e287c24f.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="G8zrq"></a></p><h1 id="12-数据获取"><a href="#12-数据获取" class="headerlink" title="12. 数据获取"></a><br />12. 数据获取</h1><p><a name="bGEpO"></a></p><h2 id="（1）Axios"><a href="#（1）Axios" class="headerlink" title="（1）Axios"></a>（1）Axios</h2><p>Axios 是一个基于promise 的网络请求库，作用于node.js和浏览器中。 <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658245855529-91574ed1-2434-414f-a13e-1b3c1e7fee43.png?x-oss-process=image/resize,w_952,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658245855529-91574ed1-2434-414f-a13e-1b3c1e7fee43.png?x-oss-process=image/resize,w_952,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="uCWIU"></a></p><h2 id="（2）vue-resource"><a href="#（2）vue-resource" class="headerlink" title="（2）vue-resource"></a><br />（2）vue-resource</h2><p>vue-resource是 Vue.js 的一款插件，它可以通过XMLHttpRequest或JSONP发起请求并处理响应。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658245988797-334b4815-9a67-49f9-bfe8-04254a81f0e1.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658245988797-334b4815-9a67-49f9-bfe8-04254a81f0e1.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="s2XtZ"></a></p><h2 id="（3）vue-axios"><a href="#（3）vue-axios" class="headerlink" title="（3）vue-axios"></a><br />（3）vue-axios</h2><p>vue-axios 是一个将 axios 集成到 Vuejs 的小型库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658246069841-a1466034-acb2-4a66-ac9b-c1ec926ab7e8.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658246069841-a1466034-acb2-4a66-ac9b-c1ec926ab7e8.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="NEJk1"></a></p><h1 id="13-构建工具"><a href="#13-构建工具" class="headerlink" title="13. 构建工具"></a><br />13. 构建工具</h1><p><a name="TmHvW"></a></p><h2 id="（1）Vite"><a href="#（1）Vite" class="headerlink" title="（1）Vite"></a>（1）Vite</h2><p>Vite 是下一代前端开发与构建工具。Vite 意在提供开箱即用的配置，同时它的插件 API 和 JavaScript API 带来了高度的可扩展性，并有完整的类型支持。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658246353785-4aecbd73-e51a-482f-b3aa-eceed2a3ee78.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658246353785-4aecbd73-e51a-482f-b3aa-eceed2a3ee78.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="h8UOM"></a></p><h2 id="（2）Webpack"><a href="#（2）Webpack" class="headerlink" title="（2）Webpack"></a><br />（2）Webpack</h2><p>webpack 是一个用于现代JavaScript应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 bundle。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658246649786-ce029da9-a405-4cf9-98ab-e317cd8a4a6e.png?x-oss-process=image/resize,w_949,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1658246649786-ce029da9-a405-4cf9-98ab-e317cd8a4a6e.png?x-oss-process=image/resize,w_949,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>debug断点调试</title>
      <link href="/2021/08/22/frontend/browser/debug/debug-duan-dian-diao-shi/"/>
      <url>/2021/08/22/frontend/browser/debug/debug-duan-dian-diao-shi/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="62glah"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前端开发中我们最常需要调试的部分是 JS ，在调试 JS 的过程中，我们最常使用的方法便是 debug 调试。何为 debug 调试？ debug调试又名断点调试，它指的是在程序指定位置设置断点，当程序运行到这个断点时会暂停执行并保留当前状态，我们可以通过查看暂停时的程序状态来定位和排查问题。</p><p>那么为什么我们需要用这种调试方法呢？实际开发中，当我们完成一个功能，但是发现在浏览器中未否生效时，如果没有很丰富的经验，我们很难直接定位到问题所在。因为这个时候程序已经完成了执行，程序中大部分使用过的变量已经被回收了。但是有了 debug 调试，我们可以在程序运行过程中实时查看它的运行状态，甚至可以一步一步得调试，来看每一个变量在每一步是如何变化的，这对我们排查异常非常有效。接下来我们来看以下几种常用的 debug 调试方法。</p><p><a name="wvsiew"></a></p><h3 id="1-代码中设置debugger断点或打印信息"><a href="#1-代码中设置debugger断点或打印信息" class="headerlink" title="1. 代码中设置debugger断点或打印信息"></a>1. 代码中设置debugger断点或打印信息</h3><p>最简单的 debug 方法，是在我们希望调试的代码前加上一行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">debugger</span>;</span><br></pre></td></tr></table></figure><p>只需要这么一行代码，就能使得程序的滚滚推进戛然而止，并且停在你想要的位置。我们亲手尝试一下，先写下一段 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>debug调试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;word&quot;</span>&gt;</span>这是一段文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;action.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再在与 HTML 文件的相同位置写下如下 JS ，命名为 action.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getNewName</span>(<span class="params">name1,name2</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> c = name1.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">4</span>),</span><br><span class="line">      d = name2.<span class="title function_">slice</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="keyword">return</span> c + d ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showNewName</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> a = <span class="string">&#x27;FreeStyle&#x27;</span>,</span><br><span class="line">  b = <span class="string">&#x27;CuteFaller&#x27;</span>;</span><br><span class="line"> <span class="keyword">var</span> newName = <span class="title function_">getNewName</span>(a,b);</span><br><span class="line"> <span class="keyword">var</span> word = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;word&#x27;</span>);</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> newWord = <span class="string">&#x27;新文字：&#x27;</span> + newName ;</span><br><span class="line">  word.<span class="property">innerText</span> = newWord ;</span><br><span class="line">  word.<span class="title function_">setAttribute</span>(<span class="string">&#x27;isNewName&#x27;</span>,<span class="literal">true</span>)</span><br><span class="line"> &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showNewName</span>();</span><br></pre></td></tr></table></figure><p>保存后在浏览器中打开 HTML 文件，我们会发现浏览器中“这是一段文字”在一秒钟之后变成了另一行文字。为什么会有这样的变化呢？我们在程序中设置一个断点来调试看看。在 getNewName 方法中写下一行 debugger;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getNewName</span>(<span class="params">name1,name2</span>)&#123;</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">  <span class="keyword">var</span> c = name1.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">4</span>),</span><br><span class="line">      d = name2.<span class="title function_">slice</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="keyword">return</span> c + d ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存文件并刷新浏览器，我们发现页面进入了断点位置</p><p>进入断点</p><p>打开控制台，此时我们停留在 Sources 一栏，还记得上一章介绍的内容吗？ Sources 展示着当前页面的资源，因此我们所写的 JS 代码自然也是可以在这里找到的。</p><p>仔细观察断点处，我们看到给 getNewName 方法传递的两个参数都有了值，控制台在代码边上备注了 “name1 &#x3D; “FreeStyle” , name2 &#x3D; “CuteFaller””这是当前函数执行时的变量值。</p><p>当我们用鼠标选中 name1.slice(0,4) 这一行，我们可以看到鼠标上方出现了一个显示 “Free”的气泡，这是浏览器执行这一句指令返回的结果。</p><p>查看运行情况</p><p>断点状态下按 F8 可以跳过当前断点继续执行，直到程序结束或是进入到下一个断点。按 F10 可以进行单步调试，即一行一行得执行代码，每一行的细节都可以进行查看。</p><p>除了可以在代码中写 debugger; 我们还可以通过 console.log(); 方法打印我们想要的信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getNewName</span>(<span class="params">name1,name2</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> c = name1.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">4</span>),</span><br><span class="line">      d = name2.<span class="title function_">slice</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br><span class="line">  <span class="keyword">return</span> c + d ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中加上一行打印，刷新页面发现没有进入断点。打开控制台，我们在 Console 中看到一行打印信息 “Free” 这就是我们打印的变量 c 的值。程序在执行到打印 c 的时候会将 c 当时的值打印到控制台，这样我们不需要进入断点也能够查看自己想知道的变量在运行阶段的值。</p><p>当然，我们还可以将两者并存，当程序进入到断点的时候，我们能通过 Console 控制台查看变量的值。断点状态下， Console 控制台会保留运行时的值和状态，我们可以在控制台直接访问当前执行函数内的变量。此外，当程序报错时，我们会第一时间在 Console 中看到，点击 Console 中的错误详情，就会跳转到 Sources 中的报错文件里，因此某种程度上，在调试过程中两者有着非常密切的联系。</p><p>最后要着重提醒的一点是，由于 debugger 和 console 这两种方式都是在源代码上添加的调试指令，所以当我们完成调试以后，<strong>一定要将它们删除</strong>，否则代码上线后他人也会进入到断点中，无法流畅得使用网页。</p><p><a name="if4mge"></a></p><h3 id="2-浏览器-Sources-中手动打断点"><a href="#2-浏览器-Sources-中手动打断点" class="headerlink" title="2. 浏览器 Sources 中手动打断点"></a>2. 浏览器 Sources 中手动打断点</h3><p>上一节内容我们介绍了如何进行 debug 调试，大家可能会觉得这样调试有些繁琐，要去源码中加调试代码，调完还得记得删除掉。那么我们在这一章，给大家提供一个简单明了的办法 —— 直接在 Sources中调试。</p><p>大家可以回顾一下上一章中我们对 JS 的调试，在 Sources 中通过 ctrl + P 找到我们希望调试的代码文件，ctrl + F 定位到我们想要调试的行。接下来，我们可以在文件的侧边栏上设置断点，设置方法就是在行数上单击。单击后行数上出现一个蓝色的便签，就表示已经在这一行上设置了断点，接下来刷新页面就可以进入到断点中查看了。</p><p>进入断点之后我们其实可以在浏览器的文件上进行编辑，不用进入源文件修改代码，就能够进行代码尝试。<br />编写临时代码</p><p>比如我们先进入到函数 getNewName 的断点中，再将代码 d &#x3D; name2.slice(4); 改写为 d &#x3D; name2.slice(4,6); 按 ctrl + S 保存。接下来按 F10 单步执行，当执行到这一句时，我们发现浏览器已经按照我们改写的代码执行了 d &#x3D; “Fa”，说明我们的临时代码生效了。</p><p>临时代码生效</p><p>跳过断点，页面上显示出 “新文字：FreeFa”，说明我们的改动并不影响后续逻辑的继续执行。但是数据已经按我们期望的临时改动展现了出来。</p><p>继续执行</p><p>这样进行代码调试我们不需要改变源代码即可对问题进行排查，非常灵活和快捷。想在什么地方设置断点只需要在 Sources 中找到对应的文件，点击一下想设置断点的那一行即可，无需改动源码，效率大大提升。调试结束后再次点击这些断点即可解除断点，对他人的网页不会造成任何影响。</p><p><a name="xy16us"></a></p><h3 id="3-浏览器-DOM-节点设置断点"><a href="#3-浏览器-DOM-节点设置断点" class="headerlink" title="3. 浏览器 DOM 节点设置断点"></a>3. 浏览器 DOM 节点设置断点</h3><p>最后我们再来看看 DOM 节点上设置断点的方法。我们在开发页面的时候，往往会对 DOM 节点做变更处理，假设业务场景比较复杂，你并不能确定某一个 DOM 的变化是由哪一个文件执行导致的。这时我们可以换一个角度，从 DOM 出发，监听 DOM 变化，再反过来追查引发其变化的代码。</p><p>浏览器提供了这样的操作，我们先在 Elements 模块中找到我们需要监听的 DOM 节点（这里我们以 p 节点为例），找到以后点击右键，选择 Break On 。里面可以监听三种变化类型：subtree modifications、attribute modifications和node removal。分别是对应子节点树更新、修改节点属性和移除节点。</p><p>监听节点操作</p><p>这里我们选择 attribute modifications 。接下来我们刷新页面，一秒钟之后进入断点。查看断点的位置，这里的代码是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">word.<span class="title function_">setAttribute</span>(<span class="string">&#x27;isNewName&#x27;</span>,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>正是这行代码在给 p 标签添加了名为 isNewName 的属性。</p><p>DOM 变化进入断点</p><p>这样我们就定位了引起 p 节点属性变化的 JS 代码，是不是很方便？对于不符合预期的节点变换，也可以通过这样的方式去追踪，真相很快就能浮出水面啦。</p><p><a name="x5emql"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上，是我们常用的几种 debug 调试方法。开发过程中妥善利用它，对我们的开发效率和排查问题的能力都有很大的帮助。当然，想学会调试最重要的还是要多尝试，熟能生巧。利器已在眼前，还请亲手体验。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React 库</title>
      <link href="/2021/06/22/frontend/collection/react-ku/"/>
      <url>/2021/06/22/frontend/collection/react-ku/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659661028895-0903535d-f3f2-4f99-8c0f-69bdfefb5694.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659661028895-0903535d-f3f2-4f99-8c0f-69bdfefb5694.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>1、状态管理</strong><br /><strong>（1）React Redux</strong><br />Redux 是 JavaScript 应用程序的状态容器，提供可预测的状态管理。React Redux 是 Redux 官方实现的 React 绑定。可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供超爽的开发体验。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659623141620-84e290b8-c9ba-4a4e-8e65-295891ad4860.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659623141620-84e290b8-c9ba-4a4e-8e65-295891ad4860.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）Mobx</strong><br />MobX 是一个身经百战的库，它通过运用透明的函数式响应编程使状态管理变得简单和可扩展。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659623224139-396bcd40-f8ae-4ec4-b05f-1b4d5da9a487.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659623224139-396bcd40-f8ae-4ec4-b05f-1b4d5da9a487.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（4）Redux-Saga</strong><br />redux-saga 是一个旨在使应用程序的副作用（即，数据获取等异步操作和访问浏览器缓存等不纯操作）更易于管理、执行更高效、易于测试以及更好地处理故障的库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659621552419-2bcd4f4f-b8b1-4824-a2b6-b91492889f19.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659621552419-2bcd4f4f-b8b1-4824-a2b6-b91492889f19.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>2、文档网站</strong><br /><strong>（1）Docusaurus</strong><br />Docusaurus 是由 facebook 开源的一个用于轻松构建、部署和维护开源项目网站的项目。使用 Docusaurus 可以让你<strong>专注于内容</strong>，并只需编写 Markdown 文件即可。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659625158061-6984b773-f55d-430a-8ace-49e7cdfcf1ba.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659625158061-6984b773-f55d-430a-8ace-49e7cdfcf1ba.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）Storybook</strong><br />Storybook 是 UI 组件的开发环境，它允许开发者浏览组件库，查看每个组件的不同状态，以及交互地开发和测试组件。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659625242414-a9892d68-35a5-4486-9ba4-a738d3cad1d1.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659625242414-a9892d68-35a5-4486-9ba4-a738d3cad1d1.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）React Styleguidist</strong><br />React Styleguidist是一个React设计规范生成器，一个本地组件开发环境，支持热重载，共享的设计规范。它会列出了组件propTypes，并基于Markdown文件显示可编辑的实时使用示例。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659625388407-8ba2a64c-0bfd-4d0d-a371-84c79b999539.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659625388407-8ba2a64c-0bfd-4d0d-a371-84c79b999539.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>3、路由</strong><br /><strong>（1）React Router</strong><br />React Router 是完整的 React 路由解决方案。React Router 保持 UI 与 URL 同步。它拥有简单的 API 与强大的功能例如代码缓冲加载、动态路由匹配、以及建立正确的位置过渡处理。<br /><img src="https://cdn.nlark.com/yuque/0/2022/webp/1500604/1659623826534-3239472c-5e96-4fed-869e-40ab485ee5b1.webp" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/webp/1500604/1659623826534-3239472c-5e96-4fed-869e-40ab485ee5b1.webp" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）React Location</strong><br />React Location 是客户端 React 应用程序的路由器。它支持异步路由、深度集成的搜索参数 API、可选的 JSX 路由定义、用于路由加载器缓存的预打包简单缓存实现、带有外部缓存和存储的轻松集成等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659623883093-6eaf5b0d-5612-438b-8987-00747ba39657.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659623883093-6eaf5b0d-5612-438b-8987-00747ba39657.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>4、脚手架</strong><br /><strong>（1）Create React App</strong><br />Create React App 是一种官方支持的创建单页 React 应用程序的方式。它提供了一个没有配置的现代构建设置。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659624007783-5b261991-b61e-43ab-bcea-8940b75ba621.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659624007783-5b261991-b61e-43ab-bcea-8940b75ba621.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）Rekit</strong><br />Rekit是开源的一个脚手架，用于使用 React、Redux 和 React-router 构建可扩展的 Web 应用程序。它可以帮助开发人员专注于业务逻辑，而不是处理大量的库、模式、配置等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659624254667-e2b02254-dd61-47ae-a5bb-7d3744df5bdb.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659624254667-e2b02254-dd61-47ae-a5bb-7d3744df5bdb.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>5、应用调试</strong><br /><strong>（1）React Developer Tools</strong><br />React Devtools 可以在 Chrome 和 Firefox 开发者工具审查 React 组件的浏览器扩展。可以用于检查React组件层次结构，在页面上显示React组件。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659624362010-fbc8f4c1-2cfd-4e15-870d-0a919077f73b.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659624362010-fbc8f4c1-2cfd-4e15-870d-0a919077f73b.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）Why Did You Render</strong><br />Why Did You Render 是由 Welldone Software 开发的，可以在开发的时候就检测到一些不必要的渲染问题，告诉我们当前渲染是什么原因导致的。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622826859-f22252b9-f21a-4987-8f2a-7334581d93a3.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622826859-f22252b9-f21a-4987-8f2a-7334581d93a3.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>6、动画</strong><br /><strong>（1）Animate.css</strong><br />animate.css 是一个使用CSS3的animation制作的动画效果的CSS集合，里面预设了很多种常用的动画，且使用非常简单。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627823935-e9f09cff-8b4d-4fed-aad8-018aa93d4d9b.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627823935-e9f09cff-8b4d-4fed-aad8-018aa93d4d9b.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）React Spring</strong><br />react-spring 是一个基于弹簧物理学的动画库，满足大多数与UI相关的动画需求，提供了足够灵活的工具，可以自信地将想法投射到不断变化的界面中。该库代表了一种现代动画方法。它继承了 animated 强大的插值和性能，以及 react-motion 的易用性。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627719149-06917885-e966-401f-b69b-8d01bb19f3ed.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627719149-06917885-e966-401f-b69b-8d01bb19f3ed.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）React Reveal</strong><br />React Reveal 是一个用于 React 的高性能动画库。它占用空间小，专门为 ES6 中的 React 编写。可用于创建各种炫酷的滚动效果显<img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627757718-0ad92ecf-0bdb-4d10-8c45-7b683f357b87.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627757718-0ad92ecf-0bdb-4d10-8c45-7b683f357b87.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif">示。</p><p><strong>GitHub：</strong><a href="https://github.com/rnosov/react-reveal">https://github.com/rnosov/react-reveal</a></p><p><strong>（4）React-Motion</strong><br />React-Motion 是一个动画库，拥有一种更轻松的方法来创建和实现逼真的动画。它利用物理学来为 React 元素创建几乎自然的动画。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659629685780-7bec1943-43a3-4654-a095-741763db9004.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659629685780-7bec1943-43a3-4654-a095-741763db9004.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>7、可视化</strong><br /><strong>（1）Apache ECharts</strong><br />Apache ECharts 是一款基于Javascript的数据可视化图表库，提供直观，生动，可交互，可个性化定制的数据可视化图表。它是用纯 JavaScript 编写的，基于zrender，是一个全新的轻量级画布库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659626661082-2ae6dc8a-d0a4-447c-a3ec-41f33305f057.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659626661082-2ae6dc8a-d0a4-447c-a3ec-41f33305f057.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）Recharts</strong><br />Recharts 是一个用React和D3构建的、重新定义的图表库。该库的主要目的是在 React 应用程序中轻松编写图表。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659626691898-90432456-3263-4cfe-9d6c-5beda120e6e7.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659626691898-90432456-3263-4cfe-9d6c-5beda120e6e7.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）react-vis</strong><br />react-vis 是一组用于呈现常见数据可视化图表的 react 组件，例如折线图&#x2F;面积图&#x2F;条形图、热图、散点图、等高线图、六边形热图、饼图和圆环图、旭日形图、雷达图、平行坐标和树形图。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659626765054-8ab6e054-e28f-49a0-b7f6-daac1d1f2814.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659626765054-8ab6e054-e28f-49a0-b7f6-daac1d1f2814.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>8、UI组件</strong><br /><strong>（1）Ant Design</strong><br />GitHub 上超过 269 k 个项目使用了 Ant Design 组件库，Ant Design of React 是一个基于 Ant Design 设计体系的 React UI 组件库，主要用于研发企业级中后台产品。Ant Design 提供了大量高质量的组件，非常适合快速构建整个 UI 框架，也可以只使用单个组件。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627209475-2aa8d171-5188-4475-95ec-7c82f22dcae6.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627209475-2aa8d171-5188-4475-95ec-7c82f22dcae6.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）MUI</strong><br />MUI 是一个基于 Google 的 Material Design 的简单且可定制的 React 组件库。MUI 不仅是一个组件库，而是一个完整的设计系统。它具有一套完整的指南、设计原则和 UI 设计最佳实践系统。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627326985-59e81a3b-948e-4373-b402-1a9c206e5cb9.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627326985-59e81a3b-948e-4373-b402-1a9c206e5cb9.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）React Bootstrap</strong><br />React-Bootstrap，是比较古老的 React UI 组件库之一。它是使用 React 来重新构建了前端框架 Bootstrap。该库由完全响应并且可访问的现成的组件组成。所有设计元素都是高度可定制的。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627626082-3d969ead-b715-4c8b-a518-d4b6a9a2de21.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627626082-3d969ead-b715-4c8b-a518-d4b6a9a2de21.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>9、性能优化</strong><br /><strong>（1）React Virtualized</strong><br />React Virtualized 是一个以高效渲染大型列表和表格数据的响应式组件，可以用来解决长列表渲染问题。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659628708101-b50b95ef-9cd1-4c52-b239-48363c1b3236.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659628708101-b50b95ef-9cd1-4c52-b239-48363c1b3236.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）React Window</strong><br />React Window 是用于高效渲染大型列表和表格数据的 React 组件。通过仅渲染大型数据集的一部分（刚好足以填充满视口）来工作。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659629884077-ce9fcfeb-1e7b-47ae-9c6c-cb1eac6d34ad.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659629884077-ce9fcfeb-1e7b-47ae-9c6c-cb1eac6d34ad.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>10、表单</strong><br /><strong>（1）React Hook Form</strong><br />React Hook Form 是一个高性能、灵活、易拓展、易于使用的表单校验库，用于 React Web 和 React Native 的表单验证。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659628331580-040f8010-42ac-4382-b772-b2f37f9d71eb.png?x-oss-process=image/resize,w_957,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659628331580-040f8010-42ac-4382-b772-b2f37f9d71eb.png?x-oss-process=image/resize,w_957,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）Formik</strong><br />Formik是一个可以在React中构建表单的组件。它旨在轻松管理具有复杂验证的表单，支持同步和异步表单级和字段级验证。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659628491386-babf6236-717c-4b5d-ac8f-85f727dbe68a.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659628491386-babf6236-717c-4b5d-ac8f-85f727dbe68a.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）React Final Form</strong><br />React Final Form 是Final Form 的一个精简 React 包装器，它是一个基于订阅的表单状态管理库，使用观察者模式，因此只有需要更新的组件会随着表单状态的变化而重新渲染。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659628589263-8999e454-3825-44d8-824f-72e4c6f85098.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659628589263-8999e454-3825-44d8-824f-72e4c6f85098.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>11、富文本编辑器</strong><br /><strong>（1）Draft.js</strong><br />Draft.js 是 Facebook 的一个开源项目，是 React 项目首选的富文本编辑器框架。这是一个健壮、可扩展和可定制的框架。Draft.js 遵循与 React 中的受控组件相同的范例，并提供了一个 Editor 呈现富文本输入的组件。它还公开了一个EditorStateAPI 来处理&#x2F;存储Editor组件中的状态更新。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659626895080-58dd4d74-8fd8-45f8-a404-7db48cd155c7.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659626895080-58dd4d74-8fd8-45f8-a404-7db48cd155c7.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）Slate.js</strong><br />Slate.js 是受 Draft.js 启发的富文本编辑器。它是一个可深度定制的富编辑器框架，专用于 React。与 Draft.js 类似，它具有良好的 API、强大的插件基础设施以及与 React 的深度连接。此外，插件生态系统比 Draft.js 小一些，但它的插件质量会更好。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659626957073-9ac22d04-0bf8-441d-95d5-4ff9d5616ad6.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659626957073-9ac22d04-0bf8-441d-95d5-4ff9d5616ad6.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）TinyMCE</strong><br />TinyMCE 是一个热门的富文本编辑器。它的目标是帮助其他开发人员构建精美的 Web 内容解决方案。它易于集成，可以部署在基于云的、自托管或混合环境中。该设置使得合并诸如 Angular、React 和 Vue 等框架成为可能。它还可以使用 50 多个插件进行扩展，每个插件都有 100 多个自定义选项。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627018874-2538f8e0-4d93-4442-bc43-204c02bbeacf.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627018874-2538f8e0-4d93-4442-bc43-204c02bbeacf.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（4）wangEditor</strong><br />wangEditor 是一个使用Typescript 开发的 Web 富文本编辑器， 轻量、简洁、易用、开源免费。它兼容常见的 PC 浏览器：Chrome，Firefox，Safar，Edge，QQ 浏览器，IE11。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627128764-7e4d9fef-8c21-4ecb-a60a-1178e9e7eb90.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659627128764-7e4d9fef-8c21-4ecb-a60a-1178e9e7eb90.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>12、CSS in JS</strong><br /><strong>（1）Styled–Components</strong><br />styled-components 可以在 JavaScript 代码中使用 CSS 来设置 React 组件的样式。通过这个库可以自定义组件的样式，它会将给定的样式包装成一个组件，可以直接使用这个组件，也不需要组件和样式之间的映射，即创建后就是一个正常的React 组件。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659629425277-2395fbc6-96c9-40cd-bcf3-d448d0944564.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659629425277-2395fbc6-96c9-40cd-bcf3-d448d0944564.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）Emotion</strong><br />Emotion 是一个高性能且灵活的 CSS-in-JS 库。基于许多其他 CSS-in-JS 库，它允许开发人员使用字符串或对象样式快速设置应用样式。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659629210965-2a64670e-cd04-479b-8233-9c6e892bc8d7.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659629210965-2a64670e-cd04-479b-8233-9c6e892bc8d7.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>13、数据请求</strong><br /><strong>（1）Axios</strong><br />Axios 是一个基于 promise 网络请求库，作用于node.js 和浏览器中。 它是 isomorphic 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js http 模块，而在客户端 (浏览端) 则使用 XMLHttpRequests。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659628850112-88db8b6d-893d-4bf6-b09d-68a59fa84656.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659628850112-88db8b6d-893d-4bf6-b09d-68a59fa84656.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）React Query</strong><br />React Query 是一个适用于react hooks的请求库，它可以为任何类型的异步数据提供React状态管理功能，使React中的获取、缓存、同步和更新服务器数据变得轻而易举。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659629045249-67dfcc4e-7f4c-433d-a2b3-f47f5022dda0.png?x-oss-process=image/resize,w_955,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659629045249-67dfcc4e-7f4c-433d-a2b3-f47f5022dda0.png?x-oss-process=image/resize,w_955,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>14、测试</strong><br /><strong>（1）Jest</strong><br />Jest 是由 Facebook 开发的 JavaScript 测试框架。它应该是测试 React 的首选，因为它是由 React 的发明者创建的，并且得到了 React 社区的支持和开发。它还支持 Babel、TypeScript、Node、Angular 和 Vue 以及其他 JS 框架。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659624570394-2473b035-c0fe-4dd3-a2e7-4eea4737fc17.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659624570394-2473b035-c0fe-4dd3-a2e7-4eea4737fc17.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）React Testing Library</strong><br />React Testing Library 基于DOM Testing Library的基础上添加一些API，主要用于测试React组件。该库在使用过程并不关注组件的内部实现，而是更关注测试。该库基于react-dom和react-dom&#x2F;test-utils，是以上两者的轻量实现。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659624741784-d4c6ce19-875e-4f47-9a70-f58c81b2925e.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659624741784-d4c6ce19-875e-4f47-9a70-f58c81b2925e.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）Vitest</strong><br />Vitest 是一个由 Vite 提供支持的极速单元测试框架。其和 Vite 的配置、转换器、解析器和插件保持一致、开箱即用的 TypeScript &#x2F; JSX 支持、支持 Smart 和 instant watch 模式，如同用于测试的 HMR、内置 Tinyspy 用于模拟、打标和监察等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659625017469-b90d5172-7866-49e6-9b27-9d1d2744176e.png?x-oss-process=image/resize,w_951,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659625017469-b90d5172-7866-49e6-9b27-9d1d2744176e.png?x-oss-process=image/resize,w_951,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>15、自定义Hooks</strong><br /><strong>（1）Ahooks</strong><br />ahooks 是一套由阿里巴巴开源的 React Hooks 库，封装了大量好用的 Hooks。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622548861-c18e9673-9685-4dfb-a5f0-d41ee3db7857.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622548861-c18e9673-9685-4dfb-a5f0-d41ee3db7857.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）React Use</strong><br />React Use 是一个必不可少的 React Hooks 集合。其包含了传感器、用户界面、动画效果、副作用、生命周期、状态这六大类的Hooks。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622548858-c93d03eb-4b72-4f1b-b313-fd219482e5c9.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622548858-c93d03eb-4b72-4f1b-b313-fd219482e5c9.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）useHooks</strong><br />useHooks 是一组易于理解的 React Hook集合。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622619158-bba9fbc2-2dd9-404f-bfc6-a4ac782207cd.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622619158-bba9fbc2-2dd9-404f-bfc6-a4ac782207cd.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>16、服务端渲染</strong><br /><strong>（1）Next.js</strong><br />Next.js 是一个用于服务器渲染的通用 JavaScript Web 应用程序的小型框架，该框架基于 React、Webpack 和 Babel 构建，为该网站提供了强大的支持。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659621913376-e477fa98-3c6c-4901-b91f-07f07e3baa48.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659621913376-e477fa98-3c6c-4901-b91f-07f07e3baa48.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）Razzle</strong><br />Razzle是类似于next.js的简单服务端框架，用于在服务端渲染 React 应用程序。比较方便的一点是无需配置。通过将一般的JavaScript应用抽象成单个的依赖，然后将框架，路由和数据提取出来。同时，Razzle 支持可插拔渲染。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622042021-e310bd26-437d-43a1-842a-93e9d266097d.png?x-oss-process=image/resize,w_955,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622042021-e310bd26-437d-43a1-842a-93e9d266097d.png?x-oss-process=image/resize,w_955,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>17、拖拽排序</strong><br /><strong>（1）React Beautiful Dnd</strong><br />react-beautiful-dnd 是一款美观且简单易用的 React 列表拖拽库。其动画效果自然，性能优秀，简洁而强大的 API，易于上手，与标准浏览器的互动性非常好。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1659622363765-7be10003-191f-407b-8468-48870f82899c.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1659622363765-7be10003-191f-407b-8468-48870f82899c.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）React DnD</strong><br />React DnD是 React 和 Redux 核心作者 Dan Abramov 创造的一组React 高阶组件，可帮助我们构建复杂的拖放界面，同时保持组件解耦。它可以在应用程序的不同部分之间通过拖动传输数据，并且组件会更改其外观和应用状态以响应拖放事件。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622410709-79d963e3-7d2c-4724-9cd5-c0a4c150ee33.png?x-oss-process=image/resize,w_949,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622410709-79d963e3-7d2c-4724-9cd5-c0a4c150ee33.png?x-oss-process=image/resize,w_949,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）React Draggable</strong><br />React-Draggable 库简单易用，将 CSS 中的 transform 应用于 React 组件，允许我们在 UI 中拖动组件。它有不同的 props 可以让你改变组件的行为，是创建直观、用户友好界面的绝佳选择。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1659622440946-bcf078ea-7c9b-4e03-b2b0-f815bf7efc52.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1659622440946-bcf078ea-7c9b-4e03-b2b0-f815bf7efc52.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>18、国际化</strong><br /><strong>（1）React Intl</strong><br />React Intl 提供了一个 React 组件和用于国际化 React Web 应用的 Mixin。它提供一个格式化日期、数字、字符串消息的描述方式。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622204634-fa5e8142-b1b3-4b07-941b-ee081a71d9c3.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622204634-fa5e8142-b1b3-4b07-941b-ee081a71d9c3.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）React-i18next</strong><br />react-i18next 是基于 i18next 的一款强大的国际化框架，可以用于 react 和 react-native 应用，是目前非常主流的国际化解决方案。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622267896-9b8a351e-3b6a-4bb6-9c9d-8b96043b1bef.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659622267896-9b8a351e-3b6a-4bb6-9c9d-8b96043b1bef.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>19、其他</strong><br /><strong>（1）Reactide</strong><br />Reactide 是首个用于 React Web 应用开发的专用 IDE 。它是一个跨平台的桌面应用程序，提供了一个自定义模拟器，不需要构建工具和服务器配置，开箱即用。 Reactide 将开发带回到打开单个文件的日子，立即在浏览器中呈现项目。 使用 Reactide，开发人员可以使用单个 React JSX 文件实现相同的简单性，同时利用 React 的强大功能。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659601981425-37c0edc9-f522-441a-b212-67215f5e92aa.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659601981425-37c0edc9-f522-441a-b212-67215f5e92aa.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（2）Gatsby</strong><br />Gatsby 是基于 React 构建的静态站点生成器，拥有丰富的插件生态，其主要目标之一是交付访问速度快速的网页，它通过利用良好的缓存、静态页面生成和基于边缘的 CDN 数据源来实现这一目标。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659621812138-36b47366-46e3-4ffd-924b-02ff10f370c9.png?x-oss-process=image/resize,w_930,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659621812138-36b47366-46e3-4ffd-924b-02ff10f370c9.png?x-oss-process=image/resize,w_930,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>（3）React Helmet</strong><br />React Helmet是一个HTML文档head管理工具，管理对文档头的所有更改。Helmet采用纯 HTML 标签并输出纯 HTML 标签。它非常简单，而且对 React 初学者友好。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659621458775-7e031028-b8db-4dd5-bafd-937cfaa4e617.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1659621458775-7e031028-b8db-4dd5-bafd-937cfaa4e617.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>console 调试技巧</title>
      <link href="/2021/06/20/frontend/browser/debug/console-diao-shi-ji-qiao/"/>
      <url>/2021/06/20/frontend/browser/debug/console-diao-shi-ji-qiao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="df368884"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如果统计一番前端最常用的方法，那么 console.log 一定位列其中。无论你写的是原生 JS 亦或者是 JQuery、Vue等等，调试之时，都离不开 console.log 方法。但是，console 对象中的方法不仅仅只有 log 方法。强大的 console 对象提供了大量控制台调试的相关方法，掌握这些方法可以大大方便你的调试，甚至做出一些炫酷的控制台字符画。</p><p><a name="864de167"></a></p><h3 id="基本输出"><a href="#基本输出" class="headerlink" title="基本输出"></a>基本输出</h3><p>console 对象最基础的方法毫无疑问是 log，该方法会直接在控制台上输出参数，如果输入多个参数，那么输出在控制台上的参数用空格分隔，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>);</span><br></pre></td></tr></table></figure><p>打开控制台，运行结果如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369005139-babaae29-8209-473d-895f-42e9c7eccb74.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369005139-babaae29-8209-473d-895f-42e9c7eccb74.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>console.log 还含有类似于 Python 的占位符功能，但是，个人认为该功能可以完全被 ES6 中的字符串模板完全替代，有兴趣的可以去了解，在此不再赘述。</p><p><a name="2da6f345"></a></p><h3 id="分类输出"><a href="#分类输出" class="headerlink" title="分类输出"></a>分类输出</h3><p>厌倦了 console.log 单调的输出？欢迎尝试 console 对象的分类输出功能。console 对象提供了 info、warn、error 方法分别输出提示、警告以及错误信息。<br />我们输入下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;log&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&#x27;info&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;warn&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;error&#x27;</span>);</span><br></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369026448-a85fdb63-f7a5-4832-bf70-d5ed63f09ab8.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369026448-a85fdb63-f7a5-4832-bf70-d5ed63f09ab8.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>可以发现，warn 和 error 方法分别输出了一条警告和一条错误信息。但是，为什么 log 方法和 info 方法输出是一样的呢？<br />原因在于，我使用的是 Chrome 浏览器，在 Chrome 浏览器上，log 方法和 info 方法的表现是一样的。但是，在其他浏览器上，比如 FireFox，info 方法前面会有一个信息图标。<br />由于 info 方法的效果不明显，并且各个浏览器中效果有差异，所以一般情况下，我们使用 log 方法代替 info 方法。</p><p><a name="2fda7b0d"></a></p><h3 id="断言输出"><a href="#断言输出" class="headerlink" title="断言输出"></a>断言输出</h3><p>console 对象提供了类似于单元测试中的断言的方法：assert。该方法接收两个参数，第一个参数为断言条件，第二个参数代表断言信息。<br />同单元测试断言一样，当断言条件为 true 时，assert 无输出；只有当断言条件为 false 时，assert 方法才会在控制台中输出一条断言错误信息。<br />我们输入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">assert</span>(<span class="literal">true</span>, <span class="string">&#x27;true&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">assert</span>(<span class="literal">false</span>, <span class="string">&#x27;false&#x27;</span>);</span><br></pre></td></tr></table></figure><p>控制台如下所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/272053/1554739550794-94b609f3-1804-4015-892b-317582fe5b7f.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2019/png/272053/1554739550794-94b609f3-1804-4015-892b-317582fe5b7f.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="assert.png"></p><p>可以发现，控制台只输出了那一条断言条件为 false 的语句。</p><p><a name="6ec21063"></a></p><h3 id="分组输出"><a href="#分组输出" class="headerlink" title="分组输出"></a>分组输出</h3><p>当你的控制台上输出了大量信息时，控制台会显得极其杂乱，你甚至不知道某一条信息是哪条代码输出的。此时，console 对象的 group 以及 groupEnd 方法可以拯救你。<br />将部分 console 语句放入 group 与 groupEnd 之间，可以形成将这部分 console 语句划定为一组信息进行输出。其中，group 方法接收一个字符，作为分组名称，groupEnd 方法不接收参数用于结束分组。<br />输入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1-1&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;1-2&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;1-3&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">groupEnd</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2-1&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;2-2&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;2-3&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">groupEnd</span>();</span><br></pre></td></tr></table></figure><p>结果如图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369059602-5b6c8e42-b7e6-47cd-92ca-82f17c99b109.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369059602-5b6c8e42-b7e6-47cd-92ca-82f17c99b109.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>通过点击分组的箭头，可以折叠分组，方便归纳整理控制台信息，避免控制台被海量信息淹没。</p><p><a name="8756f96b"></a></p><h3 id="表格输出"><a href="#表格输出" class="headerlink" title="表格输出"></a>表格输出</h3><p>我们不仅可以将控制台信息分组输出，我们还可以将其以表格的形式输出。<br />console 的 table 方法可以将一个对象以表格的形式输出，当输入的参数不是对象时，此时，table 方法相当于 log 方法。<br />输入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">table</span>(obj);</span><br></pre></td></tr></table></figure><p>控制台如图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369104176-b8364314-4b8f-4394-a319-32fcf5eb2d62.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369104176-b8364314-4b8f-4394-a319-32fcf5eb2d62.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>控制台不仅以表格形式输出了对象，还以基础输出的方式输出了对象以方便查看信息。</p><p><a name="0e0b2800"></a></p><h3 id="计次输出"><a href="#计次输出" class="headerlink" title="计次输出"></a>计次输出</h3><p>在日常开发中，有一个常见的调试需求——计算一段代码的执行次数。一般来说，我们会在这段代码中定义一个变量，每执行一次它就进行一次自增，并通过 console.log 方法输出该变量。<br />可以看出，上述的方法略显麻烦，可不可以一行代码就解决这个问题呢？当然可以！count 方法，你值得拥有。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">count</span>(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">count</span>(<span class="string">&quot;num&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">count</span>(<span class="string">&quot;anotherNum&quot;</span>);</span><br></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369126613-bb2fcde7-e59a-4ad3-8bc0-7621ea3ac25f.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369126613-bb2fcde7-e59a-4ad3-8bc0-7621ea3ac25f.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>可以发现，count 方法通过输入的字符串区分不同的计数语句。</p><p><a name="5ec5f672"></a></p><h3 id="计时输出"><a href="#计时输出" class="headerlink" title="计时输出"></a>计时输出</h3><p>当测试算法性能时，我们通常使用时间复杂度来评价算法的性能，但是，时间复杂度哪里有代码执行时间来的直观呢？<br />在之前不了解 console 对象的时候，我们在算法的头尾分别获取时间戳，取时间戳的差值作为代码执行时间。很明显，这种方法太过繁琐。<br />使用 console 对象的 time 以及 timeEnd 方法可以计算出代码执行时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;time&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>;i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;time&#x27;</span>);</span><br></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369146285-3964aeb0-8dea-4c22-b108-59efe8386548.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2019/png/272053/1551369146285-3964aeb0-8dea-4c22-b108-59efe8386548.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="9415a826"></a></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>除了上述的方法，cnosole 方法还有很多强大的方法，比如：dir、debug、trace等，但是它们有的在 Chrome 效果不佳，有的能被 Chrome debugger 完美替代，所以，在此不再赘述。如果有兴趣，可以进一步了解。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome 性能监测</title>
      <link href="/2021/04/11/frontend/browser/debug/chrome-xing-neng-jian-ce/"/>
      <url>/2021/04/11/frontend/browser/debug/chrome-xing-neng-jian-ce/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>前端性能优化一直是前端工作中必不可少的一部分，但是我们如何知道哪些部分的性能有优化的空间呢？此时，Chrome 性能监测就派上用场了。</p><p>正所谓：知己知彼，百战百胜，只有确定了性能瓶颈，才能有条不紊地进行前端性能优化工作。</p><p><a name="Performance"></a></p><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>Performance 是 Chrome 开发者工具中的一个功能，用于记录网页从初始化到运行时的所有性能指标。</p><p>使用 Performance 之前，我们需要先打开 Chrome 的无痕模式，因为，身为开发者，Chrome 上一般都有着大量的 Chrome 插件，而 Chrome 插件会显著影响页面的性能。所以，我们需要进入无痕模式来规避 Chrome 插件对页面性能的影响。</p><p>进入无痕模式后，我们打开需要进行性能监测的网站，开启 Chrome 开发者工具，点击 Performance 选项卡，进入面板。此时的面板什么都没有，只有几个操作提示。</p><p>接下来，我们点击左上角的 Record（小圆点）按钮，Performance 进入 Record 阶段，从此刻开始，它会记录用户的交互以及这些交互对页面性能数据的影响。当交互完成后，点击 Stop 来停止 Record ，Performance 面板会展示出刚才录制的页面性能数据。如下所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/272053/1555237392439-f5416a63-ec9f-4a29-bee0-573cbd2810df.jpeg" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2019/jpeg/272053/1555237392439-f5416a63-ec9f-4a29-bee0-573cbd2810df.jpeg" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="performance总览.jpg"></p><p>拿到 Performance 性能报告，首先，我们先看顶部的三个数据：FPS、CPU 以及 NET。</p><ol><li>FPS：主要和动画性能有关，代表每秒帧数。图表中的绿色长条越高，说明FPS越高，用户体验越好。如果其中有红色长条，代表着这部分帧数有卡顿，需要优化。</li><li>CPU：和底部的 Summary 对应，显示了页面加载过程中，各阶段对 CPU 的占用时间，占用时间越多，代表该阶段越需要优化。在 Performance 中，该部分是最需要关注的指标之一。</li><li>NET：主要展示了网络请求的先后顺序以及各自的请求耗时，可以被 Network 面板完美替代，建议直接查看 Network。</li></ol><p>接下来，我们来了解一下最杂乱的中间部分，一般情况下，我们主要根据中间部分中 Main 的图表来分析页面性能。</p><p>由于 Main 的图表长得像一团团倒立的火焰，所以，我们将其称为火焰图。它展现了主线程在 Record 过程中做的所有事情，包括：Loading、Scripting、Rendering、Painting 等等。火焰图的横轴代表着时间，纵轴代表着调用堆栈。每一个长条代表执行了一个事件或函数，长条的长度代表着耗时的长短，如果某个长条右上角是红色的则表示该函数存在性能问题，需要重点关注。</p><p>活用 Performance，按照 Chrome 的提示进行优化，可以解决掉绝大部分的性能问题。</p><p><a name="23ab71fd"></a></p><h3 id="Performance-monitor"><a href="#Performance-monitor" class="headerlink" title="Performance monitor"></a>Performance monitor</h3><p>看起来，Performance 提供的性能监测功能已经较为完备，但是，它有两个问题：</p><ol><li>数据缺少实时性</li><li>数据面板过于复杂，不够直观</li></ol><p>为了解决这两个问题，Chrome 提供了 Performance monitor 功能，以实时直观的数据展示页面性能。</p><p>相比 Performance ，Performance monitor 所在的位置较为隐蔽，需要以下几个步骤才能打开：</p><ol><li>打开 Chrome 开发者工具</li><li>按“Esc”，打开附加面板</li><li>点击选项按钮，打开选项菜单</li><li>选择“Performance monitor”</li></ol><p>由于 Performance monitor 是实时的，所以，进入面板后，Performance monitor 将会自动运行，记录页面性能数据，通过点击左侧的选项，可以调整记录的数据类型。</p><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/272053/1555237407434-b08210b3-5a80-4a2d-ac10-4db029112cec.jpeg" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2019/jpeg/272053/1555237407434-b08210b3-5a80-4a2d-ac10-4db029112cec.jpeg" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="performance moniitor.jpg"></p><p>相比 Performance，Performance monitor 的功能虽然不够全面，但胜在简洁、实时。通常情况下，可以通过 Performance monitor 来分析页面使用过程中的性能问题，例如：动画性能等。</p><p><a name="Audits"></a></p><h3 id="Audits"><a href="#Audits" class="headerlink" title="Audits"></a>Audits</h3><p>虽然 Performance 以及 Performance monitor 提供了大量性能数据，但是，如果开发者经验不足，复杂的性能数据无异于天书。那么，Chrome 能不能自动分析出页面的性能缺陷，给出具体的性能优化点呢？万幸，Chrome 提供了 Audits。</p><p>Audits 源于著名的开源自动化分析插件——Lighthouse，Lighthouse 不仅能够分析页面性能，还能够对 PWA、无障碍访问、SEO 等进行测试评分，并给出优化建议。为了方便开发者使用，在 Chrome 60 版本，Chrome 开发团队直接将其加入 Chrome 开发者工具中的 Audits 面板中。</p><p>Lighthouse 转正之后，使用该功能不需要安装额外的 Chrome 插件，只需要进入 Audits 面板，点击 Run audits 按钮即可生成一份页面分析报告，如下所示：</p><p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/272053/1555237418556-4b5dc443-fe24-46a3-a951-7192ce573da6.jpeg" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2019/jpeg/272053/1555237418556-4b5dc443-fe24-46a3-a951-7192ce573da6.jpeg" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="audits.jpg"></p><p>通过结果可以看到，Audits 不仅能够自动分析出页面的缺陷，还能根据缺陷给出具体的优化建议。这就意味着，使用了 Audits 之后，我们只需要按照 Audits 给出的优化建议逐条尝试，即可大幅度提高页面性能，实乃前端偷懒神器~</p><p><a name="c1163678"></a></p><h3 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h3><p>之前我们一直说的是基于 Chrome 浏览器的性能监测方案，但是，其实还有一种不基于浏览器的性能监测方案：编程式性能监测。</p><p>编程式性能监测主要依托于 W3C 推出的 Performance API，该套 API 的目的是简化开发者对网站性能进行精确分析与控制的过程，方便开发者采取手段提高 web 性能。</p><p>相比之前的性能监测方法，Performance API 最大的优点是：灵活、精确，所以一经推出便风靡全球。比如，Vue 中便封装了 Performance API 方便开发者进行性能追踪。</p><p>由于篇幅有限，在此不再赘述，有兴趣的同学可以自行了解。</p><p><a name="25f9c7fa"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>性能监测是前端性能优化的第一步，只有学会了性能监测，我们才能更好地剖析性能问题，直至彻底解决性能问题。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 调试 </tag>
            
            <tag> 性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise A+ 规范</title>
      <link href="/2021/03/17/frontend/interview/promise-a-gui-fan/"/>
      <url>/2021/03/17/frontend/interview/promise-a-gui-fan/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>Promise 对象用于表示一个异步操作的最终完成（或失败）及其结果值。<br><a name="Arniy"></a></p><h1 id="Promise-A-规范"><a href="#Promise-A-规范" class="headerlink" title="Promise A+ 规范"></a>Promise A+ 规范</h1><p><a href="http://malcolmyu.github.io/malnote/2015/06/12/Promises-A-Plus/">Promise A+ 规范</a><br><a name="Kgt2P"></a></p><h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">RESOLVED</span> = <span class="string">&#x27;resolved&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">asyncFun</span> = (<span class="params">fn</span>) =&gt; &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(fn, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Promise_</span> &#123;</span><br><span class="line">    </span><br><span class="line">    status;</span><br><span class="line">    resolver;</span><br><span class="line">    rejecter;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">executor, options</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">PENDING</span>;</span><br><span class="line">        <span class="title function_">executor</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">asyncFun</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">RESOLVED</span>;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">resolver</span>?.(res);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">asyncFun</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">rejecter</span>?.(err);</span><br><span class="line">                <span class="title function_">asyncFun</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="title class_">Error</span>(err);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">then</span>(<span class="params">resolver, rejecter</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">resolver</span> = resolver;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rejecter</span> = rejecter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">err</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>_) <span class="keyword">return</span> value;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(value);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">all</span>(<span class="params">promisers</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> resArr = [];</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">resolver</span> = (<span class="params">res, index</span>) =&gt; &#123;</span><br><span class="line">                resArr[index] = res;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count === promisers.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(resArr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">rejecter</span> = (<span class="params">err</span>) =&gt; &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err)</span><br><span class="line">            &#125;;</span><br><span class="line">            promisers.<span class="title function_">map</span>(<span class="function">(<span class="params">promiser, index</span>) =&gt;</span> &#123;</span><br><span class="line">                promiser.<span class="title function_">then</span>(</span><br><span class="line">                    <span class="function"><span class="params">res</span> =&gt;</span> <span class="title function_">resolver</span>(res, index),</span><br><span class="line">                    <span class="function"><span class="params">err</span> =&gt;</span> <span class="title function_">rejecter</span>(err)</span><br><span class="line">                );</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">race</span>(<span class="params">promisers</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">resolver</span> = res =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="title function_">resolve</span>(res);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">rejecter</span> = err =&gt; &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            promisers.<span class="title function_">map</span>(<span class="function"><span class="params">promiser</span> =&gt;</span> &#123;</span><br><span class="line">                promiser.<span class="title function_">then</span>(</span><br><span class="line">                    resolver,</span><br><span class="line">                    rejecter</span><br><span class="line">                );</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">any</span>(<span class="params">promisers</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> stopReject = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">resolver</span> = res =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(!stopReject) &#123;</span><br><span class="line">                    stopReject = <span class="literal">true</span>;</span><br><span class="line">                    <span class="title function_">resolve</span>(res);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> errs = [];</span><br><span class="line">            <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="title function_">rejecter</span> = err =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(stopReject) <span class="keyword">return</span>;</span><br><span class="line">                count++;</span><br><span class="line">                errs.<span class="title function_">push</span>(err);</span><br><span class="line">                <span class="keyword">if</span>(count === promisers.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="title function_">reject</span>(errs);</span><br><span class="line">                    <span class="title function_">asyncFun</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AggregateError</span>(errs)</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            promisers.<span class="title function_">map</span>(<span class="function"><span class="params">promiser</span> =&gt;</span> &#123;</span><br><span class="line">                promiser.<span class="title function_">then</span>(</span><br><span class="line">                    resolver,</span><br><span class="line">                    rejecter</span><br><span class="line">                );</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">// reject(&#x27;发生错误1&#x27;)</span></span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line">        <span class="comment">// reject(&#x27;发生错误2&#x27;)</span></span><br><span class="line">    &#125;, <span class="number">50</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="title class_">Promise</span>_(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="number">3</span>)</span><br><span class="line">        <span class="comment">// reject(&#x27;发生错误3&#x27;)</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>_.<span class="title function_">race</span>([promise1, promise2, promise3]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise4 = <span class="title class_">Promise</span>_.<span class="title function_">resolve</span>(promise3);</span><br><span class="line">promise4.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise5 = <span class="title class_">Promise</span>_.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;fail&#x27;</span>));</span><br><span class="line"></span><br><span class="line">promise5.<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">    <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
            <tag> es6 </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome调试技巧</title>
      <link href="/2020/11/11/frontend/browser/debug/chrome-diao-shi-ji-qiao/"/>
      <url>/2020/11/11/frontend/browser/debug/chrome-diao-shi-ji-qiao/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="54bcvn"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在前端开发过程中，我们通过浏览器的页面来查看我们代码编写的成果。然而浏览器的功能非常强大，它不只是能展示我们编写的页面，还能够帮助我们定位开发过程中遇到的问题，提升我们的开发效率。有些时候我们甚至还可以通过浏览器的调试工具来查看一些网站酷炫效果的实现方式。下面我们以Chrome浏览器为例，来介绍一些常用的调试技巧。</p><p><a name="l229zq"></a></p><h3 id="1-Chrome开发者工具"><a href="#1-Chrome开发者工具" class="headerlink" title="1. Chrome开发者工具"></a>1. Chrome开发者工具</h3><p>首先我们打开Chrome的开发者工具（又称控制台），打开方式有以下几种：</p><ol><li>点击浏览器右上角竖排的“三个点”，选择“更多工具”，再选择“开发者工具”打开</li><li>单机鼠标右键，点击“查看”选项打开</li><li>通过按快捷键 Ctrl + shift + I 快速打开</li></ol><p>通过以上任意一种方式打开开发者工具后，我们能够看到这样的界面。</p><p>开发者工具界面</p><p>开发者工具界面的信息量比较大，不过不用担心，我们一点点来看。工具栏上前几个tab是我们最常用的调试模块。</p><ul><li>Element 用于查看和编辑DOM节点和节点相对应的CSS样式。</li><li>Console 用于打印运行时抛出的信息，我们可以通过它查看异常信息或主动抛出信息进行调试。</li><li>Sources 用于查看资源信息，我们编写和运行的代码都可以在这里找到。我们可以通过在这里设置断点来达到调试的目的。</li><li>Network 用于查看请求信息，这里可以看到所有的页面资源请求，包括网络请求、图片资源、HTML、CSS、JS等。可以根据需求筛选请求项，一般多用于网络请求的查看和分析。</li><li>Performance 用于查看页面加载的性能情况，包括页面渲染时间、JS执行时间等</li><li>Application用于查看 cookie、localStorage 等信息</li></ul><p>以上是Chrome开发者工具的主要功能模块，虽然内容略多，但是正因为有了这些信息，浏览器的调试功能才会如此强大。现在记不住这些模块也没关系，接下来我们将通过使用这些调试工具，来加深对它们的理解，并看看它们能为我们的开发带来怎样的帮助。</p><p><a name="i8b1dy"></a></p><h3 id="2-DOM调试"><a href="#2-DOM调试" class="headerlink" title="2. DOM调试"></a>2. DOM调试</h3><p><a name="3wv6ln"></a></p><h4 id="2-1-查看-DOM"><a href="#2-1-查看-DOM" class="headerlink" title="2.1 查看 DOM"></a>2.1 查看 DOM</h4><p>在浏览器中，如果我们想要了解一个页面的 DOM 结构，我们可以通过开发者工具中的 Element 模块进行查看。我们首先编写一段 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM调试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个表格<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>第一列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>第二列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>第三列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>11<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>22<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>33<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>保存这段 HTML 后在浏览器打开，并开启控制台。我们将工具栏选中到 Element ，会看到这样的信息</p><p>查看 DOM 元素</p><p>你会发现这里展示的 DOM 结构就是我们写的 HTML ，浏览器不仅将我们的 HTML 渲染成页面，还将它的 DOM 显示在控制台中方便我们调试。</p><p>用鼠标在控制台里选中不同的 DOM 节点，会发现页面中有蓝色区块会随着鼠标选中 DOM 节点的变化而调整，实际上 <strong>蓝色区块就是当前 DOM 节点对应渲染的页面部分</strong> 。</p><p><a name="xqf4th"></a></p><h4 id="2-2-定位-DOM"><a href="#2-2-定位-DOM" class="headerlink" title="2.2 定位 DOM"></a>2.2 定位 DOM</h4><p>当一个页面结构比较复杂，层级较深的时候，我们通过移动鼠标在 DOM 节点中寻找需要查看的节点就会变得比较麻烦。要点开它的外层节点并一级一级找下去，这样的查找方式费时费力，因此浏览器控制台提供了一个方便定位 DOM 的功能。</p><p>依然是上面那个例子，如果我们需要去找到 table 中的第一行第二列的那个单元格，怎样操作比较迅速？这里我们通过点击控制台左上角的一个定位按钮来进行快速选中。打开控制台，点击定位按钮，点击后该按钮会变成蓝色，标志我们当前正处于定位模式（定位模式下鼠标无法触发页面交互，如按钮事件等）。</p><p>定位按钮</p><p>接下来我们在页面上点击我们想要查看的元素，点击页面上table 中第一行第二列的单元格（显示 2 的那个）。点击后我们发现控制台的 Element 直接将那个 <td> 节点高亮定位了。</p><p>高亮定位</p><p>这样我们就迅速的定位了我们想要查看的 DOM 节点，此时定位按钮从蓝色变为灰色，标志着定位完成，退出定位模式。快速定位的功能在复杂结构的页面中尤为实用，我们可以在开发过程中充分利用起来。</p><p><a name="40cwdw"></a></p><h4 id="2-3-操作-DOM"><a href="#2-3-操作-DOM" class="headerlink" title="2.3 操作 DOM"></a>2.3 操作 DOM</h4><p>完成了 DOM 的定位，接下来我们可以对 DOM 元素做一些操作。对当前选中的 DOM 元素点击右键可以看到一系列的操作选项。</p><p>DOM操作选项</p><p>点击 Edit as HTML 来对当前的 DOM 节点做改写和添加，例如这里我们对 <p> 标签做编辑，在后面添加另一个 <p> 标签。</p><p>编辑p标签</p><p>完成后点击旁边未被选中到元素即可保存编辑，并在浏览器页面上同步生效。此时可以发现页面上已经出现了我们刚刚添加的节点了。</p><p>编辑后生效</p><p>如果你想撤销上一次 DOM 变更，按 ctrl + Z 即可，重做则按 ctrl + shift + Z。</p><p>其他的一些 DOM 操作也都很直观，比如可以点击 Add attribute 给选中节点添加属性；Delete element会删除选中节点等等。操作很简单，这里就不一一演示，读者可以自己尝试一下。</p><p><a name="otkqal"></a></p><h3 id="3-CSS调试"><a href="#3-CSS调试" class="headerlink" title="3. CSS调试"></a>3. CSS调试</h3><p>除了对 DOM 的操作，我们还能够方便得对CSS进行调试。不知大家在查看 DOM 的时候有没有关注到界面上还有这么一块区域？</p><p>CSS 调试区域</p><p>这里就是 CSS 的地盘。我们可以在这里看到选中的 DOM 节点上已添加的样式，可以对里面对值进行修改，或是添加其他 CSS 样式。这里我们给 <p> 标签添加一个 color 样式。</p><p>添加文字颜色样式</p><p>先用 DOM 调试的技巧选中这段文字，再对它添加完 color:red ，这时我们发现页面上的文字变成了红色，与此同时控制台对 DOM 节点树中也对这个节点动态得添加了一个 style 属性，于是我们完成了样式添加。这就是浏览器调试 CSS 样式的便捷之处 —— 简单且直观。甚至于接下来如果我想改变一下文字的颜色，只需要在样式栏里点击一下 color 属性，就可以进行变更了，所见即所得。</p><p>改变文字颜色</p><p>我们再注意到样式栏的顶部，有一些 :hover 的图标，点开来看，发现这里可以设置 DOM 的交互状态。假设勾选一个 :focus 复选框，当前选中的 DOM 节点便被模拟了获取焦点的样式特性。</p><p>模拟 DOM 交互状态</p><p>最后我们再看一下右侧部分，上面有个矩形，它就是我们在 CSS 部分中学习过的“盒子模型”。通过将鼠标在盒子模型上移动，页面上会显示出相对应的 DOM 节点，通过它我们能够更好得了解页面上的布局结构。选中 Computed ，下方显示出一系列的样式，这些样式就是节点经过浏览器计算后渲染在页面上的最终样式，如果某一个节点受到多个地方的样式影响，我们就可以在这里看到它最终的样式属性（与页面上的渲染效果相对应）。</p><p>盒子模型与最终样式</p><p><a name="yu8prs"></a></p><h3 id="4-JS调试"><a href="#4-JS调试" class="headerlink" title="4. JS调试"></a>4. JS调试</h3><p>本节内容将简单介绍如何使用浏览器对 JS 进行调试，由于很多时候我们所说的浏览器调试都是指 JS 调试，因此这部分有很多调试的方法和技巧。具体的调试技巧将在下一章节详细介绍，本节只做一个熟悉的过程。</p><p>JS 的调试主要关注的区域是 Console 和 Sources 模块，前文说过 Console 模块是用于打印运行时抛出的信息，我们可以通过它查看异常信息或主动抛出信息进行调试。 Sources 用于查看资源信息，我们编写和运行的代码都可以在这里找到。我们可以通过在这里设置断点来达到调试的目的。那么接下来我们分别对这两个模块加以认识。</p><p>首先点击进入 Console 模块，会看到一个可输入的控制台界面。在这里我们可以输入一些简单的 JS 指令，按回车键执行。</p><p>Console 控制台</p><p>通过简单的尝试可以看到，在这里我们可以能够执行 JS 脚本，并且直观得看到输出结果。这意味着当我们希望看到 JS 代码运行时的数据状态时，我们可以利用这个工具来给我们展现。那么如何在 JS 中使用 Console 控制台呢？其实很简单，只要在你希望查看的数据处加上一行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(希望查看的数据);</span><br></pre></td></tr></table></figure><p>即可在 Console 控制台中查看数据。有了它我们不需要等到 JS 代码执行完毕才能看是否符合预期，在执行过程中我们就可以很方便得查看动态数据并打印记录在控制台中，这对我们的编程有很大的帮助。</p><p>接下来我们来看 Sources 模块。我们可以任意访问一个在线网站，然后打开控制台，点击  Sources 会看到一些代码。这些代码就是当前这个页面所引用的资源，包括 JS 文件，样式文件等等，由于线上运行的代码通常是经过混淆和压缩的,可能难以定位和阅读。我们在文件底部可以看到一个花括号 {} ,点击这个花括号我们能将压缩了的文件格式化成正常的语法缩进。</p><p>Sources 界面</p><p>我们注意到代码的左侧是一列数字，标记着当前的代码处于第几行。这列数字是可以点击的，当点击某个数后，数字被标记成蓝色，此时标记着我们在这一行代码处设置了断点，当程序运行到这段代码处时会停止运行并保留运行现场。我们可以查看当下运行时的数据和方法的执行情况，实际上这就是我们所谓的“断点调试”，下一章节会详细演示。</p><p>这里我们关注到当程序运行到断点处时，页面上会出现一个条形的操作栏显示 paused in debugger ，右边紧跟着两个按钮。第一个三角形的按钮表示 “跳过断点” ，点击它之后脚本会继续往下执行，直到完成运行或是进入到下一个设置的断点。另一个弧形的按钮表示 “单步调试” ，代码会进入到断点的下一行，我们可以查看下一行代码的运行情况。由于此时仍然是断点状态我们可以重复点击 “单步调试” 的按钮达到逐步运行的调试效果。</p><p>断点调试操作界面</p><p>最后再介绍一些 Sources 模块下实用的快捷键，选中控制台的 Sources 之后按下 ctrl + P ，能够搜索当前页面引用的资源。通过它我们可以迅速找到希望调试的 JS 文件。当我们选中某个文件之后，可以使用快捷键 ctrl + F 进行文件内容检索，方便快速定位代码片段和查看变量使用。</p><p>常用快捷键操作</p><p><a name="q2h3lz"></a></p><h3 id="5-网络请求调试"><a href="#5-网络请求调试" class="headerlink" title="5. 网络请求调试"></a>5. 网络请求调试</h3><p>接下来我们再来看看网络请求的调试。在网页开发中网络请求是的数据的来源渠道，加载一个页面所需的 HTML 、 CSS 、JS 以及图片等资源都是通过网络请求获取的。数据的获取直接影响着页面内容的展示，如此重要的环节浏览器自然也对其做了监控。我们可以通过 Network 模块来对网络请求进行分析和调试。</p><p>任意打开一个在线网址如 <a href="https://github.com/">https://github.com</a> ，进入控制台并点击 Network ，我们能够看到很多资源请求。</p><p>Network工具栏</p><p>工具栏上有很多分类：XHR、JS、CSS、Img、Media、Font、Doc、WS、Manifest等，这些是请求资源的分类。默认是展示全部 All ，点击到其中某一项则能够将请求列表过滤为只有该类型。如点击 JS 则下面的请求列表全部为 JS 资源，点击 XHR 则过滤为向后端发送的异步请求。</p><p>大部分时候我们用到最多的分类是 XHR ，它能够帮助我们调试异步请求。从我们发送请求到我们接收响应数据的过程中，大量细节都记录在控制台中。我们可以点击一个具体的异步请求进行查看</p><p>异步请求调试</p><p>首先看到 Header 这一栏，里面包含了很多信息，这些信息分成4个模块： General 、 Response Headers 、 Request Headers 和 Query String Parameters。</p><ul><li>General里面记录的是请求的基本信息，包括请求地址（Request URL）、请求类型（Request Method）、请求发送状态（Status Code）等</li><li>Response Headers是响应头，里面记录了返回数据的类型（Content-Type）,浏览器数据的压缩格式(Content-Encoding),服务器的类型(Server),当前时间(Date)等</li><li>Request Headers是请求头，里面记录了本次请求的客户机支持的数据类型（Accept），缓存控制（Cache-Control），Cookie，访问的主机名（Host），处理完这次请求后的连接方式（Connection）等</li><li>Query String Parameters是异步请求的参数，如果是 get 请求，则参数为加在url后面的一串查询参数，如果是post请求，则参数为 body 体里的 json 对象。</li></ul><p>然后我们切到 Preview 这里我们看到的内容是异步请求返回的数据，数据格式是 JSON 对象。很多时候我们就是通过查看这里的数据来进行异步请求的数据查看和问题排查。当我们调用了一个后端提供的接口，我们第一时间就该来到这里查看后端返回了怎样的数据，我们才能继续利用这些数据进行后续的操作。</p><p>查看请求返回数据</p><p>接下来我们再看 Response ，里面的内容是也是异步请求返回数据，不过它跟 preview 的区别在于 preview 中的数据是以  JSON 对象的形式返回的，而在 Response 中是以 JSON 字符串的形式返回。</p><p>JSON字符串形式的返回数据</p><p>最后的 Timing 一栏中，展示了本次异步请求的时间开销。在哪个环节消耗了多少时间在这一栏里都能很明确得展示出来，因此当一个异步请求的等待时间较长时，我们不妨可以到这里来看看是在哪个环节能够进行优化。</p><p>请求耗时分布</p><p>怎么样？一个异步请求的发送过程是不是在浏览器中记录得非常详细了？正是因为有了这样强大的功能，Chrome浏览器才会成为众多前端开发人员钟爱的调试利器。</p><p><a name="sv5glk"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本章节介绍了 Chrome 浏览器的基本调试场景和调试方法，并分别对 DOM 调试，CSS调试，JS调试和网络请求的调试做了展示。当然， Chrome 浏览器的调试功能并不仅限于此，还有很多模块值得大家去探索。浏览器是前端开发用于展示的平台，更是我们提升效率的利器，大家一定要多多尝试，将它充分利用起来。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>发布订阅subscribe</title>
      <link href="/2020/10/07/frontend/interview/fa-bu-ding-yue-subscribe/"/>
      <url>/2020/10/07/frontend/interview/fa-bu-ding-yue-subscribe/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布订阅模式 EventBus.js</span></span><br><span class="line"><span class="keyword">let</span> instance = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> listeners = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> getInstance = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">      <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">    instance = <span class="keyword">new</span> <span class="title class_">EventBus</span>()</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  on = <span class="function">(<span class="params">event, fn</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (listeners[event]) &#123;</span><br><span class="line">      listeners[event].<span class="title function_">push</span>(fn)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      listeners[event] = [fn]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  emit = <span class="function">(<span class="params">event, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      listeners[event].<span class="title function_">map</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>(data))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> error</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  off = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> listeners[event]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventBus = <span class="title class_">EventBus</span>.<span class="title function_">getInstance</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">eventBus.<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">eventBus.<span class="title function_">emit</span>(<span class="string">&#x27;click&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">eventBus.<span class="title function_">off</span>(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> eventBus;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS</title>
      <link href="/2020/08/06/frontend/browser/dns/"/>
      <url>/2020/08/06/frontend/browser/dns/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>DNS (Domain Name System)， 也叫网域名称系统，是互联网的一项服务。它实质上是一个 <strong>域名</strong> 和 <strong>IP</strong> 相互映射的分布式数据库，有了它，我们就可以通过域名更方便的访问互联网。最初，由于ip长且难记，通过ip访问网站不方便。。所以后来通过发明了DNS服务器，这个时候我们访问网站输入网站域名，DNS服务器就解析我们的域名为ip。这样我们实际访问的就是对应的ip地址啦。<br />DNS有以下特点:</p><ul><li>分布式的</li><li>协议支持TCP 和 UDP, 常用端口是53</li><li>每一级域名的长度限制是63</li><li>域名总长度限制是253</li></ul><p><strong>那么，什么情况下使用TCP，什么情况下使用UDP呢?</strong><br />最早的时候，DNS 的UDP报文上限大小是512 字节， 所以当某个response大小超过512 (返回信息太多)，DNS服务就会使用TCP协议来传输。后来DNS 协议扩展了自己的UDP协议，DNS client 发出查询请求时，可以指定自己能接收超过512字节的UDP包， 这种情况下，DNS 还是会使用UDP协议</p><p>域名与ip的对应关系，被称为记录(record)，可分为各种类型</p><ul><li>A: Address，域名指向的IP地址，一个域名可以有多个A记录。</li><li>NS：Name Server，保存下一级域名信息的服务器地址</li><li>MX：Mail eXchange，接受电子邮件的服务器地址</li><li>CNAME：Canonical Name，返回另一个域名，令当前查询域名挑去该域名，多个域名-&gt;服务器的映射。</li><li>PTR： Pointer Record，只用于ip地址查询域名</li></ul><p>DNS由下面三个部分组成</p><ul><li>名称解析器（resolver）</li><li>域名空间（domain name space）</li><li>名称服务器（name server）</li></ul><p>假如你要访问baidu.com，需要先通过dns系统查出他的ip地址如220.181.57.216，才能访问。</p><p><a name="sjKGj"></a></p><h2 id="dns查询的过程"><a href="#dns查询的过程" class="headerlink" title="dns查询的过程"></a>dns查询的过程</h2><p>dns通过域名查出ip（我们以浏览器输入<a href="http://www.example.com为例）：">www.example.com为例）：</a></p><ol><li>检查浏览器缓存(缓存时间比较短，默认只有1分钟，且只能容纳1000条缓存)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查看Chrome自身的缓存</span><br><span class="line">chrome://net-internals/<span class="comment">#dns</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589511986523-9ee9d1e7-6c5a-4c1d-818f-8c95b137f801.png#height=235&id=i8N3l&originHeight=235&originWidth=529&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19755&status=done&style=none&title=&width=529" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589511986523-9ee9d1e7-6c5a-4c1d-818f-8c95b137f801.png#height=235&id=i8N3l&originHeight=235&originWidth=529&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19755&status=done&style=none&title=&width=529" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><ol start="2"><li>检查操作系统DNS缓存</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Windows - 查看DNS缓存条目</span></span><br><span class="line">$ pconfig /displaydns</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mac - 查看DNS缓存条目 打开控制台应用</span></span><br><span class="line">sudo <span class="built_in">log</span> config --mode <span class="string">&quot;private_data:on&quot;</span></span><br><span class="line">sudo killall -INFO mDNSResponder</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>读取<code>hosts</code>文件</li><li>检查路由器缓存</li><li>如果前几步都没没找到，会向ISP(网络服务提供商)的LDNS服务器查询</li><li>如果LDNS服务器没找到，会向跟域名服务器(Root Server)请求解析，分为以下几步：<ol><li>跟服务器返回顶级域名(TLD)服务器如.com，.cn，.org等的地址，全球只有13台，该例子中会返回.com的地址</li><li>接着向TLD发送请求，然后会返回次级域名(SLD)服务器的地址，本例子会返回.example的地址</li><li>接着向SLD域名服务器通过域名查询目标IP，本例子会返回<a href="http://www.example.com的地址/">www.example.com的地址</a></li><li>Local DNS Server会缓存结果，并返回给用户，缓存在系统中。</li></ol></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589512622044-d53a60f9-2bba-4672-b3ad-3581fbb188d8.png#height=806&id=LY0qf&originHeight=806&originWidth=1280&originalType=binary&ratio=1&rotation=0&showTitle=false&size=791656&status=done&style=none&title=&width=1280" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589512622044-d53a60f9-2bba-4672-b3ad-3581fbb188d8.png#height=806&id=LY0qf&originHeight=806&originWidth=1280&originalType=binary&ratio=1&rotation=0&showTitle=false&size=791656&status=done&style=none&title=&width=1280" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="vcpIP"></a></p><h2 id="DNS安全问题"><a href="#DNS安全问题" class="headerlink" title="DNS安全问题"></a>DNS安全问题</h2><ol><li>DNS反射&#x2F;放大攻击<br />向大量开放DNS服务器发送大范围域名查询的DNS请求，并将该DNS请求的源IP地址伪造成想要攻击的目标IP地址。由于请求数据比相应数据小得多，攻击者可以利用该技术放大掌握的带宽资源和攻击流量。</li><li>DDOS攻击可能造成域名解析瘫痪</li><li>DNS&#x2F;域名劫持<br />在劫持的网络范围内拦截域名解析的请求，分析请求的域名，返回假的IP地址或者使请求失去响应。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。</li><li>DNS污染<br />DNS污染是一种让一般用户由于得到虚假目标主机IP而不能与其通信的方法，指的是用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。<br />dns污染与dns劫持的区别在于，dns劫持修改了dns的解析结果，dns污染是不经过dns服务器，返回错误信息</li><li>DNS信息黑客被修改</li></ol><p><a name="tX5Ik"></a></p><h2 id="DNS优化"><a href="#DNS优化" class="headerlink" title="DNS优化"></a>DNS优化</h2><p>可以看出，dns解析是一个漫长的过程，如何优化这一过程呢？</p><ol><li>DNS Prefetching用户在请求某个链接之前，浏览器先尝试解析该链接的域名再将其进行缓存。这样真正请求的时候就不需要进行DNS解析。可以<ul><li>在服务器中响应设置<code>X-DNS-Prefetch-Control</code>的值为<code>on</code>启动预解析</li><li>HTML中，<code>&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;</code></li><li>对特定域名预解析<code>&lt;link rel=”dns-prefetch” href=”//fonts.googleapis.com”&gt;</code></li></ul></li><li>域名收敛<br />建议将静态资源只放在一个域名下面，可以有效减少dns的请求</li><li>httpdns基于Http协议向HTTPDNS服务器发送域名解析请求，替代了基于DNS协议向运营商Local DNS发起解析请求的传统方式，可以避免运营商的域名劫持和进行精准调度。这过程分为两步<ol><li>客户端直接访问HttpDNS接口，获取业务在域名配置管理系统上配置的访问延迟最优的IP。（基于容灾考虑，还是保留次选使用运营商LocalDNS解析域名的方式）</li><li>客户端向获取到的IP后就向直接往此IP发送业务协议请求。以Http请求为例，通过在header中指定host字段，向HttpDNS返回的IP发送标准的Http请求即可。</li></ol></li></ol><p><a name="thwCN"></a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>「真®全栈之路 - DNS篇」故事从输入URL开始….：<a href="https://juejin.im/post/5ceebb7251882507266414b7#heading-10">https://juejin.im/post/5ceebb7251882507266414b7#heading-10</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css常见兼容问题</title>
      <link href="/2020/07/28/compatible/css-compatible/"/>
      <url>/2020/07/28/compatible/css-compatible/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h4 id="移动端的-1px"><a href="#移动端的-1px" class="headerlink" title="移动端的 1px"></a>移动端的 1px</h4><p>问题描述：1px 的边框。在高清屏下，移动端的 1px 会很粗。<br />产生原因：首先先要了解一个概念：<strong>DPR(devicePixelRatio) 设备像素比</strong>，它是默认缩放为 100%的情况下，设备像素和 CSS 逻辑像素的比值。目前主流的屏幕 DPR&#x3D;2 或者 3。CSS中设置的px是逻辑像素,这就造成1px变成物理像素的2px或者3px，比如2 倍屏，设备的物理像素要实现 1 像素，所以 CSS 逻辑像素只能是 0.5px。<br />下面介绍最常用的方法<br />通过CSS :before 选择器或CSS :after 选择器设置height:1px，同时缩放0.5倍实现。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 底边框 */</span></span><br><span class="line"><span class="selector-class">.b-border</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.b-border</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#d9d9d9</span>;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  -webkit-<span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 四条边 */</span></span><br><span class="line"><span class="selector-class">.setBorderAll</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  &amp;<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">    <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e5e5e5</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="KO4Ca"></a></p><h4 id="CSS动画页面闪白-动画卡顿"><a href="#CSS动画页面闪白-动画卡顿" class="headerlink" title="CSS动画页面闪白,动画卡顿"></a>CSS动画页面闪白,动画卡顿</h4><p>问题描述：CSS动画页面闪白,动画卡顿<br />解决方法: <br />1.尽可能地使用合成属性transform和opacity来设计CSS3动画，不使用position的left和top来定位 <br />2.开启硬件加速</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-webkit-<span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">-moz-<span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">-ms-<span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><a name="cvaLi"></a></p><h4 id="屏蔽用户选择"><a href="#屏蔽用户选择" class="headerlink" title="屏蔽用户选择"></a>屏蔽用户选择</h4><p>禁止用户选择页面中的文字或者图片</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  -webkit-touch-callout: none;</span><br><span class="line">  -webkit-user-select: none;</span><br><span class="line">  -khtml-user-select: none;</span><br><span class="line">  -moz-user-select: none;</span><br><span class="line">  -ms-user-select: none;</span><br><span class="line">  user-select: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="IzfcU"></a></p><h4 id="清除输入框内阴影"><a href="#清除输入框内阴影" class="headerlink" title="清除输入框内阴影"></a>清除输入框内阴影</h4><p>问题描述：在 iOS 上，输入框默认有内部阴影 解决方式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">  -webkit-appearance: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="GBwTM"></a></p><h4 id="禁止保存或拷贝图像"><a href="#禁止保存或拷贝图像" class="headerlink" title="禁止保存或拷贝图像"></a>禁止保存或拷贝图像</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  -webkit-touch-callout: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="o7i6z"></a></p><h4 id="输入框默认字体颜色设置"><a href="#输入框默认字体颜色设置" class="headerlink" title="输入框默认字体颜色设置"></a>输入框默认字体颜色设置</h4><p>设置 input 里面 placeholder 字体的颜色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span>::-webkit-input-placeholder,</span><br><span class="line">textarea::-webkit-input-placeholder &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#c7c7c7</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span>:-moz-placeholder,</span><br><span class="line">textarea:-moz-placeholder &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#c7c7c7</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span>:-ms-input-placeholder,</span><br><span class="line">textarea:-ms-input-placeholder &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#c7c7c7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="b54E7"></a></p><h4 id="用户设置字号放大或者缩小导致页面布局错误"><a href="#用户设置字号放大或者缩小导致页面布局错误" class="headerlink" title="用户设置字号放大或者缩小导致页面布局错误"></a>用户设置字号放大或者缩小导致页面布局错误</h4><p>设置字体禁止缩放</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  -webkit-text-size-adjust: <span class="number">100%</span> <span class="meta">!important</span>;</span><br><span class="line">  text-size-adjust: <span class="number">100%</span> <span class="meta">!important</span>;</span><br><span class="line">  -moz-text-size-adjust: <span class="number">100%</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="QmFWH"></a></p><h4 id="android系统中元素被点击时产生边框"><a href="#android系统中元素被点击时产生边框" class="headerlink" title="android系统中元素被点击时产生边框"></a>android系统中元素被点击时产生边框</h4><p>部分android系统点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样。去除代码如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>,<span class="selector-tag">button</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>&#123;</span><br><span class="line">  -webkit-tap-highlight-<span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">  -webkit-user-modify:read-write-plaintext-only; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="OVd7J"></a></p><h4 id="iOS-滑动不流畅"><a href="#iOS-滑动不流畅" class="headerlink" title="iOS 滑动不流畅"></a>iOS 滑动不流畅</h4><p>ios 手机上下滑动页面会产生卡顿，手指离开页面，页面立即停止运动。整体表现就是滑动不流畅，没有滑动惯性。 iOS 5.0 以及之后的版本，滑动有定义有两个值 auto 和 touch，默认值为 auto。</p><ul><li>解决方式</li></ul><p>1.在滚动容器上增加滚动 touch 方法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  -webkit-<span class="attribute">overflow</span>-scrolling: touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2.设置 overflow 设置外部 overflow 为 hidden,设置内容元素 overflow 为 auto。内部元素超出 body 即产生滚动，超出的部分 body 隐藏。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">overflow-y</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">overflow-y</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> compatible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端四大手写</title>
      <link href="/2020/07/23/frontend/interview/qian-duan-si-da-shou-xie/"/>
      <url>/2020/07/23/frontend/interview/qian-duan-si-da-shou-xie/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>要问程序员最心虚的面试题，如果要投票选择，<strong>手撕代码</strong>一定是前三位的。其中在前端领域，以<strong>手写 bind</strong>、<strong>手写深拷贝</strong>、<strong>手写 EventHub</strong>（发布-订阅）、<strong>手写 Promise</strong>最为常见，我将他们称为<strong>四大手写。</strong>本文的目的就是要破除大家对四大手写的恐惧，将从<strong>为什么要会手写</strong>，到每个手写的<strong>关键思路总结</strong>，再到<strong>最终模板</strong>，我都会<strong>毫无保留</strong>地分享给大家。话不多说，让我们开始吧。<br><a name="VqL5S"></a></p><h2 id="为什么要会手写"><a href="#为什么要会手写" class="headerlink" title="为什么要会手写"></a>为什么要会手写</h2><p>面试遇到手写题一脸懵逼的你也许一定想问：网上代码一堆，随便抄一下不香吗，为什么要手写？关于这个问题最直接的回答：为了<strong>区分</strong>厉害的和普通的。但坦白来讲，<strong>会白板实现关键功能的人，实现业务需求的效率一定更高</strong>。<br />为什么这么说？<br />拿手写 Promise 举例来讲，真实的业务场景会遇到大量的 AJAX 异步请求，而且大多是嵌套多层的异步代码。<br />普通前端 A 平时只会最简单的 Promise 用法，遇到多层嵌套的 Promise 就搞不清楚逻辑了，于是开发 1 小时，修 Bug 3 小时，<strong>内卷 996</strong>；<br />高级前端 B 会手写 Promise，对 Promise 的内在逻辑一清二楚，于是开发半小时，修 Bug 15 分钟，完成质量高速度快，深受 PM 小姐姐和测试小哥哥的喜爱，<strong>准点下班绩效高</strong>。<br />再举个 EventHub 的例子，会手写 EventHub 的前端，Vue 里的 $emit、$on 基本就是闭眼写；同理还有 React 里面组件想要调用普通函数（非箭头函数），需要 this.fn.bind(this)，会手写 bind 的前端就更容易举一反三，不会的就只能死记硬背，遇到 Bug 不知所措。。。<br />所以，会“四大手写”是<strong>前端进阶</strong>的必由之路，甚至可以说，<strong>手写关键代码的能力 ≈ 编程能力</strong>。</p><hr><p><a name="sODCV"></a></p><h2 id="手写-bind"><a href="#手写-bind" class="headerlink" title="手写 bind"></a>手写 bind</h2><p>bind 用法不难，一句话解释就是把新的 this 绑定到某个函数 func 上，并返回 func 的一个拷贝。使用方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> boundFunc = func.<span class="title function_">bind</span>(thisArg[, arg1[, arg2[, ...argN]]])</span><br></pre></td></tr></table></figure><p><br />那怎么实现呢？我认为手写 bind 可以分为三个境界：</p><ol><li>初级：只用 ES6 新语法</li></ol><ul><li>优点：因为可以使用 const 、… 操作符，代码简洁</li><li>缺点：兼容性稍差</li></ul><ol start="2"><li>中级：使用 ES5 语法</li></ol><ul><li>优点：兼容 IE（其实可以忽略）</li><li>缺点：参数要用Array.prototype.slice 获取，复杂且不支持 new</li></ul><ol start="3"><li>高级：ES5 + 支持 new</li></ol><ul><li>优点：支持 new</li><li>缺点：最复杂</li></ul><p><a name="P5uSV"></a></p><h3 id="初级-bind"><a href="#初级-bind" class="headerlink" title="初级 bind"></a>初级 bind</h3><p>这种方式的优点是因为可以使用 const 、… 操作符，代码简洁；缺点是不兼容 IE 等一些古老浏览器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初级：ES6 新语法 const/...</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bind_1</span>(<span class="params">asThis, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span>; <span class="comment">// 这里的 this 就是调用 bind 的函数 func</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(asThis, ...args, ...args2);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="mivQ4"></a></p><h3 id="中级-bind"><a href="#中级-bind" class="headerlink" title="中级 bind"></a>中级 bind</h3><ul><li>优点：兼容 IE</li><li>缺点：参数要用Array.prototype.slice 取，复杂且不支持 new</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中级：兼容 ES5</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bind_2</span>(<span class="params">asThis</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> slice = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>;</span><br><span class="line">  <span class="keyword">var</span> args = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;cannot bind non_function&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> args2 = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(asThis, args.<span class="title function_">concat</span>(args2));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="Vig5y"></a></p><h3 id="高级-bind"><a href="#高级-bind" class="headerlink" title="高级 bind"></a>高级 bind</h3><ul><li>优点：支持 new</li><li>缺点：最复杂</li></ul><p>写之前，我们先来看一看我们应该如何判断 new，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title function_">fn</span>(args)</span><br></pre></td></tr></table></figure><p> 其实<strong>等价于</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> temp = &#123;&#125;</span><br><span class="line">temp.<span class="property">__proto__</span> = fn.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">fn.<span class="title function_">apply</span>(temp, [...args])</span><br><span class="line"><span class="keyword">return</span> temp</span><br></pre></td></tr></table></figure><p>核心在第二句：temp.<strong>proto</strong> &#x3D; fn.prototype，有了这个，我们便知道可以用 fn.prototype 是否为对象原型来判断是否为 new 的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高级：支持 new，例如 new (funcA.bind(thisArg, args))</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bind_3</span>(<span class="params">asThis</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> slice = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>;</span><br><span class="line">  <span class="comment">// 改变数组slice方法的作用域，使 this 指向arguments对象</span></span><br><span class="line">  <span class="comment">// call () 方法的第二个参数表示传递给slice的参数即截取数组的起始位置</span></span><br><span class="line">  <span class="keyword">var</span> args1 = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Must accept function&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resultFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> args2 = slice.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">      resultFn.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(<span class="variable language_">this</span>) ? <span class="variable language_">this</span> : asThis, <span class="comment">// 用来绑定 this</span></span><br><span class="line">      args1.<span class="title function_">concat</span>(args2)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  resultFn.<span class="property"><span class="keyword">prototype</span></span> = fn.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="keyword">return</span> resultFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是前端年年考，年年不会，网上博客又经常误人子弟的“手写深拷贝”。</p><hr><p><a name="vuhlj"></a></p><h2 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h2><p>先问这么几个问题，</p><ul><li>首先为什么要深拷贝？不希望数据被修改或者只需要部分修改数据。</li><li>怎么实现深拷贝？简单需求用 JSON 反序列化，复杂需求用递归克隆。</li><li>手写深拷贝的优点？体现扎实的 JS 基础。</li><li>至于缺点以及如何解决稍后再回答<br><a name="IQGQm"></a></li></ul><h3 id="简单需求"><a href="#简单需求" class="headerlink" title="简单需求"></a>简单需求</h3><p>最简单的手写深拷贝就一行，通过 <strong>JSON 反序列化</strong>来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> B = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(A))</span><br></pre></td></tr></table></figure><p>缺点也是显而易见的，<strong>JSON value不支持的数据类型，都拷贝不了</strong></p><ol><li>不支持函数</li><li>不支持undefined（<strong>支持null</strong>）</li><li>不支持循环引用，比如 a &#x3D; {name: ‘a’}; a.self &#x3D; a; a2 &#x3D; JSON.parse(JSON.stringify(a))</li><li>不支持Date，会变成 ISO8601 格式的字符串</li><li>不支持正则表达式</li><li>不支持Symbol</li></ol><p>如何支持这些复杂需求，就需要用到<strong>递归克隆</strong>了。<br><a name="LTgyG"></a></p><h3 id="复杂需求"><a href="#复杂需求" class="headerlink" title="复杂需求"></a>复杂需求</h3><p><strong>核心</strong>有三点：</p><ol><li>递归</li><li>对象分类型讨论</li><li>解决循环引用（环）</li></ol><p>下面给出我的模板：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeepClone</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cacheList</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">clone</span>(<span class="params">source</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">Object</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> cache = <span class="variable language_">this</span>.<span class="title function_">findCache</span>(source);</span><br><span class="line">      <span class="keyword">if</span> (cache) <span class="keyword">return</span> cache; <span class="comment">// 如果找到缓存，直接返回</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> target;</span><br><span class="line">        <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">          target = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123;</span><br><span class="line">          target = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> source.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">          target = <span class="keyword">new</span> <span class="title class_">Date</span>(source);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) &#123;</span><br><span class="line">          target = <span class="keyword">new</span> <span class="title class_">RegExp</span>(source.<span class="property">source</span>, source.<span class="property">flags</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cacheList</span>.<span class="title function_">push</span>([source, target]); <span class="comment">// 把源对象和新对象放进缓存列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">          <span class="keyword">if</span> (source.<span class="title function_">hasOwnProperty</span>(key)) &#123; <span class="comment">// 不拷贝原型上的属性，太浪费内存</span></span><br><span class="line">            target[key] = <span class="variable language_">this</span>.<span class="title function_">clone</span>(source[key]); <span class="comment">// 递归克隆</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">findCache</span>(<span class="params">source</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">cacheList</span>.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cacheList</span>[i][<span class="number">0</span>] === source) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">cacheList</span>[i][<span class="number">1</span>]; <span class="comment">// 如果有环，返回对应的新对象</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充一句，如果您想看详细的测试与运行结果，请参见 <a href="https://link.zhihu.com/?target=https://github.com/venaissance/source-deepClone">我的 GitHub →</a><br />递归克隆看起来很强大，但是完美无缺吗？其实还是有不小的距离：</p><ol><li>对象类型支持不够多（Buffer，Map，Set等都不支持）</li><li>存在递归爆栈的风险</li></ol><p>如果要解决这些问题，实现一个”完美“的深拷贝，只能求教上百行代码的 <a href="https://link.zhihu.com/?target=https://github.com/lodash/lodash/blob/master/cloneDeep.js">Lodash.cloneDeep()</a> 了 。<br />让我们再引申一下，深拷贝有局限吗？<br><a name="hlf23"></a></p><h2 id="深拷贝的局限"><a href="#深拷贝的局限" class="headerlink" title="深拷贝的局限"></a>深拷贝的局限</h2><p>如果需要对一个复杂对象进行频繁操作，每次都完全深拷贝一次的话性能岂不是太差了，因为大部分场景下都只是更新了这个对象的某几个字段，而其他的字段都不变，对这些不变的字段的拷贝明显是多余的。那么问题来了，浅拷贝不更新，深拷贝性能差，怎么办？<br />这里推荐3个可以实现”部分“深拷贝的库：</p><ol><li><a href="https://link.zhihu.com/?target=https://immutable-js.github.io/immutable-js/">Immutable.js</a> Immutable.js 会把对象所有的 key 进行 hash 映射，将得到的 hash 值转化为二进制，从后向前每 5 位进行分割后再转化为 Trie 树。Trie 树利用这些 hash 值的公共前缀来减少查询时间，最大限度地减少无谓 key 的比较。关于 Trie 树（字典树）的介绍，可以看我的博客<a href="https://zhuanlan.zhihu.com/p/136103651">算法基础06-字典树、并查集、高级搜索、红黑树、AVL 树</a></li><li><a href="https://link.zhihu.com/?target=https://github.com/rtfeldman/seamless-immutable">seamless-immutable</a>，如果数据量不大但想用这种类似 updateIn 便利的语法的话可以用 seamless-immutable。这个库就没有上面的 Trie 树这些幺蛾子了，就是为其扩展了 updateIn、merge 等 9 个方法的普通简单对象，利用 Object.freeze 冻结对象本身改动, 每次修改返回副本。感觉像是阉割版，性能不及 Immutable.js，但在部分场景下也是适用的。</li><li><a href="https://link.zhihu.com/?target=https://github.com/immerjs/immer">Immer.js</a>，通过用来数据劫持的 Proxy 实现：对原始数据中每个访问到的节点都创建一个 Proxy，修改节点时修改副本而不操作原数据，最后返回到对象由未修改的部分和已修改的副本组成。（这不就是 Vue3 数据响应式原理嘛）<br><a name="ZzcKr"></a></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看完这一段，你现在能回答怎么实现深拷贝了吗？概括成一句就是：<strong>简单需求用 JSON 反序列化，复杂需求用递归克隆</strong>。<br />对于递归克隆的深拷贝，核心有三点：</p><ol><li><strong>对象分类</strong></li><li><strong>递归</strong></li><li>用<strong>缓存</strong>对付<strong>环</strong></li></ol><hr><p><a name="QMocX"></a></p><h2 id="手写-EventHub（发布-订阅）"><a href="#手写-EventHub（发布-订阅）" class="headerlink" title="手写 EventHub（发布-订阅）"></a>手写 EventHub（发布-订阅）</h2><p>核心思路是：</p><ol><li>使用一个对象作为<strong>缓存</strong></li><li>on 负责把方法<strong>发布</strong>到缓存的 EventName 对应的数组</li><li>emit 负责遍历触发<strong>（订阅）</strong> EventName 下的方法数组</li><li>off <strong>找</strong>方法的<strong>索引</strong>，并删除</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventHub</span> &#123;</span><br><span class="line">  cache = &#123;&#125;;</span><br><span class="line">  <span class="title function_">on</span>(<span class="params">eventName, fn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>[eventName] = <span class="variable language_">this</span>.<span class="property">cache</span>[eventName] || [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>[eventName].<span class="title function_">push</span>(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">eventName</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>[eventName].<span class="title function_">forEach</span>(<span class="function">(<span class="params">fn</span>) =&gt;</span> <span class="title function_">fn</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">off</span>(<span class="params">eventName, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="title function_">indexOf</span>(<span class="variable language_">this</span>.<span class="property">cache</span>[eventName], fn); <span class="comment">// 这里用 this.cache[eventName].indexOf(fn) 完全可以，封装成函数是为了向下兼容</span></span><br><span class="line">    <span class="keyword">if</span> (index === -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span>[eventName].<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兼容 IE 8 的 indexOf</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">indexOf</span>(<span class="params">arr, item</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr === <span class="literal">undefined</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> index = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] === item) &#123;</span><br><span class="line">      index = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您想看详细的测试与运行结果，请参见 <a href="https://link.zhihu.com/?target=https://github.com/venaissance/ts-source-EventHub">我的 GitHub →</a></p><hr><p><a name="kGhQd"></a></p><h2 id="手写-Promise"><a href="#手写-Promise" class="headerlink" title="手写 Promise"></a>手写 Promise</h2><p>无疑是要求最高的，如果要硬按照 Promises&#x2F;A+ 规范来写，可能至少要 2-3 个小时，400+行代码，这种情况是几乎不可能出现在面试中。所以我们只需要完成一个<strong>差不多</strong>的版本，保留最核心的功能。<br />核心功能：</p><ul><li>new Promise(fn) 其中 fn 只能为函数，且要<strong>立即执行</strong></li><li>promise.then(success, fail)中的 success 是函数，且会在 resolve 被调用的时候执行，fail 同理</li></ul><p>实现思路：</p><ol><li>then(succeed, fail) 先把成功失败回调放到一个回调数组 callbacks[] 上</li><li>resolve() 和 reject() 遍历 callbacks</li><li>resolve() 读取成功回调 &#x2F; reject() 读取失败回调，并异步执行 callbacks 里面的成功和失败回调（放到本轮的微任务队列中）</li></ol><p>下面分享我自己根据上述需求及思路实现的模板：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise2</span> &#123;</span><br><span class="line">  state = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">  callbacks = [];</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;must pass function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">resolve</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="variable language_">this</span>.<span class="property">reject</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">    <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">handle</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> handle[<span class="number">0</span>] === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">          handle[<span class="number">0</span>].<span class="title function_">call</span>(<span class="literal">undefined</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">    <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">handle</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> handle[<span class="number">1</span>] === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">          handle[<span class="number">1</span>].<span class="title function_">call</span>(<span class="literal">undefined</span>, reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">succeed, fail</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> handle = [];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> succeed === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      handle[<span class="number">0</span>] = succeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fail === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      handle[<span class="number">1</span>] = fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callbacks</span>.<span class="title function_">push</span>(handle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process !== <span class="literal">undefined</span> &amp;&amp; <span class="keyword">typeof</span> process.<span class="property">nextTick</span> === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> process.<span class="title function_">nextTick</span>(fn);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 用MutationObserver实现浏览器上的nextTick</span></span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(fn);</span><br><span class="line">    <span class="keyword">var</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter));</span><br><span class="line"></span><br><span class="line">    observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">      <span class="attr">characterData</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line">    textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，如果您想看详细的测试与运行结果，请参见 <a href="https://link.zhihu.com/?target=https://github.com/venaissance/ts-source-promise">我的 GitHub →</a></p><hr><p><a name="HjuHV"></a></p><h2 id="手写-Promise-all"><a href="#手写-Promise-all" class="headerlink" title="手写 Promise.all()"></a>手写 Promise.all()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">PromiseAll</span>(<span class="params">promiseArray</span>) &#123;    <span class="comment">//返回一个Promise对象</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(promiseArray)) &#123;                        <span class="comment">//传入的参数是否为数组</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;传入的参数不是数组！&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> res = []</span><br><span class="line">        <span class="keyword">let</span> counter = <span class="number">0</span>                         <span class="comment">//设置一个计数器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promiseArray.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promiseArray[i]).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                counter++                  <span class="comment">//使用计数器返回 必须使用counter</span></span><br><span class="line">                res[i] = value</span><br><span class="line">                <span class="keyword">if</span> (counter === promiseArray.<span class="property">length</span>) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(res)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">reject</span>(e))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上为核心实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">res</span>(<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">res</span>(<span class="string">&#x27;p2&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">res</span>(<span class="string">&#x27;p3&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="title class_">PromiseAll</span>([p1, p2, p3])</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e))</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test);</span><br></pre></td></tr></table></figure><p><a name="C9epL"></a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>总结一下，会手写关键代码对技术发展的重要性是不言而喻的，所以大家一定要勇于克服自己内心的恐惧，<strong>刻意练习</strong>，终有一天，你会体会到技术精进的快感！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请求中常见的状态码</title>
      <link href="/2019/10/24/frontend/browser/qing-qiu-zhong-chang-jian-de-zhuang-tai-ma/"/>
      <url>/2019/10/24/frontend/browser/qing-qiu-zhong-chang-jian-de-zhuang-tai-ma/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><a name="vXcr4"></a>### 状态码是什么？客户端HTTP请求的返回标志，由3个十进制数字组成。<br />第一个数字：状态码的分类<br />后面两个数字：不同分类情况下的不同状态<a name="iFNoU"></a>### 最常见报错的状态码有哪些？<ol><li>304：有缓存， 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</li><li>400：请求内容有误，服务器不理解请求的语法。一般请求的内容写错或者格式不正确可能会出现这种错误</li><li>404：服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；</li><li>405：请求的方法不正确，例如定义的是post方式，请求写的是get 就会报这种错</li><li>500：服务器内部错误，服务器遇到错误，无法完成请求。</li><li>502：错误网关，我一般遇见这个会出现在ngnix没有启动或者代理写错的时候<br><a name="zriL2"></a></li></ol><h3 id="总体概括"><a href="#总体概括" class="headerlink" title="总体概括"></a>总体概括</h3><p><a name="p4ZiA"></a></p><h4 id="1xx-：临时响应，需要请求者继续执行操作的状态代码"><a href="#1xx-：临时响应，需要请求者继续执行操作的状态代码" class="headerlink" title="1xx ：临时响应，需要请求者继续执行操作的状态代码"></a>1xx ：临时响应，需要请求者继续执行操作的状态代码</h4><table><thead><tr><th>100</th><th>表示服务器已经收到一部分请求正在等待剩余不符</th></tr></thead><tbody><tr><td>101</td><td>切换协议 要求服务器切换协议，并且服务器已确认并准备切换</td></tr></tbody></table><p><a name="KHEnD"></a></p><h4 id="2xx-：成功，请求已经成功"><a href="#2xx-：成功，请求已经成功" class="headerlink" title="2xx ：成功，请求已经成功"></a>2xx ：成功，请求已经成功</h4><table><thead><tr><th>200</th><th>请求成功</th></tr></thead><tbody><tr><td>201</td><td>已创建 请求成功并且服务器创建了新的资源</td></tr><tr><td>202</td><td>已接收 服务器已接收请求，但尚未处理</td></tr><tr><td>203</td><td>非授权信息 服务器已经成功处理了请求，但返回的信息来自于另外源</td></tr><tr><td>204</td><td>没有任何返回内容的成功请求，不更新文档视图</td></tr><tr><td>205</td><td>没有任何返回内容的成功请求，必须重置文档视图</td></tr><tr><td>206</td><td>成功处理了部分GET请求</td></tr></tbody></table><p><a name="mbJ3o"></a></p><h4 id="3xx-：重定向"><a href="#3xx-：重定向" class="headerlink" title="3xx ：重定向"></a>3xx ：重定向</h4><table><thead><tr><th>300</th><th>可选择的重定向资源</th></tr></thead><tbody><tr><td>301</td><td>请求资源已永久移动到新位置</td></tr><tr><td>302</td><td>请求的资源现在从不同的URL响应请求</td></tr><tr><td>303</td><td>当前请求的响应可以在另一个URL上找到</td></tr><tr><td>304</td><td>本次请求的内容和之前的一样没有变化</td></tr></tbody></table><p><a name="bV6Y1"></a></p><h4 id="4xx-：客户端响应"><a href="#4xx-：客户端响应" class="headerlink" title="4xx ：客户端响应"></a>4xx ：客户端响应</h4><table><thead><tr><th>400</th><th>语义有误，当前请求无法被服务器理解。请求参数有误</th></tr></thead><tbody><tr><td>401</td><td>当前请求需要用户验证</td></tr><tr><td>403</td><td>服务器拒绝的请求</td></tr><tr><td>404</td><td>请求资源没有在服务器上找到，请求失败</td></tr><tr><td>405</td><td>请求的方法不正确</td></tr></tbody></table><p><a name="AU3Jh"></a></p><h4 id="5xx-：服务器端响应"><a href="#5xx-：服务器端响应" class="headerlink" title="5xx ：服务器端响应"></a>5xx ：服务器端响应</h4><table><thead><tr><th>500</th><th>服务器不知道如何处理</th></tr></thead><tbody><tr><td>501</td><td>请求方法不被服务器支持</td></tr><tr><td>502</td><td>服务器的忘光得到一个错误的响应</td></tr><tr><td>503</td><td>服务器没有准备好处理请求，服务器在维护或者重载或者停机了</td></tr><tr><td>504</td><td>网关请求超时</td></tr><tr><td>505</td><td>服务器不支持请求中所使用的HTTP协议版本</td></tr></tbody></table><p>每种状态码下的分类只写到了5或者6，没有再往多的写，对于我们日常的使用足够了，如果有不在上面的分类的请到以下参考地址<br /><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status#%E6%88%90%E5%8A%9F%E5%93%8D%E5%BA%94">HTTP参考地址请点击</a></p><p><strong>I suppose some things are worth the wait.</strong><br /><strong>生命中有些事值得等待。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 状态码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Https</title>
      <link href="/2019/08/15/frontend/browser/https/"/>
      <url>/2019/08/15/frontend/browser/https/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。<br /><code>HTTPS</code>使用的是<code>TSL</code>协议（<code>SSL</code>是<code>TSL</code>协议的一种）。</p><p><a name="IOK6P"></a></p><h2 id="HTTPS的功能"><a href="#HTTPS的功能" class="headerlink" title="HTTPS的功能"></a>HTTPS的功能</h2><ul><li><strong>内容加密，</strong>对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;<ul><li>非对称密钥加密：传输公钥时可能被截获并掉包，解决方案：使用第三方机构颁发的证书加密公钥（根据服务器地址等多个信息生成，无法被第三方伪造），浏览器收到后使用证书机构颁发的公钥进行解密（前提是浏览器要信任同一个证书颁发机构）解密结果与用证书生成的规则再生成一个签名对比一致就是真证书；</li><li>对称密钥加密：中间人随意截获。</li></ul></li><li><strong>身份认证，</strong>对网站服务器进行真实身份认证。<ul><li>数字证书</li></ul></li><li><strong>数据完整性</strong></li></ul><p>我们经常会在Web的登录页面和购物结算界面等使用HTTPS通信。使用HTTPS通信时，不再用<code>http://</code>，而是改用<code>https://</code>。另外，当浏览器访问HTTPS通信有效的Web网站时，浏览器的地址栏内会出现一个带锁的标记。对HTTPS的显示方式会因浏览器的不同而有所改变。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1597216775859-581b6650-dd85-4d01-8a72-07fd24a166dd.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1597216775859-581b6650-dd85-4d01-8a72-07fd24a166dd.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p><a name="cKLDt"></a></p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>发送方和接收方需要持有同一把密钥，发送消息和接收消息均使用该密钥。相对于非对称加密，对称加密具有更高的加解密速度，但双方都需要事先知道密钥，密钥在传输过程中可能会被窃取，因此安全性没有非对称加密高。</p><p><a name="x7TYm"></a></p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>接收方在发送消息前需要事先生成公钥和私钥，然后将公钥发送给发送方。发送放收到公钥后，将待发送数据用公钥加密，发送给接收方。接收到收到数据后，用私钥解密。<br />在这个过程中，公钥负责加密，私钥负责解密，数据在传输过程中即使被截获，攻击者由于没有私钥，因此也无法破解。<br />非对称加密算法的加解密速度低于对称加密算法，但是安全性更高。</p><p><a name="r3hH1"></a></p><h2 id="几个名词要理清"><a href="#几个名词要理清" class="headerlink" title="几个名词要理清"></a>几个名词要理清</h2><ul><li>RSA：非对称加密</li><li>AES：对称加密 生成一个随机字符串key 只有客户端和服务端有 他们两个通过这个key对数据加密和传输跟解密 这一个统称对称加密</li><li>CA：权威认证机构 服务器在建站的时候 去CA认证机构认证 得到对应的数字签名 相当于身份证号 客户端每次安装浏览器的时候 都会下载最新的CA列表 这个列表有对应的数字签名和服务器IP一一对应的列表 这就是为什么我们自己搭建的localhost没法发https的原因 因为没法进行CA认证</li><li>数字证书：包含了数字签名跟RSA公钥</li><li>数字签名：保证数字证书一定是服务器传给客户端的 相当于服务器的身份证ID</li><li>对称密钥： 对数据进行加密的key</li><li>非对称密钥： （k1， k2） k1加密的数据 只有k2能解开 k1位非对称公钥 k2为非对称私钥</li><li>非对称公钥：RSA公钥 k1加密的数据 只有k2能解开</li><li>非对称私钥：RSA私钥 k1加密的数据 只有k2能解开</li></ul><blockquote><p><a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> 是一种广泛使用的非对称加密算法，严格来说并不等同于非对称加密，同样的对称加密算法除了 <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> ，还有 DES，3DES 等等。</p></blockquote><p><a name="aHLQF"></a></p><h2 id="为什么需要HTTPS"><a href="#为什么需要HTTPS" class="headerlink" title="为什么需要HTTPS"></a>为什么需要HTTPS</h2><p><strong>在HTTP协议中有可能存在信息窃取或身份伪装等安全问题。使用HTTPS通信机制可以有效地防止这些问题。</strong><br><a name="g8XiL"></a></p><h3 id="HTTP协议存在的哪些问题"><a href="#HTTP协议存在的哪些问题" class="headerlink" title="HTTP协议存在的哪些问题"></a>HTTP协议存在的哪些问题</h3><p><a name="0PUiE"></a></p><h4 id="1、通信使用明文（不加密）——内容可能被窃听"><a href="#1、通信使用明文（不加密）——内容可能被窃听" class="headerlink" title="1、通信使用明文（不加密）——内容可能被窃听"></a>1、通信使用明文（不加密）——内容可能被窃听</h4><p>由于HTTP本身不具备加密的功能，所以也无法做到对通信整体（使用HTTP协议通信的请求和响应的内容）进行加密。即，<strong>HTTP报文使用明文（指未经过加密的报文）方式发送</strong>。<br />HTTP明文协议的缺陷是导致数据泄露、数据篡改、流量劫持、钓鱼攻击等安全问题的重要原因。HTTP协议无法加密数据，所有通信数据都在网络中明文“裸奔”。通过网络的嗅探设备及一些技术手段，就可还原HTTP报文内容。<br><a name="m3zAR"></a></p><h4 id="2、无法证明报文的完整性——可能遭篡改"><a href="#2、无法证明报文的完整性——可能遭篡改" class="headerlink" title="2、无法证明报文的完整性——可能遭篡改"></a>2、无法证明报文的完整性——可能遭篡改</h4><p>所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。由于HTTP协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。<br />换句话说，<strong>没有任何办法确认，发出的请求&#x2F;响应和接收到的请求&#x2F;响应是前后相同的</strong>。<br><a name="3Zw9l"></a></p><h4 id="3、不验证通信方的身份——有可能遭遇伪装"><a href="#3、不验证通信方的身份——有可能遭遇伪装" class="headerlink" title="3、不验证通信方的身份——有可能遭遇伪装"></a>3、不验证通信方的身份——有可能遭遇伪装</h4><p><strong>HTTP协议中的请求和响应不会对通信方进行确认</strong>。在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的IP地址和端口号没有被Web服务器设定限制访问的前提下）<br />HTTP协议无法验证通信方身份，任何人都可以伪造虚假服务器欺骗用户，实现“钓鱼欺诈”，用户无法察觉。</p><p><a name="2EvNz"></a></p><h3 id="HTTPS协议优势"><a href="#HTTPS协议优势" class="headerlink" title="HTTPS协议优势"></a>HTTPS协议优势</h3><p>反观HTTPS协议，它比HTTP协议相比多了以下优势（下文会详细介绍）:</p><ul><li>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</li><li>数据完整性：内容传输经过完整性校验</li><li>身份认证：第三方无法伪造服务端（客户端）身份</li></ul><br /><a name="JTPVJ"></a>## HTTPS如何解决HTTP上述问题?HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。<br />通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，**所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP**。<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/164572/1597216790803-23ec8d37-f653-43a3-8f99-d0f30e649fb1.png)<a name="uRu88"></a>### 1、解决内容可能被窃听的问题——加密<a name="Os7yv"></a>#### 方法1.对称加密这种方式加密和解密同用一个密钥。加密和解密都会用到密钥。**没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了**。<br />以对称加密方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落人攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。<a name="0FzwQ"></a>#### 方法2.非对称加密公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。顾名思义，**私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得**。<br />使用公开密钥加密方式，发送密文的一方使用**对方的公开密钥**进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。<br />![image.png](https://cdn.nlark.com/yuque/0/2020/png/164572/1591153515709-c746c4ae-13cf-4707-9668-34aa0bf433f7.png)<br />非对称加密的特点是信息传输一对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信。<br />这种方式有以下缺点：<ul><li>公钥是公开的，所以针对私钥加密的信息，黑客截获后可以使用公钥进行解密，获取其中的内容；</li><li>公钥并不包含服务器的信息，使用非对称加密算法无法确保服务器身份的合法性，存在中间人攻击的风险，服务器发送给客户端的公钥可能在传送过程中被中间人截获并篡改；</li><li>使用非对称加密<strong>在数据加密解密过程需要消耗一定时间</strong>，降低了数据传输效率；<br><a name="4LNXx"></a></li></ul><h4 id="方法3-对称加密-非对称加密-HTTPS采用这种方式"><a href="#方法3-对称加密-非对称加密-HTTPS采用这种方式" class="headerlink" title="方法3.对称加密+非对称加密(HTTPS采用这种方式)"></a>方法3.对称加密+非对称加密(HTTPS采用这种方式)</h4><p>使用对称密钥的好处是解密的效率比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，因为就算你拦截到了数据，但是没有对应的私钥，也是不能破解内容的。就比如说你抢到了一个保险柜，但是没有保险柜的钥匙也不能打开保险柜。那我们就将对称加密与非对称加密结合起来,充分利用两者各自的优势，<strong>在交换密钥环节使用非对称加密方式，之后的建立通信交换报文阶段则使用对称加密方式</strong>。<br />具体做法是：<strong>发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信</strong>。所以，HTTPS采用对称加密和非对称加密两者并用的混合加密机制。<br><a name="VxtyC"></a></p><h3 id="2、解决报文可能遭篡改问题——数字签名"><a href="#2、解决报文可能遭篡改问题——数字签名" class="headerlink" title="2、解决报文可能遭篡改问题——数字签名"></a>2、解决报文可能遭篡改问题——数字签名</h3><p>网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？—-校验数字签名。<br /><strong>数字签名有两种功效</strong>：</p><ul><li>能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。</li><li>数字签名能确定消息的完整性,证明数据是否未被篡改过。</li></ul><p><strong>数字签名如何生成:</strong><br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1597216899684-3f5d4d8a-20a9-4758-96a4-9fd9216a54ca.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1597216899684-3f5d4d8a-20a9-4758-96a4-9fd9216a54ca.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。<br />假设消息传递在Kobe，James两人之间发生。James将消息连同数字签名一起发送给Kobe，Kobe接收到消息后，通过校验数字签名，就可以验证接收到的消息就是James发送的。当然，这个过程的前提是Kobe知道James的公钥。问题的关键的是，和消息本身一样，公钥不能在不安全的网络中直接发送给Kobe,或者说拿到的公钥如何证明是James的。<br />此时就需要引入了<strong>证书颁发机构</strong>（Certificate Authority，简称CA），CA数量并不多，Kobe客户端内置了所有受信任CA的证书。CA对James的公钥（和其他信息）数字签名后生成证书。<br><a name="XZnPc"></a></p><h3 id="3、解决通信方身份可能被伪装的问题——数字证书"><a href="#3、解决通信方身份可能被伪装的问题——数字证书" class="headerlink" title="3、解决通信方身份可能被伪装的问题——数字证书"></a>3、解决通信方身份可能被伪装的问题——数字证书</h3><p>数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1597216913635-98e02084-b788-4706-ad18-a16808d21158.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1597216913635-98e02084-b788-4706-ad18-a16808d21158.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />我们来介绍一下数字证书认证机构的业务流程：</p><ul><li>服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;</li><li>CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;</li><li>如信息审核通过，CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名;</li><li>客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件;</li><li>客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。</li><li>客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。</li></ul><p><a name="VnaZj"></a></p><h2 id="HTTPS工作流程"><a href="#HTTPS工作流程" class="headerlink" title="HTTPS工作流程"></a>HTTPS工作流程</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1591153548973-72bc5b03-f83e-4856-ae4d-b635d6226251.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1591153548973-72bc5b03-f83e-4856-ae4d-b635d6226251.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>1.Client发起一个HTTPS（比如<code>[https://juejin.im/user/5a9a9cdcf265da238b7d771c](https://juejin.im/user/5a9a9cdcf265da238b7d771c)</code>）的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。<br />2.Server把事先配置好的公钥证书（public key certificate）返回给客户端。<br />3.Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。<br />4.Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。<br />5.Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。<br />6.Server使用对称密钥加密“明文内容A”，发送给Client。<br />7.Client使用对称密钥解密响应的密文，得到“明文内容A”。<br />8.Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。</p><p><a name="uWHqy"></a></p><h2 id="HTTPS-工作原理"><a href="#HTTPS-工作原理" class="headerlink" title="HTTPS 工作原理"></a>HTTPS 工作原理</h2><p>HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS&#x2F;SSL协议不仅仅是一套加密传输的协议，更是一件经过艺术家精心设计的艺术品，TLS&#x2F;SSL中使用了非对称加密，对称加密以及HASH算法。握手过程的简单描述如下：</p><ul><li>浏览器将自己支持的一套加密规则发送给网站。</li><li>网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。</li><li>获得网站证书之后浏览器要做以下工作：<ul><li>a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。</li><li>如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。</li><li>使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。</li></ul></li><li>4.网站接收浏览器发来的数据之后要做以下的操作：<ul><li>a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。</li><li>b) 使用密码加密一段握手消息，发送给浏览器。</li></ul></li><li>5.浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</li></ul><p><a name="cLzva"></a></p><h2 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h2><ul><li>HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1597216926835-99e5026c-69dd-4034-9ab9-17678d8b24b8.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1597216926835-99e5026c-69dd-4034-9ab9-17678d8b24b8.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"><br />关于安全性，用最简单的比喻形容两者的关系就是卡车运货，HTTP下的运货车是敞篷的，货物都是暴露的。而https则是封闭集装箱车，安全性自然提升不少。</p><ul><li>HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页;</li><li>HTTPS需要用到SSL证书，而HTTP不用;</li><li>HTTPS标准端口443，HTTP标准端口80;</li><li>HTTPS基于传输层，HTTP基于应用层;</li><li>HTTPS在浏览器显示绿色安全锁，HTTP没有显示。</li></ul><p><a name="RSZOV"></a></p><h2 id="HTTPS的使用成本"><a href="#HTTPS的使用成本" class="headerlink" title="HTTPS的使用成本"></a>HTTPS的使用成本</h2><p><code>HTTPS</code>是一个大趋势</p><ul><li><strong>证书费用以及更新维护</strong><ul><li>证书现在不贵，也有免费的；</li></ul></li><li><strong>HTTPS降低用户访问速度</strong><ul><li>经过合理的优化（比如<code>SPDY</code>）和部署甚至可以比<code>HTTP1.0</code>快，不过这也是成本之一就是了；</li></ul></li><li><strong>消耗CPU资源，需要增加大量机器</strong><ul><li>需要多次计算</li></ul></li></ul><p><a name="eDb4S"></a></p><h2 id="HTTPS对性能的影响"><a href="#HTTPS对性能的影响" class="headerlink" title="HTTPS对性能的影响"></a>HTTPS对性能的影响</h2><ul><li><strong>协议交互所增加的网络RTP（往返时延）</strong></li><li><strong>加解密相关计算的耗时</strong><br><a name="CyevJ"></a></li></ul><h3 id="网络耗时"><a href="#网络耗时" class="headerlink" title="网络耗时"></a>网络耗时</h3><p><code>HTTP</code>只需要通过<code>TCP</code>的三次握手就能建立<code>HTTP</code>连接：<br />[<img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1588932715395-4e136e9c-a03c-4aad-8973-bdf85ec06d43.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1588932715395-4e136e9c-a03c-4aad-8973-bdf85ec06d43.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />关于<code>302</code>自动跳转，这是因为，比如访问百度，我们输入网址全称而是输入<code>baidu.com</code>，所以会自动跳转至<code>HTTPS</code>，这本身也需要耗时；<br />并且跳转后，<code>URI</code>不一样了，浏览器要与服务器重新通过三次握手建立<code>TCP</code>连接；<br />之后还要进行<code>TLS</code>协商，比如密钥交换算法，对称加密算法，内容一致性校验算法，证书签名算法等等；浏览器获取到证书后，也需要校验证书的有效性，比如证书是否过期，是否撤销等等；<br />接着，浏览器首先获取证书里的<code>CA</code>域名如果该<code>CA</code>域名没有命中缓存，浏览器需要解析域名的<code>DNS</code>，这个<code>DNS</code>解析至少耗费一个<code>RTP</code>；<br /><code>DNS</code>解析到<code>IP</code>之后就要完成三次握手，建立<code>CA</code>站点的<code>TCP</code>连接，这又耗费一个<code>RTP</code>；<br />再接着浏览器发送<code>OCSP</code>请求，获取响应耗费一个<code>RTP</code>；</p><blockquote><p>关于<code>OCSP</code>：在线证书状态协议，它是维护服务器和其他网络资源安全性的两种普遍模式之一，另外一个叫做<code>CRL</code>证书注销列表；当用户试图访问一个服务器的时候，在线证书状态协议发送一个对于证书状态信息的请求，服务器会回复一个有效、过期、未知的响应；协议规定了服务器和客户端应用程序通信的语法；在线证书协议给了用户到期证书一个宽限期，这样用户就可以在更新证书前的一段时间继续访问服务器，所以这里就需要发起一个对于证书状态的请求，也需要消耗一个<code>RTP</code></p></blockquote><p>最后就是<code>TLS</code>完全握手阶段<code>2</code>，这个阶段主要进行密钥协商，耗时一个<code>RTP</code>；随后进行应用层的<code>TCP</code>数据通信。<br><a name="9QRd7"></a></p><h3 id="计算耗时"><a href="#计算耗时" class="headerlink" title="计算耗时"></a>计算耗时</h3><ul><li>浏览器计算耗时；</li><li>服务器计算耗时。</li></ul><p><a name="qwoNX"></a></p><h2 id="HTTPS常见问题"><a href="#HTTPS常见问题" class="headerlink" title="HTTPS常见问题"></a>HTTPS常见问题</h2><ul><li><code>HTTPS</code>需要安装证书；</li><li>大型网站比如百度，从<code>HTTP</code>升级为<code>HTTPS</code>比较困难（不能因为升级而降低用户体验这样就本末倒置了）；</li><li><code>HTTPS</code>并不能解决所有安全问题（比如<code>XSS</code>攻击，木马等），只是能更加安全的传输数据。</li></ul><p><a name="JsaBH"></a></p><h2 id="影响HTTP网络请求的因素"><a href="#影响HTTP网络请求的因素" class="headerlink" title="影响HTTP网络请求的因素"></a>影响HTTP网络请求的因素</h2><ul><li><strong>带宽</strong></li><li><strong>延迟</strong><ul><li>一条连接上只可发送<strong>一个</strong>请求；</li><li>请求只能从<strong>客户端开始</strong>，客户端不可以接收除响应以外的指令；</li><li>请求&#x2F;响应头部<strong>不经压缩</strong>就发送，每次互相发送<strong>相同</strong>的头部造成的浪费很多；</li><li>非强制压缩发送；</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
            <tag> Https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http-proxy 源码解析以及实现</title>
      <link href="/2019/07/08/frontend/browser/http-proxy-yuan-ma-jie-xi-yi-ji-shi-xian/"/>
      <url>/2019/07/08/frontend/browser/http-proxy-yuan-ma-jie-xi-yi-ji-shi-xian/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="08bd9bc4"></a></p><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>这段时间公司进行了前后端的分离，分离开发是如丝般顺滑了，但是却带来一个问题，接口的跨域，会在调试中带来麻烦。<br />现阶段接口跨域的3中方式。<br />1.jsonp<br />2.cors<br />3.代理<br />代理（英语：Proxy）也称网络代理，是一种特殊的网络服务，允许一个网络终端（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击。</p><p><a name="cad80607"></a></p><h2 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h2><p><strong>1.正向代理</strong><br />正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p><p><strong>2.反向代理</strong><br />反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p><p><a name="c74360c9"></a></p><h2 id="图解代理"><a href="#图解代理" class="headerlink" title="图解代理"></a>图解代理</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555714-a0737d00-d3b0-4d93-b556-8b2e940c4fe6.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555714-a0737d00-d3b0-4d93-b556-8b2e940c4fe6.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555777-9e122eae-ed24-4c51-a909-7fe004df403e.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555777-9e122eae-ed24-4c51-a909-7fe004df403e.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端。<br />反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端。<br />如果以上没看明白可以看下面：<br /><strong>正向代理</strong>：我想去买小明水果，但是我自己懒得去买，我通过一个中介的去帮我跑腿买，即是正向代理，小明水果并不需要知道，我来买水果了。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555752-aa6efb9e-965a-4365-9376-ee6a5c82beea.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555752-aa6efb9e-965a-4365-9376-ee6a5c82beea.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>反向代理</strong>：而在反向代理中，我想吃苹果，我还是懒得去买，但是我和中介说，我想吃苹果，我不关心吃什么苹果，你只要给我拿到一个苹果。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555614-5fb627f6-c290-4545-a98f-55fc26645404.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555614-5fb627f6-c290-4545-a98f-55fc26645404.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="dae4f3ea"></a></p><h2 id="项目中的代理"><a href="#项目中的代理" class="headerlink" title="项目中的代理"></a>项目中的代理</h2><p><a name="h9yEh"></a></p><h4 id="http-proxy-middleware"><a href="#http-proxy-middleware" class="headerlink" title="http-proxy-middleware"></a>http-proxy-middleware</h4><p>这个插件正是我们公司在项目中用到的代理插件，他支持connect, express and browser-sync，应该来说非常方便，下面是他的使用方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>, <span class="title function_">proxy</span>(&#123;<span class="attr">target</span>: <span class="string">&#x27;http://www.example.org&#x27;</span>, <span class="attr">changeOrigin</span>: <span class="literal">true</span>&#125;));</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>查看他的部分源码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> httpProxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> configFactory = <span class="built_in">require</span>(<span class="string">&#x27;./config-factory&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> handlers = <span class="built_in">require</span>(<span class="string">&#x27;./handlers&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> contextMatcher = <span class="built_in">require</span>(<span class="string">&#x27;./context-matcher&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">PathRewriter</span> = <span class="built_in">require</span>(<span class="string">&#x27;./path-rewriter&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;./router&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> logger = <span class="built_in">require</span>(<span class="string">&#x27;./logger&#x27;</span>).<span class="title function_">getInstance</span>()</span><br><span class="line"><span class="keyword">var</span> getArrow = <span class="built_in">require</span>(<span class="string">&#x27;./logger&#x27;</span>).<span class="property">getArrow</span></span><br><span class="line">...省略</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">HttpProxyMiddleware</span></span><br></pre></td></tr></table></figure><p>通过看到他的代码得知他用到了http-proxy这个库。</p><p><a name="S106F"></a></p><h4 id="http-proxy"><a href="#http-proxy" class="headerlink" title="http-proxy"></a>http-proxy</h4><p>那我们就来看http-proxy</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>),</span><br><span class="line">    httpProxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Create a proxy server with custom application logic</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> proxy = httpProxy.<span class="title function_">createProxyServer</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Create your custom server and just call `proxy.web()` to proxy</span></span><br><span class="line"><span class="comment">// a web request to the target passed in the options</span></span><br><span class="line"><span class="comment">// also you can use `proxy.ws()` to proxy a websockets request</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="comment">// You can define here your custom logic to handle the request</span></span><br><span class="line">  <span class="comment">// and then proxy the request.</span></span><br><span class="line">  proxy.<span class="title function_">web</span>(req, res, &#123; <span class="attr">target</span>: <span class="string">&#x27;http://127.0.0.1:5060&#x27;</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;listening on port 5050&quot;</span>)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">5050</span>);</span><br></pre></td></tr></table></figure><p>目录结构<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589184406366-528ed49a-6443-4115-939f-9f256d94ac77.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589184406366-528ed49a-6443-4115-939f-9f256d94ac77.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif" alt="image.png"></p><p>http-proxy.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">ProxyServer</span> = <span class="built_in">require</span>(<span class="string">&#x27;./http-proxy/index.js&#x27;</span>).<span class="property">Server</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createProxyServer</span>(<span class="params">options</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProxyServer</span>(options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">ProxyServer</span>.<span class="property">createProxyServer</span> = createProxyServer;</span><br><span class="line"><span class="title class_">ProxyServer</span>.<span class="property">createServer</span>      = createProxyServer;</span><br><span class="line"><span class="title class_">ProxyServer</span>.<span class="property">createProxy</span>       = createProxyServer;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">ProxyServer</span>;</span><br></pre></td></tr></table></figure><p>.&#x2F;http-proxy&#x2F;index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> httpProxy = <span class="variable language_">module</span>.<span class="property">exports</span>,</span><br><span class="line">    extend    = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>).<span class="property">_extend</span>,</span><br><span class="line">    parse_url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>).<span class="property">parse</span>,</span><br><span class="line">    <span class="title class_">EE3</span>       = <span class="built_in">require</span>(<span class="string">&#x27;eventemitter3&#x27;</span>),</span><br><span class="line">    http      = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>),</span><br><span class="line">    https     = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>),</span><br><span class="line">    web       = <span class="built_in">require</span>(<span class="string">&#x27;./passes/web-incoming&#x27;</span>),</span><br><span class="line">    ws        = <span class="built_in">require</span>(<span class="string">&#x27;./passes/ws-incoming&#x27;</span>);</span><br><span class="line"></span><br><span class="line">httpProxy.<span class="property">Server</span> = <span class="title class_">ProxyServer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createRightProxy</span>(<span class="params">type</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">req, res <span class="comment">/*, [head], [opts] */</span></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> passes = (type === <span class="string">&#x27;ws&#x27;</span>) ? <span class="variable language_">this</span>.<span class="property">wsPasses</span> : <span class="variable language_">this</span>.<span class="property">webPasses</span>,</span><br><span class="line">          args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>),</span><br><span class="line">          cntr = args.<span class="property">length</span> - <span class="number">1</span>,</span><br><span class="line">          head, cbl;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* optional args parse begin */</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> args[cntr] === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        cbl = args[cntr];</span><br><span class="line"></span><br><span class="line">        cntr--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> requestOptions = options;</span><br><span class="line">      <span class="keyword">if</span>(</span><br><span class="line">        !(args[cntr] <span class="keyword">instanceof</span> <span class="title class_">Buffer</span>) &amp;&amp;</span><br><span class="line">        args[cntr] !== res</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">//Copy global options</span></span><br><span class="line">        requestOptions = <span class="title function_">extend</span>(&#123;&#125;, options);</span><br><span class="line">        <span class="comment">//Overwrite with request options</span></span><br><span class="line">        <span class="title function_">extend</span>(requestOptions, args[cntr]);</span><br><span class="line"></span><br><span class="line">        cntr--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(args[cntr] <span class="keyword">instanceof</span> <span class="title class_">Buffer</span>) &#123;</span><br><span class="line">        head = args[cntr];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      [<span class="string">&#x27;target&#x27;</span>, <span class="string">&#x27;forward&#x27;</span>].<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> requestOptions[e] === <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">          requestOptions[e] = <span class="title function_">parse_url</span>(requestOptions[e]);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!requestOptions.<span class="property">target</span> &amp;&amp; !requestOptions.<span class="property">forward</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">emit</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Must provide a proper URL as target&#x27;</span>));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; passes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(passes[i](req, res, requestOptions, head, <span class="variable language_">this</span>, cbl)) &#123; <span class="comment">// passes can return a truthy value to halt the loop</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">httpProxy.<span class="property">createRightProxy</span> = createRightProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ProxyServer</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="title class_">EE3</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">  options = options || &#123;&#125;;</span><br><span class="line">  options.<span class="property">prependPath</span> = options.<span class="property">prependPath</span> === <span class="literal">false</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">web</span> = <span class="variable language_">this</span>.<span class="property">proxyRequest</span>           = <span class="title function_">createRightProxy</span>(<span class="string">&#x27;web&#x27;</span>)(options);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">ws</span>  = <span class="variable language_">this</span>.<span class="property">proxyWebsocketRequest</span>  = <span class="title function_">createRightProxy</span>(<span class="string">&#x27;ws&#x27;</span>)(options);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">options</span> = options;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">webPasses</span> = <span class="title class_">Object</span>.<span class="title function_">keys</span>(web).<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">pass</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> web[pass];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">wsPasses</span> = <span class="title class_">Object</span>.<span class="title function_">keys</span>(ws).<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">pass</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ws[pass];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="variable language_">this</span>.<span class="property">onError</span>, <span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>).<span class="title function_">inherits</span>(<span class="title class_">ProxyServer</span>, <span class="title class_">EE3</span>);</span><br></pre></td></tr></table></figure><p>结构</p><p><code>ProxyServer.createServer</code> 创建使用<br /><code>ProxyServer.createServer</code>  等价 <code>createProxyServer</code> <br /><code>createProxyServer</code>  返回一个 <code>ProxyServer</code> 实例</p><p>ProxyServer<br /><code>ProxyServer</code>  拥有web属性<br />web属性 <code>createRightProxy</code> 支持 <code>http</code> ， <code>https</code> ， <code>webscoket</code> <br />轮询方法 <code>deleteLength</code> ， 设置 <code>content-length</code> <code>timeout</code> <code>XHeaders</code> <code>stream</code>   核心方法<br />处理 <code>http.request</code>   核心模块 <code>pipe</code>  <code>response</code></p><p>下面列出来他的核心方法。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555827-8d83ed48-4e64-4925-bbbe-fb9f9630a45e.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555827-8d83ed48-4e64-4925-bbbe-fb9f9630a45e.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><a name="732dc02e"></a></p><h2 id="带你动手撸一个"><a href="#带你动手撸一个" class="headerlink" title="带你动手撸一个"></a>带你动手撸一个</h2><p>以下是我们代理的主要流程思路。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555669-7961c2a1-810e-44d6-a031-f517091f264e.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2020/png/164572/1589178555669-7961c2a1-810e-44d6-a031-f517091f264e.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p>api.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">request, response</span>) &#123;</span><br><span class="line">    response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    response.<span class="title function_">write</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">huayifeng</span>: <span class="number">1</span>&#125;));</span><br><span class="line">    response.<span class="title function_">end</span>();</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">8081</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>);</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="title function_">proxy</span>(req, res);</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">8080</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">proxy</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> options = &#123;</span><br><span class="line">        <span class="attr">hostname</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8081</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> proxyReq = http.<span class="title function_">request</span>(options);  </span><br><span class="line"></span><br><span class="line">    proxyReq.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;problem with request: &#x27;</span> + e.<span class="property">message</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">     </span><br><span class="line">    proxyReq.<span class="title function_">on</span>(<span class="string">&#x27;response&#x27;</span>, <span class="keyword">function</span>(<span class="params">proxyRes</span>) &#123;</span><br><span class="line">        proxyRes.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        proxyRes.<span class="title function_">pipe</span>(res);</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    proxyReq.<span class="title function_">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就简易实现了一个代理。当你访问localhost:8080 请求已经被代理到localhost:8081了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图标库</title>
      <link href="/2019/05/16/frontend/collection/tu-biao-ku/"/>
      <url>/2019/05/16/frontend/collection/tu-biao-ku/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="uVpIM"></a></p><h1 id="1-IconPark"><a href="#1-IconPark" class="headerlink" title="1. IconPark"></a>1. IconPark</h1><p>IconPark 提供超过 2400 个高质量图标，还提供了每个图标的含义和来源的描述，便于开发者使用。除此之外，该网站还可以自定义图标，这是与其他图标网站与众不同的地方。该图标库是字节跳动旗下的技术驱动图标样式的开源图标库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654763709432-d1005f7c-1be9-468e-a1bd-7c889613ce25.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654763709432-d1005f7c-1be9-468e-a1bd-7c889613ce25.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/bytedance/iconpark">https://github.com/bytedance/iconpark</a><br><a name="utSN0"></a></p><h1 id="2-Font-Awesome"><a href="#2-Font-Awesome" class="headerlink" title="2. Font Awesome"></a><br />2. Font Awesome</h1><p>Font Awesome 提供了可缩放的矢量图标，可以使用CSS所提供的所有特性对它们进行更改，包括：大小、颜色、阴影或者其它任何支持的效果。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654763943916-4c569392-0c51-4dd5-a9cb-6900270b200d.png?x-oss-process=image/resize,w_838,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654763943916-4c569392-0c51-4dd5-a9cb-6900270b200d.png?x-oss-process=image/resize,w_838,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p><p><strong>Github：</strong><a href="https://github.com/FortAwesome/Font-Awesome">https://github.com/FortAwesome/Font-Awesome</a><br><a name="qcmQV"></a></p><h1 id="3-Ionicons"><a href="#3-Ionicons" class="headerlink" title="3. Ionicons"></a><br />3. Ionicons</h1><p>Ionicons 是一个完全开源的图标集，是知名混合开发框架 Ionic Framework 内置的图标库，包含 1300 个设计优雅、风格统一的高质量图标，能满足大多数的业务场景。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654764121675-69522b19-59b6-4601-af04-26d20ea77eb9.png?x-oss-process=image/resize,w_792,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654764121675-69522b19-59b6-4601-af04-26d20ea77eb9.png?x-oss-process=image/resize,w_792,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="F78kv"></a></p><h1 id="4-Bootstrap-Icons"><a href="#4-Bootstrap-Icons" class="headerlink" title="4. Bootstrap Icons"></a><br />4. Bootstrap Icons</h1><p>Bootstrap Icons 是 Bootstrap 开源的 SVG 图标库，此图标库起初专门针对其组件（从表单控件到导航）和文档进行定制设计和构建，现在可以免费用于任何项目。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654764209164-bcbf319e-661e-4e3d-8099-760a316d24f6.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654764209164-bcbf319e-661e-4e3d-8099-760a316d24f6.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="EN0eS"></a></p><h1 id="5-Unicons"><a href="#5-Unicons" class="headerlink" title="5. Unicons"></a><br />5. Unicons</h1><p>Unicons 是一套收录超过 4500 种图标的图标库，提供 SVG 矢量和图标字型（Iconfont）格式，使用者可以自订每个图标大小、颜色和颜色。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654764499021-c3ec0e41-cb80-4383-bad2-7cc2198a1e54.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654764499021-c3ec0e41-cb80-4383-bad2-7cc2198a1e54.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="nXUx0"></a></p><h1 id="6-Tabler-Icons"><a href="#6-Tabler-Icons" class="headerlink" title="6. Tabler Icons"></a><br />6. Tabler Icons</h1><p>Tabler Icons 是一组超过 1950 个免费的高质量 SVG 图标，可以在 Web 项目中用。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654765090572-586b5285-63e4-4976-9b76-5ce960ac159d.png?x-oss-process=image/resize,w_860,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1654765090572-586b5285-63e4-4976-9b76-5ce960ac159d.png?x-oss-process=image/resize,w_860,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> 图标 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动画库</title>
      <link href="/2019/03/01/frontend/collection/dong-hua-ku/"/>
      <url>/2019/03/01/frontend/collection/dong-hua-ku/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>很多时候我们在开发前端页面时都会做一些动画效果来提升用户体验度和页面美观度，所以今天就来给大家推荐几个好用的JavaScript动画库，希望对各位小伙伴有所帮助！</p><p><a name="Z7TS0"></a></p><h1 id="Animate-css"><a href="#Animate-css" class="headerlink" title="Animate.css"></a>Animate.css</h1><p>animate.css 是一个使用CSS3的animation制作的动画效果的CSS集合，里面预设了很多种常用的动画，且使用非常简单。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643079212742-891d0237-e517-421b-9a94-444861644415.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643079212742-891d0237-e517-421b-9a94-444861644415.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="aYbml"></a></p><h1 id="Hover-css"><a href="#Hover-css" class="headerlink" title="Hover.css"></a><br />Hover.css</h1><p>Hover.css 是一套基于 CSS3 的鼠标悬停效果和动画，这些可以非常轻松的被应用到按钮、LOGO 以及图片等元素。所有这些效果都是只需要单一的标签，必要的时候使用 before 和 after 伪元素。因为使用了 CSS3 过渡、转换和动画效果，因此只支持 Chrome、Firefox 和 Safari 等现代浏览器。 <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643885334717-b36150c7-6d61-4b57-b90f-38a7bce71cc7.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643885334717-b36150c7-6d61-4b57-b90f-38a7bce71cc7.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="bFOsx"></a></p><h1 id="Magic-css"><a href="#Magic-css" class="headerlink" title="Magic.css"></a><br />Magic.css</h1><p>Magic CSS3 Animations 动画是一款独特的CSS3动画特效包，可以自由地使用在网页中。只需简单的在页面上引入 CSS 文件: magic.css 或者压缩版本 magic.min.css 就可以使用了。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643885435396-2b5df028-041d-49b2-b136-de4214626b75.png?x-oss-process=image/resize,w_957,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643885435396-2b5df028-041d-49b2-b136-de4214626b75.png?x-oss-process=image/resize,w_957,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="wGOZ6"></a></p><h1 id="React-Spring"><a href="#React-Spring" class="headerlink" title="React Spring"></a><br />React Spring</h1><p>react-spring 是一个基于弹簧物理学的动画库，满足大多数与UI相关的动画需求，提供了足够灵活的工具，可以自信地将想法投射到不断变化的界面中。该库代表了一种现代动画方法。它继承了 animated 强大的插值和性能，以及 react-motion 的易用性。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643878102964-52cd623b-075c-4c0a-8eea-08e53a5b6922.png?x-oss-process=image/resize,w_957,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643878102964-52cd623b-075c-4c0a-8eea-08e53a5b6922.png?x-oss-process=image/resize,w_957,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="AxzNH"></a></p><h1 id="React-Reveal"><a href="#React-Reveal" class="headerlink" title="React Reveal"></a><br />React Reveal</h1><p>React Reveal 是一个用于 React 的高性能动画库。它占用空间小，专门为 ES6 中的 React 编写。可用于创建各种炫酷的滚动效果显示。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643878159451-b74c722e-4448-4035-8248-b15890802718.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643878159451-b74c722e-4448-4035-8248-b15890802718.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="UAcIs"></a></p><h1 id="Greensock"><a href="#Greensock" class="headerlink" title="Greensock"></a><br />Greensock</h1><p>GreenSock是一个JavaScript动画库，可轻松对HTML元素进行动画处理。 用于创建高性能，零依赖性，跨浏览器动画，声称在超过 400 万个网站中使用。 其具有一下特点：<br />●速度快，专门优化了动画性能，使之实现和css一样的高性能动画效果。<br />●轻量与模块化。模块化与插件式的结构保持了核心引擎的轻量，TweenLite包非常小(基本上低于7kb)。提供了TweenLite, TimelineLite, TimelineMax 和 TweenMax不同功能的动画模块，你可以按需使用。<br />●没有依赖。<br />●灵活控制。不用受限于线性序列，可以重叠动画序列，可以通过精确时间控制，灵活地使用最少的代码实现动画。<br />●任何对象都可以实现动画。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643878632425-50cff842-d447-4a33-8aa8-123d55826940.png?x-oss-process=image/resize,w_795,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643878632425-50cff842-d447-4a33-8aa8-123d55826940.png?x-oss-process=image/resize,w_795,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="EMS0s"></a></p><h1 id="Velocity-js"><a href="#Velocity-js" class="headerlink" title="Velocity.js"></a><br />Velocity.js</h1><p>Velocity.js 是velocity模板语法的javascript实现。Velocity 是基于Java的模板引擎，广泛应用在阿里集 体各个子公司。Velocity模板适用于大量模板使用的场景，支持复杂的逻辑运算，包含 本数据类型、变量赋值和函数等功能。还拥有：<strong>颜色动画</strong>、<strong>转换动画(transforms)<strong>、</strong>循环</strong>、 <strong>缓动</strong>、<strong>SVG 动画</strong>、和 <strong>滚动动画</strong> 等特色功能。Velocity.js 支持 Node.js 和浏览器环境。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643878973365-30359de7-cb34-46ca-a66d-ceb270bcadfc.png?x-oss-process=image/resize,w_794,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643878973365-30359de7-cb34-46ca-a66d-ceb270bcadfc.png?x-oss-process=image/resize,w_794,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br />其具有以下特点：<br />●支持客户端和服务器端使用<br />●语法是富逻辑的，构成门微型的语言<br />●语法分析和模板渲染分离<br />●基本完全支持velocity语法<br />●浏览器使用支持模板之间相互引用，依据kissy模块加载机制</p><p>GitHub：<a href="http://github.com/julianshapiro/velocity">http://github.com/julianshapiro/velocity</a><br><a name="OkC3t"></a></p><h1 id="Lax-js"><a href="#Lax-js" class="headerlink" title="Lax.js"></a><br />Lax.js</h1><p>Lax.js 是一款原生零依赖的制作跟随页面滑动的 JavaScript 动画插件，这款插件非常的轻巧，压缩版大小只有3kb。当滑动页面时，帮助创建酷炫的动画效果，比如滚动视差、变形移动等基本的动画效果，响应式兼容方面，比如手机端也有不错的支持。除了可以使用插件默认集成的动画属性，还可以自定义更加丰富的动画属性。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1643884980168-b3a8b0a1-c68e-4baa-a312-a0b38980223e.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1643884980168-b3a8b0a1-c68e-4baa-a312-a0b38980223e.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="E1iPL"></a></p><h1 id="Rellax-js"><a href="#Rellax-js" class="headerlink" title="Rellax.js"></a><br />Rellax.js</h1><p>rellax.js是一款轻量级的纯JavaScript滚动视觉差特效插件。rellax.js压缩后的版本仅871字节，在手机等小屏幕设备中，插件会自动限制视觉差特性。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643880381677-c0de007d-aa39-4a29-af21-bebebb8c939d.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643880381677-c0de007d-aa39-4a29-af21-bebebb8c939d.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="aRJcU"></a></p><h1 id="three-js"><a href="#three-js" class="headerlink" title="three.js"></a><br />three.js</h1><p>three.js 是一个易于使用、轻量级、跨浏览器的通用 JavaScript 3D 库，它是一套基于WebGL 开发出的Javascript 函式库，它提供了比 WebGL 更简单的Javascript API，让开发者能够轻易在浏览器制作 3D 绘图。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643880619524-2e2a1392-ada9-442e-a8bd-ae70c922a005.png?x-oss-process=image/resize,w_957,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643880619524-2e2a1392-ada9-442e-a8bd-ae70c922a005.png?x-oss-process=image/resize,w_957,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="qdhLI"></a></p><h1 id="wow-js"><a href="#wow-js" class="headerlink" title="wow.js"></a><br />wow.js</h1><p>WOW.js 是一款帮助你实现滚动页面时触发CSS 动画效果的插件。它依赖 animate.css，所以它支持 animate.css 多达 60 多种的动画效果，可以改变动画设置喜欢的风格、延迟、长度、偏移和迭代等，能满足各种需求。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643881012619-0815f141-f9ef-4d9e-bdb1-4f42e96a85bc.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643881012619-0815f141-f9ef-4d9e-bdb1-4f42e96a85bc.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="o61TN"></a></p><h1 id="AniJS"><a href="#AniJS" class="headerlink" title="AniJS"></a><br />AniJS</h1><p>AniJS允许我们为网站创建动画样式，而无需任何JavaScript或CSS编码！ 您可以使用简单的<strong>If</strong> - <strong>On</strong> - <strong>Do</strong> - <strong>To</strong>语法用HTML指定所有动画<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643881180295-960b17ec-1a1e-41ec-880b-223d8173a45d.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643881180295-960b17ec-1a1e-41ec-880b-223d8173a45d.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="is0DJ"></a></p><h1 id="Anime-js"><a href="#Anime-js" class="headerlink" title="Anime.js"></a><br />Anime.js</h1><p>Anime.js 是一个轻量的JavaScript 动画库， 拥有简单而强大的API。可对 CSS 属性、 SVG、 DOM 和JavaScript 对象进行动画。它很轻便，gzip压缩完只有9kb左右。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643881400291-d7ddd8b0-062d-4ede-8a58-48d1148fc89b.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643881400291-d7ddd8b0-062d-4ede-8a58-48d1148fc89b.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="uxMR2"></a></p><h1 id="Typed-js"><a href="#Typed-js" class="headerlink" title="Typed.js"></a><br />Typed.js</h1><p>typed.js是一个类型化库，效果是用打字机的方式显示一段话，可以自定义任何字符串、指定显示速度、指定是否循环等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1643881755659-578bbdfb-421c-469a-8e9a-b14afdaf932b.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1643881755659-578bbdfb-421c-469a-8e9a-b14afdaf932b.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="RtNic"></a></p><h1 id="Vivus"><a href="#Vivus" class="headerlink" title="Vivus"></a><br />Vivus</h1><p>Vivus 是一个轻量级的 JavaScript 库（没有依赖项），它允许我们对 SVG 进行动画处理，使它们看起来像是被绘制的。它有多种不同的动画可用，以及创建自定义脚本的选项，以喜欢的任何方式绘制 SVG。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643881836944-f040f549-034b-4f94-a8ae-f20b9fd9b6d7.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643881836944-f040f549-034b-4f94-a8ae-f20b9fd9b6d7.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="pEZse"></a></p><h1 id="Popmotion"><a href="#Popmotion" class="headerlink" title="Popmotion"></a><br />Popmotion</h1><p>Popmotion 是一个只有12KB的 JavaScript 运动引擎，可以用来实现动画，物理效果和输入跟踪。原生的DOM支持：CSS，SVG，SVG路径和DOM属性的支持，开箱即用。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643881986801-afdd8037-d86f-444f-9419-0a0d24f8e864.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643881986801-afdd8037-d86f-444f-9419-0a0d24f8e864.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="un8xH"></a></p><h1 id="Granim-js"><a href="#Granim-js" class="headerlink" title="Granim.js"></a><br />Granim.js</h1><p>granim.js是一个在网页中创建流畅的交互式流体动画的小型JavaScript库，granim.js可以实现各种想要的渐变的动画效果，使网页色彩更加丰富，视觉效果更佳！<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643882236367-0849eaa1-13f6-48fe-b24e-dae0899e1e29.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643882236367-0849eaa1-13f6-48fe-b24e-dae0899e1e29.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="Klkao"></a></p><h1 id="Kute-js"><a href="#Kute-js" class="headerlink" title="Kute.js"></a><br />Kute.js</h1><p>Kute.js 是一个原生的 Javascript 动画引擎，具有优秀的性能和模块化的代码。 它提供了一大堆工具，以帮助创建自定义动画。它提供了易于使用的方法来设置高性能、跨浏览器的动画。 <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643882340536-aef0dbd9-af05-4f6f-af2b-4ef464551781.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643882340536-aef0dbd9-af05-4f6f-af2b-4ef464551781.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="vXxCT"></a></p><h1 id="Simple-Parallax"><a href="#Simple-Parallax" class="headerlink" title="Simple Parallax"></a><br />Simple Parallax</h1><p>simpleParallax.js 是一个非常简单且小巧的 Vanilla JS 库，可在任何图像上添加视差动画。它因其易用性和可视化渲染而脱颖而出。视差效果直接应用于图像标签，无需使用背景图像。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643882513364-7682c188-5167-4992-a0a8-f5db2754b31c.png?x-oss-process=image/resize,w_959,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643882513364-7682c188-5167-4992-a0a8-f5db2754b31c.png?x-oss-process=image/resize,w_959,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="PWsjk"></a></p><h1 id="Barba-js"><a href="#Barba-js" class="headerlink" title="Barba.js"></a><br />Barba.js</h1><p>Barba.js是一个小（4kb的压缩和压缩），灵活和无依赖的库，可以帮助您创建流畅和平滑的过渡网站的页面。 它可以减少页面之间的延迟，最大限度地减少浏览器HTTP请求并增强用户的Web体验。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643882962879-d2852eea-27fe-4b78-a603-7d8e90eb01cd.png?x-oss-process=image/resize,w_956,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643882962879-d2852eea-27fe-4b78-a603-7d8e90eb01cd.png?x-oss-process=image/resize,w_956,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="ef9oD"></a></p><h1 id="mo-js"><a href="#mo-js" class="headerlink" title="mo.js"></a><br />mo.js</h1><p>Mo.js是一个简洁、高效的图形动画库，拥有流畅的动画和惊人的用户体验，在任何设备上，屏幕密度独立的效果都很好，可以绘制内置的形状或者自定义形状，还可以绘制多个动画，再让它们串联在一起。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1643883159339-05c308ba-8dd2-434e-ba44-eb140943be36.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1643883159339-05c308ba-8dd2-434e-ba44-eb140943be36.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="h7kd5"></a></p><h1 id="Particles-js"><a href="#Particles-js" class="headerlink" title="Particles.js"></a><br />Particles.js</h1><p>Particles.js 一个轻量级的JavaScript库，用来在网页上创建颗粒效果。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643883928603-4d5f3db8-5cb3-427f-8886-0b8489dca50c.png?x-oss-process=image/resize,w_750,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643883928603-4d5f3db8-5cb3-427f-8886-0b8489dca50c.png?x-oss-process=image/resize,w_750,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="ifwc5"></a></p><h1 id="tsParticles"><a href="#tsParticles" class="headerlink" title="tsParticles"></a><br />tsParticles</h1><p>tsParticles可以轻松创建高度可定制的粒子动画并将它们用作网站的动画背景。可用于 React.js、Vue.js（2.x 和 3.x）、Angular、Svelte、jQuery、Preact、Inferno、Solid、Riot 和 Web 组件的现成可用组件。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643884168246-4419bbf9-0987-4791-8112-6ea30149d884.png?x-oss-process=image/resize,w_958,limit_0" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643884168246-4419bbf9-0987-4791-8112-6ea30149d884.png?x-oss-process=image/resize,w_958,limit_0" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="NFmxd"></a></p><h1 id="Rough-Notation"><a href="#Rough-Notation" class="headerlink" title="Rough Notation"></a><br />Rough Notation</h1><p>Rough Notation是一个小型 JavaScript 库，用于在网页上创建和动画注释。它使用RoughJS 创建手绘的外观和感觉。元素可以用多种不同的样式进行注释。动画持续时间可以配置，或者只是关闭。压缩后的大小仅 3.83kb。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643884317111-7c264d54-b4d2-42a3-aeb4-7f62dd42cd78.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1643884317111-7c264d54-b4d2-42a3-aeb4-7f62dd42cd78.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="d7wV6"></a></p><h1 id="Animate-on-Scroll"><a href="#Animate-on-Scroll" class="headerlink" title="Animate on Scroll"></a><br />Animate on Scroll</h1><p>Animate on Scroll是一个在页面时创建动画的JavaScript动画库。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1643884596967-b53dc332-fab0-4580-82d6-fae24ddec22d.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1643884596967-b53dc332-fab0-4580-82d6-fae24ddec22d.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="bGCX6"></a></p><h1 id="Framer-Motion"><a href="#Framer-Motion" class="headerlink" title="Framer Motion"></a><br />Framer Motion</h1><p>Motion 是Framer的 React 的生产就绪运动库。它带来了声明性动画、轻松的布局转换和手势，同时保持了 HTML 和 SVG 语义。Motion 使用强大的手势识别器扩展了 React 的事件系统。它支持悬停、点击、平移和拖动。注意，Motion 需要 React 16.8 或更高版本。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1500604/1644295728196-2fb91e5e-841c-4a12-a408-4a157e21ecef.png" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/png/1500604/1644295728196-2fb91e5e-841c-4a12-a408-4a157e21ecef.png" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"><br><a name="ROnvv"></a></p><h1 id="React-Motion"><a href="#React-Motion" class="headerlink" title="React Motion"></a><br />React Motion</h1><p>React Motion 是一个用于 React 应用程序的动画库，可以轻松创建和实现逼真的动画。<br /><img src="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1644296500821-54b8f275-632d-48b4-af76-957aa1c92e88.gif" class="lazyload placeholder" data-srcset="https://cdn.nlark.com/yuque/0/2022/gif/1500604/1644296500821-54b8f275-632d-48b4-af76-957aa1c92e88.gif" srcset="https://maiwoqiche-1251117131.cos.ap-shanghai.myqcloud.com/internationalStation/loading.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 收藏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6新特性</title>
      <link href="/2019/02/24/frontend/interview/es6-xin-te-xing/"/>
      <url>/2019/02/24/frontend/interview/es6-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="Wx6je"></a></p><h1 id="展开运算符和剩余运算符"><a href="#展开运算符和剩余运算符" class="headerlink" title="展开运算符和剩余运算符"></a>展开运算符和剩余运算符</h1><p><a name="LahyN"></a></p><h2 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h2><p>**展开语法,**可以在函数调用&#x2F;数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。(字面量一般指 [1, 2, 3] 或者 {name: “mdn”} 这种简洁的构造方式)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(...numbers));<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum.<span class="title function_">apply</span>(<span class="literal">null</span>, numbers));<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="ghlNZ"></a></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><a name="QGAKj"></a></p><h3 id="等价于apply的方式"><a href="#等价于apply的方式" class="headerlink" title="等价于apply的方式"></a>等价于apply的方式</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">x, y, z</span>) &#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">myFunction.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">x, y, z</span>) &#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="title function_">myFunction</span>(...args);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">v, w, x, y, z</span>) &#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"><span class="title function_">myFunction</span>(-<span class="number">1</span>, ...args, <span class="number">2</span>, ...[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p><a name="UubqH"></a></p><h3 id="数组拷贝-copy）浅拷贝"><a href="#数组拷贝-copy）浅拷贝" class="headerlink" title="数组拷贝(copy）浅拷贝"></a>数组拷贝(copy）浅拷贝</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr]; <span class="comment">// like arr.slice()</span></span><br><span class="line">arr2.<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr2 此时变成 [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// arr 不受影响</span></span><br></pre></td></tr></table></figure><p><a name="jHKuE"></a></p><h3 id="连接多个数组"><a href="#连接多个数组" class="headerlink" title="连接多个数组"></a>连接多个数组</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 将 arr2 中所有元素附加到 arr1 后面并返回</span></span><br><span class="line"><span class="keyword">var</span> arr3 = arr1.<span class="title function_">concat</span>(arr2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [...arr1, ...arr2];</span><br></pre></td></tr></table></figure><p><a name="kMGW4"></a></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p><a name="NdZfB"></a></p><h3 id="操作对象"><a href="#操作对象" class="headerlink" title="操作对象"></a>操作对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;<span class="attr">id</span>:<span class="string">&#x27;1&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;...obj&#125; <span class="comment">//&#123;id: &#x27;1&#x27;, name: &#x27;张三&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2=&#123;<span class="attr">type</span>:<span class="string">&#x27;annimal&#x27;</span>,<span class="attr">lang</span>:<span class="string">&#x27;js&#x27;</span>, <span class="attr">sex</span>:<span class="string">&#x27;man&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj,&#123;...obj2&#125; </span><br><span class="line"><span class="comment">//&#123;id: &#x27;1&#x27;, name: &#x27;张三&#x27;, type: &#x27;annimal&#x27;, lang: &#x27;js&#x27;, sex:&#x27;man&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p><a name="ajqzu"></a></p><h2 id="剩余操作符"><a href="#剩余操作符" class="headerlink" title="剩余操作符"></a>剩余操作符</h2><p><strong>剩余参数</strong>语法允许我们将一个不定数量的参数表示为<strong>一个数组。</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params">...theArgs</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(theArgs.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fun1</span>();  <span class="comment">// 弹出 &quot;0&quot;, 因为theArgs没有元素</span></span><br><span class="line"><span class="title function_">fun1</span>(<span class="number">5</span>); <span class="comment">// 弹出 &quot;1&quot;, 因为theArgs只有一个元素</span></span><br><span class="line"><span class="title function_">fun1</span>(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>); <span class="comment">// 弹出 &quot;3&quot;, 因为theArgs有三个元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a,b,...arr</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);<span class="comment">//[ 3, 4 ]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="yJxLj"></a></p><h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>解构赋值是对赋值运算符的扩展。<br />他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。<br />在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。</p><p><a name="mfqd0"></a></p><h2 id="数组模型的解构"><a href="#数组模型的解构" class="headerlink" title="数组模型的解构"></a>数组模型的解构</h2><p><a name="YzvVM"></a></p><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br></pre></td></tr></table></figure><p><a name="XTzbx"></a></p><h3 id="可嵌套"><a href="#可嵌套" class="headerlink" title="可嵌套"></a>可嵌套</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// c = 3</span></span><br></pre></td></tr></table></figure><p><a name="ggpaM"></a></p><h3 id="可忽略"><a href="#可忽略" class="headerlink" title="可忽略"></a>可忽略</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, , b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 3</span></span><br></pre></td></tr></table></figure><p><a name="ENMyt"></a></p><h3 id="不完全解构"><a href="#不完全解构" class="headerlink" title="不完全解构"></a>不完全解构</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b] = []; <span class="comment">// a = 1, b = undefined</span></span><br></pre></td></tr></table></figure><p><a name="aOlg8"></a></p><h3 id="剩余运算符"><a href="#剩余运算符" class="headerlink" title="剩余运算符"></a>剩余运算符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">//a = 1</span></span><br><span class="line"><span class="comment">//b = [2, 3]</span></span><br></pre></td></tr></table></figure><p><a name="MwtAH"></a></p><h3 id="字符串等"><a href="#字符串等" class="headerlink" title="字符串等"></a>字符串等</h3><p>在数组的解构中，解构的目标若为可遍历对象，皆可进行解构赋值。可遍历对象即实现 Iterator 接口的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="comment">// a = &#x27;h&#x27;</span></span><br><span class="line"><span class="comment">// b = &#x27;e&#x27;</span></span><br><span class="line"><span class="comment">// c = &#x27;l&#x27;</span></span><br><span class="line"><span class="comment">// d = &#x27;l&#x27;</span></span><br><span class="line"><span class="comment">// e = &#x27;o&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="yaEro"></a></p><h3 id="解构默认值"><a href="#解构默认值" class="headerlink" title="解构默认值"></a>解构默认值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a = <span class="number">2</span>] = [<span class="literal">undefined</span>]; <span class="comment">// a = 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当解构模式有匹配结果，且匹配结果是 undefined 时，会触发默认值作为返回结果。</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [];     <span class="comment">// a = 3, b = 3</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>];    <span class="comment">// a = 1, b = 1</span></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">3</span>, b = a] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// a = 1, b = 2</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">a 与 b 匹配结果为 undefined ，触发默认值：a = 3; b = a =3</span></span><br><span class="line"><span class="comment">a 正常解构赋值，匹配结果：a = 1，b 匹配结果 undefined ，触发默认值：b = a =1</span></span><br><span class="line"><span class="comment">a 与 b 正常解构赋值，匹配结果：a = 1，b = 2</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//总结：有匹配的优先匹配，没有匹配的看默认</span></span><br></pre></td></tr></table></figure><p><a name="U4fzN"></a></p><h2 id="对象模型的解构"><a href="#对象模型的解构" class="headerlink" title="对象模型的解构"></a>对象模型的解构</h2><p><a name="Xpf5k"></a></p><h3 id="基本-1"><a href="#基本-1" class="headerlink" title="基本"></a>基本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// foo = &#x27;aaa&#x27;</span></span><br><span class="line"><span class="comment">// bar = &#x27;bbb&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> &#123; baz : foo &#125; = &#123; baz : <span class="string">&#x27;ddd&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// foo = &#x27;ddd&#x27;</span></span><br></pre></td></tr></table></figure><p><a name="Y8wOM"></a></p><h3 id="可嵌套可忽略"><a href="#可嵌套可忽略" class="headerlink" title="可嵌套可忽略"></a>可嵌套可忽略</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">&#x27;hello&#x27;</span>, &#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// x = &#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">// y = &#x27;world&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [<span class="string">&#x27;hello&#x27;</span>, &#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [x, &#123;  &#125;] &#125; = obj;</span><br><span class="line"><span class="comment">// x = &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure><p><a name="ZhnlL"></a></p><h3 id="不完全解构-1"><a href="#不完全解构-1" class="headerlink" title="不完全解构"></a>不完全解构</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">p</span>: [&#123;<span class="attr">y</span>: <span class="string">&#x27;world&#x27;</span>&#125;] &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">p</span>: [&#123; y &#125;, x ] &#125; = obj;</span><br><span class="line"><span class="comment">// x = undefined</span></span><br><span class="line"><span class="comment">// y = &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure><p><a name="RlJE6"></a></p><h3 id="剩余运算符-1"><a href="#剩余运算符-1" class="headerlink" title="剩余运算符"></a>剩余运算符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b, ...rest&#125; = &#123;<span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span>&#125;;</span><br><span class="line"><span class="comment">// a = 10</span></span><br><span class="line"><span class="comment">// b = 20</span></span><br><span class="line"><span class="comment">// rest = &#123;c: 30, d: 40&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="cpMKP"></a></p><h3 id="解构默认值-1"><a href="#解构默认值-1" class="headerlink" title="解构默认值"></a>解构默认值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a = <span class="number">10</span>, b = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// a = 3; b = 5;</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>: aa = <span class="number">10</span>, <span class="attr">b</span>: bb = <span class="number">5</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// aa = 3; bb = 5;</span></span><br></pre></td></tr></table></figure><p><a href="https://fangyinghang.com/es-6-tutorials/">https://fangyinghang.com/es-6-tutorials/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 面试 </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
